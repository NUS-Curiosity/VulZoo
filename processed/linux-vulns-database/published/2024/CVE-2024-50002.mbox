From bippy-5f407fcff5a0 Mon Sep 17 00:00:00 2001
From: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
To: <linux-cve-announce@vger.kernel.org>
Reply-to: <cve@kernel.org>, <linux-kernel@vger.kernel.org>
Subject: CVE-2024-50002: static_call: Handle module init failure correctly in static_call_del_module()

Description
===========

In the Linux kernel, the following vulnerability has been resolved:

static_call: Handle module init failure correctly in static_call_del_module()

Module insertion invokes static_call_add_module() to initialize the static
calls in a module. static_call_add_module() invokes __static_call_init(),
which allocates a struct static_call_mod to either encapsulate the built-in
static call sites of the associated key into it so further modules can be
added or to append the module to the module chain.

If that allocation fails the function returns with an error code and the
module core invokes static_call_del_module() to clean up eventually added
static_call_mod entries.

This works correctly, when all keys used by the module were converted over
to a module chain before the failure. If not then static_call_del_module()
causes a #GP as it blindly assumes that key::mods points to a valid struct
static_call_mod.

The problem is that key::mods is not a individual struct member of struct
static_call_key, it's part of a union to save space:

        union {
                /* bit 0: 0 = mods, 1 = sites */
                unsigned long type;
                struct static_call_mod *mods;
                struct static_call_site *sites;
	};

key::sites is a pointer to the list of built-in usage sites of the static
call. The type of the pointer is differentiated by bit 0. A mods pointer
has the bit clear, the sites pointer has the bit set.

As static_call_del_module() blidly assumes that the pointer is a valid
static_call_mod type, it fails to check for this failure case and
dereferences the pointer to the list of built-in call sites, which is
obviously bogus.

Cure it by checking whether the key has a sites or a mods pointer.

If it's a sites pointer then the key is not to be touched. As the sites are
walked in the same order as in __static_call_init() the site walk can be
terminated because all subsequent sites have not been touched by the init
code due to the error exit.

If it was converted before the allocation fail, then the inner loop which
searches for a module match will find nothing.

A fail in the second allocation in __static_call_init() is harmless and
does not require special treatment. The first allocation succeeded and
converted the key to a module chain. That first entry has mod::mod == NULL
and mod::next == NULL, so the inner loop of static_call_del_module() will
neither find a module match nor a module chain. The next site in the walk
was either already converted, but can't match the module, or it will exit
the outer loop because it has a static_call_site pointer and not a
static_call_mod pointer.

The Linux kernel CVE team has assigned CVE-2024-50002 to this issue.


Affected and fixed versions
===========================

	Issue introduced in 5.10 with commit 9183c3f9ed710a8edf1a61e8a96d497258d26e08 and fixed in 5.15.168 with commit ed4c8ce0f307f2ab8778aeb40a8866d171e8f128
	Issue introduced in 5.10 with commit 9183c3f9ed710a8edf1a61e8a96d497258d26e08 and fixed in 6.1.113 with commit b566c7d8a2de403ccc9d8a06195e19bbb386d0e4
	Issue introduced in 5.10 with commit 9183c3f9ed710a8edf1a61e8a96d497258d26e08 and fixed in 6.6.55 with commit c0abbbe8c98c077292221ec7e2baa667c9f0974c
	Issue introduced in 5.10 with commit 9183c3f9ed710a8edf1a61e8a96d497258d26e08 and fixed in 6.10.14 with commit 2b494471797bff3d257e99dc0a7abb0c5ff3b4cd
	Issue introduced in 5.10 with commit 9183c3f9ed710a8edf1a61e8a96d497258d26e08 and fixed in 6.11.3 with commit 9c48c2b53191bf991361998f5bb97b8f2fc5a89c
	Issue introduced in 5.10 with commit 9183c3f9ed710a8edf1a61e8a96d497258d26e08 and fixed in 6.12 with commit 4b30051c4864234ec57290c3d142db7c88f10d8a

Please see https://www.kernel.org for a full list of currently supported
kernel versions by the kernel community.

Unaffected versions might change over time as fixes are backported to
older supported kernel versions.  The official CVE entry at
	https://cve.org/CVERecord/?id=CVE-2024-50002
will be updated if fixes are backported, please check that for the most
up to date information about this issue.


Affected files
==============

The file(s) affected by this issue are:
	kernel/static_call_inline.c


Mitigation
==========

The Linux kernel CVE team recommends that you update to the latest
stable kernel version for this, and many other bugfixes.  Individual
changes are never tested alone, but rather are part of a larger kernel
release.  Cherry-picking individual commits is not recommended or
supported by the Linux kernel community at all.  If however, updating to
the latest release is impossible, the individual changes to resolve this
issue can be found at these commits:
	https://git.kernel.org/stable/c/ed4c8ce0f307f2ab8778aeb40a8866d171e8f128
	https://git.kernel.org/stable/c/b566c7d8a2de403ccc9d8a06195e19bbb386d0e4
	https://git.kernel.org/stable/c/c0abbbe8c98c077292221ec7e2baa667c9f0974c
	https://git.kernel.org/stable/c/2b494471797bff3d257e99dc0a7abb0c5ff3b4cd
	https://git.kernel.org/stable/c/9c48c2b53191bf991361998f5bb97b8f2fc5a89c
	https://git.kernel.org/stable/c/4b30051c4864234ec57290c3d142db7c88f10d8a
