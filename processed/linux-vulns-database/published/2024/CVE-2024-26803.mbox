From bippy-5f407fcff5a0 Mon Sep 17 00:00:00 2001
From: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
To: <linux-cve-announce@vger.kernel.org>
Reply-to: <cve@kernel.org>, <linux-kernel@vger.kernel.org>
Subject: CVE-2024-26803: net: veth: clear GRO when clearing XDP even when down

Description
===========

In the Linux kernel, the following vulnerability has been resolved:

net: veth: clear GRO when clearing XDP even when down

veth sets NETIF_F_GRO automatically when XDP is enabled,
because both features use the same NAPI machinery.

The logic to clear NETIF_F_GRO sits in veth_disable_xdp() which
is called both on ndo_stop and when XDP is turned off.
To avoid the flag from being cleared when the device is brought
down, the clearing is skipped when IFF_UP is not set.
Bringing the device down should indeed not modify its features.

Unfortunately, this means that clearing is also skipped when
XDP is disabled _while_ the device is down. And there's nothing
on the open path to bring the device features back into sync.
IOW if user enables XDP, disables it and then brings the device
up we'll end up with a stray GRO flag set but no NAPI instances.

We don't depend on the GRO flag on the datapath, so the datapath
won't crash. We will crash (or hang), however, next time features
are sync'ed (either by user via ethtool or peer changing its config).
The GRO flag will go away, and veth will try to disable the NAPIs.
But the open path never created them since XDP was off, the GRO flag
was a stray. If NAPI was initialized before we'll hang in napi_disable().
If it never was we'll crash trying to stop uninitialized hrtimer.

Move the GRO flag updates to the XDP enable / disable paths,
instead of mixing them with the ndo_open / ndo_close paths.

The Linux kernel CVE team has assigned CVE-2024-26803 to this issue.


Affected and fixed versions
===========================

	Issue introduced in 5.13 with commit d3256efd8e8b234a6251e4d4580bd2c3c31fdc4c and fixed in 5.15.151 with commit f011c103e654d83dc85f057a7d1bd0960d02831c
	Issue introduced in 5.13 with commit d3256efd8e8b234a6251e4d4580bd2c3c31fdc4c and fixed in 6.1.81 with commit 7985d73961bbb4e726c1be7b9cd26becc7be8325
	Issue introduced in 5.13 with commit d3256efd8e8b234a6251e4d4580bd2c3c31fdc4c and fixed in 6.6.21 with commit 16edf51f33f52dff70ed455bc40a6cc443c04664
	Issue introduced in 5.13 with commit d3256efd8e8b234a6251e4d4580bd2c3c31fdc4c and fixed in 6.7.9 with commit 8f7a3894e58e6f5d5815533cfde60e3838947941
	Issue introduced in 5.13 with commit d3256efd8e8b234a6251e4d4580bd2c3c31fdc4c and fixed in 6.8 with commit fe9f801355f0b47668419f30f1fac1cf4539e736

Please see https://www.kernel.org for a full list of currently supported
kernel versions by the kernel community.

Unaffected versions might change over time as fixes are backported to
older supported kernel versions.  The official CVE entry at
	https://cve.org/CVERecord/?id=CVE-2024-26803
will be updated if fixes are backported, please check that for the most
up to date information about this issue.


Affected files
==============

The file(s) affected by this issue are:
	drivers/net/veth.c


Mitigation
==========

The Linux kernel CVE team recommends that you update to the latest
stable kernel version for this, and many other bugfixes.  Individual
changes are never tested alone, but rather are part of a larger kernel
release.  Cherry-picking individual commits is not recommended or
supported by the Linux kernel community at all.  If however, updating to
the latest release is impossible, the individual changes to resolve this
issue can be found at these commits:
	https://git.kernel.org/stable/c/f011c103e654d83dc85f057a7d1bd0960d02831c
	https://git.kernel.org/stable/c/7985d73961bbb4e726c1be7b9cd26becc7be8325
	https://git.kernel.org/stable/c/16edf51f33f52dff70ed455bc40a6cc443c04664
	https://git.kernel.org/stable/c/8f7a3894e58e6f5d5815533cfde60e3838947941
	https://git.kernel.org/stable/c/fe9f801355f0b47668419f30f1fac1cf4539e736
