diff --git a/package.json b/package.json
index 289e4f7..05d8a9b 100644
--- a/package.json
+++ b/package.json
@@ -1,7 +1,7 @@
 {
   "name": "hoolock-main",
   "description": "Suite of lightweight utilities.",
-  "version": "2.2.0",
+  "version": "2.2.1",
   "private": true,
   "author": {
     "name": "Elijah Harry",
diff --git a/src/invert.ts b/src/invert.ts
index 5c78375..a77eb10 100644
--- a/src/invert.ts
+++ b/src/invert.ts
@@ -1,6 +1,7 @@
 import isPropertyKey from "./shared/isPropertyKey";
 
 import iterateProperties from "./shared/iterateProperties";
+import setSafeProperty from "./shared/setSafeProperty";
 import { FlattenIntersection, UnionToIntersection } from "./types";
 
 namespace Invert {
@@ -76,7 +77,11 @@ function invert<T extends Record<PropertyKey, unknown>>(source: T): Invert<T>;
 function invert(source: Record<PropertyKey, any>): Record<PropertyKey, any> {
   const result: Record<PropertyKey, any> = {};
   iterateProperties(source, (key, value) => {
-    if (isPropertyKey(value)) result[value] = key;
+    if (isPropertyKey(value)) {
+      setSafeProperty(result, value, {
+        value: key,
+      });
+    }
   });
   return result;
 }
diff --git a/src/merge.ts b/src/merge.ts
index 116b5ec..48d0df3 100644
--- a/src/merge.ts
+++ b/src/merge.ts
@@ -2,6 +2,7 @@ import cloneSimple from "./shared/cloneSimple";
 import deepClone from "./shared/deepClone";
 import isReactElement from "./shared/isReactElement";
 import iterateOwnEnumerableProperties from "./shared/iterateProperties";
+import setSafeProperty from "./shared/setSafeProperty";
 import type { Mapped } from "./types";
 
 function isMergable(source: any): source is Mapped {
@@ -26,16 +27,17 @@ function _merge(target: Mapped, source: Mapped) {
       return target;
     }
   } else if (!Array.isArray(target)) {
-    let current: any;
+    let currenTarget: any;
     iterateOwnEnumerableProperties(source, (key, value) => {
-      if (
-        isMergable(value) &&
-        key in target &&
-        isMergable((current = target[key]))
-      ) {
-        value = _merge(current, value);
-      }
-      target[key] = value;
+      setSafeProperty(target, key, () => {
+        if (
+          isMergable(value) &&
+          key in target &&
+          isMergable((currenTarget = target[key]))
+        )
+          return _merge(currenTarget, value);
+        return value;
+      });
     });
     return target;
   }
@@ -94,12 +96,12 @@ function merge<T extends {}, U, V, W, X>(
 function merge<T extends {}>(source: T): T;
 function merge(source: any, ...sources: any[]): any;
 function merge(...sources: any[]): any {
-  let result: Mapped | undefined, source: any;
+  let result: Mapped | undefined, source: any, cloned: any;
   const clone = deepClone(cloneSimple);
   for (source of sources)
     if (isMergable(source)) {
-      source = clone(source);
-      result = result ? _merge(result, source) : source;
+      cloned = clone(source);
+      result = result ? _merge(result, cloned) : cloned;
     }
 
   return result ?? {};
diff --git a/src/omit.ts b/src/omit.ts
index 6c5476e..da23afe 100644
--- a/src/omit.ts
+++ b/src/omit.ts
@@ -4,6 +4,8 @@ import deepClone from "./shared/deepClone";
 import cloneSimple from "./shared/cloneSimple";
 import iterateProperties from "./shared/iterateProperties";
 import type { Path, Mapped } from "./types";
+import setSafeProperty from "./shared/setSafeProperty";
+import isObjectLike from "./shared/isObjectLike";
 
 function omitRecursive(
   target: Mapped,
@@ -22,21 +24,20 @@ function omitRecursive(
       if (node.nodes) {
         // If it has nodes, then we only want to copy the
         // shape of the object, as it's children may be omitted
-        if (!(typeof value === "object" && value !== null)) {
+        if (!isObjectLike(value)) {
           // If it's not an object, then we cannot traverse down it.
           // Maybe copy the whole value instead here? Not sure.
           return;
         }
-        return omitRecursive(
-          (target[key] ??= emptyObjectFrom(value)),
-          value,
-          node.nodes,
-          clone
-        );
+
+        if (setSafeProperty(target, key, () => emptyObjectFrom(value)))
+          omitRecursive(target[key], value, node.nodes, clone);
+
+        return;
       }
     }
     // Otherwise, we can simply copy the entire value
-    target[key] = clone(value);
+    setSafeProperty(target, key, () => clone(value));
   });
 
   return target;
diff --git a/src/pick.ts b/src/pick.ts
index 935e4e5..ea42f3d 100644
--- a/src/pick.ts
+++ b/src/pick.ts
@@ -1,8 +1,10 @@
 import cloneSimple from "./shared/cloneSimple";
 import deepClone from "./shared/deepClone";
 import emptyObjectFrom from "./shared/emptyObjectFrom";
+import isObjectLike from "./shared/isObjectLike";
 import iterateProperties from "./shared/iterateProperties";
 import pathTrie, { PathTrie } from "./shared/pathTrie";
+import setSafeProperty from "./shared/setSafeProperty";
 import type { Mapped, Path } from "./types";
 
 function pickRecursive(
@@ -16,23 +18,21 @@ function pickRecursive(
     if (node) {
       if (node.target) {
         // If the node is a target, then we want to copy the entire value
-        return (target[key] = clone(value));
+        return setSafeProperty(target, key, () => clone(value));
       }
       // Otherwise, check to see if the node has any children
       if (node.nodes) {
         // If it does, then we want to copy the shape of the object,
         // and traverse down to pick the children
-        if (!(typeof value === "object" && value !== null)) {
+        if (!isObjectLike(value)) {
           // If it's not an object, then we cannot traverse down it.
           // Maybe copy the whole value instead here? Not sure.
           return;
         }
-        return pickRecursive(
-          (target[key] ??= emptyObjectFrom(value)),
-          value,
-          node.nodes,
-          clone
-        );
+        if (setSafeProperty(target, key, () => emptyObjectFrom(value))) {
+          pickRecursive(target[key], value, node.nodes, clone);
+        }
+        return;
       }
     }
   });
diff --git a/src/set.test.ts b/src/set.test.ts
index 7dec6e1..1a38bfd 100644
--- a/src/set.test.ts
+++ b/src/set.test.ts
@@ -32,4 +32,37 @@ describe("set", () => {
     expect(result.a.b).toBeInstanceOf(Parent);
     expect(result.a.b.c).toBe(1);
   });
+
+  it("prevents prototype pollution", () => {
+    expect(() => set({}, "__proto__.polluted", true)).toThrow(
+      new TypeError(
+        'Property "__proto__" does not belong to target object and cannot be accessed.'
+      )
+    );
+
+    expect(() =>
+      set(
+        {
+          a: {},
+        },
+        "a.__proto__.polluted",
+        true
+      )
+    ).toThrow(
+      new TypeError(
+        'Property "__proto__" does not belong to target object and cannot be accessed.'
+      )
+    );
+
+    expect(() => set({}, "constructor.prototype", true)).toThrow(
+      new TypeError(
+        'Property "constructor" does not belong to target object and cannot be accessed.'
+      )
+    );
+
+    expect(
+      // @ts-expect-error
+      {}.polluted
+    ).toBeUndefined();
+  });
 });
diff --git a/src/set.ts b/src/set.ts
index 4246385..3b1de2f 100644
--- a/src/set.ts
+++ b/src/set.ts
@@ -1,3 +1,4 @@
+import setSafeProperty from "./shared/setSafeProperty";
 import targetPath from "./shared/targetPath";
 import type { Path } from "./types";
 
@@ -73,7 +74,9 @@ function set(
   createParent?: (() => object) | boolean
 ): any {
   const { target, key } = targetPath(obj, path, createParent);
-  target[key] = value;
+  setSafeProperty(target, key, {
+    value,
+  });
   return obj;
 }
 
diff --git a/src/shape.ts b/src/shape.ts
index 7637b8d..24c8bc8 100644
--- a/src/shape.ts
+++ b/src/shape.ts
@@ -1,5 +1,6 @@
 import isArray from "./isArray";
 import isFunction from "./isFunction";
+import setSafeProperty from "./shared/setSafeProperty";
 
 type ShapeDynamicValues<K extends PropertyKey, T> = (key: K) => T;
 
@@ -49,7 +50,7 @@ function shape<T>(
   if (isArray(properties)) {
     const result: Record<string | number | symbol, T> = {};
     for (const property of properties) {
-      result[property] = generate(property);
+      setSafeProperty(result, property, () => generate(property));
     }
     return result;
   }
diff --git a/src/shared/cloneComplex.ts b/src/shared/cloneComplex.ts
index c8e7116..814a0c6 100644
--- a/src/shared/cloneComplex.ts
+++ b/src/shared/cloneComplex.ts
@@ -5,7 +5,11 @@ import emptyObjectFrom from "./emptyObjectFrom";
 
 type Recurse = <T>(obj: T) => T;
 
-function create(source: Mapped, recurse: Recurse, cloned?: Visited): Mapped {
+function initializeClone(
+  source: Mapped,
+  recurse: Recurse,
+  cloned?: Visited
+): Mapped {
   if (source instanceof Set) {
     const target = new Set();
     if (cloned) cloned.set(source, target);
@@ -48,7 +52,7 @@ function cloneComplex(source: any, recurse: Recurse, cloned?: Visited) {
   if (isClonable(source)) {
     let target = cloned && cloned.get(source);
     if (target) return target;
-    target = create(source, recurse, cloned);
+    target = initializeClone(source, recurse, cloned);
     if (cloned) cloned.set(source, target);
     copyProperties(target, source, recurse);
     return target;
diff --git a/src/shared/copyProperties.ts b/src/shared/copyProperties.ts
index cf52a93..4f7843e 100644
--- a/src/shared/copyProperties.ts
+++ b/src/shared/copyProperties.ts
@@ -1,6 +1,7 @@
 import iterateProperties from "./iterateProperties";
 import returnInitialArgument from "./returnInitialArgument";
 import type { Mapped } from "../types";
+import setSafeProperty from "./setSafeProperty";
 
 /** Copies non-existant properties from a source object to a target object. */
 function copyProperties(
@@ -9,7 +10,7 @@ function copyProperties(
   recurse = returnInitialArgument
 ) {
   iterateProperties(from, (key, value) => {
-    if (!(key in to)) to[key] = recurse(value);
+    setSafeProperty(to, key, () => recurse(value));
   });
   return to;
 }
diff --git a/src/shared/isEnumerableProperty.ts b/src/shared/isEnumerableProperty.ts
new file mode 100644
index 0000000..fb6bf86
--- /dev/null
+++ b/src/shared/isEnumerableProperty.ts
@@ -0,0 +1,4 @@
+const isEnumerableProperty = <T extends {}>(obj: T, key: PropertyKey) =>
+  Object.propertyIsEnumerable.call(obj, key);
+
+export default isEnumerableProperty;
diff --git a/src/shared/isSimpleObject.ts b/src/shared/isObjectLike.ts
similarity index 50%
rename from src/shared/isSimpleObject.ts
rename to src/shared/isObjectLike.ts
index ef69ba0..1b88e38 100644
--- a/src/shared/isSimpleObject.ts
+++ b/src/shared/isObjectLike.ts
@@ -1,6 +1,6 @@
 import type { Mapped } from "../types";
 
-const isSimpleObject = (obj: any): obj is Mapped =>
+const isObjectLike = (obj: any): obj is Mapped =>
   typeof obj === "object" && obj !== null;
 
-export default isSimpleObject;
+export default isObjectLike;
diff --git a/src/shared/isOwnEnumerableProperty.ts b/src/shared/isOwnEnumerableProperty.ts
index 11216c3..15a8a48 100644
--- a/src/shared/isOwnEnumerableProperty.ts
+++ b/src/shared/isOwnEnumerableProperty.ts
@@ -1,5 +1,9 @@
-const isOwnEnumerableProperty = (obj: {}, key: string | number | symbol) =>
-  Object.hasOwnProperty.call(obj, key) &&
-  Object.propertyIsEnumerable.call(obj, key);
+import isOwnProperty from "./isOwnProperty";
+import isEnumerableProperty from "./isEnumerableProperty";
+
+const isOwnEnumerableProperty = <T extends {}>(
+  obj: T,
+  key: string | number | symbol
+) => isOwnProperty(obj, key) && isEnumerableProperty(obj, key);
 
 export default isOwnEnumerableProperty;
diff --git a/src/shared/isOwnProperty.ts b/src/shared/isOwnProperty.ts
new file mode 100644
index 0000000..ed5de33
--- /dev/null
+++ b/src/shared/isOwnProperty.ts
@@ -0,0 +1,4 @@
+const isOwnProperty = <T extends {}>(obj: T, key: string | number | symbol) =>
+  Object.hasOwnProperty.call(obj, key);
+
+export default isOwnProperty;
diff --git a/src/shared/isPrivateProperty.ts b/src/shared/isPrivateProperty.ts
new file mode 100644
index 0000000..1d9a900
--- /dev/null
+++ b/src/shared/isPrivateProperty.ts
@@ -0,0 +1,8 @@
+import { Mapped } from "../types";
+import isOwnProperty from "./isOwnProperty";
+
+const isPrivateProperty = (object: Mapped, key: PropertyKey) => {
+  return key in object && !isOwnProperty(object, key);
+};
+
+export default isPrivateProperty;
diff --git a/src/shared/pathTrie.ts b/src/shared/pathTrie.ts
index 7d29b10..97c56cd 100644
--- a/src/shared/pathTrie.ts
+++ b/src/shared/pathTrie.ts
@@ -1,4 +1,5 @@
 import type { AnyArray, Path } from "../types";
+import isOwnProperty from "./isOwnProperty";
 import toPath from "./toPath";
 
 export namespace PathTrie {
@@ -11,12 +12,25 @@ export interface PathTrie {
   [key: string | symbol]: PathTrie.Node;
 }
 
+const getNode = (
+  object: PathTrie,
+  key: PropertyKey
+): PathTrie.Node | undefined => {
+  if (key in object) {
+    if (!isOwnProperty(object, key)) return;
+    return object[key];
+  }
+  return (object[key] ??= {} as any);
+};
+
 const setNode = (trie: PathTrie, path: Array<string | symbol>) => {
   if (!path.length) return;
-  let node = (trie[path[0]] ??= {});
-  for (let i = 1; i < path.length; i++)
-    node = (node.nodes ??= {})[path[i]] ??= {};
-  node.target = true;
+  let node = getNode(trie, path[0]);
+  for (let i = 1; i < path.length; i++) {
+    if (!node) return;
+    node = getNode((node.nodes ??= {}), path[i]);
+  }
+  if (node) node.target = true;
 };
 
 const pathTrie = (pathlike: AnyArray<Path>): PathTrie => {
diff --git a/src/shared/setProperty.ts b/src/shared/setProperty.ts
new file mode 100644
index 0000000..3303fd7
--- /dev/null
+++ b/src/shared/setProperty.ts
@@ -0,0 +1,16 @@
+import { Mapped } from "../types";
+
+const setProperty = <T>(target: Mapped, key: PropertyKey, value: T) => {
+  if (key === "__proto__") {
+    Object.defineProperty(target, key, {
+      value,
+      writable: true,
+      enumerable: true,
+      configurable: true,
+    });
+  } else {
+    target[key] = value;
+  }
+};
+
+export default setProperty;
diff --git a/src/shared/setSafeProperty.ts b/src/shared/setSafeProperty.ts
new file mode 100644
index 0000000..2d3f741
--- /dev/null
+++ b/src/shared/setSafeProperty.ts
@@ -0,0 +1,28 @@
+import isFunction from "../isFunction";
+import { Mapped } from "../types";
+import isPrivateProperty from "./isPrivateProperty";
+import setProperty from "./setProperty";
+
+function setSafeProperty(
+  target: Mapped,
+  key: PropertyKey,
+  options: {
+    value: unknown;
+  }
+): boolean;
+function setSafeProperty(
+  target: Mapped,
+  key: PropertyKey,
+  makeValue: () => unknown
+): boolean;
+function setSafeProperty(
+  target: Mapped,
+  key: PropertyKey,
+  input: { value: any } | (() => any)
+): boolean {
+  if (isPrivateProperty(target, key)) return false;
+  setProperty(target, key, isFunction(input) ? input() : input.value);
+  return true;
+}
+
+export default setSafeProperty;
diff --git a/src/shared/stringifyPath.ts b/src/shared/stringifyPath.ts
new file mode 100644
index 0000000..2e01393
--- /dev/null
+++ b/src/shared/stringifyPath.ts
@@ -0,0 +1,37 @@
+import { Path } from "../types";
+
+const stringifyPath = /* @__PURE__ */ (() => {
+  type Stringifier<T> = (value: T) => [str: string, delimit?: boolean];
+  const NUMBER = /^\d+(?:\.\d+)?$/;
+  const NO_QUOTES = /^[a-zA-Z_$][\w$]*$/;
+  const QUOTE_ESCAPE = /"/g;
+
+  const symbolString: Stringifier<symbol> =
+    "description" in Symbol.prototype
+      ? (value) => [`[Symbol("${value.description}")]`]
+      : () => [`[Symbol()]`];
+
+  const string: Stringifier<string | symbol> = (value) => {
+    if (typeof value === "symbol") return symbolString(value);
+    if (NUMBER.test(value)) {
+      const num = Number(value);
+      if (!Number.isNaN(num)) return [`[${num}]`];
+    }
+    if (NO_QUOTES.test(value)) return [value, true];
+    value = `["${value.replace(QUOTE_ESCAPE, '\\"')}"]`;
+    return [value];
+  };
+  return (path: Array<string | symbol>): string => {
+    if (!path.length) return "";
+    let result = string(path[0]),
+      str = result[0];
+    for (let i = 1; i < path.length; i++) {
+      result = string(path[i]);
+      if (result[1]) str += ".";
+      str += result[0];
+    }
+    return str;
+  };
+})();
+
+export default stringifyPath;
diff --git a/src/shared/targetPath.ts b/src/shared/targetPath.ts
index f3cd0ee..394aa7d 100644
--- a/src/shared/targetPath.ts
+++ b/src/shared/targetPath.ts
@@ -1,9 +1,21 @@
 import isBoolean from "../isBoolean";
 import toPath from "./toPath";
 import type { Path, Mapped, ParentObjectCreator } from "../types";
+import isString from "../isString";
+import isPrivateProperty from "./isPrivateProperty";
+import setProperty from "./setProperty";
 
 const createPlainParent: ParentObjectCreator = () => ({});
 
+const preventPrivate = (target: Mapped, key: PropertyKey) => {
+  if (isPrivateProperty(target, key))
+    throw new TypeError(
+      `Property ${
+        isString(key) ? `"${key}"` : String(key)
+      } does not belong to target object and cannot be accessed.`
+    );
+};
+
 const targetPath = (
   source: Mapped,
   pathlike: Path,
@@ -23,10 +35,15 @@ const targetPath = (
 
   for (let i = 0; i < fin; i++) {
     key = path[i];
-    target = target[key] ??= (parentCreator && parentCreator()) as any;
+    // if (key in target) {
+    preventPrivate(target, key);
+    target =
+      target[key] ??
+      (setProperty(target, key, parentCreator && parentCreator()), target[key]);
   }
 
   key = path[fin];
+  preventPrivate(target, key);
 
   return {
     target,
diff --git a/src/shared/transformSource.ts b/src/shared/transformSource.ts
index 1d577a4..82b4aa9 100644
--- a/src/shared/transformSource.ts
+++ b/src/shared/transformSource.ts
@@ -1,6 +1,7 @@
 import isPropertyKey from "./isPropertyKey";
 import iterateProperties from "./iterateProperties";
 import returnInitialArgument from "./returnInitialArgument";
+import setSafeProperty from "./setSafeProperty";
 
 type Setter<T extends object = Record<PropertyKey, any>> = (
   target: T & Record<PropertyKey, any>,
@@ -57,13 +58,15 @@ export type TransformPropertyCreator<
 
 const arraySetter: Setter<any[]> = (target, value, key, keyOverride) => {
   if (isPropertyKey(keyOverride)) {
-    target[keyOverride] = value;
+    setSafeProperty(target, keyOverride, { value });
   } else {
     target.push(value);
   }
 };
 const objectSetter: Setter = (target, value, key, keyOverride) => {
-  target[isPropertyKey(keyOverride) ? keyOverride : key] = value;
+  setSafeProperty(target, isPropertyKey(keyOverride) ? keyOverride : key, {
+    value,
+  });
 };
 
 const ruleSave = (property: TransformProperty): TransformRule._ => ({
diff --git a/src/transformDeep.ts b/src/transformDeep.ts
index 05398a2..aa289cf 100644
--- a/src/transformDeep.ts
+++ b/src/transformDeep.ts
@@ -1,5 +1,5 @@
 import emptyObjectFrom from "./shared/emptyObjectFrom";
-import isSimpleObject from "./shared/isSimpleObject";
+import isSimpleObject from "./shared/isObjectLike";
 import transformObject, {
   TransformResult,
   TransformRule,
diff --git a/src/update.test.ts b/src/update.test.ts
index d4a8ca2..64e3de0 100644
--- a/src/update.test.ts
+++ b/src/update.test.ts
@@ -53,4 +53,37 @@ describe("update", () => {
       },
     });
   });
+
+  it("prevents prototype pollution", () => {
+    expect(() => update({}, "__proto__.polluted", () => true)).toThrow(
+      new TypeError(
+        'Property "__proto__" does not belong to target object and cannot be accessed.'
+      )
+    );
+
+    expect(() =>
+      update(
+        {
+          a: {},
+        },
+        "a.__proto__.polluted",
+        () => true
+      )
+    ).toThrow(
+      new TypeError(
+        'Property "__proto__" does not belong to target object and cannot be accessed.'
+      )
+    );
+
+    expect(() => update({}, "constructor.prototype", () => true)).toThrow(
+      new TypeError(
+        'Property "constructor" does not belong to target object and cannot be accessed.'
+      )
+    );
+
+    expect(
+      // @ts-expect-error
+      {}.polluted
+    ).toBeUndefined();
+  });
 });
diff --git a/src/update.ts b/src/update.ts
index 61e1987..1c7766f 100644
--- a/src/update.ts
+++ b/src/update.ts
@@ -1,3 +1,4 @@
+import setSafeProperty from "./shared/setSafeProperty";
 import targetPath from "./shared/targetPath";
 import type { Path } from "./types";
 
@@ -86,15 +87,15 @@ function update(
   updater: Updater<any>,
   createParent?: (() => object) | boolean
 ): any {
-  const { target, key, path } = targetPath(source, pathlike, createParent),
-    value = target[key];
-
-  target[key] = updater({
-    target,
-    path,
-    key,
-    value,
-  });
+  const { target, key, path } = targetPath(source, pathlike, createParent);
+  setSafeProperty(target, key, () =>
+    updater({
+      target,
+      path,
+      key,
+      value: target[key],
+    })
+  );
 
   return source;
 }
