diff --git a/precompiles/ics20/ics20.go b/precompiles/ics20/ics20.go
index 7df8d463c3..a5e0611b78 100644
--- a/precompiles/ics20/ics20.go
+++ b/precompiles/ics20/ics20.go
@@ -17,6 +17,7 @@ import (
 	"github.com/evmos/evmos/v18/precompiles/authorization"
 	cmn "github.com/evmos/evmos/v18/precompiles/common"
 	transferkeeper "github.com/evmos/evmos/v18/x/ibc/transfer/keeper"
+	stakingkeeper "github.com/evmos/evmos/v18/x/staking/keeper"
 )
 
 var _ vm.PrecompiledContract = &Precompile{}
@@ -28,6 +29,7 @@ var f embed.FS
 
 type Precompile struct {
 	cmn.Precompile
+	stakingKeeper  stakingkeeper.Keeper
 	transferKeeper transferkeeper.Keeper
 	channelKeeper  channelkeeper.Keeper
 }
@@ -35,6 +37,7 @@ type Precompile struct {
 // NewPrecompile creates a new ICS-20 Precompile instance as a
 // PrecompiledContract interface.
 func NewPrecompile(
+	stakingKeeper stakingkeeper.Keeper,
 	transferKeeper transferkeeper.Keeper,
 	channelKeeper channelkeeper.Keeper,
 	authzKeeper authzkeeper.Keeper,
@@ -59,6 +62,7 @@ func NewPrecompile(
 		},
 		transferKeeper: transferKeeper,
 		channelKeeper:  channelKeeper,
+		stakingKeeper:  stakingKeeper,
 	}, nil
 }
 
diff --git a/precompiles/ics20/tx.go b/precompiles/ics20/tx.go
index 8fa1cddf74..43dee10ca7 100644
--- a/precompiles/ics20/tx.go
+++ b/precompiles/ics20/tx.go
@@ -4,12 +4,16 @@
 package ics20
 
 import (
+	"fmt"
+
 	errorsmod "cosmossdk.io/errors"
+
 	sdk "github.com/cosmos/cosmos-sdk/types"
 	channeltypes "github.com/cosmos/ibc-go/v7/modules/core/04-channel/types"
 	"github.com/ethereum/go-ethereum/accounts/abi"
 	"github.com/ethereum/go-ethereum/common"
 	"github.com/ethereum/go-ethereum/core/vm"
+	"github.com/evmos/evmos/v18/x/evm/statedb"
 )
 
 const (
@@ -37,14 +41,12 @@ func (p Precompile) Transfer(
 		return nil, errorsmod.Wrapf(channeltypes.ErrChannelNotFound, "port ID (%s) channel ID (%s)", msg.SourcePort, msg.SourceChannel)
 	}
 
-	// The provided sender address should always be equal to the origin address.
-	// In case the contract caller address is the same as the sender address provided,
-	// update the sender address to be equal to the origin address.
-	// Otherwise, if the provided delegator address is different from the origin address,
-	// return an error because is a forbidden operation
-	sender, err = CheckOriginAndSender(contract, origin, sender)
-	if err != nil {
-		return nil, err
+	// isCallerSender is true when the contract caller is the same as the sender
+	isCallerSender := contract.CallerAddress == sender
+
+	// If the contract caller is not the same as the sender, the sender must be the origin
+	if !isCallerSender && origin != sender {
+		return nil, fmt.Errorf(ErrDifferentOriginFromSender, origin.String(), sender.String())
 	}
 
 	// no need to have authorization when the contract caller is the same as origin (owner of funds)
@@ -78,5 +80,11 @@ func (p Precompile) Transfer(
 		return nil, err
 	}
 
+	// NOTE: This ensures that the changes in the bank keeper are correctly mirrored to the EVM stateDB.
+	// This prevents the stateDB from overwriting the changed balance in the bank keeper when committing the EVM state.
+	if isCallerSender && msg.Token.Denom == p.stakingKeeper.BondDenom(ctx) {
+		stateDB.(*statedb.StateDB).SubBalance(contract.CallerAddress, msg.Token.Amount.BigInt())
+	}
+
 	return method.Outputs.Pack(res.Sequence)
 }
diff --git a/precompiles/ics20/types.go b/precompiles/ics20/types.go
index a3f80a34e2..f36c01cd0f 100644
--- a/precompiles/ics20/types.go
+++ b/precompiles/ics20/types.go
@@ -374,7 +374,7 @@ func convertToAllocation(allocs []transfertypes.Allocation) []cmn.ICS20Allocatio
 // CheckOriginAndSender ensures the correct sender is being used.
 func CheckOriginAndSender(contract *vm.Contract, origin common.Address, sender common.Address) (common.Address, error) {
 	if contract.CallerAddress == sender {
-		return origin, nil
+		return sender, nil
 	} else if origin != sender {
 		return common.Address{}, fmt.Errorf(ErrDifferentOriginFromSender, origin.String(), sender.String())
 	}
diff --git a/precompiles/ics20/utils_test.go b/precompiles/ics20/utils_test.go
index e10b6d1ecc..c70a128acf 100644
--- a/precompiles/ics20/utils_test.go
+++ b/precompiles/ics20/utils_test.go
@@ -273,7 +273,7 @@ func (s *PrecompileTestSuite) NewTestChainWithValSet(coord *ibctesting.Coordinat
 	s.app.FeeMarketKeeper.SetBlockGasWanted(s.ctx, 0)
 	s.app.FeeMarketKeeper.SetTransientBlockGasWanted(s.ctx, 0)
 
-	precompile, err := ics20.NewPrecompile(s.app.TransferKeeper, s.app.IBCKeeper.ChannelKeeper, s.app.AuthzKeeper)
+	precompile, err := ics20.NewPrecompile(s.app.StakingKeeper, s.app.TransferKeeper, s.app.IBCKeeper.ChannelKeeper, s.app.AuthzKeeper)
 	s.Require().NoError(err)
 	s.precompile = precompile
 
diff --git a/tests/nix_tests/hardhat/contracts/ICS20FromContract.sol b/tests/nix_tests/hardhat/contracts/ICS20FromContract.sol
new file mode 100644
index 0000000000..6c57295965
--- /dev/null
+++ b/tests/nix_tests/hardhat/contracts/ICS20FromContract.sol
@@ -0,0 +1,62 @@
+// SPDX-License-Identifier: LGPL-3.0-only
+pragma solidity >=0.8.18;
+
+import "./evmos/ics20/ICS20I.sol";
+import "./evmos/common/Types.sol";
+
+
+contract ICS20FromContract {
+    int64 public counter;
+
+    function balanceOfContract() public view returns (uint256) {
+        return address(this).balance;
+    }
+
+    function deposit() public payable {}
+
+    function transfer(
+        string memory sourcePort,
+        string memory sourceChannel,
+        string memory denom,
+        uint256 amount,
+        string memory receiver
+    ) external {
+        counter += 1;
+        Height memory timeoutHeight =  Height(100, 100);
+        ICS20_CONTRACT.transfer(
+            sourcePort,
+            sourceChannel,
+            denom,
+            amount,
+            address(this),
+            receiver,
+            timeoutHeight,
+            0,
+            ""
+        );
+        counter -= 1;
+    }
+
+    function transferFromEOA(
+        string memory sourcePort,
+        string memory sourceChannel,
+        string memory denom,
+        uint256 amount,
+        string memory receiver
+    ) external {
+        counter += 1;
+        Height memory timeoutHeight =  Height(100, 100);
+        ICS20_CONTRACT.transfer(
+            sourcePort,
+            sourceChannel,
+            denom,
+            amount,
+            msg.sender,
+            receiver,
+            timeoutHeight,
+            0,
+            ""
+        );
+        counter -= 1;
+    }
+}
diff --git a/tests/nix_tests/test_ics20_precompile.py b/tests/nix_tests/test_ics20_precompile.py
new file mode 100644
index 0000000000..b31c68a187
--- /dev/null
+++ b/tests/nix_tests/test_ics20_precompile.py
@@ -0,0 +1,208 @@
+import re
+
+import pytest
+from .ibc_utils import EVMOS_IBC_DENOM, assert_ready, get_balance, prepare_network
+from .network import Evmos
+from .utils import (
+    ADDRS,
+    CONTRACTS,
+    KEYS,
+    deploy_contract,
+    get_precompile_contract,
+    send_transaction,
+    wait_for_fn,
+)
+
+
+@pytest.fixture(scope="module", params=["evmos", "evmos-rocksdb"])
+def ibc(request, tmp_path_factory):
+    """
+    Prepares the network.
+    """
+    name = "ibc-precompile"
+    evmos_build = request.param
+    path = tmp_path_factory.mktemp(name)
+    network = prepare_network(path, name, [evmos_build, "chainmain"])
+    yield from network
+
+
+def test_ibc_transfer_from_contract(ibc):
+    """Test ibc transfer from contract"""
+    assert_ready(ibc)
+
+    evmos: Evmos = ibc.chains["evmos"]
+    w3 = evmos.w3
+
+    dst_addr = ibc.chains["chainmain"].cosmos_cli().address("signer2")
+    amt = 1000000000000000000
+    src_denom = "aevmos"
+    gas_limit = 200_000
+
+    pc = get_precompile_contract(ibc.chains["evmos"].w3, "ICS20I")
+    evmos_gas_price = ibc.chains["evmos"].w3.eth.gas_price
+
+    src_adr = ibc.chains["evmos"].cosmos_cli().address("signer2")
+
+    # Deployment of contracts and initial checks
+    eth_contract, tx_receipt = deploy_contract(w3, CONTRACTS["ICS20FromContract"])
+    assert tx_receipt.status == 1
+
+    counter = eth_contract.functions.counter().call()
+    assert counter == 0
+
+    # Approve the contract to spend the src_denom
+    approve_tx = pc.functions.approve(
+        eth_contract.address, [["transfer", "channel-0", [[src_denom, amt]], []]]
+    ).build_transaction(
+        {
+            "from": ADDRS["signer2"],
+            "gasPrice": evmos_gas_price,
+            "gas": gas_limit,
+        }
+    )
+    tx_receipt = send_transaction(ibc.chains["evmos"].w3, approve_tx, KEYS["signer2"])
+    assert tx_receipt.status == 1
+
+    def check_allowance_set():
+        new_allowance = pc.functions.allowance(
+            eth_contract.address, ADDRS["signer2"]
+        ).call()
+        return new_allowance != []
+
+    wait_for_fn("allowance has changed", check_allowance_set)
+
+    src_amount_evmos_prev = get_balance(ibc.chains["evmos"], src_adr, src_denom)
+    # Deposit into the contract
+    deposit_tx = eth_contract.functions.deposit().build_transaction(
+        {
+            "from": ADDRS["signer2"],
+            "value": amt,
+            "gas": gas_limit,
+            "gasPrice": evmos_gas_price,
+        }
+    )
+    deposit_receipt = send_transaction(
+        ibc.chains["evmos"].w3, deposit_tx, KEYS["signer2"]
+    )
+    assert deposit_receipt.status == 1
+    fees = deposit_receipt.gasUsed * evmos_gas_price
+
+    def check_contract_balance():
+        new_contract_balance = eth_contract.functions.balanceOfContract().call()
+        return new_contract_balance > 0
+
+    wait_for_fn("contract balance change", check_contract_balance)
+
+    # Calling the actual transfer function on the custom contract
+    send_tx = eth_contract.functions.transfer(
+        "transfer", "channel-0", src_denom, amt, dst_addr
+    ).build_transaction(
+        {
+            "from": ADDRS["signer2"],
+            "gasPrice": evmos_gas_price,
+            "gas": gas_limit,
+        }
+    )
+    receipt = send_transaction(ibc.chains["evmos"].w3, send_tx, KEYS["signer2"])
+    assert receipt.status == 1
+    fees += receipt.gasUsed * evmos_gas_price
+
+    final_dest_balance = 0
+
+    def check_dest_balance():
+        nonlocal final_dest_balance
+        final_dest_balance = get_balance(
+            ibc.chains["chainmain"], dst_addr, EVMOS_IBC_DENOM
+        )
+        return final_dest_balance > 0
+
+    # check balance of destination
+    wait_for_fn("destination balance change", check_dest_balance)
+    assert final_dest_balance == amt
+
+    # check balance of contract
+    final_contract_balance = eth_contract.functions.balanceOfContract().call()
+    assert final_contract_balance == 0
+
+    src_amount_evmos = get_balance(ibc.chains["evmos"], src_adr, src_denom)
+    assert src_amount_evmos == src_amount_evmos_prev - amt - fees
+
+    # check counter of contract
+    counter_after = eth_contract.functions.counter().call()
+    assert counter_after == 0
+
+
+def test_ibc_transfer_from_eoa_through_contract(ibc):
+    """Test ibc transfer from contract"""
+    assert_ready(ibc)
+
+    evmos: Evmos = ibc.chains["evmos"]
+    w3 = evmos.w3
+
+    amt = 1000000000000000000
+    src_denom = "aevmos"
+    gas_limit = 200_000
+    evmos_gas_price = ibc.chains["evmos"].w3.eth.gas_price
+
+    dst_addr = ibc.chains["chainmain"].cosmos_cli().address("signer2")
+    src_adr = ibc.chains["evmos"].cosmos_cli().address("signer2")
+
+    # Deployment of contracts and initial checks
+    eth_contract, tx_receipt = deploy_contract(w3, CONTRACTS["ICS20FromContract"])
+    assert tx_receipt.status == 1
+
+    counter = eth_contract.functions.counter().call()
+    assert counter == 0
+
+    pc = get_precompile_contract(ibc.chains["evmos"].w3, "ICS20I")
+    # Approve the contract to spend the src_denom
+    approve_tx = pc.functions.approve(
+        eth_contract.address, [["transfer", "channel-0", [[src_denom, amt]], []]]
+    ).build_transaction(
+        {
+            "from": ADDRS["signer2"],
+            "gasPrice": evmos_gas_price,
+            "gas": gas_limit,
+        }
+    )
+    tx_receipt = send_transaction(ibc.chains["evmos"].w3, approve_tx, KEYS["signer2"])
+    assert tx_receipt.status == 1
+
+    def check_allowance_set():
+        new_allowance = pc.functions.allowance(
+            eth_contract.address, ADDRS["signer2"]
+        ).call()
+        return new_allowance != []
+
+    wait_for_fn("allowance has changed", check_allowance_set)
+
+    src_starting_balance = get_balance(ibc.chains["evmos"], src_adr, "aevmos")
+    dest_starting_balance = get_balance(
+        ibc.chains["chainmain"], dst_addr, EVMOS_IBC_DENOM
+    )
+    # Calling the actual transfer function on the custom contract
+    send_tx = eth_contract.functions.transferFromEOA(
+        "transfer", "channel-0", src_denom, amt, dst_addr
+    ).build_transaction(
+        {"from": ADDRS["signer2"], "gasPrice": evmos_gas_price, "gas": gas_limit}
+    )
+    receipt = send_transaction(ibc.chains["evmos"].w3, send_tx, KEYS["signer2"])
+    assert receipt.status == 1
+    fees = receipt.gasUsed * evmos_gas_price
+
+    final_dest_balance = dest_starting_balance
+    def check_dest_balance():
+        nonlocal final_dest_balance
+        final_dest_balance = get_balance(
+            ibc.chains["chainmain"], dst_addr, EVMOS_IBC_DENOM
+        )
+        return final_dest_balance > dest_starting_balance
+
+    wait_for_fn("destination balance change", check_dest_balance)
+    assert final_dest_balance == dest_starting_balance + amt
+
+    src_final_amount_evmos = get_balance(ibc.chains["evmos"], src_adr, src_denom)
+    assert src_final_amount_evmos == src_starting_balance - amt - fees
+
+    counter_after = eth_contract.functions.counter().call()
+    assert counter_after == 0
diff --git a/tests/nix_tests/test_precompiles.py b/tests/nix_tests/test_precompiles.py
index f8bfd9ac7d..e9c0efdb4d 100644
--- a/tests/nix_tests/test_precompiles.py
+++ b/tests/nix_tests/test_precompiles.py
@@ -67,7 +67,7 @@ def test_ibc_transfer(ibc):
 
     assert receipt.status == 1
     # check gas used
-    assert receipt.gasUsed == 48184
+    assert receipt.gasUsed == 49307
 
     # check gas estimation is accurate
     assert receipt.gasUsed == gas_estimation
diff --git a/tests/nix_tests/utils.py b/tests/nix_tests/utils.py
index 2561b164ca..36f14b24c3 100644
--- a/tests/nix_tests/utils.py
+++ b/tests/nix_tests/utils.py
@@ -2,6 +2,7 @@
 import configparser
 import json
 import os
+import requests
 import socket
 import subprocess
 import sys
@@ -15,6 +16,7 @@
 from dotenv import load_dotenv
 from eth_account import Account
 from hexbytes import HexBytes
+from pystarport import ports
 from pystarport.cluster import SUPERVISOR_CONFIG_FILE
 from web3 import Web3
 from web3._utils.transactions import fill_nonce, fill_transaction_defaults
@@ -40,6 +42,7 @@
     "TestChainID": "ChainID.sol",
     "Mars": "Mars.sol",
     "StateContract": "StateContract.sol",
+    "ICS20FromContract": "ICS20FromContract.sol",
     "ICS20I": "evmos/ics20/ICS20I.sol",
     "DistributionI": "evmos/distribution/DistributionI.sol",
     "StakingI": "evmos/staking/StakingI.sol",
@@ -539,3 +542,16 @@ def erc20_balance(w3, erc20_contract_addr, addr):
     info = json.loads(CONTRACTS["IERC20"].read_text())
     contract = w3.eth.contract(erc20_contract_addr, abi=info["abi"])
     return contract.functions.balanceOf(addr).call()
+
+
+def debug_trace_tx(evmos, tx_hash: str):
+    url = f"http://127.0.0.1:{ports.evmrpc_port(evmos.base_port(0))}"
+    params = {
+        "method": "debug_traceTransaction",
+        "params": [tx_hash, {"tracer": "callTracer"}],
+        "id": 1,
+        "jsonrpc": "2.0",
+    }
+    rsp = requests.post(url, json=params)
+    assert rsp.status_code == 200
+    return rsp.json()["result"]
diff --git a/x/evm/keeper/precompiles.go b/x/evm/keeper/precompiles.go
index bfae6db4b7..44c27eac6c 100644
--- a/x/evm/keeper/precompiles.go
+++ b/x/evm/keeper/precompiles.go
@@ -70,7 +70,7 @@ func AvailablePrecompiles(
 		panic(fmt.Errorf("failed to instantiate distribution precompile: %w", err))
 	}
 
-	ibcTransferPrecompile, err := ics20precompile.NewPrecompile(transferKeeper, channelKeeper, authzKeeper)
+	ibcTransferPrecompile, err := ics20precompile.NewPrecompile(stakingKeeper, transferKeeper, channelKeeper, authzKeeper)
 	if err != nil {
 		panic(fmt.Errorf("failed to instantiate ICS20 precompile: %w", err))
 	}
