diff --git a/include/h2o.h b/include/h2o.h
index 3de1303bea..a835c24d78 100644
--- a/include/h2o.h
+++ b/include/h2o.h
@@ -1594,6 +1594,10 @@ h2o_ostream_t *h2o_add_ostream(h2o_req_t *req, size_t alignment, size_t sz, h2o_
  * prepares the request for processing by looking at the method, URI, headers
  */
 h2o_hostconf_t *h2o_req_setup(h2o_req_t *req);
+/**
+ * applies given environment configuration to the request
+ */
+void h2o_req_apply_env(h2o_req_t *req, h2o_envconf_t *env);
 /**
  * binds configurations to the request
  */
diff --git a/include/h2o/configurator.h b/include/h2o/configurator.h
index 2a241db1a2..5ee8bd0628 100644
--- a/include/h2o/configurator.h
+++ b/include/h2o/configurator.h
@@ -142,6 +142,10 @@ int h2o_configurator_apply(h2o_globalconf_t *config, yoml_t *node, int dry_run);
  *
  */
 int h2o_configurator_apply_commands(h2o_configurator_context_t *ctx, yoml_t *node, int flags_mask, const char **ignore_commands);
+/**
+ *
+ */
+static int h2o_configurator_at_extension_level(h2o_configurator_context_t *ctx);
 /**
  * emits configuration error
  */
@@ -193,4 +197,11 @@ void h2o_configurator_define_headers_commands(h2o_globalconf_t *global_conf, h2o
 void h2o_configurator__init_core(h2o_globalconf_t *conf);
 void h2o_configurator__dispose_configurators(h2o_globalconf_t *conf);
 
+/* inline definitions */
+
+inline int h2o_configurator_at_extension_level(h2o_configurator_context_t *ctx)
+{
+    return ctx->pathconf != NULL && ctx->pathconf->path.base == NULL && ctx->pathconf != &ctx->hostconf->fallback_path;
+}
+
 #endif
diff --git a/lib/core/request.c b/lib/core/request.c
index 235862e7f1..4bf02bb76e 100644
--- a/lib/core/request.c
+++ b/lib/core/request.c
@@ -570,12 +570,12 @@ h2o_ostream_t *h2o_add_ostream(h2o_req_t *req, size_t alignment, size_t sz, h2o_
     return ostr;
 }
 
-static void apply_env(h2o_req_t *req, h2o_envconf_t *env)
+void h2o_req_apply_env(h2o_req_t *req, h2o_envconf_t *env)
 {
     size_t i;
 
     if (env->parent != NULL)
-        apply_env(req, env->parent);
+        h2o_req_apply_env(req, env->parent);
     for (i = 0; i != env->unsets.size; ++i)
         h2o_req_unsetenv(req, env->unsets.entries[i].base, env->unsets.entries[i].len);
     for (i = 0; i != env->sets.size; i += 2)
@@ -594,7 +594,7 @@ void h2o_req_bind_conf(h2o_req_t *req, h2o_hostconf_t *hostconf, h2o_pathconf_t
     req->num_loggers = pathconf->_loggers.size;
 
     if (pathconf->env != NULL)
-        apply_env(req, pathconf->env);
+        h2o_req_apply_env(req, pathconf->env);
 }
 
 void h2o_proceed_response_deferred(h2o_req_t *req)
diff --git a/lib/handler/configurator/access_log.c b/lib/handler/configurator/access_log.c
index e63794123c..6711a041d7 100644
--- a/lib/handler/configurator/access_log.c
+++ b/lib/handler/configurator/access_log.c
@@ -101,7 +101,7 @@ static int on_config_exit(h2o_configurator_t *_self, h2o_configurator_context_t
     /* register all handles, and decref them */
     for (i = 0; i != self->handles->size; ++i) {
         h2o_access_log_filehandle_t *fh = self->handles->entries[i];
-        if (ctx->pathconf != NULL)
+        if (ctx->pathconf != NULL && !h2o_configurator_at_extension_level(ctx))
             h2o_access_log_register(ctx->pathconf, fh);
         h2o_mem_release_shared(fh);
     }
@@ -122,5 +122,7 @@ void h2o_access_log_register_configurator(h2o_globalconf_t *conf)
     self->super.exit = on_config_exit;
     self->handles = self->_handles_stack;
 
-    h2o_configurator_define_command(&self->super, "access-log", H2O_CONFIGURATOR_FLAG_ALL_LEVELS, on_config);
+    h2o_configurator_define_command(&self->super, "access-log",
+                                    H2O_CONFIGURATOR_FLAG_GLOBAL | H2O_CONFIGURATOR_FLAG_HOST | H2O_CONFIGURATOR_FLAG_PATH,
+                                    on_config);
 }
diff --git a/lib/handler/configurator/compress.c b/lib/handler/configurator/compress.c
index cb09633555..ccd005b4ab 100644
--- a/lib/handler/configurator/compress.c
+++ b/lib/handler/configurator/compress.c
@@ -140,7 +140,8 @@ static int on_config_exit(h2o_configurator_t *configurator, h2o_configurator_con
 {
     struct compress_configurator_t *self = (void *)configurator;
 
-    if (ctx->pathconf != NULL && (self->vars->gzip.quality != -1 || self->vars->brotli.quality != -1))
+    if (ctx->pathconf != NULL && !h2o_configurator_at_extension_level(ctx) &&
+        (self->vars->gzip.quality != -1 || self->vars->brotli.quality != -1))
         h2o_compress_register(ctx->pathconf, self->vars);
 
     --self->vars;
@@ -153,11 +154,16 @@ void h2o_compress_register_configurator(h2o_globalconf_t *conf)
 
     c->super.enter = on_config_enter;
     c->super.exit = on_config_exit;
-    h2o_configurator_define_command(&c->super, "compress", H2O_CONFIGURATOR_FLAG_ALL_LEVELS, on_config_compress);
+    h2o_configurator_define_command(&c->super, "compress",
+                                    H2O_CONFIGURATOR_FLAG_GLOBAL | H2O_CONFIGURATOR_FLAG_HOST | H2O_CONFIGURATOR_FLAG_PATH,
+                                    on_config_compress);
     h2o_configurator_define_command(&c->super, "compress-minimum-size",
-                                    H2O_CONFIGURATOR_FLAG_ALL_LEVELS | H2O_CONFIGURATOR_FLAG_EXPECT_SCALAR,
+                                    H2O_CONFIGURATOR_FLAG_GLOBAL | H2O_CONFIGURATOR_FLAG_HOST | H2O_CONFIGURATOR_FLAG_PATH |
+                                        H2O_CONFIGURATOR_FLAG_EXPECT_SCALAR,
                                     on_config_compress_min_size);
-    h2o_configurator_define_command(&c->super, "gzip", H2O_CONFIGURATOR_FLAG_ALL_LEVELS | H2O_CONFIGURATOR_FLAG_EXPECT_SCALAR,
+    h2o_configurator_define_command(&c->super, "gzip",
+                                    H2O_CONFIGURATOR_FLAG_GLOBAL | H2O_CONFIGURATOR_FLAG_HOST | H2O_CONFIGURATOR_FLAG_PATH |
+                                        H2O_CONFIGURATOR_FLAG_EXPECT_SCALAR,
                                     on_config_gzip);
     c->vars = c->_vars_stack;
     c->vars->gzip.quality = -1;
diff --git a/lib/handler/configurator/errordoc.c b/lib/handler/configurator/errordoc.c
index 684ae37632..ec5acea8ea 100644
--- a/lib/handler/configurator/errordoc.c
+++ b/lib/handler/configurator/errordoc.c
@@ -133,7 +133,7 @@ static int on_config_exit(h2o_configurator_t *_self, h2o_configurator_context_t
 {
     struct errordoc_configurator_t *self = (void *)_self;
 
-    if (ctx->pathconf != NULL && self->vars->size != 0)
+    if (ctx->pathconf != NULL && !h2o_configurator_at_extension_level(ctx) && self->vars->size != 0)
         h2o_errordoc_register(ctx->pathconf, self->vars->entries, self->vars->size);
 
     --self->vars;
@@ -157,5 +157,7 @@ void h2o_errordoc_register_configurator(h2o_globalconf_t *conf)
     c->super.exit = on_config_exit;
 
     /* reproxy: ON | OFF */
-    h2o_configurator_define_command(&c->super, "error-doc", H2O_CONFIGURATOR_FLAG_ALL_LEVELS, on_config_errordoc);
+    h2o_configurator_define_command(&c->super, "error-doc",
+                                    H2O_CONFIGURATOR_FLAG_GLOBAL | H2O_CONFIGURATOR_FLAG_HOST | H2O_CONFIGURATOR_FLAG_PATH,
+                                    on_config_errordoc);
 }
diff --git a/lib/handler/configurator/expires.c b/lib/handler/configurator/expires.c
index 01d404dd57..bc7b7513bd 100644
--- a/lib/handler/configurator/expires.c
+++ b/lib/handler/configurator/expires.c
@@ -95,9 +95,8 @@ static int on_config_exit(h2o_configurator_t *_self, h2o_configurator_context_t
 
     if (*self->args != NULL) {
         /* setup */
-        if (ctx->pathconf != NULL) {
+        if (ctx->pathconf != NULL && !h2o_configurator_at_extension_level(ctx))
             h2o_expires_register(ctx->pathconf, *self->args);
-        }
         /* destruct */
         assert((*self->args)->mode == H2O_EXPIRES_MODE_MAX_AGE);
         free(*self->args);
@@ -118,6 +117,8 @@ void h2o_expires_register_configurator(h2o_globalconf_t *conf)
     /* setup handlers */
     c->super.enter = on_config_enter;
     c->super.exit = on_config_exit;
-    h2o_configurator_define_command(&c->super, "expires", H2O_CONFIGURATOR_FLAG_ALL_LEVELS | H2O_CONFIGURATOR_FLAG_EXPECT_SCALAR,
+    h2o_configurator_define_command(&c->super, "expires",
+                                    H2O_CONFIGURATOR_FLAG_GLOBAL | H2O_CONFIGURATOR_FLAG_HOST | H2O_CONFIGURATOR_FLAG_PATH |
+                                        H2O_CONFIGURATOR_FLAG_EXPECT_SCALAR,
                                     on_config_expires);
 }
diff --git a/lib/handler/configurator/fastcgi.c b/lib/handler/configurator/fastcgi.c
index fb365fea68..15331e7313 100644
--- a/lib/handler/configurator/fastcgi.c
+++ b/lib/handler/configurator/fastcgi.c
@@ -178,10 +178,12 @@ static int create_spawnproc(h2o_configurator_command_t *cmd, yoml_t *node, const
     if (fcntl(pipe_fds[1], F_SETFD, FD_CLOEXEC) < 0)
         goto Error;
 
-    /* spawn */
-    int mapped_fds[] = {listen_fd, 0,   /* listen_fd to 0 */
-                        pipe_fds[0], 5, /* pipe_fds[0] to 5 */
-                        -1};
+    /* spawn, mapping listen_fd to fd 0, read-side of the pipe to fd 5 */
+    int mapped_fds[] = {listen_fd, 0, -1, -1, -1};
+    if (pipe_fds[0] != 5) {
+        mapped_fds[2] = pipe_fds[0];
+        mapped_fds[3] = 5;
+    }
     pid_t pid = h2o_spawnp(argv[0], argv, mapped_fds, 0);
     if (pid == -1) {
         h2o_error_printf("[lib/handler/fastcgi.c] failed to launch helper program %s:%s\n", argv[0], strerror(errno));
diff --git a/lib/handler/configurator/headers.c b/lib/handler/configurator/headers.c
index 68536c0529..1107d6b8fc 100644
--- a/lib/handler/configurator/headers.c
+++ b/lib/handler/configurator/headers.c
@@ -44,7 +44,7 @@ static int on_config_exit(h2o_configurator_t *_self, h2o_configurator_context_t
 {
     struct headers_configurator_t *self = (void *)_self;
 
-    if (ctx->pathconf != NULL && *self->cmds != NULL) {
+    if (ctx->pathconf != NULL && !h2o_configurator_at_extension_level(ctx) && *self->cmds != NULL) {
         if (*self->cmds != NULL)
             h2o_mem_addref_shared(*self->cmds);
         h2o_headers_register(ctx->pathconf, *self->cmds);
diff --git a/lib/handler/configurator/headers_util.c b/lib/handler/configurator/headers_util.c
index 8304efebc7..3d84d16cf1 100644
--- a/lib/handler/configurator/headers_util.c
+++ b/lib/handler/configurator/headers_util.c
@@ -255,8 +255,9 @@ void h2o_configurator_define_headers_commands(h2o_globalconf_t *global_conf, h2o
 
 #define DEFINE_CMD(name, cb)                                                                                                       \
     h2o_configurator_define_command(&c->super, name,                                                                               \
-                                    H2O_CONFIGURATOR_FLAG_ALL_LEVELS | H2O_CONFIGURATOR_FLAG_EXPECT_SCALAR |                       \
-                                        H2O_CONFIGURATOR_FLAG_EXPECT_SEQUENCE | H2O_CONFIGURATOR_FLAG_EXPECT_MAPPING,              \
+                                    H2O_CONFIGURATOR_FLAG_GLOBAL | H2O_CONFIGURATOR_FLAG_HOST | H2O_CONFIGURATOR_FLAG_PATH |       \
+                                        H2O_CONFIGURATOR_FLAG_EXPECT_SCALAR | H2O_CONFIGURATOR_FLAG_EXPECT_SEQUENCE |              \
+                                        H2O_CONFIGURATOR_FLAG_EXPECT_MAPPING,                                                      \
                                     cb)
     DEFINE_CMD(add_directive, on_config_header_add);
     DEFINE_CMD(append_directive, on_config_header_append);
diff --git a/lib/handler/configurator/reproxy.c b/lib/handler/configurator/reproxy.c
index 21650e4fb2..0b58a425df 100644
--- a/lib/handler/configurator/reproxy.c
+++ b/lib/handler/configurator/reproxy.c
@@ -57,7 +57,7 @@ static int on_config_exit(h2o_configurator_t *_self, h2o_configurator_context_t
 {
     struct reproxy_configurator_t *self = (void *)_self;
 
-    if (ctx->pathconf != NULL && self->vars->enabled != 0)
+    if (ctx->pathconf != NULL && !h2o_configurator_at_extension_level(ctx) && self->vars->enabled != 0)
         h2o_reproxy_register(ctx->pathconf);
 
     --self->vars;
@@ -76,6 +76,8 @@ void h2o_reproxy_register_configurator(h2o_globalconf_t *conf)
     c->super.exit = on_config_exit;
 
     /* reproxy: ON | OFF */
-    h2o_configurator_define_command(&c->super, "reproxy", H2O_CONFIGURATOR_FLAG_ALL_LEVELS | H2O_CONFIGURATOR_FLAG_EXPECT_SCALAR,
+    h2o_configurator_define_command(&c->super, "reproxy",
+                                    H2O_CONFIGURATOR_FLAG_GLOBAL | H2O_CONFIGURATOR_FLAG_HOST | H2O_CONFIGURATOR_FLAG_PATH |
+                                        H2O_CONFIGURATOR_FLAG_EXPECT_SCALAR,
                                     on_config_reproxy);
 }
diff --git a/lib/handler/configurator/server_timing.c b/lib/handler/configurator/server_timing.c
index bb5e7fe48a..8c7ad926d8 100644
--- a/lib/handler/configurator/server_timing.c
+++ b/lib/handler/configurator/server_timing.c
@@ -59,7 +59,7 @@ static int on_config_exit(h2o_configurator_t *_self, h2o_configurator_context_t
 {
     struct server_timing_configurator_t *self = (void *)_self;
 
-    if (ctx->pathconf != NULL && self->vars->mode != SERVER_TIMING_MODE_OFF)
+    if (ctx->pathconf != NULL && !h2o_configurator_at_extension_level(ctx) && self->vars->mode != SERVER_TIMING_MODE_OFF)
         h2o_server_timing_register(ctx->pathconf, self->vars->mode == SERVER_TIMING_MODE_ENFORCE);
 
     --self->vars;
@@ -78,5 +78,7 @@ void h2o_server_timing_register_configurator(h2o_globalconf_t *conf)
     c->super.exit = on_config_exit;
 
     /* server_timing: ON | OFF */
-    h2o_configurator_define_command(&c->super, "server-timing", H2O_CONFIGURATOR_FLAG_ALL_LEVELS, on_config_server_timing);
+    h2o_configurator_define_command(&c->super, "server-timing",
+                                    H2O_CONFIGURATOR_FLAG_GLOBAL | H2O_CONFIGURATOR_FLAG_HOST | H2O_CONFIGURATOR_FLAG_PATH,
+                                    on_config_server_timing);
 }
diff --git a/lib/handler/configurator/throttle_resp.c b/lib/handler/configurator/throttle_resp.c
index 61431f756a..d951cd112d 100644
--- a/lib/handler/configurator/throttle_resp.c
+++ b/lib/handler/configurator/throttle_resp.c
@@ -53,7 +53,7 @@ static int on_config_exit(h2o_configurator_t *configurator, h2o_configurator_con
 {
     struct throttle_resp_configurator_t *self = (void *)configurator;
 
-    if (ctx->pathconf != NULL && self->vars->on)
+    if (ctx->pathconf != NULL && !h2o_configurator_at_extension_level(ctx) && self->vars->on)
         h2o_throttle_resp_register(ctx->pathconf);
 
     --self->vars;
@@ -67,7 +67,8 @@ void h2o_throttle_resp_register_configurator(h2o_globalconf_t *conf)
     c->super.enter = on_config_enter;
     c->super.exit = on_config_exit;
     h2o_configurator_define_command(&c->super, "throttle-response",
-                                    H2O_CONFIGURATOR_FLAG_ALL_LEVELS | H2O_CONFIGURATOR_FLAG_EXPECT_SCALAR,
+                                    H2O_CONFIGURATOR_FLAG_GLOBAL | H2O_CONFIGURATOR_FLAG_HOST | H2O_CONFIGURATOR_FLAG_PATH |
+                                        H2O_CONFIGURATOR_FLAG_EXPECT_SCALAR,
                                     on_config_throttle_resp);
     c->vars = c->_vars_stack;
 }
diff --git a/lib/handler/file.c b/lib/handler/file.c
index 6e82d30e5c..0c23c0b0aa 100644
--- a/lib/handler/file.c
+++ b/lib/handler/file.c
@@ -598,19 +598,25 @@ static int delegate_dynamic_request(h2o_req_t *req, h2o_iovec_t script_name, h2o
                                     size_t local_path_len, h2o_mimemap_type_t *mime_type)
 {
     h2o_filereq_t *filereq;
-    h2o_handler_t *handler;
 
     assert(mime_type->data.dynamic.pathconf.handlers.size == 1);
+    assert(mime_type->data.dynamic.pathconf._filters.size == 0);
+    assert(mime_type->data.dynamic.pathconf._loggers.size == 0);
 
+    /* setup CGI attributes (e.g., PATH_INFO) */
     filereq = h2o_mem_alloc_pool(&req->pool, *filereq, 1);
     filereq->script_name = script_name;
     filereq->path_info = path_info;
     filereq->local_path = h2o_strdup(&req->pool, local_path, local_path_len);
-
-    h2o_req_bind_conf(req, req->hostconf, &mime_type->data.dynamic.pathconf);
     req->filereq = filereq;
 
-    handler = mime_type->data.dynamic.pathconf.handlers.entries[0];
+    /* apply environment */
+    if (mime_type->data.dynamic.pathconf.env != NULL)
+        h2o_req_apply_env(req, mime_type->data.dynamic.pathconf.env);
+
+    /* call the dynamic handler while retaining current hostconf or pathconf; in other words, filters and loggers of current
+     * path level is applied, rather than of the extension level */
+    h2o_handler_t *handler = mime_type->data.dynamic.pathconf.handlers.entries[0];
     return handler->on_req(handler, req);
 }
 
diff --git a/t/50file-custom-handler.t b/t/50file-custom-handler.t
index 94a1be257a..5730c852e7 100644
--- a/t/50file-custom-handler.t
+++ b/t/50file-custom-handler.t
@@ -123,11 +123,14 @@ EOT
     my $doit = sub {
         my ($path, $expected) = @_;
         subtest $path => sub {
-            my $resp = `curl --silent http://127.0.0.1:$server->{port}$path`;
-            my $env = +{ map { split(':', $_, 2) } split(/\n/, $resp) };
-            for my $key (sort keys %$expected) {
-                is $env->{$key}, $expected->{$key}, $key;
-            }
+            run_with_curl($server, sub {
+                my ($proto, $port, $cmd) = @_;
+                my $resp = `$cmd --silent $proto://127.0.0.1:$port$path`;
+                my $env = +{ map { split(':', $_, 2) } split(/\n/, $resp) };
+                for my $key (sort keys %$expected) {
+                    is $env->{$key}, $expected->{$key}, $key;
+                }
+            });
         };
     };
 
@@ -144,5 +147,31 @@ EOT
 
 };
 
-done_testing;
+subtest 'pathconf' => sub {
+    eval q{use CGI; 1}
+        or plan skip_all => 'CGI.pm not found';
+
+    # spawn h2o
+    my $server = spawn_h2o(<< "EOT");
+file.index: ['printenv.cgi']
+file.custom-handler:
+  extension: .cgi
+  fastcgi.spawn: "exec \$H2O_ROOT/share/h2o/fastcgi-cgi"
+hosts:
+  default:
+    paths:
+      /:
+        file.dir: @{[DOC_ROOT]}
+        header.set: "path: 3"
+    header.set: "host: 2"
+header.set: "global: 1"
+EOT
 
+    run_with_curl($server, sub {
+        my ($proto, $port, $cmd) = @_;
+        my $resp = `$cmd --silent --dump-header /dev/stdout $proto://127.0.0.1:$port/hello.cgi?name=h2o`;
+        like $resp, qr{\nglobal: 1\r?\nhost: 2\r?\npath: 3\r?\n.*\r?\nHello h2o$}s;
+    });
+};
+
+done_testing;
