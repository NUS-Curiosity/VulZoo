diff --git a/src/ImageSharp/Formats/Gif/GifDecoderCore.cs b/src/ImageSharp/Formats/Gif/GifDecoderCore.cs
index d64792eba7..982dbdc780 100644
--- a/src/ImageSharp/Formats/Gif/GifDecoderCore.cs
+++ b/src/ImageSharp/Formats/Gif/GifDecoderCore.cs
@@ -427,68 +427,49 @@ private void ReadFrame<TPixel>(BufferedReadStream stream, ref Image<TPixel>? ima
     {
         this.ReadImageDescriptor(stream);
 
-        Buffer2D<byte>? indices = null;
-        try
-        {
-            // Determine the color table for this frame. If there is a local one, use it otherwise use the global color table.
-            bool hasLocalColorTable = this.imageDescriptor.LocalColorTableFlag;
-
-            if (hasLocalColorTable)
-            {
-                // Read and store the local color table. We allocate the maximum possible size and slice to match.
-                int length = this.currentLocalColorTableSize = this.imageDescriptor.LocalColorTableSize * 3;
-                this.currentLocalColorTable ??= this.configuration.MemoryAllocator.Allocate<byte>(768, AllocationOptions.Clean);
-                stream.Read(this.currentLocalColorTable.GetSpan()[..length]);
-            }
-
-            indices = this.configuration.MemoryAllocator.Allocate2D<byte>(this.imageDescriptor.Width, this.imageDescriptor.Height, AllocationOptions.Clean);
-            this.ReadFrameIndices(stream, indices);
+        // Determine the color table for this frame. If there is a local one, use it otherwise use the global color table.
+        bool hasLocalColorTable = this.imageDescriptor.LocalColorTableFlag;
 
-            Span<byte> rawColorTable = default;
-            if (hasLocalColorTable)
-            {
-                rawColorTable = this.currentLocalColorTable!.GetSpan()[..this.currentLocalColorTableSize];
-            }
-            else if (this.globalColorTable != null)
-            {
-                rawColorTable = this.globalColorTable.GetSpan();
-            }
-
-            ReadOnlySpan<Rgb24> colorTable = MemoryMarshal.Cast<byte, Rgb24>(rawColorTable);
-            this.ReadFrameColors(ref image, ref previousFrame, indices, colorTable, this.imageDescriptor);
+        if (hasLocalColorTable)
+        {
+            // Read and store the local color table. We allocate the maximum possible size and slice to match.
+            int length = this.currentLocalColorTableSize = this.imageDescriptor.LocalColorTableSize * 3;
+            this.currentLocalColorTable ??= this.configuration.MemoryAllocator.Allocate<byte>(768, AllocationOptions.Clean);
+            stream.Read(this.currentLocalColorTable.GetSpan()[..length]);
+        }
 
-            // Skip any remaining blocks
-            SkipBlock(stream);
+        Span<byte> rawColorTable = default;
+        if (hasLocalColorTable)
+        {
+            rawColorTable = this.currentLocalColorTable!.GetSpan()[..this.currentLocalColorTableSize];
         }
-        finally
+        else if (this.globalColorTable != null)
         {
-            indices?.Dispose();
+            rawColorTable = this.globalColorTable.GetSpan();
         }
-    }
 
-    /// <summary>
-    /// Reads the frame indices marking the color to use for each pixel.
-    /// </summary>
-    /// <param name="stream">The <see cref="BufferedReadStream"/> containing image data.</param>
-    /// <param name="indices">The 2D pixel buffer to write to.</param>
-    [MethodImpl(MethodImplOptions.AggressiveInlining)]
-    private void ReadFrameIndices(BufferedReadStream stream, Buffer2D<byte> indices)
-    {
-        int minCodeSize = stream.ReadByte();
-        using LzwDecoder lzwDecoder = new(this.configuration.MemoryAllocator, stream);
-        lzwDecoder.DecodePixels(minCodeSize, indices);
+        ReadOnlySpan<Rgb24> colorTable = MemoryMarshal.Cast<byte, Rgb24>(rawColorTable);
+        this.ReadFrameColors(stream, ref image, ref previousFrame, colorTable, this.imageDescriptor);
+
+        // Skip any remaining blocks
+        SkipBlock(stream);
     }
 
     /// <summary>
     /// Reads the frames colors, mapping indices to colors.
     /// </summary>
     /// <typeparam name="TPixel">The pixel format.</typeparam>
+    /// <param name="stream">The <see cref="BufferedReadStream"/> containing image data.</param>
     /// <param name="image">The image to decode the information to.</param>
     /// <param name="previousFrame">The previous frame.</param>
-    /// <param name="indices">The indexed pixels.</param>
     /// <param name="colorTable">The color table containing the available colors.</param>
     /// <param name="descriptor">The <see cref="GifImageDescriptor"/></param>
-    private void ReadFrameColors<TPixel>(ref Image<TPixel>? image, ref ImageFrame<TPixel>? previousFrame, Buffer2D<byte> indices, ReadOnlySpan<Rgb24> colorTable, in GifImageDescriptor descriptor)
+    private void ReadFrameColors<TPixel>(
+        BufferedReadStream stream,
+        ref Image<TPixel>? image,
+        ref ImageFrame<TPixel>? previousFrame,
+        ReadOnlySpan<Rgb24> colorTable,
+        in GifImageDescriptor descriptor)
         where TPixel : unmanaged, IPixel<TPixel>
     {
         int imageWidth = this.logicalScreenDescriptor.Width;
@@ -549,69 +530,79 @@ private void ReadFrameColors<TPixel>(ref Image<TPixel>? image, ref ImageFrame<TP
         byte transIndex = this.graphicsControlExtension.TransparencyIndex;
         int colorTableMaxIdx = colorTable.Length - 1;
 
-        for (int y = descriptorTop; y < descriptorBottom && y < imageHeight; y++)
+        // For a properly encoded gif the descriptor dimensions will never exceed the logical screen dimensions.
+        // However we have images that exceed this that can be decoded by other libraries. #1530
+        using IMemoryOwner<byte> indicesRowOwner = this.memoryAllocator.Allocate<byte>(descriptor.Width);
+        Span<byte> indicesRow = indicesRowOwner.Memory.Span;
+        ref byte indicesRowRef = ref MemoryMarshal.GetReference(indicesRow);
+
+        int minCodeSize = stream.ReadByte();
+        if (LzwDecoder.IsValidMinCodeSize(minCodeSize))
         {
-            ref byte indicesRowRef = ref MemoryMarshal.GetReference(indices.DangerousGetRowSpan(y - descriptorTop));
+            using LzwDecoder lzwDecoder = new(this.configuration.MemoryAllocator, stream, minCodeSize);
 
-            // Check if this image is interlaced.
-            int writeY; // the target y offset to write to
-            if (descriptor.InterlaceFlag)
+            for (int y = descriptorTop; y < descriptorBottom && y < imageHeight; y++)
             {
-                // If so then we read lines at predetermined offsets.
-                // When an entire image height worth of offset lines has been read we consider this a pass.
-                // With each pass the number of offset lines changes and the starting line changes.
-                if (interlaceY >= descriptor.Height)
+                // Check if this image is interlaced.
+                int writeY; // the target y offset to write to
+                if (descriptor.InterlaceFlag)
                 {
-                    interlacePass++;
-                    switch (interlacePass)
+                    // If so then we read lines at predetermined offsets.
+                    // When an entire image height worth of offset lines has been read we consider this a pass.
+                    // With each pass the number of offset lines changes and the starting line changes.
+                    if (interlaceY >= descriptor.Height)
                     {
-                        case 1:
-                            interlaceY = 4;
-                            break;
-                        case 2:
-                            interlaceY = 2;
-                            interlaceIncrement = 4;
-                            break;
-                        case 3:
-                            interlaceY = 1;
-                            interlaceIncrement = 2;
-                            break;
+                        interlacePass++;
+                        switch (interlacePass)
+                        {
+                            case 1:
+                                interlaceY = 4;
+                                break;
+                            case 2:
+                                interlaceY = 2;
+                                interlaceIncrement = 4;
+                                break;
+                            case 3:
+                                interlaceY = 1;
+                                interlaceIncrement = 2;
+                                break;
+                        }
                     }
-                }
 
-                writeY = interlaceY + descriptor.Top;
-                interlaceY += interlaceIncrement;
-            }
-            else
-            {
-                writeY = y;
-            }
+                    writeY = Math.Min(interlaceY + descriptor.Top, image.Height);
+                    interlaceY += interlaceIncrement;
+                }
+                else
+                {
+                    writeY = y;
+                }
 
-            ref TPixel rowRef = ref MemoryMarshal.GetReference(imageFrame.PixelBuffer.DangerousGetRowSpan(writeY));
+                lzwDecoder.DecodePixelRow(indicesRow);
+                ref TPixel rowRef = ref MemoryMarshal.GetReference(imageFrame.PixelBuffer.DangerousGetRowSpan(writeY));
 
-            if (!transFlag)
-            {
-                // #403 The left + width value can be larger than the image width
-                for (int x = descriptorLeft; x < descriptorRight && x < imageWidth; x++)
+                if (!transFlag)
                 {
-                    int index = Numerics.Clamp(Unsafe.Add(ref indicesRowRef, (uint)(x - descriptorLeft)), 0, colorTableMaxIdx);
-                    Unsafe.Add(ref rowRef, (uint)x) = TPixel.FromRgb24(colorTable[index]);
+                    // #403 The left + width value can be larger than the image width
+                    for (int x = descriptorLeft; x < descriptorRight && x < imageWidth; x++)
+                    {
+                        int index = Numerics.Clamp(Unsafe.Add(ref indicesRowRef, (uint)(x - descriptorLeft)), 0, colorTableMaxIdx);
+                        Unsafe.Add(ref rowRef, (uint)x) = TPixel.FromRgb24(colorTable[index]);
+                    }
                 }
-            }
-            else
-            {
-                for (int x = descriptorLeft; x < descriptorRight && x < imageWidth; x++)
+                else
                 {
-                    int rawIndex = Unsafe.Add(ref indicesRowRef, (uint)(x - descriptorLeft));
-
-                    // Treat any out of bounds values as transparent.
-                    if (rawIndex > colorTableMaxIdx || rawIndex == transIndex)
+                    for (int x = descriptorLeft; x < descriptorRight && x < imageWidth; x++)
                     {
-                        continue;
-                    }
+                        int index = Unsafe.Add(ref indicesRowRef, (uint)(x - descriptorLeft));
+
+                        // Treat any out of bounds values as transparent.
+                        if (index > colorTableMaxIdx || index == transIndex)
+                        {
+                            continue;
+                        }
 
-                    int index = Numerics.Clamp(rawIndex, 0, colorTableMaxIdx);
-                    Unsafe.Add(ref rowRef, (uint)x) = TPixel.FromRgb24(colorTable[index]);
+                        Unsafe.Add(ref rowRef, (uint)x) = TPixel.FromRgb24(colorTable[index]);
+                    }
                 }
             }
         }
@@ -652,8 +643,11 @@ private void ReadFrameMetadata(BufferedReadStream stream, List<ImageFrameMetadat
         // Skip the frame indices. Pixels length + mincode size.
         // The gif format does not tell us the length of the compressed data beforehand.
         int minCodeSize = stream.ReadByte();
-        using LzwDecoder lzwDecoder = new(this.configuration.MemoryAllocator, stream);
-        lzwDecoder.SkipIndices(minCodeSize, this.imageDescriptor.Width * this.imageDescriptor.Height);
+        if (LzwDecoder.IsValidMinCodeSize(minCodeSize))
+        {
+            using LzwDecoder lzwDecoder = new(this.configuration.MemoryAllocator, stream, minCodeSize);
+            lzwDecoder.SkipIndices(this.imageDescriptor.Width * this.imageDescriptor.Height);
+        }
 
         ImageFrameMetadata currentFrame = new();
         frameMetadata.Add(currentFrame);
diff --git a/src/ImageSharp/Formats/Gif/LzwDecoder.cs b/src/ImageSharp/Formats/Gif/LzwDecoder.cs
index 19f646b597..ec33f2b3ed 100644
--- a/src/ImageSharp/Formats/Gif/LzwDecoder.cs
+++ b/src/ImageSharp/Formats/Gif/LzwDecoder.cs
@@ -44,10 +44,29 @@ internal sealed class LzwDecoder : IDisposable
     /// </summary>
     private readonly IMemoryOwner<int> suffix;
 
+    /// <summary>
+    /// The scratch buffer for reading data blocks.
+    /// </summary>
+    private readonly IMemoryOwner<byte> scratchBuffer;
+
     /// <summary>
     /// The pixel stack buffer.
     /// </summary>
     private readonly IMemoryOwner<int> pixelStack;
+    private readonly int minCodeSize;
+    private readonly int clearCode;
+    private readonly int endCode;
+    private int code;
+    private int codeSize;
+    private int codeMask;
+    private int availableCode;
+    private int oldCode = NullCode;
+    private int bits;
+    private int top;
+    private int count;
+    private int bufferIndex;
+    private int data;
+    private int first;
 
     /// <summary>
     /// Initializes a new instance of the <see cref="LzwDecoder"/> class
@@ -55,335 +74,277 @@ internal sealed class LzwDecoder : IDisposable
     /// </summary>
     /// <param name="memoryAllocator">The <see cref="MemoryAllocator"/> to use for buffer allocations.</param>
     /// <param name="stream">The stream to read from.</param>
+    /// <param name="minCodeSize">The minimum code size.</param>
     /// <exception cref="ArgumentNullException"><paramref name="stream"/> is null.</exception>
-    public LzwDecoder(MemoryAllocator memoryAllocator, BufferedReadStream stream)
+    public LzwDecoder(MemoryAllocator memoryAllocator, BufferedReadStream stream, int minCodeSize)
     {
         this.stream = stream ?? throw new ArgumentNullException(nameof(stream));
 
         this.prefix = memoryAllocator.Allocate<int>(MaxStackSize, AllocationOptions.Clean);
         this.suffix = memoryAllocator.Allocate<int>(MaxStackSize, AllocationOptions.Clean);
         this.pixelStack = memoryAllocator.Allocate<int>(MaxStackSize + 1, AllocationOptions.Clean);
+        this.scratchBuffer = memoryAllocator.Allocate<byte>(byte.MaxValue, AllocationOptions.None);
+        this.minCodeSize = minCodeSize;
+
+        // Calculate the clear code. The value of the clear code is 2 ^ minCodeSize
+        this.clearCode = 1 << minCodeSize;
+        this.codeSize = minCodeSize + 1;
+        this.codeMask = (1 << this.codeSize) - 1;
+        this.endCode = this.clearCode + 1;
+        this.availableCode = this.clearCode + 2;
+
+        ref int suffixRef = ref MemoryMarshal.GetReference(this.suffix.GetSpan());
+        for (this.code = 0; this.code < this.clearCode; this.code++)
+        {
+            Unsafe.Add(ref suffixRef, (uint)this.code) = (byte)this.code;
+        }
     }
 
     /// <summary>
-    /// Decodes and decompresses all pixel indices from the stream, assigning the pixel values to the buffer.
+    /// Gets a value indicating whether the minimum code size is valid.
     /// </summary>
-    /// <param name="minCodeSize">Minimum code size of the data.</param>
-    /// <param name="pixels">The pixel array to decode to.</param>
-    public void DecodePixels(int minCodeSize, Buffer2D<byte> pixels)
+    /// <param name="minCodeSize">The minimum code size.</param>
+    /// <returns>
+    /// <see langword="true"/> if the minimum code size is valid; otherwise, <see langword="false"/>.
+    /// </returns>
+    public static bool IsValidMinCodeSize(int minCodeSize)
     {
-        // Calculate the clear code. The value of the clear code is 2 ^ minCodeSize
-        int clearCode = 1 << minCodeSize;
-
         // It is possible to specify a larger LZW minimum code size than the palette length in bits
         // which may leave a gap in the codes where no colors are assigned.
         // http://www.matthewflickinger.com/lab/whatsinagif/lzw_image_data.asp#lzw_compression
+        int clearCode = 1 << minCodeSize;
         if (minCodeSize < 2 || minCodeSize > MaximumLzwBits || clearCode > MaxStackSize)
         {
             // Don't attempt to decode the frame indices.
             // Theoretically we could determine a min code size from the length of the provided
             // color palette but we won't bother since the image is most likely corrupted.
-            return;
+            return false;
         }
 
-        // The resulting index table length.
-        int width = pixels.Width;
-        int height = pixels.Height;
-        int length = width * height;
-
-        int codeSize = minCodeSize + 1;
-
-        // Calculate the end code
-        int endCode = clearCode + 1;
-
-        // Calculate the available code.
-        int availableCode = clearCode + 2;
-
-        // Jillzhangs Code see: http://giflib.codeplex.com/
-        // Adapted from John Cristy's ImageMagick.
-        int code;
-        int oldCode = NullCode;
-        int codeMask = (1 << codeSize) - 1;
-        int bits = 0;
-
-        int top = 0;
-        int count = 0;
-        int bi = 0;
-        int xyz = 0;
+        return true;
+    }
 
-        int data = 0;
-        int first = 0;
+    /// <summary>
+    /// Decodes and decompresses all pixel indices for a single row from the stream, assigning the pixel values to the buffer.
+    /// </summary>
+    /// <param name="indices">The pixel indices array to decode to.</param>
+    public void DecodePixelRow(Span<byte> indices)
+    {
+        indices.Clear();
 
+        ref byte pixelsRowRef = ref MemoryMarshal.GetReference(indices);
         ref int prefixRef = ref MemoryMarshal.GetReference(this.prefix.GetSpan());
         ref int suffixRef = ref MemoryMarshal.GetReference(this.suffix.GetSpan());
         ref int pixelStackRef = ref MemoryMarshal.GetReference(this.pixelStack.GetSpan());
+        Span<byte> buffer = this.scratchBuffer.GetSpan();
 
-        for (code = 0; code < clearCode; code++)
-        {
-            Unsafe.Add(ref suffixRef, (uint)code) = (byte)code;
-        }
-
-        Span<byte> buffer = stackalloc byte[byte.MaxValue];
-
-        int y = 0;
         int x = 0;
-        int rowMax = width;
-        ref byte pixelsRowRef = ref MemoryMarshal.GetReference(pixels.DangerousGetRowSpan(y));
-        while (xyz < length)
+        int xyz = 0;
+        while (xyz < indices.Length)
         {
-            // Reset row reference.
-            if (xyz == rowMax)
-            {
-                x = 0;
-                pixelsRowRef = ref MemoryMarshal.GetReference(pixels.DangerousGetRowSpan(++y));
-                rowMax = (y * width) + width;
-            }
-
-            if (top == 0)
+            if (this.top == 0)
             {
-                if (bits < codeSize)
+                if (this.bits < this.codeSize)
                 {
                     // Load bytes until there are enough bits for a code.
-                    if (count == 0)
+                    if (this.count == 0)
                     {
                         // Read a new data block.
-                        count = this.ReadBlock(buffer);
-                        if (count == 0)
+                        this.count = this.ReadBlock(buffer);
+                        if (this.count == 0)
                         {
                             break;
                         }
 
-                        bi = 0;
+                        this.bufferIndex = 0;
                     }
 
-                    data += buffer[bi] << bits;
+                    this.data += buffer[this.bufferIndex] << this.bits;
 
-                    bits += 8;
-                    bi++;
-                    count--;
+                    this.bits += 8;
+                    this.bufferIndex++;
+                    this.count--;
                     continue;
                 }
 
                 // Get the next code
-                code = data & codeMask;
-                data >>= codeSize;
-                bits -= codeSize;
+                this.code = this.data & this.codeMask;
+                this.data >>= this.codeSize;
+                this.bits -= this.codeSize;
 
                 // Interpret the code
-                if (code > availableCode || code == endCode)
+                if (this.code > this.availableCode || this.code == this.endCode)
                 {
                     break;
                 }
 
-                if (code == clearCode)
+                if (this.code == this.clearCode)
                 {
                     // Reset the decoder
-                    codeSize = minCodeSize + 1;
-                    codeMask = (1 << codeSize) - 1;
-                    availableCode = clearCode + 2;
-                    oldCode = NullCode;
+                    this.codeSize = this.minCodeSize + 1;
+                    this.codeMask = (1 << this.codeSize) - 1;
+                    this.availableCode = this.clearCode + 2;
+                    this.oldCode = NullCode;
                     continue;
                 }
 
-                if (oldCode == NullCode)
+                if (this.oldCode == NullCode)
                 {
-                    Unsafe.Add(ref pixelStackRef, (uint)top++) = Unsafe.Add(ref suffixRef, (uint)code);
-                    oldCode = code;
-                    first = code;
+                    Unsafe.Add(ref pixelStackRef, (uint)this.top++) = Unsafe.Add(ref suffixRef, (uint)this.code);
+                    this.oldCode = this.code;
+                    this.first = this.code;
                     continue;
                 }
 
-                int inCode = code;
-                if (code == availableCode)
+                int inCode = this.code;
+                if (this.code == this.availableCode)
                 {
-                    Unsafe.Add(ref pixelStackRef, (uint)top++) = (byte)first;
+                    Unsafe.Add(ref pixelStackRef, (uint)this.top++) = (byte)this.first;
 
-                    code = oldCode;
+                    this.code = this.oldCode;
                 }
 
-                while (code > clearCode)
+                while (this.code > this.clearCode)
                 {
-                    Unsafe.Add(ref pixelStackRef, (uint)top++) = Unsafe.Add(ref suffixRef, (uint)code);
-                    code = Unsafe.Add(ref prefixRef, (uint)code);
+                    Unsafe.Add(ref pixelStackRef, (uint)this.top++) = Unsafe.Add(ref suffixRef, (uint)this.code);
+                    this.code = Unsafe.Add(ref prefixRef, (uint)this.code);
                 }
 
-                int suffixCode = Unsafe.Add(ref suffixRef, (uint)code);
-                first = suffixCode;
-                Unsafe.Add(ref pixelStackRef, (uint)top++) = suffixCode;
+                int suffixCode = Unsafe.Add(ref suffixRef, (uint)this.code);
+                this.first = suffixCode;
+                Unsafe.Add(ref pixelStackRef, (uint)this.top++) = suffixCode;
 
                 // Fix for Gifs that have "deferred clear code" as per here :
                 // https://bugzilla.mozilla.org/show_bug.cgi?id=55918
-                if (availableCode < MaxStackSize)
+                if (this.availableCode < MaxStackSize)
                 {
-                    Unsafe.Add(ref prefixRef, (uint)availableCode) = oldCode;
-                    Unsafe.Add(ref suffixRef, (uint)availableCode) = first;
-                    availableCode++;
-                    if (availableCode == codeMask + 1 && availableCode < MaxStackSize)
+                    Unsafe.Add(ref prefixRef, (uint)this.availableCode) = this.oldCode;
+                    Unsafe.Add(ref suffixRef, (uint)this.availableCode) = this.first;
+                    this.availableCode++;
+                    if (this.availableCode == this.codeMask + 1 && this.availableCode < MaxStackSize)
                     {
-                        codeSize++;
-                        codeMask = (1 << codeSize) - 1;
+                        this.codeSize++;
+                        this.codeMask = (1 << this.codeSize) - 1;
                     }
                 }
 
-                oldCode = inCode;
+                this.oldCode = inCode;
             }
 
             // Pop a pixel off the pixel stack.
-            top--;
+            this.top--;
 
             // Clear missing pixels
             xyz++;
-            Unsafe.Add(ref pixelsRowRef, (uint)x++) = (byte)Unsafe.Add(ref pixelStackRef, (uint)top);
+            Unsafe.Add(ref pixelsRowRef, (uint)x++) = (byte)Unsafe.Add(ref pixelStackRef, (uint)this.top);
         }
     }
 
     /// <summary>
     /// Decodes and decompresses all pixel indices from the stream allowing skipping of the data.
     /// </summary>
-    /// <param name="minCodeSize">Minimum code size of the data.</param>
     /// <param name="length">The resulting index table length.</param>
-    public void SkipIndices(int minCodeSize, int length)
+    public void SkipIndices(int length)
     {
-        // Calculate the clear code. The value of the clear code is 2 ^ minCodeSize
-        int clearCode = 1 << minCodeSize;
-
-        // It is possible to specify a larger LZW minimum code size than the palette length in bits
-        // which may leave a gap in the codes where no colors are assigned.
-        // http://www.matthewflickinger.com/lab/whatsinagif/lzw_image_data.asp#lzw_compression
-        if (minCodeSize < 2 || minCodeSize > MaximumLzwBits || clearCode > MaxStackSize)
-        {
-            // Don't attempt to decode the frame indices.
-            // Theoretically we could determine a min code size from the length of the provided
-            // color palette but we won't bother since the image is most likely corrupted.
-            return;
-        }
-
-        int codeSize = minCodeSize + 1;
-
-        // Calculate the end code
-        int endCode = clearCode + 1;
-
-        // Calculate the available code.
-        int availableCode = clearCode + 2;
-
-        // Jillzhangs Code see: http://giflib.codeplex.com/
-        // Adapted from John Cristy's ImageMagick.
-        int code;
-        int oldCode = NullCode;
-        int codeMask = (1 << codeSize) - 1;
-        int bits = 0;
-
-        int top = 0;
-        int count = 0;
-        int bi = 0;
-        int xyz = 0;
-
-        int data = 0;
-        int first = 0;
-
         ref int prefixRef = ref MemoryMarshal.GetReference(this.prefix.GetSpan());
         ref int suffixRef = ref MemoryMarshal.GetReference(this.suffix.GetSpan());
         ref int pixelStackRef = ref MemoryMarshal.GetReference(this.pixelStack.GetSpan());
+        Span<byte> buffer = this.scratchBuffer.GetSpan();
 
-        for (code = 0; code < clearCode; code++)
-        {
-            Unsafe.Add(ref suffixRef, (uint)code) = (byte)code;
-        }
-
-        Span<byte> buffer = stackalloc byte[byte.MaxValue];
+        int xyz = 0;
         while (xyz < length)
         {
-            if (top == 0)
+            if (this.top == 0)
             {
-                if (bits < codeSize)
+                if (this.bits < this.codeSize)
                 {
                     // Load bytes until there are enough bits for a code.
-                    if (count == 0)
+                    if (this.count == 0)
                     {
                         // Read a new data block.
-                        count = this.ReadBlock(buffer);
-                        if (count == 0)
+                        this.count = this.ReadBlock(buffer);
+                        if (this.count == 0)
                         {
                             break;
                         }
 
-                        bi = 0;
+                        this.bufferIndex = 0;
                     }
 
-                    data += buffer[bi] << bits;
+                    this.data += buffer[this.bufferIndex] << this.bits;
 
-                    bits += 8;
-                    bi++;
-                    count--;
+                    this.bits += 8;
+                    this.bufferIndex++;
+                    this.count--;
                     continue;
                 }
 
                 // Get the next code
-                code = data & codeMask;
-                data >>= codeSize;
-                bits -= codeSize;
+                this.code = this.data & this.codeMask;
+                this.data >>= this.codeSize;
+                this.bits -= this.codeSize;
 
                 // Interpret the code
-                if (code > availableCode || code == endCode)
+                if (this.code > this.availableCode || this.code == this.endCode)
                 {
                     break;
                 }
 
-                if (code == clearCode)
+                if (this.code == this.clearCode)
                 {
                     // Reset the decoder
-                    codeSize = minCodeSize + 1;
-                    codeMask = (1 << codeSize) - 1;
-                    availableCode = clearCode + 2;
-                    oldCode = NullCode;
+                    this.codeSize = this.minCodeSize + 1;
+                    this.codeMask = (1 << this.codeSize) - 1;
+                    this.availableCode = this.clearCode + 2;
+                    this.oldCode = NullCode;
                     continue;
                 }
 
-                if (oldCode == NullCode)
+                if (this.oldCode == NullCode)
                 {
-                    Unsafe.Add(ref pixelStackRef, (uint)top++) = Unsafe.Add(ref suffixRef, (uint)code);
-                    oldCode = code;
-                    first = code;
+                    Unsafe.Add(ref pixelStackRef, (uint)this.top++) = Unsafe.Add(ref suffixRef, (uint)this.code);
+                    this.oldCode = this.code;
+                    this.first = this.code;
                     continue;
                 }
 
-                int inCode = code;
-                if (code == availableCode)
+                int inCode = this.code;
+                if (this.code == this.availableCode)
                 {
-                    Unsafe.Add(ref pixelStackRef, (uint)top++) = (byte)first;
+                    Unsafe.Add(ref pixelStackRef, (uint)this.top++) = (byte)this.first;
 
-                    code = oldCode;
+                    this.code = this.oldCode;
                 }
 
-                while (code > clearCode)
+                while (this.code > this.clearCode)
                 {
-                    Unsafe.Add(ref pixelStackRef, (uint)top++) = Unsafe.Add(ref suffixRef, (uint)code);
-                    code = Unsafe.Add(ref prefixRef, (uint)code);
+                    Unsafe.Add(ref pixelStackRef, (uint)this.top++) = Unsafe.Add(ref suffixRef, (uint)this.code);
+                    this.code = Unsafe.Add(ref prefixRef, (uint)this.code);
                 }
 
-                int suffixCode = Unsafe.Add(ref suffixRef, (uint)code);
-                first = suffixCode;
-                Unsafe.Add(ref pixelStackRef, (uint)top++) = suffixCode;
+                int suffixCode = Unsafe.Add(ref suffixRef, (uint)this.code);
+                this.first = suffixCode;
+                Unsafe.Add(ref pixelStackRef, (uint)this.top++) = suffixCode;
 
                 // Fix for Gifs that have "deferred clear code" as per here :
                 // https://bugzilla.mozilla.org/show_bug.cgi?id=55918
-                if (availableCode < MaxStackSize)
+                if (this.availableCode < MaxStackSize)
                 {
-                    Unsafe.Add(ref prefixRef, (uint)availableCode) = oldCode;
-                    Unsafe.Add(ref suffixRef, (uint)availableCode) = first;
-                    availableCode++;
-                    if (availableCode == codeMask + 1 && availableCode < MaxStackSize)
+                    Unsafe.Add(ref prefixRef, (uint)this.availableCode) = this.oldCode;
+                    Unsafe.Add(ref suffixRef, (uint)this.availableCode) = this.first;
+                    this.availableCode++;
+                    if (this.availableCode == this.codeMask + 1 && this.availableCode < MaxStackSize)
                     {
-                        codeSize++;
-                        codeMask = (1 << codeSize) - 1;
+                        this.codeSize++;
+                        this.codeMask = (1 << this.codeSize) - 1;
                     }
                 }
 
-                oldCode = inCode;
+                this.oldCode = inCode;
             }
 
             // Pop a pixel off the pixel stack.
-            top--;
+            this.top--;
 
             // Clear missing pixels
             xyz++;
@@ -419,5 +380,6 @@ public void Dispose()
         this.prefix.Dispose();
         this.suffix.Dispose();
         this.pixelStack.Dispose();
+        this.scratchBuffer.Dispose();
     }
 }
diff --git a/src/ImageSharp/Formats/Jpeg/Components/Quantization.cs b/src/ImageSharp/Formats/Jpeg/Components/Quantization.cs
index 3d53d5bfe8..7dca1cf5ea 100644
--- a/src/ImageSharp/Formats/Jpeg/Components/Quantization.cs
+++ b/src/ImageSharp/Formats/Jpeg/Components/Quantization.cs
@@ -146,7 +146,7 @@ public static int EstimateQuality(ref Block8x8F table, ReadOnlySpan<byte> target
             quality = (int)Math.Round(5000.0 / sumPercent);
         }
 
-        return quality;
+        return Numerics.Clamp(quality, MinQualityFactor, MaxQualityFactor);
     }
 
     /// <summary>
diff --git a/tests/ImageSharp.Tests/Formats/Gif/GifDecoderTests.cs b/tests/ImageSharp.Tests/Formats/Gif/GifDecoderTests.cs
index ee108b9d96..f4e6487a57 100644
--- a/tests/ImageSharp.Tests/Formats/Gif/GifDecoderTests.cs
+++ b/tests/ImageSharp.Tests/Formats/Gif/GifDecoderTests.cs
@@ -204,6 +204,17 @@ public void Issue1530_BadDescriptorDimensions<TPixel>(TestImageProvider<TPixel>
         image.CompareToReferenceOutputMultiFrame(provider, ImageComparer.Exact);
     }
 
+    // https://github.com/SixLabors/ImageSharp/issues/2758
+    [Theory]
+    [WithFile(TestImages.Gif.Issues.Issue2758, PixelTypes.Rgba32)]
+    public void Issue2758_BadDescriptorDimensions<TPixel>(TestImageProvider<TPixel> provider)
+        where TPixel : unmanaged, IPixel<TPixel>
+    {
+        using Image<TPixel> image = provider.GetImage();
+        image.DebugSaveMultiFrame(provider);
+        image.CompareToReferenceOutputMultiFrame(provider, ImageComparer.Exact);
+    }
+
     // https://github.com/SixLabors/ImageSharp/issues/405
     [Theory]
     [WithFile(TestImages.Gif.Issues.BadAppExtLength, PixelTypes.Rgba32)]
diff --git a/tests/ImageSharp.Tests/Formats/Jpg/JpegDecoderTests.Metadata.cs b/tests/ImageSharp.Tests/Formats/Jpg/JpegDecoderTests.Metadata.cs
index cbb2befcd4..3c88d8cbe9 100644
--- a/tests/ImageSharp.Tests/Formats/Jpg/JpegDecoderTests.Metadata.cs
+++ b/tests/ImageSharp.Tests/Formats/Jpg/JpegDecoderTests.Metadata.cs
@@ -8,6 +8,7 @@
 using SixLabors.ImageSharp.Metadata.Profiles.Exif;
 using SixLabors.ImageSharp.Metadata.Profiles.Icc;
 using SixLabors.ImageSharp.PixelFormats;
+using SixLabors.ImageSharp.Processing;
 using SixLabors.ImageSharp.Tests.TestUtilities;
 
 // ReSharper disable InconsistentNaming
@@ -438,6 +439,33 @@ public void JpegDecoder_DecodeMetadataComment<TPixel>(TestImageProvider<TPixel>
         Assert.Equal(expectedComment, metadata.Comments.ElementAtOrDefault(0).ToString());
         image.DebugSave(provider);
         image.CompareToOriginal(provider);
+
+    }
+    
+    // https://github.com/SixLabors/ImageSharp/issues/2758
+    [Theory]
+    [WithFile(TestImages.Jpeg.Issues.Issue2758, PixelTypes.L8)]
+    public void Issue2758_DecodeWorks<TPixel>(TestImageProvider<TPixel> provider)
+        where TPixel : unmanaged, IPixel<TPixel>
+    {
+        using Image<TPixel> image = provider.GetImage(JpegDecoder.Instance);
+
+        Assert.Equal(59787, image.Width);
+        Assert.Equal(511, image.Height);
+
+        JpegMetadata meta = image.Metadata.GetJpegMetadata();
+
+        // Quality determination should be between 1-100.
+        Assert.Equal(15, meta.LuminanceQuality);
+        Assert.Equal(1, meta.ChrominanceQuality);
+
+        // We want to test the encoder to ensure the determined values can be encoded but not by encoding
+        // the full size image as it would be too slow.
+        // We will crop the image to a smaller size and then encode it.
+        image.Mutate(x => x.Crop(new(0, 0, 100, 100)));
+
+        using MemoryStream ms = new();
+        image.Save(ms, new JpegEncoder());
     }
 
     private static void VerifyEncodedStrings(ExifProfile exif)
diff --git a/tests/ImageSharp.Tests/TestImages.cs b/tests/ImageSharp.Tests/TestImages.cs
index 8937799e1b..36f2a7a503 100644
--- a/tests/ImageSharp.Tests/TestImages.cs
+++ b/tests/ImageSharp.Tests/TestImages.cs
@@ -321,6 +321,7 @@ public static class Issues
             public const string Issue2517 = "Jpg/issues/issue2517-bad-d7.jpg";
             public const string Issue2067_CommentMarker = "Jpg/issues/issue-2067-comment.jpg";
             public const string Issue2638 = "Jpg/issues/Issue2638.jpg";
+            public const string Issue2758 = "Jpg/issues/issue-2758.jpg";
 
             public static class Fuzz
             {
@@ -531,6 +532,7 @@ public static class Issues
             public const string Issue2450_A = "Gif/issues/issue_2450.gif";
             public const string Issue2450_B = "Gif/issues/issue_2450_2.gif";
             public const string Issue2198 = "Gif/issues/issue_2198.gif";
+            public const string Issue2758 = "Gif/issues/issue_2758.gif";
         }
 
         public static readonly string[] Animated =
diff --git a/tests/Images/External/ReferenceOutput/GifDecoderTests/Issue2012BadMinCode_Rgba32_issue2012_drona1.png b/tests/Images/External/ReferenceOutput/GifDecoderTests/Issue2012BadMinCode_Rgba32_issue2012_drona1.png
index cdba9277b1..b07e806620 100644
--- a/tests/Images/External/ReferenceOutput/GifDecoderTests/Issue2012BadMinCode_Rgba32_issue2012_drona1.png
+++ b/tests/Images/External/ReferenceOutput/GifDecoderTests/Issue2012BadMinCode_Rgba32_issue2012_drona1.png
@@ -1,3 +1,3 @@
 version https://git-lfs.github.com/spec/v1
-oid sha256:a3a24c066895fd3a76649da376485cbc1912d6a3ae15369575f523e66364b3b6
-size 141563
+oid sha256:588d055a93c7b4fdb62e8b77f3ae08753a9e8990151cb0523f5e761996189b70
+size 142244
diff --git a/tests/Images/External/ReferenceOutput/GifDecoderTests/Issue2758_BadDescriptorDimensions_Rgba32_issue_2758.gif/00.png b/tests/Images/External/ReferenceOutput/GifDecoderTests/Issue2758_BadDescriptorDimensions_Rgba32_issue_2758.gif/00.png
new file mode 100644
index 0000000000..f63cc98ada
--- /dev/null
+++ b/tests/Images/External/ReferenceOutput/GifDecoderTests/Issue2758_BadDescriptorDimensions_Rgba32_issue_2758.gif/00.png
@@ -0,0 +1,3 @@
+version https://git-lfs.github.com/spec/v1
+oid sha256:4f39b23217f1d095eeb8eed5ccea36be813c307a60ef4b1942e9f74028451c38
+size 81944
diff --git a/tests/Images/External/ReferenceOutput/GifDecoderTests/Issue2758_BadDescriptorDimensions_Rgba32_issue_2758.gif/01.png b/tests/Images/External/ReferenceOutput/GifDecoderTests/Issue2758_BadDescriptorDimensions_Rgba32_issue_2758.gif/01.png
new file mode 100644
index 0000000000..f63cc98ada
--- /dev/null
+++ b/tests/Images/External/ReferenceOutput/GifDecoderTests/Issue2758_BadDescriptorDimensions_Rgba32_issue_2758.gif/01.png
@@ -0,0 +1,3 @@
+version https://git-lfs.github.com/spec/v1
+oid sha256:4f39b23217f1d095eeb8eed5ccea36be813c307a60ef4b1942e9f74028451c38
+size 81944
diff --git a/tests/Images/External/ReferenceOutput/GifDecoderTests/IssueTooLargeLzwBits_Rgba32_issue_2743.gif/07.png b/tests/Images/External/ReferenceOutput/GifDecoderTests/IssueTooLargeLzwBits_Rgba32_issue_2743.gif/07.png
index 75cf685e43..efba40c99d 100644
--- a/tests/Images/External/ReferenceOutput/GifDecoderTests/IssueTooLargeLzwBits_Rgba32_issue_2743.gif/07.png
+++ b/tests/Images/External/ReferenceOutput/GifDecoderTests/IssueTooLargeLzwBits_Rgba32_issue_2743.gif/07.png
@@ -1,3 +1,3 @@
 version https://git-lfs.github.com/spec/v1
-oid sha256:489642f0c81fd12e97007fe6feb11b0e93e351199a922ce038069a3782ad0722
-size 135
+oid sha256:5016a323018f09e292165ad5392d82dcbad5e79c2b6b93aff3322dffff80b309
+size 126
diff --git a/tests/Images/Input/Gif/issues/issue_2758.gif b/tests/Images/Input/Gif/issues/issue_2758.gif
new file mode 100644
index 0000000000..17db9fa132
--- /dev/null
+++ b/tests/Images/Input/Gif/issues/issue_2758.gif
@@ -0,0 +1,3 @@
+version https://git-lfs.github.com/spec/v1
+oid sha256:13e9374181c7536d1d2ecb514753a5290c0ec06234ca079c6c8c8a832586b668
+size 199
diff --git a/tests/Images/Input/Jpg/issues/issue-2758.jpg b/tests/Images/Input/Jpg/issues/issue-2758.jpg
new file mode 100644
index 0000000000..48ee1159ec
--- /dev/null
+++ b/tests/Images/Input/Jpg/issues/issue-2758.jpg
@@ -0,0 +1,3 @@
+version https://git-lfs.github.com/spec/v1
+oid sha256:f32a238b57b7073f7442f8ae7efd6ba3ae4cda30d57e6666fb8a1eaa27108558
+size 1412
