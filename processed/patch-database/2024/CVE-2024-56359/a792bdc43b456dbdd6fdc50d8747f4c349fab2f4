diff --git a/app/client/components/WidgetFrame.ts b/app/client/components/WidgetFrame.ts
index b06c0d4f9b..9c853c0986 100644
--- a/app/client/components/WidgetFrame.ts
+++ b/app/client/components/WidgetFrame.ts
@@ -5,6 +5,7 @@ import {GristDoc} from 'app/client/components/GristDoc';
 import {hooks} from 'app/client/Hooks';
 import {get as getBrowserGlobals} from 'app/client/lib/browserGlobals';
 import {makeTestId} from 'app/client/lib/domUtils';
+import {sanitizeHttpUrl} from 'app/client/lib/sanitizeUrl';
 import {ColumnRec, ViewSectionRec} from 'app/client/models/DocModel';
 import {reportError} from 'app/client/models/errors';
 import {gristThemeObs} from 'app/client/ui2018/theme';
@@ -12,7 +13,7 @@ import {AccessLevel, ICustomWidget, isSatisfied, matchWidget} from 'app/common/C
 import {DisposableWithEvents} from 'app/common/DisposableWithEvents';
 import {BulkColValues, fromTableDataAction, RowRecord} from 'app/common/DocActions';
 import {extractInfoFromColType, reencodeAsAny} from 'app/common/gristTypes';
-import {getGristConfig, sanitizeUrl} from 'app/common/urlUtils';
+import {getGristConfig} from 'app/common/urlUtils';
 import {
   AccessTokenOptions, CursorPos, CustomSectionAPI, FetchSelectedOptions, GristDocAPI, GristView,
   InteractionOptionsRequest, WidgetAPI, WidgetColumnMap
@@ -242,7 +243,7 @@ export class WidgetFrame extends DisposableWithEvents {
     // Append user and document preferences to query string.
     const settingsParams = new URLSearchParams(this._options.preferences);
     settingsParams.forEach((value, key) => urlObj.searchParams.append(key, value));
-    return sanitizeUrl(urlObj.href);
+    return sanitizeHttpUrl(urlObj.href);
   }
 
   private _getEmptyWidgetPage(): string {
diff --git a/app/client/lib/sanitizeUrl.ts b/app/client/lib/sanitizeUrl.ts
new file mode 100644
index 0000000000..99fdea3ade
--- /dev/null
+++ b/app/client/lib/sanitizeUrl.ts
@@ -0,0 +1,42 @@
+import DOMPurify from "dompurify";
+
+// Export dependencies for stubbing in tests.
+export const Deps = { DOMPurify };
+
+/**
+ * Returns the provided URL if it is valid and safe to use in
+ * HTTP-only contexts, such as form redirects and custom widget
+ * URLs.
+ *
+ * Returns `null` if the URL is invalid or unsafe.
+ *
+ * For sanitizing hyperlink URLs, such as those used by `a`
+ * elements, see `sanitizeLinkUrl`.
+ */
+export function sanitizeHttpUrl(url: string): string | null {
+  try {
+    const parsedUrl = new URL(url);
+    if (!["http:", "https:"].includes(parsedUrl.protocol)) {
+      return null;
+    }
+
+    return parsedUrl.href;
+  } catch (e) {
+    return null;
+  }
+}
+
+/**
+ * Returns the provided URL if it is valid and safe to use for hyperlinks,
+ * such as those used by `a` elements. This includes URLs prefixed with
+ * `http[s]:`, `mailto:`, and `tel:`, and excludes URLs prefixed with
+ * `javascript:`.
+ *
+ * Returns `null` if the URL is invalid or unsafe.
+ *
+ * For sanitizing HTTP-only URLs, such as those used for redirects, see
+ * `sanitizeHttpUrl`.
+ */
+export function sanitizeLinkUrl(url: string): string | null {
+  return Deps.DOMPurify.isValidAttribute("a", "href", url) ? url : null;
+}
diff --git a/app/client/ui/FormPage.ts b/app/client/ui/FormPage.ts
index a49fd95439..d76911668b 100644
--- a/app/client/ui/FormPage.ts
+++ b/app/client/ui/FormPage.ts
@@ -1,6 +1,7 @@
 import {FormRenderer} from 'app/client/components/FormRenderer';
 import {handleSubmit, TypedFormData} from 'app/client/lib/formUtils';
 import {makeT} from 'app/client/lib/localization';
+import {sanitizeHttpUrl} from 'app/client/lib/sanitizeUrl';
 import {FormModel, FormModelImpl} from 'app/client/models/FormModel';
 import {buildFormFooter} from 'app/client/ui/FormContainer';
 import {FormErrorPage} from 'app/client/ui/FormErrorPage';
@@ -8,7 +9,7 @@ import {FormSuccessPage} from 'app/client/ui/FormSuccessPage';
 import {colors} from 'app/client/ui2018/cssVars';
 import {ApiError} from 'app/common/ApiError';
 import {getPageTitleSuffix} from 'app/common/gristUrls';
-import {getGristConfig, sanitizeUrl} from 'app/common/urlUtils';
+import {getGristConfig} from 'app/common/urlUtils';
 import {Disposable, dom, makeTestId, Observable, styled, subscribe} from 'grainjs';
 
 const t = makeT('FormPage');
@@ -90,7 +91,7 @@ export class FormPage extends Disposable {
 
     const {successURL} = formLayout;
     if (successURL) {
-      const url = sanitizeUrl(successURL);
+      const url = sanitizeHttpUrl(successURL);
       if (url) {
         window.location.href = url;
       }
diff --git a/app/client/ui/sanitizeHTML.ts b/app/client/ui/sanitizeHTML.ts
index e979959cda..8b4c32ea27 100644
--- a/app/client/ui/sanitizeHTML.ts
+++ b/app/client/ui/sanitizeHTML.ts
@@ -24,10 +24,10 @@ function handleSanitizeAttribute(node: Element) {
   node.setAttribute('target', '_blank');
 }
 
-function handleSanitizeTutorialElement(node: Element, data: createDOMPurifier.SanitizeElementHookEvent) {
+function handleSanitizeTutorialElement(node: Node, data: createDOMPurifier.UponSanitizeElementHookEvent) {
   if (data.tagName !== 'iframe') { return; }
 
-  const src = node.getAttribute('src');
+  const src = (node as Element).getAttribute('src');
   if (src?.startsWith('https://www.youtube.com/embed/')) {
     return;
   }
diff --git a/app/client/widgets/HyperLinkTextBox.ts b/app/client/widgets/HyperLinkTextBox.ts
index 348e349a7a..e8c9549d2a 100644
--- a/app/client/widgets/HyperLinkTextBox.ts
+++ b/app/client/widgets/HyperLinkTextBox.ts
@@ -1,3 +1,4 @@
+import { sanitizeLinkUrl } from 'app/client/lib/sanitizeUrl';
 import { DataRowModel } from 'app/client/models/DataRowModel';
 import { ViewFieldRec } from 'app/client/models/entities/ViewFieldRec';
 import { constructUrl } from 'app/client/models/gristUrlState';
@@ -20,7 +21,10 @@ export class HyperLinkTextBox extends NTextBox {
 
   public buildDom(row: DataRowModel) {
     const value = row.cells[this.field.colId()];
-    const url = Computed.create(null, (use) => constructUrl(use(value)));
+    const url = Computed.create(
+      null,
+      (use) => sanitizeLinkUrl(constructUrl(use(value))) ?? "about:blank"
+    );
     return cssFieldClip(
       dom.autoDispose(url),
       dom.style('text-align', this.alignment),
diff --git a/app/common/urlUtils.ts b/app/common/urlUtils.ts
index 6d43bff9f6..3a2310be3b 100644
--- a/app/common/urlUtils.ts
+++ b/app/common/urlUtils.ts
@@ -79,20 +79,3 @@ export function fetchFromHome(path: string, opts: RequestInit): Promise<Response
   const baseUrl = addCurrentOrgToPath(getGristConfig().homeUrl!);
   return window.fetch(`${baseUrl}${path}`, opts);
 }
-
-/**
- * Returns the provided URL if it has a valid protocol (`http:` or `https:`), or
- * `null` otherwise.
- */
-export function sanitizeUrl(url: string): string | null {
-  try {
-    const parsedUrl = new URL(url);
-    if (!["http:", "https:"].includes(parsedUrl.protocol)) {
-      return null;
-    }
-
-    return parsedUrl.href;
-  } catch (e) {
-    return null;
-  }
-}
diff --git a/app/server/lib/DocWorker.ts b/app/server/lib/DocWorker.ts
index 2a795c9aa6..8529acde85 100644
--- a/app/server/lib/DocWorker.ts
+++ b/app/server/lib/DocWorker.ts
@@ -61,6 +61,7 @@ export class DocWorker {
         .type(ext)
         .set('Content-Disposition', contentDispHeader)
         .set('Cache-Control', 'private, max-age=3600')
+        .set("Content-Security-Policy", "sandbox; default-src: 'none'")
         .send(data);
     } catch (err) {
       res.status(404).send({error: err.toString()});
diff --git a/package.json b/package.json
index ab53c61ebf..05c56d4287 100644
--- a/package.json
+++ b/package.json
@@ -49,7 +49,6 @@
     "@types/chai-as-promised": "7.1.0",
     "@types/content-disposition": "0.5.2",
     "@types/diff-match-patch": "1.0.32",
-    "@types/dompurify": "3.0.5",
     "@types/double-ended-queue": "2.1.0",
     "@types/express": "4.17.17",
     "@types/form-data": "2.2.1",
@@ -139,7 +138,7 @@
     "csv": "6.3.8",
     "currency-symbol-map": "5.1.0",
     "diff-match-patch": "1.0.5",
-    "dompurify": "3.0.6",
+    "dompurify": "3.2.3",
     "double-ended-queue": "2.1.0-0",
     "engine.io": "^6.5.4",
     "engine.io-client": "^6.5.3",
diff --git a/test/client/lib/sanitizeUrl.ts b/test/client/lib/sanitizeUrl.ts
new file mode 100644
index 0000000000..462a186695
--- /dev/null
+++ b/test/client/lib/sanitizeUrl.ts
@@ -0,0 +1,71 @@
+import {
+  Deps,
+  sanitizeHttpUrl,
+  sanitizeLinkUrl,
+} from "app/client/lib/sanitizeUrl";
+import { assert } from "chai";
+import DOMPurify from "dompurify";
+import { JSDOM } from "jsdom";
+import * as sinon from "sinon";
+
+describe("sanitizeUrl", function () {
+  let sandbox: sinon.SinonSandbox;
+
+  beforeEach(function () {
+    // These grainjs browserGlobals are needed for using dom() in tests.
+    const jsdomDoc = new JSDOM("<!doctype html><html><body></body></html>");
+    sandbox = sinon.createSandbox();
+    sandbox.stub(Deps, "DOMPurify").value(DOMPurify(jsdomDoc.window));
+  });
+
+  afterEach(function () {
+    sandbox.restore();
+  });
+
+  describe("sanitizeHttpUrl", function () {
+    it("returns the provided URL if valid", function () {
+      assert.equal(
+        sanitizeHttpUrl("https://example.com"),
+        "https://example.com/"
+      );
+      assert.equal(
+        sanitizeHttpUrl("http://example.com"),
+        "http://example.com/"
+      );
+    });
+
+    it("returns null if the provided URL is invalid", function () {
+      assert.isNull(sanitizeHttpUrl("www.example.com"));
+      assert.isNull(sanitizeHttpUrl(""));
+      assert.isNull(sanitizeHttpUrl("invalid"));
+      assert.isNull(sanitizeHttpUrl("mailto:support@getgrist.com"));
+      assert.isNull(sanitizeHttpUrl("ftp://getgrist.com/path"));
+      assert.isNull(sanitizeHttpUrl("javascript:alert()"));
+    });
+  });
+
+  describe("sanitizeLinkUrl", function () {
+    it("returns the provided URL if valid", function () {
+      assert.equal(
+        sanitizeLinkUrl("https://example.com"),
+        "https://example.com"
+      );
+      assert.equal(sanitizeLinkUrl("http://example.com"), "http://example.com");
+      assert.equal(sanitizeLinkUrl("www.example.com"), "www.example.com");
+      assert.equal(sanitizeLinkUrl(""), "");
+      assert.equal(
+        sanitizeLinkUrl("mailto:support@getgrist.com"),
+        "mailto:support@getgrist.com"
+      );
+      assert.equal(sanitizeLinkUrl("tel:0123456789"), "tel:0123456789");
+      assert.equal(
+        sanitizeLinkUrl("ftp://getgrist.com/path"),
+        "ftp://getgrist.com/path"
+      );
+    });
+
+    it("returns null if the provided URL is unsafe", function () {
+      assert.isNull(sanitizeLinkUrl("javascript:alert()"));
+    });
+  });
+});
diff --git a/test/common/urlUtils.ts b/test/common/urlUtils.ts
deleted file mode 100644
index e655be6991..0000000000
--- a/test/common/urlUtils.ts
+++ /dev/null
@@ -1,24 +0,0 @@
-import { sanitizeUrl } from "app/common/urlUtils";
-import { assert } from "chai";
-
-describe("urlUtils", function () {
-  describe("sanitizeUrl", function () {
-    it("returns the provided URL if the scheme is http[s]", function () {
-      assert.equal(sanitizeUrl("https://example.com"), "https://example.com/");
-      assert.equal(sanitizeUrl("http://example.com"), "http://example.com/");
-      assert.equal(sanitizeUrl("https://example.com"), "https://example.com/");
-    });
-
-    it("returns null if the provided URL is invalid", function () {
-      assert.isNull(sanitizeUrl("www.example.com"));
-      assert.isNull(sanitizeUrl(""));
-      assert.isNull(sanitizeUrl("invalid"));
-    });
-
-    it("returns null if the provided URL's scheme is not http[s]", function () {
-      assert.isNull(sanitizeUrl("mailto:support@getgrist.com.com"));
-      assert.isNull(sanitizeUrl("ftp://getgrist.com/path"));
-      assert.isNull(sanitizeUrl("javascript:alert()"));
-    });
-  });
-});
diff --git a/test/fixtures/uploads/image_with_script.svg b/test/fixtures/uploads/image_with_script.svg
new file mode 100644
index 0000000000..6acfaf8c27
--- /dev/null
+++ b/test/fixtures/uploads/image_with_script.svg
@@ -0,0 +1,6 @@
+<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
+  <polygon id="triangle" points="0,0 0,50 50,0" fill="#009900" stroke="#004400"/>
+  <script type="text/javascript">
+    alert('I should not appear');
+  </script>
+</svg>
diff --git a/test/nbrowser/AttachmentsWidget.ts b/test/nbrowser/AttachmentsWidget.ts
new file mode 100644
index 0000000000..e15aed1759
--- /dev/null
+++ b/test/nbrowser/AttachmentsWidget.ts
@@ -0,0 +1,548 @@
+import {
+  assert,
+  driver,
+  Key,
+  stackWrapFunc,
+  WebElement,
+} from "mocha-webdriver";
+import fetch from "node-fetch";
+import * as gu from "test/nbrowser/gristUtils";
+import { server, setupTestSuite } from "test/nbrowser/testUtils";
+
+describe("AttachmentsWidget", function () {
+  this.timeout(20000);
+  setupTestSuite();
+  let docId: string;
+
+  before(async function () {
+    docId = (
+      await gu.importFixturesDoc(
+        "chimpy",
+        "nasa",
+        "Horizon",
+        "Hello.grist",
+        false
+      )
+    ).id;
+    await server.simulateLogin("Chimpy", "chimpy@getgrist.com", "nasa");
+    await gu.loadDoc(`/o/nasa/doc/${docId}`);
+  });
+
+  afterEach(async function () {
+    await gu.checkForErrors();
+  });
+
+  after(async function () {
+    // Close any open cell/attachments editor, to avoid an unload alert that would interfere with
+    // the next test suite.
+    await driver.sendKeys(Key.ESCAPE);
+  });
+
+  // Returns the 'title' attributes of all attachments in the given cell. These should be the
+  // names of the attached files.
+  const getCellThumbnailTitles = stackWrapFunc(async function (
+    cell: WebElement
+  ) {
+    return await cell.findAll(".test-pw-thumbnail", (el) =>
+      el.getAttribute("title")
+    );
+  });
+
+  it("should include a functioning attachment widget", async function () {
+    await gu.toggleSidePanel("right", "open");
+    await driver.find(".test-right-tab-field").click();
+
+    // Move to first column
+    await gu.getCell(0, 1).click();
+
+    // Change type to Attachment.
+    await gu.setType(/Attachment/);
+    await driver.findWait(".test-type-transform-apply", 1000).click();
+    await gu.waitForServer();
+    assert.equal(
+      await gu.getCell(0, 2).find(".test-attachment-widget").isDisplayed(),
+      true
+    );
+  });
+
+  it("should include a functioning upload button", async function () {
+    // Put 'foo1' in a cell, then replace it immediately with 'foo2'.
+    // This is just setting up for testing undo behaviour below.
+    await gu.getCell(1, 2).click();
+    await driver.sendKeys("foo1", Key.ENTER);
+    await gu.getCell(1, 2).click();
+    await driver.sendKeys("foo2", Key.ENTER);
+
+    await gu.getCell(0, 2).click();
+    await driver.sendKeys(Key.ENTER);
+
+    await gu.fileDialogUpload("uploads/sample.pdf,uploads/grist.png", () =>
+      driver.find(".test-pw-add").click()
+    );
+    await driver.findContentWait(".test-pw-counter", /of 2/, 3000);
+
+    const href: string = await driver
+      .findWait(".test-pw-download", 2000)
+      .getAttribute("href");
+    assert.include(href.split("name=")[1], "sample.pdf");
+    assert.equal(await driver.find(".test-pw-counter").getText(), "1 of 2");
+    await driver.find(".test-modal-dialog .test-pw-close").click();
+    await gu.waitForServer();
+
+    // Check that title attributes are set to file names.
+    assert.deepEqual(await getCellThumbnailTitles(gu.getCell(0, 2)), [
+      "sample.pdf",
+      "grist.png",
+    ]);
+
+    // Check that in the absence of a thumbnail we show the extension.
+    assert.deepEqual(
+      await gu
+        .getCell(0, 2)
+        .findAll(".test-pw-thumbnail", (el) => el.getText()),
+      ["PDF", ""]
+    );
+
+    async function checkState(expectedCells: string[], isSoftDeleted: boolean) {
+      assert.deepEqual(
+        await gu.getVisibleGridCells({ cols: [0, 1], rowNums: [2] }),
+        expectedCells
+      );
+
+      // Previously, undo would remove the uploaded attachment metadata completely,
+      // which could lead to hard deleting the file data and leaving broken attachments after redo.
+      // Here we check that after checking for unused attachments and removing expired ones
+      // (as should happen automatically every hour)
+      // the metadata records (and thus files) are still there, but appropriately marked as soft deleted.
+      const headers = { Authorization: "Bearer api_key_for_chimpy" };
+      const url = server.getUrl("nasa", `/api/docs/${docId}`);
+      let resp = await fetch(
+        url + "/attachments/removeUnused?verifyfiles=1&expiredonly=1",
+        { headers, method: "POST" }
+      );
+      assert.equal(resp.status, 200);
+      resp = await fetch(url + "/tables/_grist_Attachments/records", {
+        headers,
+      });
+      const data = await resp.json();
+      assert.lengthOf(data.records, 2);
+      for (const record of data.records) {
+        assert.equal(Boolean(record.fields.timeDeleted), isSoftDeleted);
+      }
+    }
+
+    // Check current state before testing undo/redo
+    assert.deepEqual(
+      await gu.getVisibleGridCells({ cols: [0, 1], rowNums: [2] }),
+      ["PDF", "foo2"]
+    );
+    await checkState(["PDF", "foo2"], false);
+
+    // Check that undo once removes the attachments we just added to the cell
+    await gu.undo();
+    await checkState(["", "foo2"], true); // true: attachment metadata marked as soft deleted
+
+    // Check that undo again undoes the thing we did before attaching: changing foo1 to foo2
+    // (previously it would undo creating the attachment metadata, which was invisible)
+    await gu.undo();
+    await checkState(["", "foo1"], true);
+
+    // Check that redoing twice restores things as expected
+    await gu.redo();
+    await checkState(["", "foo2"], true);
+    await gu.redo();
+    await checkState(["PDF", "foo2"], false); // false: attachment metadata un-deleted
+  });
+
+  it("should allow resizing thumbnails", async function () {
+    const slider = await driver.find(".test-pw-thumbnail-size");
+    assert.equal(
+      (await driver.findWait(".test-pw-thumbnail:last-child", 1000).getRect())
+        .height,
+      36
+    );
+    for (let i = 0; i < 5; i++) {
+      await slider.sendKeys(Key.RIGHT);
+    }
+    assert.equal(
+      (await driver.find(".test-pw-thumbnail:last-child").getRect()).height,
+      41
+    );
+    for (let i = 0; i < 3; i++) {
+      await slider.sendKeys(Key.LEFT);
+    }
+    assert.equal(
+      (await driver.find(".test-pw-thumbnail:last-child").getRect()).height,
+      38
+    );
+    // Wait to ensure the new setting is saved.
+    await driver.sleep(300);
+
+    // Thumbnail size setting should persist across refresh
+    await driver.navigate().refresh();
+    await gu.waitForServer(10000);
+    assert.equal(
+      (await driver.findWait(".test-pw-thumbnail:last-child", 1000).getRect())
+        .height,
+      38
+    );
+  });
+
+  it("should get correct headers from the server", async function () {
+    const cell: any = gu.getCell(0, 2);
+    await cell.click();
+    await driver.sendKeys(Key.ENTER);
+
+    const fetchOptions = {
+      headers: { Authorization: "Bearer api_key_for_chimpy" },
+    };
+    const hrefDownload = await driver
+      .findWait(".test-pw-download", 500)
+      .getAttribute("href");
+    const respDownload = await fetch(hrefDownload, fetchOptions);
+    assert.equal(
+      respDownload.headers.get("Content-Disposition"),
+      'attachment; filename="sample.pdf"'
+    );
+    assert.equal(
+      respDownload.headers.get("Content-Security-Policy"),
+      "sandbox; default-src: 'none'"
+    );
+
+    const hrefInline = await driver
+      .find(".test-pw-attachment-content")
+      .getAttribute("data");
+    const respInline = await fetch(hrefInline, fetchOptions);
+    assert.equal(
+      respInline.headers.get("Content-Disposition"),
+      'inline; filename="sample.pdf"'
+    );
+
+    // Attach an html file and ensure it doesn't get served inline.
+    await gu.fileDialogUpload("uploads/htmlfile.html", () =>
+      driver.findWait(".test-pw-add", 500).click()
+    );
+    await driver.findContentWait(".test-pw-counter", /of 3/, 3000);
+
+    const hrefLinkHtml = await driver
+      .findWait(".test-pw-download", 2000)
+      .getAttribute("href");
+    const respLinkHtml = await fetch(hrefLinkHtml, fetchOptions);
+    // Note that the disposition here is NOT "inline" (that would be bad).
+    assert.equal(
+      respLinkHtml.headers.get("Content-Disposition"),
+      'attachment; filename="htmlfile.html"'
+    );
+    await driver.find(".test-modal-dialog .test-pw-close").click();
+  });
+
+  it("should allow editing the attachments list", async function () {
+    let cell = gu.getCell(0, 2);
+    assert.deepEqual(await getCellThumbnailTitles(cell), [
+      "sample.pdf",
+      "grist.png",
+      "htmlfile.html",
+    ]);
+
+    // Open an image preview.
+    await driver.withActions((a) =>
+      a.doubleClick(driver.find(".test-pw-thumbnail"))
+    );
+
+    assert.equal(
+      await driver.findWait(".test-pw-counter", 500).getText(),
+      "1 of 3"
+    );
+
+    // Assert that the attachment filename can be changed.
+    await driver
+      .find(".test-pw-name")
+      .doClick()
+      .sendKeys("renamed.pdf", Key.ENTER);
+    // Wait for doc name input to lose focus, indicating that the save call completed.
+    await driver.findWait(".test-bc-doc:not(:focus)", 2000);
+    assert.equal(await driver.find(".test-pw-name").value(), "renamed.pdf");
+
+    // Assert that the attachment has the correct download link.
+    const href = await driver.find(".test-pw-download").getAttribute("href");
+    assert.include(href, "attId=1");
+    assert.include(href, "name=renamed.pdf");
+
+    // Assert that other previews can be viewed without closing the modal.
+    await driver.find(".test-pw-right").click();
+    assert.equal(await driver.find(".test-pw-name").value(), "grist.png");
+    await driver.find(".test-pw-left").click();
+    assert.equal(await driver.find(".test-pw-name").value(), "renamed.pdf");
+    await driver.sendKeys(Key.RIGHT, Key.RIGHT);
+    assert.equal(await driver.find(".test-pw-name").value(), "htmlfile.html");
+
+    // Assert that the attachment can be removed from the cell.
+    assert.equal(await driver.find(".test-pw-counter").getText(), "3 of 3");
+    await driver.find(".test-pw-remove").click();
+    await gu.waitForServer();
+    assert.equal(await driver.find(".test-pw-counter").getText(), "2 of 2");
+    await driver.find(".test-modal-dialog .test-pw-close").click();
+    cell = gu.getCell(0, 2);
+    assert.deepEqual(await getCellThumbnailTitles(cell), [
+      "renamed.pdf",
+      "grist.png",
+    ]);
+  });
+
+  it("should allow uploading to the add row", async function () {
+    assert.equal(await gu.getCell({ col: 0, rowNum: 6 }).isPresent(), false);
+    const cell = await gu.getCell({ col: 0, rowNum: 5 });
+
+    await gu.fileDialogUpload("uploads/grist.png", () =>
+      cell.find(".test-attachment-icon").click()
+    );
+    await gu.waitToPass(async () =>
+      assert.lengthOf(
+        await gu.getCell({ col: 0, rowNum: 5 }).findAll(".test-pw-thumbnail"),
+        1
+      )
+    );
+
+    assert.deepEqual(
+      await getCellThumbnailTitles(gu.getCell({ col: 0, rowNum: 5 })),
+      ["grist.png"]
+    );
+    // Assert that a row is added
+    assert.equal(await gu.getCell({ col: 0, rowNum: 6 }).isPresent(), true);
+  });
+
+  it("should not initialize as invalid when a row is added", async function () {
+    // The first cell is invalid, just to check that the assert is correct.
+    let cell = gu.getCell({ col: 0, rowNum: 1 });
+    assert.equal(await cell.getText(), "hello");
+    assert.equal(await cell.find(".field_clip").matches(".invalid"), true);
+    await cell.click();
+    // Add a new row and ensure it's NOT invalid.
+    await driver
+      .find("body")
+      .sendKeys(Key.chord(await gu.modKey(), Key.SHIFT, Key.ENTER));
+    await gu.waitForServer();
+    cell = gu.getCell({ col: 0, rowNum: 1 });
+    assert.equal(await cell.getText(), "");
+    assert.equal(await cell.find(".field_clip").matches(".invalid"), false);
+    await gu.undo();
+  });
+
+  it("should open preview to double-clicked attachment", async function () {
+    const cell = gu.getCell({ col: 0, rowNum: 2 });
+    assert.deepEqual(await getCellThumbnailTitles(cell), [
+      "renamed.pdf",
+      "grist.png",
+    ]);
+
+    // Double-click the first attachment.
+    await driver.withActions((a) =>
+      a.doubleClick(cell.find(".test-pw-thumbnail[title*=pdf]"))
+    );
+    assert.equal(
+      await driver.findWait(".test-pw-counter", 500).getText(),
+      "1 of 2"
+    );
+    assert.equal(await driver.find(".test-pw-name").value(), "renamed.pdf");
+    await driver.sendKeys(Key.ESCAPE);
+
+    // Double-click the second attachment.
+    await driver.withActions((a) =>
+      a.doubleClick(cell.find(".test-pw-thumbnail[title*=png]"))
+    );
+    assert.equal(
+      await driver.findWait(".test-pw-counter", 500).getText(),
+      "2 of 2"
+    );
+    assert.equal(await driver.find(".test-pw-name").value(), "grist.png");
+    await driver.sendKeys(Key.ESCAPE);
+  });
+
+  it("should render various types of files appropriately", async function () {
+    const cell = gu.getCell({ col: 0, rowNum: 2 });
+    await cell.click();
+    assert.deepEqual(await getCellThumbnailTitles(cell), [
+      "renamed.pdf",
+      "grist.png",
+    ]);
+    await gu.fileDialogUpload(
+      "uploads/file1.mov,uploads/file2.mp3,uploads/file3.zip,uploads/simple_array.json",
+      () => cell.find(".test-attachment-icon").click()
+    );
+    await gu.waitToPass(async () =>
+      assert.lengthOf(await cell.findAll(".test-pw-thumbnail"), 6)
+    );
+    await gu.waitForServer();
+    assert.deepEqual(await getCellThumbnailTitles(cell), [
+      "renamed.pdf",
+      "grist.png",
+      "file1.mov",
+      "file2.mp3",
+      "file3.zip",
+      "simple_array.json",
+    ]);
+    await driver.sendKeys(Key.ENTER);
+    assert.equal(
+      await driver.findWait(".test-pw-counter", 500).getText(),
+      "1 of 6"
+    );
+
+    // For various recognized file types, see that a suitable element is created.
+    assert.equal(await driver.find(".test-pw-name").value(), "renamed.pdf");
+    assert.equal(
+      await driver.find(".test-pw-attachment-content").getTagName(),
+      "object"
+    );
+    assert.match(
+      await driver.find(".test-pw-attachment-content").getAttribute("data"),
+      /name=renamed.pdf&rowId=2&colId=A&tableId=Table1&maybeNew=1&attId=1&inline=1/
+    );
+    assert.equal(
+      await driver.find(".test-pw-attachment-content").getAttribute("type"),
+      "application/pdf"
+    );
+
+    await driver.sendKeys(Key.RIGHT);
+    assert.equal(await driver.find(".test-pw-name").value(), "grist.png");
+    assert.equal(
+      await driver.find(".test-pw-attachment-content").getTagName(),
+      "img"
+    );
+    assert.match(
+      await driver.find(".test-pw-attachment-content").getAttribute("src"),
+      /name=grist.png&rowId=2&colId=A&tableId=Table1&maybeNew=1&attId=2/
+    );
+
+    await driver.sendKeys(Key.RIGHT);
+    assert.equal(await driver.find(".test-pw-name").value(), "file1.mov");
+    assert.equal(
+      await driver.find(".test-pw-attachment-content").getTagName(),
+      "video"
+    );
+    assert.match(
+      await driver.find(".test-pw-attachment-content").getAttribute("src"),
+      /name=file1.mov&rowId=2&colId=A&tableId=Table1&maybeNew=1&attId=5&inline=1/
+    );
+
+    await driver.sendKeys(Key.RIGHT);
+    assert.equal(await driver.find(".test-pw-name").value(), "file2.mp3");
+    assert.equal(
+      await driver.find(".test-pw-attachment-content").getTagName(),
+      "audio"
+    );
+    assert.match(
+      await driver.find(".test-pw-attachment-content").getAttribute("src"),
+      /name=file2.mp3&rowId=2&colId=A&tableId=Table1&maybeNew=1&attId=6&inline=1/
+    );
+
+    // Test that for an unsupported file, the extension is shown along with a message.
+    await driver.sendKeys(Key.RIGHT);
+    assert.equal(await driver.find(".test-pw-name").value(), "file3.zip");
+    assert.equal(
+      await driver.find(".test-pw-attachment-content").getTagName(),
+      "object"
+    );
+    assert.match(
+      await driver.find(".test-pw-attachment-content").getAttribute("data"),
+      /name=file3.zip&rowId=2&colId=A&tableId=Table1&maybeNew=1&attId=7&inline=1/
+    );
+    assert.equal(
+      await driver.find(".test-pw-attachment-content").getText(),
+      "ZIP\nPreview not available."
+    );
+
+    // Test the same for a text/json file that we also don't currently render.
+    await driver.sendKeys(Key.RIGHT);
+    assert.equal(
+      await driver.find(".test-pw-name").value(),
+      "simple_array.json"
+    );
+    assert.equal(
+      await driver.find(".test-pw-attachment-content").getTagName(),
+      "div"
+    );
+    assert.equal(
+      await driver.find(".test-pw-attachment-content").getText(),
+      "JSON\nPreview not available."
+    );
+    await driver.sendKeys(Key.ESCAPE);
+
+    // Undo.
+    await gu.undo();
+    assert.deepEqual(await getCellThumbnailTitles(cell), [
+      "renamed.pdf",
+      "grist.png",
+    ]);
+  });
+
+  const checkClosing = stackWrapFunc(async function (
+    shouldSave: boolean,
+    trigger: () => Promise<void>
+  ) {
+    let cell = gu.getCell({ col: 0, rowNum: 2 });
+    await cell.click();
+    assert.deepEqual(await getCellThumbnailTitles(cell), [
+      "renamed.pdf",
+      "grist.png",
+    ]);
+
+    // Open attachments editor.
+    await driver.sendKeys(Key.ENTER);
+    await driver.findWait(".test-pw-attachment-content", 500);
+
+    // Close using the given trigger. No actions should be emitted.
+    await gu.userActionsCollect();
+    await trigger();
+    await gu.userActionsVerify([]);
+
+    // Open editor and delete a file.
+    await driver.sendKeys(Key.ENTER);
+    await driver.findWait(".test-pw-attachment-content", 500);
+    await driver.find(".test-pw-remove").click();
+    await gu.waitForServer();
+
+    // Close using the given trigger.
+    await gu.userActionsCollect();
+    await trigger();
+    await gu.waitForServer();
+    cell = gu.getCell({ col: 0, rowNum: 2 });
+    if (shouldSave) {
+      // If shouldSave is set, files should reflect the change. Check it and undo.
+      await gu.userActionsCollect(false);
+      assert.deepEqual(await getCellThumbnailTitles(cell), ["grist.png"]);
+      await gu.undo();
+    } else {
+      // If shouldSave is false, there should be no actions.
+      await gu.userActionsVerify([]);
+    }
+    assert.deepEqual(await getCellThumbnailTitles(cell), [
+      "renamed.pdf",
+      "grist.png",
+    ]);
+  });
+
+  it("should not save on Escape", async function () {
+    await checkClosing(false, () => driver.sendKeys(Key.ESCAPE));
+  });
+
+  it("should save on Enter", async function () {
+    await checkClosing(true, () => driver.sendKeys(Key.ENTER));
+  });
+
+  it("should save on close button", async function () {
+    await checkClosing(true, () =>
+      driver.find(".test-modal-dialog .test-pw-close").click()
+    );
+  });
+
+  it("should preview images properly", async function () {
+    const cell = await gu.getCell({ col: 0, rowNum: 2 });
+    await cell.click();
+    await gu.fileDialogUpload("uploads/image_with_script.svg", () =>
+      cell.find(".test-attachment-icon").click()
+    );
+    await driver.withActions((a) => a.doubleClick(cell));
+    await driver.findWait(".test-pw-attachment-content", 1000);
+    assert.isFalse(await gu.isAlertShown());
+  });
+});
diff --git a/test/nbrowser/CellFormat.ts b/test/nbrowser/CellFormat.ts
new file mode 100644
index 0000000000..4e00dc132e
--- /dev/null
+++ b/test/nbrowser/CellFormat.ts
@@ -0,0 +1,264 @@
+import {assert, driver, Key} from 'mocha-webdriver';
+import * as gu from 'test/nbrowser/gristUtils';
+import {server, setupTestSuite} from 'test/nbrowser/testUtils';
+import {DocCreationInfo} from "app/common/DocListAPI";
+
+describe('CellFormat', function() {
+  this.timeout(20000);
+  const cleanup = setupTestSuite();
+  let session: gu.Session, doc: DocCreationInfo, api;
+
+  // Checks that a bug where alignment settings did not survive doc reload is gone.
+  it('saves alignment settings', async function() {
+    session = await gu.session().login();
+    doc = await session.tempDoc(cleanup, 'Hello.grist');
+    await gu.toggleSidePanel('right', 'open');
+    await driver.findWait('.test-right-tab-field', 3000).click();
+
+    // Alignment should be left.
+    assert.equal(await driver.find(`.test-alignment-select .test-select-button:first-child`)
+                 .matches('[class*=-selected]'), true);
+
+    // Click on center aligmment.
+    await (await driver.findAll('.test-alignment-select .test-select-button'))[1].click();
+    await gu.waitForServer();
+
+    // Alignment should no longer be left.
+    assert.equal(await driver.find(`.test-alignment-select .test-select-button:first-child`)
+                 .matches('[class*=-selected]'), false);
+
+    // Reload document.
+    await session.loadDocMenu('/');
+    await session.loadDoc(`/doc/${doc.id}`);
+
+    // Alignment should still not be left.
+    assert.equal(await driver.find(`.test-alignment-select .test-select-button:first-child`)
+                 .matches('[class*=-selected]'), false);
+  });
+
+  it('should open hyperlinks in new tabs only when needed', async function () {
+    api = session.createHomeApi();
+    const currentUrl = await driver.getCurrentUrl();
+    const urls = [
+      // Different origin, must open in new tab.
+      // The driver waits for the page to load so something that loads quickly is needed.
+      'about:blank',
+
+      // Same origin, but still needs a new tab because it's not the current document
+      server.getUrl(session.settings.orgDomain, '/'),
+
+      // Same URL but with a link key, needs a new tab
+      currentUrl + "?foo_=bar",
+
+      // Shouldn't open a new tab
+      currentUrl,
+    ];
+
+    // Create and open a new table in the same document containing the above URLs
+    await api.applyUserActions(doc.id, [
+      ['AddTable', 'Links',
+        [{id: 'Link', type: 'Text'}]],
+      ...urls.map(url => ['AddRecord', 'Links', null, {Link: url}]),
+    ]);
+    await gu.getPageItem(/Links/).click();
+
+    // Confirm that we are on a different page from before (i.e. `currentUrl`)
+    // which we will be returning to
+    const newUrl = await driver.getCurrentUrl();
+    assert.isTrue(newUrl.endsWith('/p/2'));
+    assert.isFalse(currentUrl.endsWith('/p/2'));
+
+    // Convert the column to hyperlink format
+    await gu.getCell({rowNum: 1, col: 0}).click();
+    await gu.setFieldWidgetType('HyperLink');
+
+    // There should only be one tab open for the following checks to make sense
+    assert.equal((await driver.getAllWindowHandles()).length, 1);
+
+    async function checkExternalLink(rowNum: number) {
+      const cell = gu.getCell({rowNum, col: 0});
+      const url = await cell.getText();
+      await cell.find('.test-tb-link').click();
+
+      // Check that we opened the URL in the cell in a new tab
+      const handles = await driver.getAllWindowHandles();
+      assert.equal(handles.length, 2);
+      // Use gu.switchToWindow to handle occasional selenium flakage here.
+      await gu.switchToWindow(handles[1]);
+      assert.equal(await driver.getCurrentUrl(), url);
+      assert.equal(urls[rowNum - 1], url);
+      await driver.close();
+
+      // Return to the original tab with our document
+      const [originalWindow] = await driver.getAllWindowHandles();
+      await driver.switchTo().window(originalWindow);
+    }
+
+    await checkExternalLink(1);
+    await checkExternalLink(2);
+    await checkExternalLink(3);
+
+    const cell = gu.getCell({rowNum: 4, col: 0});
+    const url = await cell.getText();
+    await cell.find('.test-tb-link').click();
+    const handles = await driver.getAllWindowHandles();
+
+    // This time no new tab should have opened,
+    // but we're back to the previous page
+    assert.equal(handles.length, 1);
+    assert.equal(await driver.getCurrentUrl(), url);
+    assert.equal(currentUrl, url);
+  });
+
+  it('can display Markdown-formatted text', async function() {
+    await gu.getCell(0, 1).click();
+    await gu.setFieldWidgetType('TextBox');
+    await gu.sendKeys(
+      Key.ENTER,
+      await gu.selectAllKey(),
+      Key.DELETE,
+      '# Heading',
+      Key.chord(Key.SHIFT, Key.ENTER),
+      Key.chord(Key.SHIFT, Key.ENTER),
+      '## Subheading',
+      Key.chord(Key.SHIFT, Key.ENTER),
+      Key.chord(Key.SHIFT, Key.ENTER),
+      '1. Item 1',
+      Key.chord(Key.SHIFT, Key.ENTER),
+      '2. Item 2',
+      Key.chord(Key.SHIFT, Key.ENTER),
+      Key.chord(Key.SHIFT, Key.ENTER),
+      'A paragraph with **bold** and *italicized* text.',
+      Key.chord(Key.SHIFT, Key.ENTER),
+      Key.chord(Key.SHIFT, Key.ENTER),
+      '[Link with label](https://example.com/#1)',
+      Key.chord(Key.SHIFT, Key.ENTER),
+      Key.chord(Key.SHIFT, Key.ENTER),
+      'Link: https://example.com/#2',
+      Key.chord(Key.SHIFT, Key.ENTER),
+      Key.chord(Key.SHIFT, Key.ENTER),
+      'HTML is <span style="color: red;">escaped</span>.',
+      Key.chord(Key.SHIFT, Key.ENTER),
+      Key.chord(Key.SHIFT, Key.ENTER),
+      "![Images too](https://example.com)",
+      Key.ENTER
+    );
+    await gu.waitForServer();
+    assert.equal(
+      await gu.getCell(0, 1).getText(),
+      `# Heading
+
+## Subheading
+
+1. Item 1
+2. Item 2
+
+A paragraph with **bold** and *italicized* text.
+
+[Link with label](
+)
+
+Link: \nhttps://example.com/#2
+
+HTML is <span style="color: red;">escaped</span>.
+
+![Images too](
+)`
+    );
+    assert.isFalse(await gu.getCell(0, 1).findContent('h1', 'Heading').isPresent());
+    assert.isFalse(await gu.getCell(0, 1).findContent('h2', 'Subheading').isPresent());
+    assert.isFalse(await gu.getCell(0, 1).findContent('ol', 'Item 1').isPresent());
+    assert.isFalse(await gu.getCell(0, 1).findContent('strong', 'bold').isPresent());
+    assert.isFalse(await gu.getCell(0, 1).findContent('em', 'italicized').isPresent());
+    assert.isFalse(await gu.getCell(0, 1).findContent('a + span', 'Link with label').isPresent());
+    assert.isTrue(await gu.getCell(0, 1).find('a[href="https://example.com/#2"]').isDisplayed());
+    assert.isFalse(await gu.getCell(0, 1).findContent('span', 'escaped').isPresent());
+    assert.isFalse(await gu.getCell(0, 1).find('img').isPresent());
+
+    await gu.setFieldWidgetType('Markdown');
+    await driver.find('.test-tb-wrap-text').click();
+    await gu.waitForServer();
+    assert.equal(
+      await gu.getCell(0, 1).getText(),
+      `Heading
+Subheading
+Item 1
+Item 2
+A paragraph with bold and italicized text.
+Link with label
+Link:
+https://example.com/#2
+HTML is <span style="color: red;">escaped</span>.
+![Images too](https://example.com)`
+    );
+    assert.isTrue(await gu.getCell(0, 1).findContent('h1', 'Heading').isDisplayed());
+    assert.isTrue(await gu.getCell(0, 1).findContent('h2', 'Subheading').isDisplayed());
+    assert.isTrue(await gu.getCell(0, 1).findContent('ol', 'Item 1').isDisplayed());
+    assert.isTrue(await gu.getCell(0, 1).findContent('strong', 'bold').isDisplayed());
+    assert.isTrue(await gu.getCell(0, 1).findContent('em', 'italicized').isDisplayed());
+    assert.isTrue(await gu.getCell(0, 1)
+      .findContent('a[href="https://example.com/#1"] + span', 'Link with label').isDisplayed());
+    assert.isTrue(await gu.getCell(0, 1).find('a[href="https://example.com/#2"]').isDisplayed());
+    assert.isFalse(await gu.getCell(0, 1).findContent('span', 'escaped').isPresent());
+    assert.isFalse(await gu.getCell(0, 1).find('img').isPresent());
+
+    await gu.sendKeys(
+      Key.ENTER,
+      '> Editing works the same way as TextBox and HyperLink',
+      Key.ENTER,
+    );
+    await gu.waitForServer();
+    assert.equal(
+      await gu.getCell(0, 2).getText(),
+      'Editing works the same way as TextBox and HyperLink'
+    );
+
+    await gu.setFieldWidgetType('TextBox');
+    assert.equal(
+      await gu.getCell(0, 1).getText(),
+      `# Heading
+
+## Subheading
+
+1. Item 1
+2. Item 2
+
+A paragraph with **bold** and *italicized* text.
+
+[Link with label](
+)
+
+Link: \nhttps://example.com/#2
+
+HTML is <span style="color: red;">escaped</span>.
+
+![Images too](
+)`
+    );
+    assert.equal(
+      await gu.getCell(0, 2).getText(),
+      '> Editing works the same way as TextBox and HyperLink'
+    );
+  });
+
+  it('treats URLs in Markdown and HyperLink cells as absolute URLs', async function() {
+    // Previously, URLs in Markdown cells were treated as being relative to
+    // the document origin if they were missing a scheme. This was inconsistent
+    // with how HyperLink cells treated such URLs (with `http://` inferred).
+    await gu.setFieldWidgetType('Markdown');
+    await gu.getCell(0, 3).click();
+    await gu.sendKeys(Key.ENTER, '[Google](google.com)', Key.ENTER);
+    assert.equal(await gu.getCell(0, 3).find('a').getAttribute('href'), 'https://google.com/');
+
+    await gu.setFieldWidgetType('HyperLink');
+    await gu.getCell(0, 3).click();
+    await gu.sendKeys(Key.ENTER, await gu.selectAllKey(), Key.DELETE, 'Google google.com', Key.ENTER);
+    assert.equal(await gu.getCell(0, 3).find('a').getAttribute('href'), 'https://google.com/');
+  });
+
+  it('handles invalid URLs in HyperLink cells as "about:blank"', async function() {
+    await gu.getCell(0, 3).click();
+    await gu.sendKeys(Key.ENTER, await gu.selectAllKey(), Key.DELETE, '[Up to no good] javascript:alert()', Key.ENTER);
+    assert.equal(await gu.getCell(0, 3).find('a').getAttribute('href'), 'about:blank');
+  });
+});
diff --git a/yarn.lock b/yarn.lock
index 993d4303be..523a9810bc 100644
--- a/yarn.lock
+++ b/yarn.lock
@@ -828,13 +828,6 @@
   resolved "https://registry.npmjs.org/@types/diff-match-patch/-/diff-match-patch-1.0.32.tgz"
   integrity sha512-bPYT5ECFiblzsVzyURaNhljBH2Gh1t9LowgUwciMrNAhFewLkHT2H0Mto07Y4/3KCOGZHRQll3CTtQZ0X11D/A==
 
-"@types/dompurify@3.0.5":
-  version "3.0.5"
-  resolved "https://registry.yarnpkg.com/@types/dompurify/-/dompurify-3.0.5.tgz#02069a2fcb89a163bacf1a788f73cb415dd75cb7"
-  integrity sha512-1Wg0g3BtQF7sSb27fJQAKck1HECM6zV1EB66j8JH9i3LCjYabJa0FSdiSgsD5K/RbrsR0SiraKacLB+T8ZVYAg==
-  dependencies:
-    "@types/trusted-types" "*"
-
 "@types/double-ended-queue@2.1.0":
   version "2.1.0"
   resolved "https://registry.npmjs.org/@types/double-ended-queue/-/double-ended-queue-2.1.0.tgz"
@@ -1163,10 +1156,10 @@
   resolved "https://registry.npmjs.org/@types/tough-cookie/-/tough-cookie-4.0.2.tgz"
   integrity sha512-Q5vtl1W5ue16D+nIaW8JWebSSraJVlK+EthKn7e7UcD4KWsaSJ8BqGPXNaPghgtcn/fhvrN17Tv8ksUsQpiplw==
 
-"@types/trusted-types@*":
-  version "2.0.3"
-  resolved "https://registry.yarnpkg.com/@types/trusted-types/-/trusted-types-2.0.3.tgz#a136f83b0758698df454e328759dbd3d44555311"
-  integrity sha512-NfQ4gyz38SL8sDNrSixxU2Os1a5xcdFxipAFxYEuLUlvU2uDwS4NUpsImcf1//SlWItCVMMLiylsxbmNMToV/g==
+"@types/trusted-types@^2.0.7":
+  version "2.0.7"
+  resolved "https://registry.yarnpkg.com/@types/trusted-types/-/trusted-types-2.0.7.tgz#baccb07a970b91707df3a3e8ba6896c57ead2d11"
+  integrity sha512-ScaPdn1dQczgbl0QFTeTOmVHFULt394XJgOQNoyVhZ6r2vLnMLJfBPd53SB52T/3G36VI1/g2MZaX0cwDuXsfw==
 
 "@types/underscore@*":
   version "1.11.0"
@@ -3238,10 +3231,12 @@ domain-browser@~1.1.0:
   resolved "https://registry.npmjs.org/domain-browser/-/domain-browser-1.1.7.tgz"
   integrity sha1-hnqksJP6oF8d4IwG9NeyH9+GmLw=
 
-dompurify@3.0.6:
-  version "3.0.6"
-  resolved "https://registry.yarnpkg.com/dompurify/-/dompurify-3.0.6.tgz#925ebd576d54a9531b5d76f0a5bef32548351dae"
-  integrity sha512-ilkD8YEnnGh1zJ240uJsW7AzE+2qpbOUYjacomn3AvJ6J4JhKGSZ2nh4wUIXPZrEPppaCLx5jFe8T89Rk8tQ7w==
+dompurify@3.2.3:
+  version "3.2.3"
+  resolved "https://registry.yarnpkg.com/dompurify/-/dompurify-3.2.3.tgz#05dd2175225324daabfca6603055a09b2382a4cd"
+  integrity sha512-U1U5Hzc2MO0oW3DF+G9qYN0aT7atAou4AgI0XjWz061nyBPbdxkfdhfy5uMgGn6+oLFCfn44ZGbdDqCzVmlOWA==
+  optionalDependencies:
+    "@types/trusted-types" "^2.0.7"
 
 dot-prop@^5.2.0:
   version "5.2.0"
