diff --git a/CHANGELOG.md b/CHANGELOG.md
index f54f795a92..5c7582bc6f 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -40,6 +40,10 @@ The types of changes are:
 - Fix bug where Data Detection & Discovery table pagination fails to reset after navigating or searching  [#5234](https://github.com/ethyca/fides/pull/5234)
 - Ignoring HTTP 400 error responses from the unsubscribe endpoint for HubSpot [#5237](https://github.com/ethyca/fides/pull/5237)
 
+### Security
+- Reduced timing differences in login endpoint [CVE-2024-45052](https://github.com/ethyca/fides/security/advisories/GHSA-2h46-8gf5-fmxv)
+
+
 ## [2.43.1](https://github.com/ethyca/fides/compare/2.43.0...2.43.1)
 
 ### Added
diff --git a/src/fides/api/api/v1/endpoints/user_endpoints.py b/src/fides/api/api/v1/endpoints/user_endpoints.py
index 488a9bb831..78dc45b527 100644
--- a/src/fides/api/api/v1/endpoints/user_endpoints.py
+++ b/src/fides/api/api/v1/endpoints/user_endpoints.py
@@ -1,4 +1,6 @@
 import json
+import random
+import time
 from datetime import datetime
 from typing import List, Optional
 
@@ -35,6 +37,7 @@
 from fides.api.models.sql_models import System  # type: ignore[attr-defined]
 from fides.api.oauth.roles import APPROVER, VIEWER
 from fides.api.oauth.utils import (
+    create_temporary_user_for_login_flow,
     extract_payload,
     get_current_user,
     oauth2_scheme,
@@ -76,6 +79,11 @@
 router = APIRouter(tags=["Users"], prefix=V1_URL_PREFIX)
 
 
+ARTIFICIAL_TEMP_USER = create_temporary_user_for_login_flow(
+    CONFIG
+)  # To reduce likelihood of timing attacks.  Creating once and holding in memory
+
+
 def get_system_by_fides_key(db: Session, system_key: FidesKey) -> System:
     """Load a system by FidesKey or throw a 404"""
     system = System.get_by(db, field="fides_key", value=system_key)
@@ -541,6 +549,8 @@ def user_login(
     generate a token."""
     user: FidesUser
     client: ClientDetail
+    should_raise_exception: bool = False
+
     if (
         config.security.root_username
         and config.security.root_password
@@ -578,18 +588,15 @@ def user_login(
             db, field="username", value=user_data.username
         )
 
-        invalid_user_error_msg = "Incorrect username or password."
-
         if not user_check:
-            raise HTTPException(
-                status_code=HTTP_403_FORBIDDEN, detail=invalid_user_error_msg
-            )
+            # Postpone raising the exception to reduce the time differences between
+            # login flows for valid and invalid users. Instead, create a temporary user
+            # on which we'll perform parallel operations
+            should_raise_exception = True
+            user_check = ARTIFICIAL_TEMP_USER
 
         if not user_check.credentials_valid(user_data.password):
-            raise HTTPException(
-                status_code=HTTP_403_FORBIDDEN,
-                detail=invalid_user_error_msg,
-            )
+            should_raise_exception = True
 
         # We have already checked for None but mypy still complains. This prevents mypy
         # from complaining.
@@ -600,10 +607,21 @@ def user_login(
             config.security.oauth_client_id_length_bytes,
             config.security.oauth_client_secret_length_bytes,
             user,
+            skip_save=should_raise_exception,
         )
 
     logger.info("Creating login access token")
     access_code = client.create_access_code_jwe(config.security.app_encryption_key)
+
+    # Sleep for a random time period
+    time.sleep(random.uniform(0.00, 0.50))
+
+    if should_raise_exception:
+        # Now raise postponed exception!
+        raise HTTPException(
+            status_code=HTTP_403_FORBIDDEN, detail="Incorrect username or password."
+        )
+
     return UserLoginResponse(
         user_data=user,
         token_data=AccessToken(access_token=access_code),
diff --git a/src/fides/api/models/client.py b/src/fides/api/models/client.py
index abda210bf5..9e2fddc4ac 100644
--- a/src/fides/api/models/client.py
+++ b/src/fides/api/models/client.py
@@ -66,6 +66,7 @@ def create_client_and_secret(
         roles: list[str] | None = None,
         systems: list[str] | None = None,
         connections: list[str] | None = None,
+        in_memory: bool | None = False,
     ) -> tuple["ClientDetail", str]:
         """Creates a ClientDetail and returns that along with the unhashed secret
         so it can be returned to the user on create
@@ -92,20 +93,27 @@ def create_client_and_secret(
             salt.encode(encoding),
         )
 
-        client = super().create(
-            db,
-            data={
-                "id": client_id,
-                "salt": salt,
-                "hashed_secret": hashed_secret,
-                "scopes": scopes,
-                "fides_key": fides_key,
-                "user_id": user_id,
-                "roles": roles,
-                "systems": systems,
-                "connections": connections,
-            },
-        )
+        data = {
+            "id": client_id,
+            "salt": salt,
+            "hashed_secret": hashed_secret,
+            "scopes": scopes,
+            "fides_key": fides_key,
+            "user_id": user_id,
+            "roles": roles,
+            "systems": systems,
+            "connections": connections,
+        }
+
+        if in_memory:
+            client = ClientDetail(
+                **data
+            )  # For creating a temporary ClientDetail for invalid user login flow
+        else:
+            client = super().create(
+                db,
+                data=data,
+            )
         return client, secret  # type: ignore
 
     @classmethod
diff --git a/src/fides/api/oauth/utils.py b/src/fides/api/oauth/utils.py
index a4e6b53e03..b9c937138a 100644
--- a/src/fides/api/oauth/utils.py
+++ b/src/fides/api/oauth/utils.py
@@ -17,6 +17,7 @@
 
 from fides.api.api.deps import get_db
 from fides.api.common_exceptions import AuthenticationError, AuthorizationError
+from fides.api.cryptography.cryptographic_util import generate_secure_random_string
 from fides.api.cryptography.schemas.jwt import (
     JWE_ISSUED_AT,
     JWE_PAYLOAD_CLIENT_ID,
@@ -25,6 +26,7 @@
 )
 from fides.api.models.client import ClientDetail
 from fides.api.models.fides_user import FidesUser
+from fides.api.models.fides_user_permissions import FidesUserPermissions
 from fides.api.models.policy import PolicyPreWebhook
 from fides.api.models.pre_approval_webhook import PreApprovalWebhook
 from fides.api.models.privacy_request import RequestTask
@@ -32,7 +34,7 @@
 from fides.api.schemas.external_https import RequestTaskJWE, WebhookJWE
 from fides.api.schemas.oauth import OAuth2ClientCredentialsBearer
 from fides.common.api.v1.urn_registry import TOKEN, V1_URL_PREFIX
-from fides.config import CONFIG
+from fides.config import CONFIG, FidesConfig
 
 JWT_ENCRYPTION_ALGORITHM = ALGORITHMS.A256GCM
 
@@ -395,5 +397,50 @@ def has_scope_subset(user_scopes: List[str], endpoint_scopes: SecurityScopes) ->
     return True
 
 
+def create_temporary_user_for_login_flow(config: FidesConfig) -> FidesUser:
+    """
+    Create a temporary FidesUser in-memory with an attached in-memory ClientDetail
+    and attached in-memory FidesUserPermissions
+
+    This is for reducing the time differences in the user login flow between a
+    valid and an invalid user
+    """
+    hashed_password, salt = FidesUser.hash_password(generate_secure_random_string(16))
+    user = FidesUser(
+        **{
+            "salt": salt,
+            "hashed_password": hashed_password,
+            "username": "temp_user",
+            "email_address": "temp_user@example.com",
+            "first_name": "temp_first_name",
+            "last_name": "temp_surname",
+            "disabled": True,
+        }
+    )
+
+    # Create in-memory user permissions
+    user.permissions = FidesUserPermissions(  # type: ignore[attr-defined]
+        id="temp_user_id",
+        user_id="temp_user_id",
+        roles=["fake_role"],
+    )
+
+    # Create in-memory client, not persisted to db
+    client, _ = ClientDetail.create_client_and_secret(
+        None,  # type: ignore[arg-type]
+        config.security.oauth_client_id_length_bytes,
+        config.security.oauth_client_secret_length_bytes,
+        scopes=[],  # type: ignore
+        roles=user.permissions.roles,  # type: ignore
+        systems=user.system_ids,  # type: ignore
+        user_id="temp_user_id",
+        in_memory=True,
+    )
+
+    user.client = client
+
+    return user
+
+
 # This allows us to selectively enforce auth depending on user environment settings
 verify_oauth_client_prod = copy_func(verify_oauth_client)
diff --git a/src/fides/api/service/user/fides_user_service.py b/src/fides/api/service/user/fides_user_service.py
index 0b6524558a..9e2dc68da5 100644
--- a/src/fides/api/service/user/fides_user_service.py
+++ b/src/fides/api/service/user/fides_user_service.py
@@ -1,6 +1,6 @@
 import uuid
 from datetime import datetime
-from typing import Tuple
+from typing import Optional, Tuple
 
 from loguru import logger
 from sqlalchemy.orm import Session
@@ -87,9 +87,14 @@ def perform_login(
     client_id_byte_length: int,
     client_secret_byte_length: int,
     user: FidesUser,
+    skip_save: Optional[bool] = False,
 ) -> ClientDetail:
     """Performs a login by updating the FidesUser instance and creating and returning
     an associated ClientDetail.
+
+    If the username or password was bad, skip_save should be True. We still run through
+    parallel operations to keep the timing of operations similar, but should skip
+    saving to the database.
     """
 
     client = user.client
@@ -103,18 +108,21 @@ def perform_login(
             roles=user.permissions.roles,  # type: ignore
             systems=user.system_ids,  # type: ignore
             user_id=user.id,
+            in_memory=skip_save,  # If login flow has already errored, don't persist this to the database
         )
     else:
         # Refresh the client just in case - for example, scopes and roles were added via the db directly.
         client.roles = user.permissions.roles  # type: ignore
         client.systems = user.system_ids  # type: ignore
-        client.save(db)
+        if not skip_save:
+            client.save(db)
 
-    if not user.permissions.roles and not user.systems:  # type: ignore
+    if user.permissions and (not user.permissions.roles and not user.systems):  # type: ignore
         logger.warning("User {} needs roles or systems to login.", user.id)
         raise AuthorizationError(detail="Not Authorized for this action")
 
-    user.last_login_at = datetime.utcnow()
-    user.save(db)
+    if not skip_save:
+        user.last_login_at = datetime.utcnow()
+        user.save(db)
 
     return client
diff --git a/tests/ops/api/v1/endpoints/test_user_endpoints.py b/tests/ops/api/v1/endpoints/test_user_endpoints.py
index a0517fcba6..cc48e3146b 100644
--- a/tests/ops/api/v1/endpoints/test_user_endpoints.py
+++ b/tests/ops/api/v1/endpoints/test_user_endpoints.py
@@ -1013,7 +1013,7 @@ class TestUserLogin:
     def url(self) -> str:
         return V1_URL_PREFIX + LOGIN
 
-    def test_user_does_not_exist(self, url, api_client):
+    def test_user_does_not_exist(self, db, url, api_client):
         body = {
             "username": "does not exist",
             "password": str_to_b64_str("idonotknowmypassword"),
@@ -1021,6 +1021,20 @@ def test_user_does_not_exist(self, url, api_client):
         response = api_client.post(url, headers={}, json=body)
         assert response.status_code == HTTP_403_FORBIDDEN
 
+        user = FidesUser.get_by(db, field="username", value=body["username"])
+        assert user is None
+
+        # The temporary resources created to parallelize operations between the invalid
+        # and valid flow do not get persisted
+        user = FidesUser.get_by(db, field="username", value="temp_user")
+        assert user is None
+
+        user_perms = FidesUserPermissions.get_by(db, field="id", value="temp_user_id")
+        assert user_perms is None
+
+        client_search = ClientDetail.get_by(db, field="id", value="temp_user_id")
+        assert client_search is None
+
     def test_bad_login(self, url, user, api_client):
         body = {
             "username": user.username,
