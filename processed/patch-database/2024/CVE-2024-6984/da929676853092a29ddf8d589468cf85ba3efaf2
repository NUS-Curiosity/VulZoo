diff --git a/worker/uniter/runner/runner.go b/worker/uniter/runner/runner.go
index 609b2c22763..cb626d5ebf9 100644
--- a/worker/uniter/runner/runner.go
+++ b/worker/uniter/runner/runner.go
@@ -108,11 +108,41 @@ type Runner interface {
 }
 
 // NewRunnerFunc returns a func used to create a Runner backed by the supplied context and paths.
-type NewRunnerFunc func(context context.Context, paths context.Paths, remoteExecutor ExecFunc) Runner
+type NewRunnerFunc func(context context.Context, paths context.Paths, remoteExecutor ExecFunc, options ...Option) Runner
+
+// Option is a functional option for NewRunner.
+type Option func(*options)
+
+type options struct {
+	tokenGenerator TokenGenerator
+}
+
+// WithTokenGenerator returns an Option that sets the token generator for the
+// runner.
+func WithTokenGenerator(tg TokenGenerator) Option {
+	return func(o *options) {
+		o.tokenGenerator = tg
+	}
+}
+
+func newOptions() *options {
+	return &options{
+		tokenGenerator: &tokenGenerator{},
+	}
+}
 
 // NewRunner returns a Runner backed by the supplied context and paths.
-func NewRunner(context context.Context, paths context.Paths, remoteExecutor ExecFunc) Runner {
-	return &runner{context, paths, remoteExecutor}
+func NewRunner(context context.Context, paths context.Paths, remoteExecutor ExecFunc, options ...Option) Runner {
+	opts := newOptions()
+	for _, option := range options {
+		option(opts)
+	}
+	return &runner{
+		context:        context,
+		paths:          paths,
+		remoteExecutor: remoteExecutor,
+		tokenGenerator: opts.tokenGenerator,
+	}
 }
 
 // ExecParams holds all the necessary parameters for ExecFunc.
@@ -152,12 +182,21 @@ func execOnMachine(params ExecParams) (*utilexec.ExecResponse, error) {
 // ExecFunc is the exec func type.
 type ExecFunc func(ExecParams) (*utilexec.ExecResponse, error)
 
+// TokenGenerator is the interface for generating tokens.
+type TokenGenerator interface {
+	// Generate generates a token based on the remote flag.
+	// If remote is false, it returns an empty string. Otherwise, it returns a
+	// random token.
+	Generate(remote bool) (string, error)
+}
+
 // runner implements Runner.
 type runner struct {
 	context context.Context
 	paths   context.Paths
 	// remoteExecutor executes commands on a remote workload pod for CAAS.
 	remoteExecutor ExecFunc
+	tokenGenerator TokenGenerator
 }
 
 func (runner *runner) logger() loggo.Logger {
@@ -207,14 +246,11 @@ func (runner *runner) RunCommands(commands string, runLocation RunLocation) (*ut
 // runCommandsWithTimeout is a helper to abstract common code between run commands and
 // juju-run as an action
 func (runner *runner) runCommandsWithTimeout(commands string, timeout time.Duration, clock clock.Clock, rMode runMode, abort <-chan struct{}) (*utilexec.ExecResponse, error) {
-	var err error
-	token := ""
-	if rMode == runOnRemote {
-		token, err = utils.RandomPassword()
-		if err != nil {
-			return nil, errors.Trace(err)
-		}
+	token, err := runner.tokenGenerator.Generate(rMode == runOnRemote)
+	if err != nil {
+		return nil, errors.Trace(err)
 	}
+
 	srv, err := runner.startJujucServer(token, rMode)
 	if err != nil {
 		return nil, err
@@ -387,13 +423,11 @@ func (runner *runner) RunHook(hookName string) (HookHandlerType, error) {
 }
 
 func (runner *runner) runCharmHookWithLocation(hookName, charmLocation string, rMode runMode) (hookHandlerType HookHandlerType, err error) {
-	token := ""
-	if rMode == runOnRemote {
-		token, err = utils.RandomPassword()
-		if err != nil {
-			return InvalidHookHandler, errors.Trace(err)
-		}
+	token, err := runner.tokenGenerator.Generate(rMode == runOnRemote)
+	if err != nil {
+		return InvalidHookHandler, errors.Trace(err)
 	}
+
 	srv, err := runner.startJujucServer(token, rMode)
 	if err != nil {
 		return InvalidHookHandler, errors.Trace(err)
@@ -719,7 +753,7 @@ func (runner *runner) startJujucServer(token string, rMode runMode) (*jujuc.Serv
 	// Prepare server.
 	getCmd := func(ctxId, cmdName string) (cmd.Command, error) {
 		if ctxId != runner.context.Id() {
-			return nil, errors.Errorf("expected context id %q, got %q", runner.context.Id(), ctxId)
+			return nil, errors.Errorf("wrong context ID; got %q", ctxId)
 		}
 		return jujuc.NewCommand(runner.context, cmdName)
 	}
@@ -789,3 +823,19 @@ type hookProcess struct {
 func (p hookProcess) Pid() int {
 	return p.Process.Pid
 }
+
+type tokenGenerator struct{}
+
+// Generate generates a token based on the remote flag.
+// If remote is false, it returns an empty string. Otherwise, it returns a
+// random token.
+func (t *tokenGenerator) Generate(remote bool) (string, error) {
+	if !remote {
+		return "", nil
+	}
+	token, err := utils.RandomPassword()
+	if err != nil {
+		return "", errors.Trace(err)
+	}
+	return token, nil
+}
diff --git a/worker/uniter/runner/runner_test.go b/worker/uniter/runner/runner_test.go
index 336ea9bd9b8..e4ac6c6735f 100644
--- a/worker/uniter/runner/runner_test.go
+++ b/worker/uniter/runner/runner_test.go
@@ -21,10 +21,13 @@ import (
 	gc "gopkg.in/check.v1"
 
 	"github.com/juju/juju/core/model"
+	"github.com/juju/juju/juju/sockets"
+	"github.com/juju/juju/testing"
 	"github.com/juju/juju/worker/common/charmrunner"
 	"github.com/juju/juju/worker/uniter/hook"
 	"github.com/juju/juju/worker/uniter/runner"
 	"github.com/juju/juju/worker/uniter/runner/context"
+	"github.com/juju/juju/worker/uniter/runner/jujuc"
 	runnertesting "github.com/juju/juju/worker/uniter/runner/testing"
 )
 
@@ -227,6 +230,7 @@ func (s *RunHookSuite) TestRunHookDispatchingHookHandler(c *gc.C) {
 
 type MockContext struct {
 	context.Context
+	id              string
 	actionData      *context.ActionData
 	actionDataErr   error
 	actionParams    map[string]interface{}
@@ -239,6 +243,10 @@ type MockContext struct {
 	modelType       model.ModelType
 }
 
+func (ctx *MockContext) Id() string {
+	return ctx.id
+}
+
 func (ctx *MockContext) GetLogger(module string) loggo.Logger {
 	return loggo.GetLogger(module)
 }
@@ -322,6 +330,85 @@ func (s *RunMockContextSuite) assertRecordedPid(c *gc.C, expectPid int) {
 	c.Assert(strings.TrimRight(string(content), "\r\n"), gc.Equals, expectContent)
 }
 
+func (s *RunMockContextSuite) TestBadContextId(c *gc.C) {
+	params := map[string]interface{}{
+		"command":          "echo 1",
+		"timeout":          0,
+		"workload-context": true,
+	}
+	ctx := &MockContext{
+		id:        "foo-context",
+		modelType: model.CAAS,
+		actionData: &context.ActionData{
+			Params: params,
+		},
+		actionParams:  params,
+		actionResults: map[string]interface{}{},
+	}
+	start := make(chan struct{})
+	done := make(chan struct{})
+	result := make(chan error)
+	execCount := 0
+	execFunc := func(params runner.ExecParams) (*exec.ExecResponse, error) {
+		execCount++
+		switch execCount {
+		case 1:
+			return &exec.ExecResponse{}, nil
+		case 2:
+			close(start)
+
+			select {
+			case <-done:
+			case <-time.After(testing.LongWait):
+				c.Fatalf("timed out waiting to complete")
+			}
+			return &exec.ExecResponse{}, nil
+		}
+		return nil, nil
+	}
+	go func() {
+		defer close(done)
+		select {
+		case <-start:
+		case <-time.After(testing.LongWait):
+			c.Fatalf("timed out waiting to start")
+		}
+		socket := s.paths.GetJujucServerSocket(false)
+
+		client, err := sockets.Dial(socket)
+		c.Assert(err, jc.ErrorIsNil)
+		defer client.Close()
+
+		req := jujuc.Request{
+			ContextId:   "whatever",
+			Dir:         c.MkDir(),
+			CommandName: "remote",
+		}
+
+		var resp exec.ExecResponse
+		err = client.Call("Jujuc.Main", req, &resp)
+
+		go func() {
+			result <- err
+		}()
+	}()
+	_, err := runner.NewRunner(ctx, s.paths, execFunc, runner.WithTokenGenerator(localTokenGenerator{})).RunAction("juju-run")
+	c.Assert(err, jc.ErrorIsNil)
+
+	select {
+	case err := <-result:
+		c.Assert(err, gc.ErrorMatches, `.*wrong context ID; got "whatever"`)
+	case <-time.After(5 * time.Second):
+		c.Fatal("timed out waiting for jujuc to finish")
+	}
+}
+
+type localTokenGenerator struct{}
+
+func (localTokenGenerator) Generate(remote bool) (string, error) {
+	return "", nil
+}
+
 func (s *RunMockContextSuite) TestRunHookFlushSuccess(c *gc.C) {
 	expectErr := errors.New("pew pew pew")
 	ctx := &MockContext{
diff --git a/worker/uniter/util_test.go b/worker/uniter/util_test.go
index faacdc22a32..7de5272c2ea 100644
--- a/worker/uniter/util_test.go
+++ b/worker/uniter/util_test.go
@@ -551,7 +551,7 @@ func (s startUniter) step(c *gc.C, ctx *testContext) {
 		MachineLock:          processLock,
 		UpdateStatusSignal:   ctx.updateStatusHookTicker.ReturnTimer(),
 		NewOperationExecutor: operationExecutor,
-		NewProcessRunner: func(context runnercontext.Context, paths runnercontext.Paths, remoteExecutor runner.ExecFunc) runner.Runner {
+		NewProcessRunner: func(context runnercontext.Context, paths runnercontext.Paths, remoteExecutor runner.ExecFunc, options ...runner.Option) runner.Runner {
 			ctx.runner.ctx = context
 			return ctx.runner
 		},
