diff --git a/snap/container.go b/snap/container.go
index fd1daa0004b..bebef954ad6 100644
--- a/snap/container.go
+++ b/snap/container.go
@@ -21,6 +21,7 @@ package snap
 
 import (
 	"errors"
+	"fmt"
 	"io"
 	"os"
 	"path/filepath"
@@ -44,6 +45,12 @@ type Container interface {
 	// ReadFile returns the content of a single file from the snap.
 	ReadFile(relative string) ([]byte, error)
 
+	// ReadLink returns the destination of the named symbolic link.
+	ReadLink(relative string) (string, error)
+
+	// Lstat is like os.Lstat.
+	Lstat(relative string) (os.FileInfo, error)
+
 	// Walk is like filepath.Walk, without the ordering guarantee.
 	Walk(relative string, walkFn filepath.WalkFunc) error
 
@@ -78,6 +85,142 @@ var (
 	ErrMissingPaths = errors.New("snap is unusable due to missing files")
 )
 
+type symlinkInfo struct {
+	// target is the furthest target we could evaluate.
+	target string
+	// targetMode is the mode of the final symlink target.
+	targetMode os.FileMode
+	// naiveTarget is the first symlink target.
+	naiveTarget string
+	// isExternal determines if the symlink is considered external
+	// relative to its container.
+	isExternal bool
+}
+
+// evalSymlink follows symlinks inside given container and returns
+// information about it's target.
+//
+// The symlink is followed inside the container until we cannot
+// continue further either due to absolute symlinks or symlinks
+// that escape the container.
+//
+//       max depth reached?<------
+//               /\               \
+//            yes  no              \
+//            /      \              \
+//           V        V              \
+//        error      path             \
+//                    │                \
+//                    V                 \
+//                read target            \
+//                    │                   \
+//                    V                    \
+//               is absolute?               \
+//                   /\                      \
+//                yes  no                     \
+//                /      \                     \
+//               V        V                     \
+//       isExternal     eval relative target     \
+//           +               \                    \
+//     return target          V                    \
+//                     escapes container?           \
+//                           /\                      \
+//                        yes  no                     \
+//                       /      \                      |
+//                      V        V                     |
+//              isExternal      is symlink?            |
+//                   +                /\               |
+//             return target       yes  no             │
+//                                /      \             │
+//                               V        V            │
+//                       !isExternal    path = target  │
+//                            +             \----------│
+//                      return target
+//
+func evalSymlink(c Container, path string) (symlinkInfo, error) {
+	var naiveTarget string
+
+	const maxDepth = 10
+	currentDepth := 0
+	for currentDepth < maxDepth {
+		currentDepth++
+		target, err := c.ReadLink(path)
+		if err != nil {
+			return symlinkInfo{}, err
+		}
+		// record first symlink target
+		if currentDepth == 1 {
+			naiveTarget = target
+		}
+
+		target = filepath.Clean(target)
+		// don't follow absolute targets
+		if filepath.IsAbs(target) {
+			return symlinkInfo{target, os.FileMode(0), naiveTarget, true}, nil
+		}
+
+		// evaluate target relative to symlink directory
+		target = filepath.Join(filepath.Dir(path), target)
+
+		// target escapes container, cannot evaluate further, let's return
+		if strings.Split(target, string(os.PathSeparator))[0] == ".." {
+			return symlinkInfo{target, os.FileMode(0), naiveTarget, true}, nil
+		}
+
+		info, err := c.Lstat(target)
+		// cannot follow bad targets
+		if err != nil {
+			return symlinkInfo{}, err
+		}
+
+		// non-symlink, let's return
+		if info.Mode().Type() != os.ModeSymlink {
+			return symlinkInfo{target, info.Mode(), naiveTarget, false}, nil
+		}
+
+		// we have another symlink
+		path = target
+	}
+
+	return symlinkInfo{}, fmt.Errorf("too many levels of symbolic links")
+}
+
+func shouldValidateSymlink(path string) bool {
+	// we only check meta directory for now
+	pathTokens := strings.Split(path, string(os.PathSeparator))
+	if pathTokens[0] == "meta" {
+		return true
+	}
+	return false
+}
+
+func evalAndValidateSymlink(c Container, path string) (symlinkInfo, error) {
+	pathTokens := strings.Split(path, string(os.PathSeparator))
+	// check if meta directory is a symlink
+	if len(pathTokens) == 1 && pathTokens[0] == "meta" {
+		return symlinkInfo{}, fmt.Errorf("meta directory cannot be a symlink")
+	}
+
+	info, err := evalSymlink(c, path)
+	if err != nil {
+		return symlinkInfo{}, err
+	}
+
+	if info.isExternal {
+		return symlinkInfo{}, fmt.Errorf("external symlink found: %s -> %s", path, info.naiveTarget)
+	}
+
+	// symlinks like this don't look innocent
+	badTargets := []string{".", "meta"}
+	for _, badTarget := range badTargets {
+		if info.target == badTarget {
+			return symlinkInfo{}, fmt.Errorf("bad symlink found: %s -> %s", path, info.naiveTarget)
+		}
+	}
+
+	return info, nil
+}
+
 // ValidateComponentContainer does a minimal quick check on a snap component container.
 func ValidateComponentContainer(c Container, contName string, logf func(format string, v ...interface{})) error {
 	needsrx := map[string]bool{
@@ -196,20 +339,32 @@ func validateContainer(c Container, needsrx, needsx, needsr, needsf, noskipd map
 			return nil
 		}
 
-		if needsrx[path] || mode.IsDir() {
+		if mode&os.ModeSymlink != 0 && shouldValidateSymlink(path) {
+			symlinkInfo, err := evalAndValidateSymlink(c, path)
+			if err != nil {
+				logf("%s", err)
+				hasBadModes = true
+			} else {
+				// use target mode for checks below
+				mode = symlinkInfo.targetMode
+			}
+		}
+
+		if mode.IsDir() {
 			if mode.Perm()&0555 != 0555 {
 				logf("in %s %q: %q should be world-readable and executable, and isn't: %s", contType, name, path, mode)
 				hasBadModes = true
 			}
 		} else {
-			if needsf[path] {
-				// this assumes that if it's a symlink it's OK. Arguably we
-				// should instead follow the symlink.  We'd have to expose
-				// Lstat(), and guard against loops, and ...  huge can of
-				// worms, and as this validator is meant as a developer aid
-				// more than anything else, not worth it IMHO (as I can't
-				// imagine this happening by accident).
-				if mode&(os.ModeDir|os.ModeNamedPipe|os.ModeSocket|os.ModeDevice) != 0 {
+			if needsrx[path] {
+				if mode.Perm()&0555 != 0555 {
+					logf("in snap %q: %q should be world-readable and executable, and isn't: %s", name, path, mode)
+					hasBadModes = true
+				}
+			}
+			// XXX: do we need to match other directories?
+			if needsf[path] || strings.HasPrefix(path, "meta/") {
+				if mode&(os.ModeNamedPipe|os.ModeSocket|os.ModeDevice) != 0 {
 					logf("in %s %q: %q should be a regular file (or a symlink) and isn't", contType, name, path)
 					hasBadModes = true
 				}
diff --git a/snap/container_test.go b/snap/container_test.go
index 759653e98f6..18588e465b0 100644
--- a/snap/container_test.go
+++ b/snap/container_test.go
@@ -20,7 +20,7 @@
 package snap_test
 
 import (
-	"io/ioutil"
+	"fmt"
 	"os"
 	"path/filepath"
 	"syscall"
@@ -29,6 +29,7 @@ import (
 
 	"github.com/snapcore/snapd/snap"
 	"github.com/snapcore/snapd/snap/snapdir"
+	"github.com/snapcore/snapd/snap/squashfs"
 	"github.com/snapcore/snapd/testutil"
 )
 
@@ -38,13 +39,34 @@ var _ = Suite(&FileSuite{})
 
 type validateSuite struct {
 	testutil.BaseTest
+
+	snapDirPath      string
+	snapSquashfsPath string
+	containerType    string
 }
 
-var _ = Suite(&validateSuite{})
+type dirContainerValidateSuite struct{ validateSuite }
+type squashfsContainerValidateSuite struct{ validateSuite }
+
+var _ = Suite(&dirContainerValidateSuite{validateSuite{containerType: "dir"}})
+var _ = Suite(&squashfsContainerValidateSuite{validateSuite{containerType: "squashfs"}})
 
 func discard(string, ...interface{}) {}
 
+func (s *validateSuite) container() snap.Container {
+	if s.containerType == "squashfs" {
+		snap := squashfs.New(s.snapSquashfsPath)
+		if err := snap.Build(s.snapDirPath, nil); err != nil {
+			panic(fmt.Sprintf("internal error: couldn't build snap: %s", err))
+		}
+		return snap
+	}
+	return snapdir.New(s.snapDirPath)
+}
+
 func (s *validateSuite) SetUpTest(c *C) {
+	s.snapDirPath = c.MkDir()
+	s.snapSquashfsPath = filepath.Join(c.MkDir(), "foo.snap")
 	s.BaseTest.SetUpTest(c)
 	s.BaseTest.AddCleanup(snap.MockSanitizePlugsSlots(func(snapInfo *snap.Info) {}))
 }
@@ -57,16 +79,14 @@ func (s *validateSuite) TestValidateContainerReallyEmptyFails(c *C) {
 	const yaml = `name: empty-snap
 version: 1
 `
-	d := c.MkDir()
-	// the snap dir is a 0700 directory with nothing in it
-
+	container := s.container()
 	info, err := snap.InfoFromSnapYaml([]byte(yaml))
 	c.Assert(err, IsNil)
 
-	err = snap.ValidateSnapContainer(snapdir.New(d), info, discard)
+	err = snap.ValidateSnapContainer(container, info, discard)
 	c.Check(err, Equals, snap.ErrMissingPaths)
 
-	err = snap.ValidateComponentContainer(snapdir.New(d), "empty-snap+comp.comp", discard)
+	err = snap.ValidateComponentContainer(container, "empty-snap+comp.comp", discard)
 	c.Check(err, Equals, snap.ErrMissingPaths)
 }
 
@@ -74,37 +94,33 @@ func (s *validateSuite) TestValidateContainerEmptyButBadPermFails(c *C) {
 	const yaml = `name: empty-snap
 version: 1
 `
-	d := c.MkDir()
-
-	stat, err := os.Stat(d)
+	stat, err := os.Stat(s.snapDirPath)
 	c.Assert(err, IsNil)
 	c.Check(stat.Mode().Perm(), Equals, os.FileMode(0700)) // just to be sure
 
-	c.Assert(os.Mkdir(filepath.Join(d, "meta"), 0755), IsNil)
-	c.Assert(os.WriteFile(filepath.Join(d, "meta", "snap.yaml"), nil, 0444), IsNil)
+	c.Assert(os.Mkdir(filepath.Join(s.snapDirPath, "meta"), 0755), IsNil)
+	c.Assert(os.WriteFile(filepath.Join(s.snapDirPath, "meta", "snap.yaml"), nil, 0444), IsNil)
 
 	// snapdir has /meta/snap.yaml, but / is 0700
 
 	info, err := snap.InfoFromSnapYaml([]byte(yaml))
 	c.Assert(err, IsNil)
 
-	err = snap.ValidateSnapContainer(snapdir.New(d), info, discard)
+	err = snap.ValidateSnapContainer(s.container(), info, discard)
 	c.Check(err, Equals, snap.ErrBadModes)
 }
 
 func (s *validateSuite) TestValidateComponentContainerEmptyButBadPermFails(c *C) {
-	d := c.MkDir()
-
-	stat, err := os.Stat(d)
+	stat, err := os.Stat(s.snapDirPath)
 	c.Assert(err, IsNil)
 	c.Check(stat.Mode().Perm(), Equals, os.FileMode(0700)) // just to be sure
 
-	c.Assert(os.Mkdir(filepath.Join(d, "meta"), 0755), IsNil)
-	c.Assert(os.WriteFile(filepath.Join(d, "meta", "component.yaml"), nil, 0444), IsNil)
+	c.Assert(os.Mkdir(filepath.Join(s.snapDirPath, "meta"), 0755), IsNil)
+	c.Assert(os.WriteFile(filepath.Join(s.snapDirPath, "meta", "component.yaml"), nil, 0444), IsNil)
 
 	// snapdir has /meta/component.yaml, but / is 0700
 
-	err = snap.ValidateComponentContainer(snapdir.New(d), "empty-snap+comp.comp", discard)
+	err = snap.ValidateComponentContainer(s.container(), "empty-snap+comp.comp", discard)
 	c.Check(err, Equals, snap.ErrBadModes)
 }
 
@@ -112,21 +128,21 @@ func (s *validateSuite) TestValidateContainerMissingSnapYamlFails(c *C) {
 	const yaml = `name: empty-snap
 version: 1
 `
-	d := c.MkDir()
-	c.Assert(os.Chmod(d, 0755), IsNil)
-	c.Assert(os.Mkdir(filepath.Join(d, "meta"), 0755), IsNil)
+	container := s.container()
+	c.Assert(os.Chmod(s.snapDirPath, 0755), IsNil)
+	c.Assert(os.Mkdir(filepath.Join(s.snapDirPath, "meta"), 0755), IsNil)
 
 	// snapdir's / and /meta are 0755 (i.e. OK), but no /meta/snap.yaml
 
 	info, err := snap.InfoFromSnapYaml([]byte(yaml))
 	c.Assert(err, IsNil)
 
-	err = snap.ValidateSnapContainer(snapdir.New(d), info, discard)
+	err = snap.ValidateSnapContainer(container, info, discard)
 	c.Check(err, Equals, snap.ErrMissingPaths)
 
 	// component's / and /meta are 0755 (i.e. OK), but no /meta/component.yaml
 
-	err = snap.ValidateComponentContainer(snapdir.New(d), "empty-snap+comp.comp", discard)
+	err = snap.ValidateComponentContainer(container, "empty-snap+comp.comp", discard)
 	c.Check(err, Equals, snap.ErrMissingPaths)
 }
 
@@ -134,10 +150,9 @@ func (s *validateSuite) TestValidateContainerSnapYamlBadPermsFails(c *C) {
 	const yaml = `name: empty-snap
 version: 1
 `
-	d := c.MkDir()
-	c.Assert(os.Chmod(d, 0755), IsNil)
-	c.Assert(os.Mkdir(filepath.Join(d, "meta"), 0755), IsNil)
-	c.Assert(os.WriteFile(filepath.Join(d, "meta", "snap.yaml"), nil, 0), IsNil)
+	c.Assert(os.Chmod(s.snapDirPath, 0755), IsNil)
+	c.Assert(os.Mkdir(filepath.Join(s.snapDirPath, "meta"), 0755), IsNil)
+	c.Assert(os.WriteFile(filepath.Join(s.snapDirPath, "meta", "snap.yaml"), nil, 0), IsNil)
 
 	// snapdir's / and /meta are 0755 (i.e. OK),
 	// /meta/snap.yaml exists, but isn't readable
@@ -145,20 +160,19 @@ version: 1
 	info, err := snap.InfoFromSnapYaml([]byte(yaml))
 	c.Assert(err, IsNil)
 
-	err = snap.ValidateSnapContainer(snapdir.New(d), info, discard)
+	err = snap.ValidateSnapContainer(s.container(), info, discard)
 	c.Check(err, Equals, snap.ErrBadModes)
 }
 
 func (s *validateSuite) TestValidateComponentContainerSnapYamlBadPermsFails(c *C) {
-	d := c.MkDir()
-	c.Assert(os.Chmod(d, 0755), IsNil)
-	c.Assert(os.Mkdir(filepath.Join(d, "meta"), 0755), IsNil)
-	c.Assert(os.WriteFile(filepath.Join(d, "meta", "component.yaml"), nil, 0), IsNil)
+	c.Assert(os.Chmod(s.snapDirPath, 0755), IsNil)
+	c.Assert(os.Mkdir(filepath.Join(s.snapDirPath, "meta"), 0755), IsNil)
+	c.Assert(os.WriteFile(filepath.Join(s.snapDirPath, "meta", "component.yaml"), nil, 0), IsNil)
 
 	// components's / and /meta are 0755 (i.e. OK),
 	// /meta/component.yaml exists, but isn't readable
 
-	err := snap.ValidateComponentContainer(snapdir.New(d), "empty-snap+comp.comp", discard)
+	err := snap.ValidateComponentContainer(s.container(), "empty-snap+comp.comp", discard)
 	c.Check(err, Equals, snap.ErrBadModes)
 }
 
@@ -166,10 +180,9 @@ func (s *validateSuite) TestValidateContainerSnapYamlNonRegularFails(c *C) {
 	const yaml = `name: empty-snap
 version: 1
 `
-	d := c.MkDir()
-	c.Assert(os.Chmod(d, 0755), IsNil)
-	c.Assert(os.Mkdir(filepath.Join(d, "meta"), 0755), IsNil)
-	c.Assert(syscall.Mkfifo(filepath.Join(d, "meta", "snap.yaml"), 0444), IsNil)
+	c.Assert(os.Chmod(s.snapDirPath, 0755), IsNil)
+	c.Assert(os.Mkdir(filepath.Join(s.snapDirPath, "meta"), 0755), IsNil)
+	c.Assert(syscall.Mkfifo(filepath.Join(s.snapDirPath, "meta", "snap.yaml"), 0444), IsNil)
 
 	// snapdir's / and /meta are 0755 (i.e. OK),
 	// /meta/snap.yaml exists, is readable, but isn't a file
@@ -177,26 +190,24 @@ version: 1
 	info, err := snap.InfoFromSnapYaml([]byte(yaml))
 	c.Assert(err, IsNil)
 
-	err = snap.ValidateSnapContainer(snapdir.New(d), info, discard)
+	err = snap.ValidateSnapContainer(s.container(), info, discard)
 	c.Check(err, Equals, snap.ErrBadModes)
 }
 
-// emptyContainer returns a minimal container that passes
-// ValidateContainer: / and /meta exist and are 0755, and
-// /meta/snap.yaml is a regular world-readable file.
-func emptyContainer(c *C) *snapdir.SnapDir {
-	d := c.MkDir()
-	c.Assert(os.Chmod(d, 0755), IsNil)
-	c.Assert(os.Mkdir(filepath.Join(d, "meta"), 0755), IsNil)
-	c.Assert(os.WriteFile(filepath.Join(d, "meta", "snap.yaml"), nil, 0444), IsNil)
-	return snapdir.New(d)
+// bootstrapEmptyContainer creates a minimal container directory under
+// s.snapDirPath that passes ValidateContainer: / and /meta exist and
+// are 0755, and /meta/snap.yaml is a regular world-readable file.
+func (s *validateSuite) bootstrapEmptyContainer(c *C) {
+	c.Assert(os.Chmod(s.snapDirPath, 0755), IsNil)
+	c.Assert(os.Mkdir(filepath.Join(s.snapDirPath, "meta"), 0755), IsNil)
+	c.Assert(os.WriteFile(filepath.Join(s.snapDirPath, "meta", "snap.yaml"), nil, 0444), IsNil)
 }
 
 func (s *validateSuite) TestValidateContainerMinimalOKPermWorks(c *C) {
 	const yaml = `name: empty-snap
 version: 1
 `
-	d := emptyContainer(c)
+	s.bootstrapEmptyContainer(c)
 	// snapdir's / and /meta are 0755 (i.e. OK),
 	// /meta/snap.yaml exists, is readable regular file
 	// (this could be considered a test of emptyContainer)
@@ -204,7 +215,7 @@ version: 1
 	info, err := snap.InfoFromSnapYaml([]byte(yaml))
 	c.Assert(err, IsNil)
 
-	err = snap.ValidateSnapContainer(d, info, discard)
+	err = snap.ValidateSnapContainer(s.container(), info, discard)
 	c.Check(err, IsNil)
 }
 
@@ -215,13 +226,13 @@ apps:
  foo:
   command: foo
 `
-	d := emptyContainer(c)
+	s.bootstrapEmptyContainer(c)
 	// snapdir is empty: no apps
 
 	info, err := snap.InfoFromSnapYaml([]byte(yaml))
 	c.Assert(err, IsNil)
 
-	err = snap.ValidateSnapContainer(d, info, discard)
+	err = snap.ValidateSnapContainer(s.container(), info, discard)
 	c.Check(err, Equals, snap.ErrMissingPaths)
 }
 
@@ -232,15 +243,15 @@ apps:
  foo:
   command: foo
 `
-	d := emptyContainer(c)
-	c.Assert(os.WriteFile(filepath.Join(d.Path(), "foo"), nil, 0444), IsNil)
+	s.bootstrapEmptyContainer(c)
+	c.Assert(os.WriteFile(filepath.Join(s.snapDirPath, "foo"), nil, 0444), IsNil)
 
 	// snapdir contains the app, but the app is not executable
 
 	info, err := snap.InfoFromSnapYaml([]byte(yaml))
 	c.Assert(err, IsNil)
 
-	err = snap.ValidateSnapContainer(d, info, discard)
+	err = snap.ValidateSnapContainer(s.container(), info, discard)
 	c.Check(err, Equals, snap.ErrBadModes)
 }
 
@@ -251,16 +262,16 @@ apps:
  foo:
   command: apps/foo
 `
-	d := emptyContainer(c)
-	c.Assert(os.Mkdir(filepath.Join(d.Path(), "apps"), 0700), IsNil)
-	c.Assert(os.WriteFile(filepath.Join(d.Path(), "apps", "foo"), nil, 0555), IsNil)
+	s.bootstrapEmptyContainer(c)
+	c.Assert(os.Mkdir(filepath.Join(s.snapDirPath, "apps"), 0700), IsNil)
+	c.Assert(os.WriteFile(filepath.Join(s.snapDirPath, "apps", "foo"), nil, 0555), IsNil)
 
 	// snapdir contains executable app, but path to executable isn't rx
 
 	info, err := snap.InfoFromSnapYaml([]byte(yaml))
 	c.Assert(err, IsNil)
 
-	err = snap.ValidateSnapContainer(d, info, discard)
+	err = snap.ValidateSnapContainer(s.container(), info, discard)
 	c.Check(err, Equals, snap.ErrBadModes)
 }
 
@@ -272,16 +283,16 @@ apps:
   command: svcs/bar
   daemon: simple
 `
-	d := emptyContainer(c)
-	c.Assert(os.Mkdir(filepath.Join(d.Path(), "svcs"), 0755), IsNil)
-	c.Assert(os.WriteFile(filepath.Join(d.Path(), "svcs", "bar"), nil, 0), IsNil)
+	s.bootstrapEmptyContainer(c)
+	c.Assert(os.Mkdir(filepath.Join(s.snapDirPath, "svcs"), 0755), IsNil)
+	c.Assert(os.WriteFile(filepath.Join(s.snapDirPath, "svcs", "bar"), nil, 0), IsNil)
 
 	// snapdir contains service, but it isn't executable
 
 	info, err := snap.InfoFromSnapYaml([]byte(yaml))
 	c.Assert(err, IsNil)
 
-	err = snap.ValidateSnapContainer(d, info, discard)
+	err = snap.ValidateSnapContainer(s.container(), info, discard)
 	c.Check(err, Equals, snap.ErrBadModes)
 }
 
@@ -293,10 +304,10 @@ apps:
   command: cmds/foo
   completer: comp/foo.sh
 `
-	d := emptyContainer(c)
-	c.Assert(os.Mkdir(filepath.Join(d.Path(), "cmds"), 0755), IsNil)
-	c.Assert(os.WriteFile(filepath.Join(d.Path(), "cmds", "foo"), nil, 0555), IsNil)
-	c.Assert(os.Mkdir(filepath.Join(d.Path(), "comp"), 0755), IsNil)
+	s.bootstrapEmptyContainer(c)
+	c.Assert(os.Mkdir(filepath.Join(s.snapDirPath, "cmds"), 0755), IsNil)
+	c.Assert(os.WriteFile(filepath.Join(s.snapDirPath, "cmds", "foo"), nil, 0555), IsNil)
+	c.Assert(os.Mkdir(filepath.Join(s.snapDirPath, "comp"), 0755), IsNil)
 
 	// snapdir contains executable app, in a rx path, but refers
 	// to a completer that doesn't exist
@@ -304,7 +315,7 @@ apps:
 	info, err := snap.InfoFromSnapYaml([]byte(yaml))
 	c.Assert(err, IsNil)
 
-	err = snap.ValidateSnapContainer(d, info, discard)
+	err = snap.ValidateSnapContainer(s.container(), info, discard)
 	c.Check(err, Equals, snap.ErrMissingPaths)
 }
 
@@ -316,7 +327,7 @@ apps:
  foo:
   command: ../../../bin/echo
 `
-	d := emptyContainer(c)
+	s.bootstrapEmptyContainer(c)
 
 	// snapdir does not contain the app, but the command is
 	// "outside" so it might be OK
@@ -324,7 +335,7 @@ apps:
 	info, err := snap.InfoFromSnapYaml([]byte(yaml))
 	c.Assert(err, IsNil)
 
-	err = snap.ValidateSnapContainer(d, info, discard)
+	err = snap.ValidateSnapContainer(s.container(), info, discard)
 	c.Check(err, IsNil)
 }
 
@@ -336,8 +347,8 @@ apps:
  foo:
   command: foo
 `
-	d := emptyContainer(c)
-	fn := filepath.Join(d.Path(), "foo")
+	s.bootstrapEmptyContainer(c)
+	fn := filepath.Join(s.snapDirPath, "foo")
 	c.Assert(os.WriteFile(fn+".real", nil, 0444), IsNil)
 	c.Assert(os.Symlink(fn+".real", fn), IsNil)
 
@@ -346,7 +357,7 @@ apps:
 	info, err := snap.InfoFromSnapYaml([]byte(yaml))
 	c.Assert(err, IsNil)
 
-	err = snap.ValidateSnapContainer(d, info, discard)
+	err = snap.ValidateSnapContainer(s.container(), info, discard)
 	c.Check(err, Equals, snap.ErrBadModes)
 }
 
@@ -357,8 +368,8 @@ apps:
  foo:
   command: foo
 `
-	d := emptyContainer(c)
-	fn := filepath.Join(d.Path(), "foo")
+	s.bootstrapEmptyContainer(c)
+	fn := filepath.Join(s.snapDirPath, "foo")
 	c.Assert(os.WriteFile(fn+".real", nil, 0555), IsNil)
 	c.Assert(os.Symlink(fn+".real", fn), IsNil)
 
@@ -367,10 +378,149 @@ apps:
 	info, err := snap.InfoFromSnapYaml([]byte(yaml))
 	c.Assert(err, IsNil)
 
-	err = snap.ValidateSnapContainer(d, info, discard)
+	err = snap.ValidateSnapContainer(s.container(), info, discard)
+	c.Check(err, IsNil)
+}
+
+func (s *validateSuite) TestValidateContainerSymlinksMetaBadTargetMode(c *C) {
+	const yaml = `name: empty-snap
+version: 1
+`
+	s.bootstrapEmptyContainer(c)
+	c.Assert(os.MkdirAll(filepath.Join(s.snapDirPath, "meta"), 0755), IsNil)
+	externalSymlink := filepath.Join(s.snapDirPath, "meta", "symlink")
+	// target is has bad mode
+	const mode = os.FileMode(0711)
+	c.Assert(os.WriteFile(filepath.Join(s.snapDirPath, "target"), nil, mode), IsNil)
+	c.Assert(os.Symlink("../target", externalSymlink), IsNil)
+
+	container := s.container()
+
+	symlinkInfo, err := snap.EvalAndValidateSymlink(container, "meta/symlink")
+	c.Check(err, IsNil)
+	c.Check(symlinkInfo.Mode(), Equals, mode)
+
+	info, err := snap.InfoFromSnapYaml([]byte(yaml))
+	c.Assert(err, IsNil)
+
+	err = snap.ValidateSnapContainer(container, info, discard)
+	c.Check(err, ErrorMatches, "snap is unusable due to bad permissions")
+}
+
+func (s *validateSuite) TestValidateContainerSymlinksMetaBadTargetMode0000(c *C) {
+	const yaml = `name: empty-snap
+version: 1
+`
+	s.bootstrapEmptyContainer(c)
+	c.Assert(os.MkdirAll(filepath.Join(s.snapDirPath, "meta"), 0755), IsNil)
+	externalSymlink := filepath.Join(s.snapDirPath, "meta", "symlink")
+	// target is has bad mode
+	const mode = os.FileMode(0000)
+	c.Assert(os.WriteFile(filepath.Join(s.snapDirPath, "target"), nil, mode), IsNil)
+	c.Assert(os.Symlink("../target", externalSymlink), IsNil)
+
+	container := s.container()
+
+	symlinkInfo, err := snap.EvalAndValidateSymlink(container, "meta/symlink")
+	c.Check(err, IsNil)
+	c.Check(symlinkInfo.Mode(), Equals, mode)
+
+	info, err := snap.InfoFromSnapYaml([]byte(yaml))
+	c.Assert(err, IsNil)
+
+	err = snap.ValidateSnapContainer(container, info, discard)
+	c.Check(err, ErrorMatches, "snap is unusable due to bad permissions")
+}
+
+func (s *validateSuite) TestValidateContainerMetaExternalAbsSymlinksFails(c *C) {
+	const yaml = `name: empty-snap
+version: 1
+`
+	s.bootstrapEmptyContainer(c)
+	c.Assert(os.MkdirAll(filepath.Join(s.snapDirPath, "meta", "gui", "icons"), 0755), IsNil)
+	externalSymlink := filepath.Join(s.snapDirPath, "meta", "gui", "icons", "snap.empty-snap.png")
+	c.Assert(os.Symlink("/etc/shadow", externalSymlink), IsNil)
+
+	info, err := snap.InfoFromSnapYaml([]byte(yaml))
+	c.Assert(err, IsNil)
+
+	mockLogf := func(format string, v ...interface{}) {
+		msg := fmt.Sprintf(format, v...)
+		c.Check(msg, Equals, "external symlink found: meta/gui/icons/snap.empty-snap.png -> /etc/shadow")
+	}
+
+	err = snap.ValidateSnapContainer(s.container(), info, mockLogf)
+	c.Check(err, Equals, snap.ErrBadModes)
+}
+
+func (s *validateSuite) TestValidateContainerMetaExternalRelativeSymlinksFails(c *C) {
+	const yaml = `name: empty-snap
+version: 1
+`
+	s.bootstrapEmptyContainer(c)
+	c.Assert(os.MkdirAll(filepath.Join(s.snapDirPath, "meta", "gui", "icons"), 0755), IsNil)
+	externalSymlink := filepath.Join(s.snapDirPath, "meta", "gui", "icons", "snap.empty-snap.png")
+	// target is cleaned and checked if it escapes beyond path root folder
+	c.Assert(os.Symlink("1/../../2/../../3/4/../../../../..", externalSymlink), IsNil)
+
+	info, err := snap.InfoFromSnapYaml([]byte(yaml))
+	c.Assert(err, IsNil)
+
+	mockLogf := func(format string, v ...interface{}) {
+		msg := fmt.Sprintf(format, v...)
+		c.Check(msg, Equals, "external symlink found: meta/gui/icons/snap.empty-snap.png -> 1/../../2/../../3/4/../../../../..")
+	}
+
+	err = snap.ValidateSnapContainer(s.container(), info, mockLogf)
+	c.Check(err, Equals, snap.ErrBadModes)
+}
+
+func (s *validateSuite) TestValidateContainerMetaExternalRelativeSymlinksOk(c *C) {
+	const yaml = `name: empty-snap
+version: 1
+`
+	s.bootstrapEmptyContainer(c)
+	c.Assert(os.MkdirAll(filepath.Join(s.snapDirPath, "meta", "gui", "icons"), 0755), IsNil)
+	c.Assert(os.WriteFile(filepath.Join(s.snapDirPath, "target"), nil, 0644), IsNil)
+	externalSymlink := filepath.Join(s.snapDirPath, "meta", "gui", "icons", "snap.empty-snap.png")
+	// target is cleaned and checked if it escapes beyond path root folder
+	c.Assert(os.Symlink("1/../2/../../3/4/../../../../target", externalSymlink), IsNil)
+
+	info, err := snap.InfoFromSnapYaml([]byte(yaml))
+	c.Assert(err, IsNil)
+
+	err = snap.ValidateSnapContainer(s.container(), info, discard)
 	c.Check(err, IsNil)
 }
 
+func (s *validateSuite) TestValidateContainerMetaDirectorySymlinksFail(c *C) {
+	const yaml = `name: empty-snap
+version: 1
+`
+	c.Assert(os.Chmod(s.snapDirPath, 0755), IsNil)
+	// no need to populate the symlink target with snap.yaml as the validator
+	// will fail with ErrMissingPaths even it was added.
+	c.Assert(os.Mkdir(filepath.Join(s.snapDirPath, "target"), 0755), IsNil)
+	c.Assert(os.Symlink("target", filepath.Join(s.snapDirPath, "meta")), IsNil)
+
+	info, err := snap.InfoFromSnapYaml([]byte(yaml))
+	c.Assert(err, IsNil)
+
+	metaDirSymlinkErrFound := false
+	mockLogf := func(format string, v ...interface{}) {
+		msg := fmt.Sprintf(format, v...)
+		if msg == "meta directory cannot be a symlink" {
+			metaDirSymlinkErrFound = true
+		}
+	}
+
+	err = snap.ValidateSnapContainer(s.container(), info, mockLogf)
+	c.Check(metaDirSymlinkErrFound, Equals, true)
+	// the check for missing files precedes check for permission errors, so we
+	// check for it instead.
+	c.Check(err, Equals, snap.ErrMissingPaths)
+}
+
 func (s *validateSuite) TestValidateContainerAppsOK(c *C) {
 	const yaml = `name: empty-snap
 version: 1
@@ -390,18 +540,21 @@ apps:
   command: comp/foo.sh
   daemon: simple
 `
-	d := emptyContainer(c)
-	c.Assert(os.Mkdir(filepath.Join(d.Path(), "cmds"), 0755), IsNil)
-	c.Assert(os.WriteFile(filepath.Join(d.Path(), "cmds", "foo"), nil, 0555), IsNil)
-	c.Assert(os.Mkdir(filepath.Join(d.Path(), "comp"), 0755), IsNil)
-	c.Assert(os.WriteFile(filepath.Join(d.Path(), "comp", "foo.sh"), nil, 0555), IsNil)
-
-	c.Assert(os.Mkdir(filepath.Join(d.Path(), "svcs"), 0700), IsNil)
-	c.Assert(os.WriteFile(filepath.Join(d.Path(), "svcs", "bar"), nil, 0500), IsNil)
-
-	c.Assert(os.Mkdir(filepath.Join(d.Path(), "garbage"), 0755), IsNil)
-	c.Assert(os.Mkdir(filepath.Join(d.Path(), "garbage", "zero"), 0), IsNil)
-	defer os.Chmod(filepath.Join(d.Path(), "garbage", "zero"), 0755)
+	if s.containerType == "squashfs" {
+		c.Skip("Cannot build snap squashfs with garbge/zero directory permissions")
+	}
+	s.bootstrapEmptyContainer(c)
+	c.Assert(os.Mkdir(filepath.Join(s.snapDirPath, "cmds"), 0755), IsNil)
+	c.Assert(os.WriteFile(filepath.Join(s.snapDirPath, "cmds", "foo"), nil, 0555), IsNil)
+	c.Assert(os.Mkdir(filepath.Join(s.snapDirPath, "comp"), 0755), IsNil)
+	c.Assert(os.WriteFile(filepath.Join(s.snapDirPath, "comp", "foo.sh"), nil, 0555), IsNil)
+
+	c.Assert(os.Mkdir(filepath.Join(s.snapDirPath, "svcs"), 0700), IsNil)
+	c.Assert(os.WriteFile(filepath.Join(s.snapDirPath, "svcs", "bar"), nil, 0500), IsNil)
+
+	c.Assert(os.Mkdir(filepath.Join(s.snapDirPath, "garbage"), 0755), IsNil)
+	c.Assert(os.Mkdir(filepath.Join(s.snapDirPath, "garbage", "zero"), 0), IsNil)
+	defer os.Chmod(filepath.Join(s.snapDirPath, "garbage", "zero"), 0755)
 
 	// snapdir contains:
 	//  * a command that's world-rx, and its directory is
@@ -421,19 +574,145 @@ apps:
 	info, err := snap.InfoFromSnapYaml([]byte(yaml))
 	c.Assert(err, IsNil)
 
-	err = snap.ValidateSnapContainer(d, info, discard)
+	err = snap.ValidateSnapContainer(s.container(), info, discard)
 	c.Check(err, IsNil)
 }
 
-func (s *validateSuite) TestValidateComponentContainer(c *C) {
-	const yaml = `component: empty-snap+test-comp
+func (s *validateSuite) TestValidateSymlinkLoop(c *C) {
+	const yaml = `name: empty-snap
+version: 1
+`
+	s.bootstrapEmptyContainer(c)
+	c.Assert(os.Symlink("1", filepath.Join(s.snapDirPath, "meta", "2")), IsNil)
+	c.Assert(os.Symlink("2", filepath.Join(s.snapDirPath, "meta", "3")), IsNil)
+	c.Assert(os.Symlink("3", filepath.Join(s.snapDirPath, "meta", "1")), IsNil)
+
+	info, err := snap.InfoFromSnapYaml([]byte(yaml))
+	c.Assert(err, IsNil)
+
+	loopFound := false
+	mockLogf := func(format string, v ...interface{}) {
+		msg := fmt.Sprintf(format, v...)
+		if msg == "too many levels of symbolic links" {
+			loopFound = true
+		}
+	}
+
+	err = snap.ValidateSnapContainer(s.container(), info, mockLogf)
+	c.Check(err, Equals, snap.ErrBadModes)
+	c.Check(loopFound, Equals, true)
+}
+
+func (s *validateSuite) TestValidateSymlinkOk(c *C) {
+	const yaml = `name: empty-snap
 version: 1
 `
-	d := c.MkDir()
-	c.Assert(os.Chmod(d, 0755), IsNil)
-	c.Assert(os.Mkdir(filepath.Join(d, "meta"), 0755), IsNil)
-	c.Assert(ioutil.WriteFile(filepath.Join(d, "meta", "component.yaml"), []byte(yaml), 0444), IsNil)
+	s.bootstrapEmptyContainer(c)
+	c.Assert(os.MkdirAll(filepath.Join(s.snapDirPath, "media", "sub"), 0755), IsNil)
+	c.Assert(os.WriteFile(filepath.Join(s.snapDirPath, "media", "icon.png"), nil, 0644), IsNil)
+	c.Assert(os.Symlink("../icon.png", filepath.Join(s.snapDirPath, "media", "sub", "symlink-1.png")), IsNil)
+	c.Assert(os.Symlink("symlink-1.png", filepath.Join(s.snapDirPath, "media", "sub", "symlink-2.png")), IsNil)
+	c.Assert(os.Symlink("../media/sub/symlink-2.png", filepath.Join(s.snapDirPath, "meta", "icon.png")), IsNil)
+	// all symlinks outside meta directory are allowed
+	c.Assert(os.MkdirAll(filepath.Join(s.snapDirPath, "bin"), 0755), IsNil)
+	c.Assert(os.Symlink("/usr/bin/python3", filepath.Join(s.snapDirPath, "bin", "python3")), IsNil)
+
+	info, err := snap.InfoFromSnapYaml([]byte(yaml))
+	c.Assert(err, IsNil)
 
-	err := snap.ValidateComponentContainer(snapdir.New(d), "empty-snap+comp.comp", discard)
+	err = snap.ValidateSnapContainer(s.container(), info, discard)
 	c.Check(err, IsNil)
 }
+
+func (s *validateSuite) TestValidateSymlinkExternal(c *C) {
+	type testcase struct {
+		path   string
+		target string
+	}
+
+	s.bootstrapEmptyContainer(c)
+	for _, t := range []testcase{
+		{"meta/snap.yaml", "../.."},
+		{"meta/snap.yaml", "../../"},
+		{"meta/snap.yaml", "../../rev2"},
+		{"meta/snap.yaml", "../../../core/current/meta/snap.yaml"},
+		{"meta/gui/icons/snap.png", "../1/../../2/../../3/4/../../../test"},
+		{"meta/gui/icons/snap.png", "/etc/shadow"},
+		{"meta/gui/icons/snap.png", "/var/snap/other-snap/current/sensitive"},
+	} {
+		c.Assert(os.MkdirAll(filepath.Join(s.snapDirPath, filepath.Dir(t.path)), 0755), IsNil)
+		c.Assert(os.RemoveAll(filepath.Join(s.snapDirPath, t.path)), IsNil)
+		c.Assert(os.Symlink(t.target, filepath.Join(s.snapDirPath, t.path)), IsNil)
+
+		cmt := Commentf(fmt.Sprintf("path: %s, target: %s", t.path, t.target))
+		expectedError := fmt.Sprintf("external symlink found: %s -> %s", t.path, t.target)
+		_, err := snap.EvalAndValidateSymlink(s.container(), t.path)
+		c.Check(err, ErrorMatches, expectedError, cmt)
+	}
+}
+
+func (s *validateSuite) TestValidateSymlinkSnapMount(c *C) {
+	type testcase struct {
+		path   string
+		target string
+	}
+
+	s.bootstrapEmptyContainer(c)
+	for _, t := range []testcase{
+		{"meta/snap.yaml", ".."},
+		{"meta/snap.yaml", "../"},
+		{"meta/gui/icons/snap.png", "../1/../../2/../../3/4/../.."},
+	} {
+		c.Assert(os.MkdirAll(filepath.Join(s.snapDirPath, filepath.Dir(t.path)), 0755), IsNil)
+		c.Assert(os.RemoveAll(filepath.Join(s.snapDirPath, t.path)), IsNil)
+		c.Assert(os.Symlink(t.target, filepath.Join(s.snapDirPath, t.path)), IsNil)
+
+		cmt := Commentf(fmt.Sprintf("path: %s, target: %s", t.path, t.target))
+		expectedError := fmt.Sprintf("bad symlink found: %s -> %s", t.path, t.target)
+		_, err := snap.EvalAndValidateSymlink(s.container(), t.path)
+		c.Check(err, ErrorMatches, expectedError, cmt)
+	}
+}
+
+func (s *validateSuite) TestValidateSymlinkMeta(c *C) {
+	type testcase struct {
+		path   string
+		target string
+	}
+
+	s.bootstrapEmptyContainer(c)
+	for _, t := range []testcase{
+		{"meta/snap.yaml", "."},
+		{"meta/snap.yaml", "../meta"},
+		{"meta/gui/icons/snap.png", "../1/../../2/../../3/4/../../meta"},
+	} {
+		c.Assert(os.MkdirAll(filepath.Join(s.snapDirPath, filepath.Dir(t.path)), 0755), IsNil)
+		c.Assert(os.RemoveAll(filepath.Join(s.snapDirPath, t.path)), IsNil)
+		c.Assert(os.Symlink(t.target, filepath.Join(s.snapDirPath, t.path)), IsNil)
+
+		cmt := Commentf(fmt.Sprintf("path: %s, target: %s", t.path, t.target))
+		expectedError := fmt.Sprintf("bad symlink found: %s -> %s", t.path, t.target)
+		_, err := snap.EvalAndValidateSymlink(s.container(), t.path)
+		c.Check(err, ErrorMatches, expectedError, cmt)
+	}
+}
+
+func (s *validateSuite) TestShouldValidateSymlink(c *C) {
+	type testcase struct {
+		path     string
+		expected bool
+	}
+
+	for _, t := range []testcase{
+		{"meta", true},
+		{"meta/snap.yaml", true},
+		{"meta/gui/icons/snap.png", true},
+		{"meta/gui/snap.desktop", true},
+		{"etc", false},
+		{"etc/test", false},
+		{"other", false},
+	} {
+		cmt := Commentf(fmt.Sprintf("path: %s, expected: %t", t.path, t.expected))
+		c.Check(snap.ShouldValidateSymlink(t.path), Equals, t.expected, cmt)
+	}
+}
diff --git a/snap/export_test.go b/snap/export_test.go
index 60973b2552c..faf83716afb 100644
--- a/snap/export_test.go
+++ b/snap/export_test.go
@@ -19,17 +19,25 @@
 
 package snap
 
+import "os"
+
 var (
 	ValidateSocketName           = validateSocketName
 	ValidateTitle                = validateTitle
 	InfoFromSnapYamlWithSideInfo = infoFromSnapYamlWithSideInfo
 	GetAttribute                 = getAttribute
+	EvalAndValidateSymlink       = evalAndValidateSymlink
+	ShouldValidateSymlink        = shouldValidateSymlink
 )
 
 func (info *Info) ForceRenamePlug(oldName, newName string) {
 	info.forceRenamePlug(oldName, newName)
 }
 
+func (symlinkInfo *symlinkInfo) Mode() os.FileMode {
+	return symlinkInfo.targetMode
+}
+
 func NewScopedTracker() *scopedTracker {
 	return new(scopedTracker)
 }
diff --git a/snap/snapdir/snapdir.go b/snap/snapdir/snapdir.go
index 5e47be73297..ef2cd39c514 100644
--- a/snap/snapdir/snapdir.go
+++ b/snap/snapdir/snapdir.go
@@ -88,9 +88,18 @@ func (s *SnapDir) ReadFile(file string) (content []byte, err error) {
 	return ioutil.ReadFile(filepath.Join(s.path, file))
 }
 
+func (s *SnapDir) ReadLink(file string) (string, error) {
+	return os.Readlink(filepath.Join(s.path, file))
+}
+
+func (s *SnapDir) Lstat(file string) (os.FileInfo, error) {
+	return os.Lstat(filepath.Join(s.path, file))
+}
+
 func littleWalk(dirPath string, dirHandle *os.File, dirstack *[]string, walkFn filepath.WalkFunc) error {
 	const numSt = 100
 
+	// XXX: check if os.ReadDir is more efficient
 	sts, err := dirHandle.Readdir(numSt)
 	if err != nil {
 		return err
diff --git a/snap/snapdir/snapdir_test.go b/snap/snapdir/snapdir_test.go
index 360122be633..505083b4845 100644
--- a/snap/snapdir/snapdir_test.go
+++ b/snap/snapdir/snapdir_test.go
@@ -20,6 +20,7 @@
 package snapdir_test
 
 import (
+	"errors"
 	"fmt"
 	"math/rand"
 	"os"
@@ -70,6 +71,45 @@ func (s *SnapdirTestSuite) TestReadFile(c *C) {
 	c.Assert(content, DeepEquals, needle)
 }
 
+func (s *SnapdirTestSuite) TestReadlink(c *C) {
+	d := c.MkDir()
+	c.Assert(os.Symlink("target", filepath.Join(d, "foo")), IsNil)
+
+	sn := snapdir.New(d)
+	target, err := sn.ReadLink("foo")
+	c.Assert(err, IsNil)
+	c.Assert(target, DeepEquals, "target")
+}
+
+func (s *SnapdirTestSuite) TestLstat(c *C) {
+	d := c.MkDir()
+	c.Assert(os.Symlink("target", filepath.Join(d, "symlink")), IsNil)
+	c.Assert(os.MkdirAll(filepath.Join(d, "meta"), 0755), IsNil)
+	c.Assert(os.WriteFile(filepath.Join(d, "meta/snap.yaml"), nil, 0644), IsNil)
+
+	sn := snapdir.New(d)
+	for _, file := range []string{
+		"symlink",
+		"meta",
+		"meta/snap.yaml",
+	} {
+		expectedInfo, err := os.Lstat(filepath.Join(d, file))
+		c.Assert(err, IsNil)
+		info, err := sn.Lstat(file)
+		c.Assert(err, IsNil)
+
+		c.Check(info.Name(), Equals, expectedInfo.Name())
+		c.Check(info.Mode(), Equals, expectedInfo.Mode())
+		c.Check(info.Size(), Equals, expectedInfo.Size())
+	}
+}
+
+func (s *SnapdirTestSuite) TestLstatErrNotExist(c *C) {
+	sn := snapdir.New(c.MkDir())
+	_, err := sn.Lstat("meta/non-existent")
+	c.Check(errors.Is(err, os.ErrNotExist), Equals, true)
+}
+
 func (s *SnapdirTestSuite) TestRandomAccessFile(c *C) {
 	d := c.MkDir()
 	needle := []byte(`stuff`)
diff --git a/snap/squashfs/squashfs.go b/snap/squashfs/squashfs.go
index 2cebb77cc18..161a177691a 100644
--- a/snap/squashfs/squashfs.go
+++ b/snap/squashfs/squashfs.go
@@ -273,6 +273,41 @@ func (s *Snap) ReadFile(filePath string) (content []byte, err error) {
 	return content, nil
 }
 
+func (s *Snap) ReadLink(filePath string) (string, error) {
+	// XXX: This could be optimized by reading a cached version of
+	// unsquashfs raw output where the symlink's target is available.
+	// Check -> func fromRaw(raw []byte) (*stat, error)
+	var target string
+	err := s.withUnpackedFile(filePath, func(p string) (err error) {
+		target, err = os.Readlink(p)
+		return err
+	})
+	if err != nil {
+		return "", err
+	}
+	return target, nil
+}
+
+func (s *Snap) Lstat(filePath string) (os.FileInfo, error) {
+	var fileInfo os.FileInfo
+
+	err := s.Walk(filePath, func(path string, info os.FileInfo, err error) error {
+		if filePath == path {
+			fileInfo = info
+		}
+		return err
+	})
+	if err != nil {
+		return nil, err
+	}
+
+	if fileInfo == nil {
+		return nil, os.ErrNotExist
+	}
+
+	return fileInfo, nil
+}
+
 // skipper is used to track directories that should be skipped
 //
 // Given sk := make(skipper), if you sk.Add("foo/bar"), then
@@ -353,10 +388,14 @@ func (s *Snap) Walk(relative string, walkFn filepath.WalkFunc) error {
 				return err
 			}
 		} else {
-			path := filepath.Join(relative, st.Path())
+			path := filepath.Join(".", st.Path())
 			if skipper.Has(path) {
 				continue
 			}
+			// skip if path is not under given relative path
+			if relative != "." && !strings.HasPrefix(path, relative) {
+				continue
+			}
 			err = walkFn(path, st, nil)
 			if err != nil {
 				if err == filepath.SkipDir && st.IsDir() {
diff --git a/snap/squashfs/squashfs_test.go b/snap/squashfs/squashfs_test.go
index 0562febf09d..96ff0029696 100644
--- a/snap/squashfs/squashfs_test.go
+++ b/snap/squashfs/squashfs_test.go
@@ -76,6 +76,9 @@ func makeSnapContents(c *C, manifest, data string) string {
 	err = os.MkdirAll(filepath.Join(tmp, "food", "bard", "bazd"), 0755)
 	c.Assert(err, IsNil)
 
+	err = os.Symlink("target", filepath.Join(tmp, "symlink"))
+	c.Assert(err, IsNil)
+
 	// some data
 	err = os.WriteFile(filepath.Join(tmp, "data.bin"), []byte(data), 0644)
 	c.Assert(err, IsNil)
@@ -325,6 +328,56 @@ func (s *SquashfsTestSuite) TestReadFileFail(c *C) {
 	c.Assert(err, ErrorMatches, "cannot run unsquashfs: boom")
 }
 
+func (s *SquashfsTestSuite) TestReadlink(c *C) {
+	sn := makeSnap(c, "name: foo", "")
+
+	target, err := sn.ReadLink("symlink")
+	c.Assert(err, IsNil)
+	c.Assert(target, Equals, "target")
+}
+
+func (s *SquashfsTestSuite) TestReadlinkFail(c *C) {
+	sn := makeSnap(c, "name: foo", "")
+
+	target, err := sn.ReadLink("meta/snap.yaml")
+	c.Assert(err, ErrorMatches, "readlink .*/meta/snap.yaml: invalid argument")
+	c.Assert(target, Equals, "")
+}
+
+func (s *SquashfsTestSuite) TestLstat(c *C) {
+	sn := makeSnap(c, "name: foo", "")
+
+	base := c.MkDir()
+	c.Assert(sn.Unpack("*", base), IsNil)
+
+	for _, file := range []string{
+		"symlink",
+		"meta",
+		"meta/snap.yaml",
+		"meta/hooks/dir",
+	} {
+		expectedInfo, err := os.Lstat(filepath.Join(base, file))
+		c.Assert(err, IsNil)
+		info, err := sn.Lstat(file)
+		c.Assert(err, IsNil)
+
+		c.Check(info.Name(), Equals, expectedInfo.Name())
+		c.Check(info.Mode(), Equals, expectedInfo.Mode())
+		// sometimes 4096 bytes is the smallest allocation unit for some
+		// filesystems. let's just skip size check for directories.
+		if !expectedInfo.IsDir() {
+			c.Check(info.Size(), Equals, expectedInfo.Size())
+		}
+	}
+}
+
+func (s *SquashfsTestSuite) TestLstatErrNotExist(c *C) {
+	sn := makeSnap(c, "name: foo", "")
+
+	_, err := sn.Lstat("meta/non-existent")
+	c.Check(errors.Is(err, os.ErrNotExist), Equals, true)
+}
+
 func (s *SquashfsTestSuite) TestRandomAccessFile(c *C) {
 	sn := makeSnap(c, "name: foo", "")
 
@@ -415,6 +468,42 @@ func (s *SquashfsTestSuite) TestWalkNative(c *C) {
 
 }
 
+func (s *SquashfsTestSuite) TestWalkRelativeSingleFile(c *C) {
+	sn := makeSnap(c, "name: foo", "")
+
+	cnt := 0
+	found := false
+	err := sn.Walk("meta/snap.yaml", func(path string, info os.FileInfo, err error) error {
+		if path == "meta/snap.yaml" {
+			found = true
+		}
+		cnt++
+		return nil
+	})
+	c.Assert(err, IsNil)
+
+	c.Check(found, Equals, true)
+	c.Check(cnt, Equals, 1)
+}
+
+func (s *SquashfsTestSuite) TestWalkRelativeDirectory(c *C) {
+	sn := makeSnap(c, "name: foo", "")
+
+	cnt := 0
+	found := map[string]bool{}
+	err := sn.Walk("food", func(path string, info os.FileInfo, err error) error {
+		found[path] = true
+		cnt++
+		return nil
+	})
+	c.Assert(err, IsNil)
+
+	c.Check(found["food"], Equals, true)
+	c.Check(found["food/bard"], Equals, true)
+	c.Check(found["food/bard/bazd"], Equals, true)
+	c.Check(cnt, Equals, 3)
+}
+
 func (s *SquashfsTestSuite) testWalkMockedUnsquashfs(c *C) {
 	expectingNames := []string{
 		".",
diff --git a/tests/main/bad-meta-file-types/task.yaml b/tests/main/bad-meta-file-types/task.yaml
new file mode 100644
index 00000000000..ba65d871efa
--- /dev/null
+++ b/tests/main/bad-meta-file-types/task.yaml
@@ -0,0 +1,72 @@
+summary: Check that bad file types under meta directory are detected
+
+details: |
+  Check that a malicious snap that has non-regular (e.g. pipe/symlink)
+  files disguised under meta directory are detected and cause "snap pack"
+  and "snap install" to fail.
+
+execute: |
+    # pipe desktop files
+    mkdir -p test-bad-file-types/meta/gui/
+    mkfifo test-bad-file-types/meta/gui/test-bad-file-types.desktop
+    # snap pack should fail
+    echo "Packing snap with pipe disguised as a desktop file should fail"
+    not snap pack test-bad-file-types > pack.out 2>&1
+    MATCH "\"meta/gui/test-bad-file-types.desktop\" should be a regular file \(or a symlink\) and isn't" < pack.out
+    # snap install should also fail
+    echo "Installing snap with pipe disguised as a desktop file should fail"
+    mksquashfs test-bad-file-types test-bad-file-types.snap
+    not snap install --dangerous test-bad-file-types.snap
+    journalctl -u snapd | MATCH "\"meta/gui/test-bad-file-types.desktop\" should be a regular file \(or a symlink\) and isn't"
+    # clean up
+    rm test-bad-file-types.snap
+    rm test-bad-file-types/meta/gui/test-bad-file-types.desktop
+
+    # symlink desktop files
+    ln -s /etc/shadow test-bad-file-types/meta/gui/test-bad-file-types.desktop
+    # snap pack should fail
+    echo "Packing snap with symlink disguised as a desktop file should fail"
+    not snap pack test-bad-file-types > pack.out 2>&1
+    MATCH "external symlink found: meta/gui/test-bad-file-types.desktop -> /etc/shadow" < pack.out
+    # snap install should also fail
+    echo "Installing snap with symlink disguised as a desktop file should fail"
+    mksquashfs test-bad-file-types test-bad-file-types.snap
+    not snap install --dangerous test-bad-file-types.snap
+    journalctl -u snapd | MATCH "external symlink found: meta/gui/test-bad-file-types.desktop -> /etc/shadow"
+    # clean up
+    rm test-bad-file-types.snap
+    rm test-bad-file-types/meta/gui/test-bad-file-types.desktop
+
+    # pipe icon files
+    mkdir -p test-bad-file-types/meta/gui/icons
+    mkfifo test-bad-file-types/meta/gui/icons/snap.test-bad-file-types.png
+    # snap pack should fail
+    echo "Packing snap with pipe disguised as an icon file should fail"
+    not snap pack test-bad-file-types > pack.out 2>&1
+    MATCH "\"meta/gui/icons/snap.test-bad-file-types.png\" should be a regular file \(or a symlink\) and isn't" < pack.out
+    # snap install should also fail
+    echo "Installing snap with pipe disguised as an icon file should fail"
+    mksquashfs test-bad-file-types test-bad-file-types.snap
+    not snap install --dangerous test-bad-file-types.snap
+    journalctl -u snapd | MATCH "\"meta/gui/icons/snap.test-bad-file-types.png\" should be a regular file \(or a symlink\) and isn't"
+    # clean up
+    rm test-bad-file-types.snap
+    rm test-bad-file-types/meta/gui/icons/snap.test-bad-file-types.png
+
+    # symlink icon files
+    mkdir -p test-bad-file-types/meta/gui/icons
+    ln -s /etc/shadow test-bad-file-types/meta/gui/icons/snap.test-bad-file-types.png
+    # snap pack should fail
+    echo "Packing snap with symlink disguised as an icon file should fail"
+    not snap pack test-bad-file-types > pack.out 2>&1
+    MATCH "external symlink found: meta/gui/icons/snap.test-bad-file-types.png -> /etc/shadow" < pack.out
+    # snap install should also fail
+    echo "Installing snap with symlink disguised as an icon file should fail"
+    mksquashfs test-bad-file-types test-bad-file-types.snap
+    not snap install --dangerous test-bad-file-types.snap
+    journalctl -u snapd | MATCH "external symlink found: meta/gui/icons/snap.test-bad-file-types.png -> /etc/shadow"
+    # clean up
+    rm test-bad-file-types.snap
+    rm test-bad-file-types/meta/gui/icons/snap.test-bad-file-types.png
+
+    # TODO: Test other files that can be placed under meta directory like polkit policies and udev files
diff --git a/tests/main/bad-meta-file-types/test-bad-file-types/meta/snap.yaml b/tests/main/bad-meta-file-types/test-bad-file-types/meta/snap.yaml
new file mode 100644
index 00000000000..2fbba3207a6
--- /dev/null
+++ b/tests/main/bad-meta-file-types/test-bad-file-types/meta/snap.yaml
@@ -0,0 +1,4 @@
+name: test-bad-file-types
+base: none
+version: 1.0
+summary: A bad test snap that has non-regular files disguised under meta directory
