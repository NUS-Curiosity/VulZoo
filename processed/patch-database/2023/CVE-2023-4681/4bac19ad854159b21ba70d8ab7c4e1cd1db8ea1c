diff --git a/src/filters/dasher.c b/src/filters/dasher.c
index 2619d2291c..bc768804fd 100644
--- a/src/filters/dasher.c
+++ b/src/filters/dasher.c
@@ -8387,6 +8387,9 @@ static GF_Err dasher_process(GF_Filter *filter)
 		u32 num_ready=0, num_blocked=0;
 		for (i=0; i<count; i++) {
 			GF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);
+			if (ctx->force_period_switch) {
+				break;
+			}
 			GF_FilterPacket *pck = gf_filter_pid_get_packet(ds->ipid);
 			if (!pck) continue;
 			u64 ts = gf_filter_pck_get_cts(pck);
@@ -8406,6 +8409,9 @@ static GF_Err dasher_process(GF_Filter *filter)
 		}
 		ctx->min_cts_period.num = min_ts;
 		ctx->min_cts_period.den = min_timescale;
+
+		if (ctx->force_period_switch)
+			count = gf_list_count(ctx->current_period->streams);
 	}
 
 	nb_init = has_init = nb_reg_done = 0;
diff --git a/src/media_tools/avilib.c b/src/media_tools/avilib.c
index 27cd81133d..be93bc3a78 100644
--- a/src/media_tools/avilib.c
+++ b/src/media_tools/avilib.c
@@ -1948,8 +1948,11 @@ int avi_parse_input_file(avi_t *AVI, int getIndex)
 
 				header_offset = gf_ftell(AVI->fdes);
 
-				if( avi_read(AVI->fdes,(char *)hdrl_data, (u32) n) != n ) ERR_EXIT(AVI_ERR_READ)
+				if( avi_read(AVI->fdes,(char *)hdrl_data, (u32) n) != n ) {
+					if (hdrl_data) gf_free(hdrl_data);
+					ERR_EXIT(AVI_ERR_READ)
 				}
+			}
 			else if(strnicmp(data,"movi",4) == 0)
 			{
 				AVI->movi_start = gf_ftell(AVI->fdes);
@@ -1964,19 +1967,24 @@ int avi_parse_input_file(avi_t *AVI, int getIndex)
 
 			AVI->n_idx = AVI->max_idx = (u32) (n/16);
 			AVI->idx = (unsigned  char((*)[16]) ) gf_malloc((u32)n);
-			if(AVI->idx==0) ERR_EXIT(AVI_ERR_NO_MEM)
-				if(avi_read(AVI->fdes, (char *) AVI->idx, (u32) n) != n ) {
-					gf_free( AVI->idx);
-					AVI->idx=NULL;
-					AVI->n_idx = 0;
-				}
+			if(AVI->idx==0) {
+				if (hdrl_data) gf_free(hdrl_data);
+				ERR_EXIT(AVI_ERR_NO_MEM)
+			}
+			if(avi_read(AVI->fdes, (char *) AVI->idx, (u32) n) != n ) {
+				gf_free( AVI->idx);
+				AVI->idx=NULL;
+				AVI->n_idx = 0;
+				if (hdrl_data) gf_free(hdrl_data);
+				ERR_EXIT(AVI_ERR_READ)
+			}
 		}
 		else
 			gf_fseek(AVI->fdes,n,SEEK_CUR);
 	}
 
-	if(!hdrl_data      ) ERR_EXIT(AVI_ERR_NO_HDRL)
-		if(!AVI->movi_start) ERR_EXIT(AVI_ERR_NO_MOVI)
+	if(!hdrl_data) ERR_EXIT(AVI_ERR_NO_HDRL)
+	if(!AVI->movi_start) ERR_EXIT(AVI_ERR_NO_MOVI)
 
 			/* Interpret the header list */
 
diff --git a/src/media_tools/mpeg2_ps.c b/src/media_tools/mpeg2_ps.c
index 8e33e48d40..0af7a31f32 100644
--- a/src/media_tools/mpeg2_ps.c
+++ b/src/media_tools/mpeg2_ps.c
@@ -996,6 +996,7 @@ static void get_info_from_frame (mpeg2ps_stream_t *sptr,
 		                       &sptr->par) < 0) {
 			sptr->m_stream_id = 0;
 			sptr->m_fd = FDNULL;
+			return;
 		}
 		sptr->ticks_per_frame = (u64)(90000.0 / sptr->frame_rate);
 		return;
@@ -1202,7 +1203,7 @@ static void get_info_for_all_streams (mpeg2ps_t *ps)
 			}
 			get_info_from_frame(sptr, buffer, buflen);
 			// here - if (sptr->first_pes_has_dts == 0) should be processed
-			if (sptr->first_pes_has_dts == 0) {
+			if ((sptr->first_pes_has_dts == 0) && sptr->m_fd) {
 				u32 frames_from_beg = 0;
 				Bool have_frame;
 				do {
