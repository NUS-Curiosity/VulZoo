diff --git a/contracts/ethregistrar/ETHRegistrarAdmin.sol b/contracts/ethregistrar/ETHRegistrarAdmin.sol
new file mode 100644
index 00000000..993bea87
--- /dev/null
+++ b/contracts/ethregistrar/ETHRegistrarAdmin.sol
@@ -0,0 +1,125 @@
+//SPDX-License-Identifier: MIT
+pragma solidity ^0.8.17;
+
+import "./IBaseRegistrar.sol";
+import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
+import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";
+import {Address} from "@openzeppelin/contracts/utils/Address.sol";
+
+/**
+ * @dev A proxy contract that wraps new registrar controllers to ensure they don't shorten the duration of registrations by causing an overflow.
+ */
+contract ETHRegistrarControllerProxy {
+    address public immutable controller;
+    IBaseRegistrar public immutable registrar;
+
+    constructor(address _controller, IBaseRegistrar _registrar) {
+        controller = _controller;
+        registrar = _registrar;
+    }
+
+    function register(
+        uint256 id,
+        address owner,
+        uint256 duration
+    ) external returns (uint256) {
+        require(msg.sender == controller);
+        require(duration < 365000000 days);
+        return registrar.register(id, owner, duration);
+    }
+
+    function registerOnly(
+        uint256 id,
+        address owner,
+        uint256 duration
+    ) external returns (uint256) {
+        require(msg.sender == controller);
+        require(duration < 365000000 days);
+        return registrar.registerOnly(id, owner, duration);
+    }
+
+    function renew(uint256 id, uint256 duration) external returns (uint256) {
+        require(msg.sender == controller);
+        require(duration < 365000000 days);
+        return registrar.renew(id, duration);
+    }
+}
+
+/**
+ * @dev Contract to act as the owner of the ETHRegistrar, permitting its owner to make certain changes with additional checks.
+ *      This was implemented in response to a vulnerability disclosure that would permit the DAO to appoint a malicious controller
+ *      that shortens the registration period of affected ENS names. This contract exists to prevent that from happening.
+ */
+contract ETHRegistrarAdmin is Ownable {
+    using Address for address;
+
+    IBaseRegistrar public immutable registrar;
+
+    constructor(address _registrar) {
+        registrar = IBaseRegistrar(_registrar);
+    }
+
+    /**
+     * @dev Deploys a controller proxy for the given controller, if one does not already exist.
+     *      Anyone can call this function, but the proxy will only function if added by an authorized
+     *      caller using `addController`.
+     * @param controller The controller contract to create a proxy for.
+     * @return The address of the controller proxy.
+     */
+    function deployControllerProxy(
+        address controller
+    ) public returns (address) {
+        address proxyAddress = getProxyAddress(controller);
+        if (!proxyAddress.isContract()) {
+            new ETHRegistrarControllerProxy{salt: bytes32(0)}(
+                controller,
+                registrar
+            );
+        }
+        return proxyAddress;
+    }
+
+    /**
+     * @dev Authorizes a controller proxy to register and renew names on the registrar.
+     * @param controller The controller contract to authorize.
+     */
+    function addController(address controller) external onlyOwner {
+        deployControllerProxy(controller);
+        registrar.addController(getProxyAddress(controller));
+    }
+
+    /**
+     * @dev Deauthorizes a controller proxy.
+     * @param controller The controller contract to deauthorize.
+     */
+    function removeController(address controller) external onlyOwner {
+        registrar.removeController(getProxyAddress(controller));
+    }
+
+    /**
+     * @dev Gets the address of the proxy contract for a given controller.
+     * @param controller The controller contract to get the proxy address for.
+     * @return The address of the proxy contract.
+     */
+    function getProxyAddress(address controller) public view returns (address) {
+        return
+            Create2.computeAddress(
+                bytes32(0),
+                keccak256(
+                    abi.encodePacked(
+                        type(ETHRegistrarControllerProxy).creationCode,
+                        uint256(uint160(controller)),
+                        uint256(uint160(address(registrar)))
+                    )
+                )
+            );
+    }
+
+    /**
+     * @dev Sets the resolver for the TLD this registrar manages.
+     * @param resolver The address of the resolver to set.
+     */
+    function setResolver(address resolver) external onlyOwner {
+        registrar.setResolver(resolver);
+    }
+}
diff --git a/contracts/ethregistrar/IBaseRegistrar.sol b/contracts/ethregistrar/IBaseRegistrar.sol
index 5f43e9c1..cc0ccc8e 100644
--- a/contracts/ethregistrar/IBaseRegistrar.sol
+++ b/contracts/ethregistrar/IBaseRegistrar.sol
@@ -41,6 +41,18 @@ interface IBaseRegistrar is IERC721 {
         uint256 duration
     ) external returns (uint256);
 
+    /**
+     * @dev Register a name, without modifying the registry.
+     * @param id The token ID (keccak256 of the label).
+     * @param owner The address that should own the registration.
+     * @param duration Duration in seconds for the registration.
+     */
+    function registerOnly(
+        uint256 id,
+        address owner,
+        uint256 duration
+    ) external returns (uint256);
+
     function renew(uint256 id, uint256 duration) external returns (uint256);
 
     /**
diff --git a/contracts/wrapper/NameWrapperAdmin.sol b/contracts/wrapper/NameWrapperAdmin.sol
new file mode 100644
index 00000000..a508ab56
--- /dev/null
+++ b/contracts/wrapper/NameWrapperAdmin.sol
@@ -0,0 +1,213 @@
+//SPDX-License-Identifier: MIT
+pragma solidity ^0.8.17;
+
+import "./INameWrapper.sol";
+import "./Controllable.sol";
+import {INameWrapperUpgrade} from "./INameWrapperUpgrade.sol";
+import {BytesUtils} from "./BytesUtils.sol";
+import {ENS} from "../registry/ENS.sol";
+import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
+import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";
+import {Address} from "@openzeppelin/contracts/utils/Address.sol";
+
+/**
+ * @dev A proxy contract that wraps new name wrapper controllers to ensure they don't shorten the duration of registrations.
+ */
+contract NameWrapperControllerProxy {
+    address public immutable controller;
+    INameWrapper public immutable wrapper;
+
+    constructor(address _controller, INameWrapper _wrapper) {
+        controller = _controller;
+        wrapper = _wrapper;
+    }
+
+    /**
+     * @dev Registers a new .eth second-level domain and wraps it.
+     *      Only callable by authorised controllers.
+     * @param label The label to register (Eg, 'foo' for 'foo.eth').
+     * @param wrappedOwner The owner of the wrapped name.
+     * @param duration The duration, in seconds, to register the name for.
+     * @param resolver The resolver address to set on the ENS registry (optional).
+     * @param ownerControlledFuses Initial owner-controlled fuses to set
+     * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.
+     */
+    function registerAndWrapETH2LD(
+        string calldata label,
+        address wrappedOwner,
+        uint256 duration,
+        address resolver,
+        uint16 ownerControlledFuses
+    ) external returns (uint256 registrarExpiry) {
+        require(msg.sender == controller);
+        require(duration < 365000000 days);
+        return
+            wrapper.registerAndWrapETH2LD(
+                label,
+                wrappedOwner,
+                duration,
+                resolver,
+                ownerControlledFuses
+            );
+    }
+
+    /**
+     * @notice Renews a .eth second-level domain.
+     * @dev Only callable by authorised controllers.
+     * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').
+     * @param duration The number of seconds to renew the name for.
+     * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.
+     */
+    function renew(
+        uint256 tokenId,
+        uint256 duration
+    ) external returns (uint256 expires) {
+        require(msg.sender == controller);
+        require(duration < 365000000 days);
+        return wrapper.renew(tokenId, duration);
+    }
+}
+
+/**
+ * @dev Contract to act as the owner of the NameWrapper, permitting its owner to make certain changes with additional checks.
+ *      This was implemented in response to a vulnerability disclosure that would permit the DAO to appoint a malicious controller
+ *      that shortens the registration period of affected ENS names. This contract exists to prevent that from happening.
+ */
+contract NameWrapperAdmin is Ownable, INameWrapperUpgrade {
+    bytes32 private constant ETH_NODE =
+        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;
+
+    using BytesUtils for bytes;
+    using Address for address;
+
+    INameWrapper public immutable wrapper;
+    IBaseRegistrar public immutable registrar;
+    ENS public immutable ens;
+    INameWrapperUpgrade public upgradeContract;
+
+    constructor(address _wrapper) {
+        wrapper = INameWrapper(_wrapper);
+        registrar = wrapper.registrar();
+        ens = wrapper.ens();
+    }
+
+    /**
+     * @dev Deploys a controller proxy for the given controller, if one does not already exist.
+     *      Anyone can call this function, but the proxy will only function if added by an authorized
+     *      caller using `addController`.
+     * @param controller The controller contract to create a proxy for.
+     * @return The address of the controller proxy.
+     */
+    function deployControllerProxy(
+        address controller
+    ) public returns (address) {
+        address proxyAddress = getProxyAddress(controller);
+        if (!proxyAddress.isContract()) {
+            new NameWrapperControllerProxy{salt: bytes32(0)}(
+                controller,
+                wrapper
+            );
+        }
+        return proxyAddress;
+    }
+
+    /**
+     * @dev Authorizes a controller proxy to register and renew names on the wrapper.
+     * @param controller The controller contract to authorize.
+     */
+    function addController(address controller) external onlyOwner {
+        deployControllerProxy(controller);
+        Controllable(address(wrapper)).setController(
+            getProxyAddress(controller),
+            true
+        );
+    }
+
+    /**
+     * @dev Deauthorizes a controller proxy.
+     * @param controller The controller contract to deauthorize.
+     */
+    function removeController(address controller) external onlyOwner {
+        Controllable(address(wrapper)).setController(
+            getProxyAddress(controller),
+            false
+        );
+    }
+
+    /**
+     * @dev Gets the address of the proxy contract for a given controller.
+     * @param controller The controller contract to get the proxy address for.
+     * @return The address of the proxy contract.
+     */
+    function getProxyAddress(address controller) public view returns (address) {
+        return
+            Create2.computeAddress(
+                bytes32(0),
+                keccak256(
+                    abi.encodePacked(
+                        type(NameWrapperControllerProxy).creationCode,
+                        uint256(uint160(controller)),
+                        uint256(uint160(address(wrapper)))
+                    )
+                )
+            );
+    }
+
+    /**
+     * @notice Set the metadata service. Only the owner can do this
+     * @param _metadataService The new metadata service
+     */
+    function setMetadataService(
+        IMetadataService _metadataService
+    ) public onlyOwner {
+        wrapper.setMetadataService(_metadataService);
+    }
+
+    /**
+     * @notice Set the address of the upgradeContract of the contract. only admin can do this
+     * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time
+     * to make the contract not upgradable.
+     * @param _upgradeAddress address of an upgraded contract
+     */
+    function setUpgradeContract(
+        INameWrapperUpgrade _upgradeAddress
+    ) external onlyOwner {
+        if (address(upgradeContract) == address(0)) {
+            wrapper.setUpgradeContract(this);
+        }
+        upgradeContract = _upgradeAddress;
+        if (address(upgradeContract) == address(0)) {
+            wrapper.setUpgradeContract(INameWrapperUpgrade(address(0)));
+        }
+    }
+
+    function wrapFromUpgrade(
+        bytes calldata name,
+        address wrappedOwner,
+        uint32 fuses,
+        uint64 expiry,
+        address approved,
+        bytes calldata extraData
+    ) external {
+        require(msg.sender == address(wrapper));
+        (bytes32 labelhash, uint256 offset) = name.readLabel(0);
+        bytes32 parentNode = name.namehash(offset);
+        bytes32 node = keccak256(abi.encodePacked(parentNode, labelhash));
+        if (parentNode == ETH_NODE) {
+            registrar.transferFrom(
+                address(wrapper),
+                address(upgradeContract),
+                uint256(labelhash)
+            );
+        }
+        ens.setOwner(node, address(upgradeContract));
+        upgradeContract.wrapFromUpgrade(
+            name,
+            wrappedOwner,
+            fuses,
+            expiry,
+            approved,
+            extraData
+        );
+    }
+}
diff --git a/contracts/wrapper/mocks/UpgradedNameWrapperMock.sol b/contracts/wrapper/mocks/UpgradedNameWrapperMock.sol
index 6516eaa8..fe8c736e 100644
--- a/contracts/wrapper/mocks/UpgradedNameWrapperMock.sol
+++ b/contracts/wrapper/mocks/UpgradedNameWrapperMock.sol
@@ -43,16 +43,14 @@ contract UpgradedNameWrapperMock is INameWrapperUpgrade {
         if (parentNode == ETH_NODE) {
             address registrant = registrar.ownerOf(uint256(labelhash));
             require(
-                msg.sender == registrant &&
-                    registrar.isApprovedForAll(registrant, address(this)),
-                "No approval for registrar"
+                registrant == address(this),
+                "Upgrade contract does not own name in registrar"
             );
         } else {
             address owner = ens.owner(node);
             require(
-                msg.sender == owner &&
-                    ens.isApprovedForAll(owner, address(this)),
-                "No approval for registry"
+                owner == address(this),
+                "Upgrade contract does not own name in registry"
             );
         }
         emit NameUpgraded(
diff --git a/test/ethregistrar/TestBaseRegistrar.js b/test/ethregistrar/TestBaseRegistrar.js
index a0c7efaf..b8f0898e 100644
--- a/test/ethregistrar/TestBaseRegistrar.js
+++ b/test/ethregistrar/TestBaseRegistrar.js
@@ -2,6 +2,11 @@ const ENS = artifacts.require('./registry/ENSRegistry')
 const BaseRegistrar = artifacts.require(
   './registrar/BaseRegistrarImplementation',
 )
+const ETHRegistrarAdmin = artifacts.require('./registrar/ETHRegistrarAdmin')
+const ETHRegistrarControllerProxy = artifacts.require(
+  './registrar/ETHRegistrarControllerProxy',
+)
+const { expect } = require('chai')
 
 const namehash = require('eth-ens-namehash')
 const sha3 = require('web3-utils').sha3
@@ -21,19 +26,33 @@ contract('BaseRegistrar', function (accounts) {
 
   let ens
   let registrar
+  let admin
+  let controllerProxy
 
   before(async () => {
     ens = await ENS.new()
 
+    // Deploy the registrar
     registrar = await BaseRegistrar.new(ens.address, namehash.hash('eth'), {
       from: ownerAccount,
     })
-    await registrar.addController(controllerAccount, { from: ownerAccount })
+
+    // Deploy the admin contract and transfer ownership to it
+    admin = await ETHRegistrarAdmin.new(registrar.address)
+    await registrar.transferOwnership(admin.address)
+
+    // Create a new proxy for the controller
+    await admin.addController(controllerAccount, { from: ownerAccount })
+    controllerProxy = await ETHRegistrarControllerProxy.at(
+      await admin.getProxyAddress(controllerAccount),
+    )
+
+    // Set the registrar as owner of .eth
     await ens.setSubnodeOwner('0x0', sha3('eth'), registrar.address)
   })
 
   it('should allow new registrations', async () => {
-    var tx = await registrar.register(
+    var tx = await controllerProxy.register(
       sha3('newname'),
       registrantAccount,
       86400,
@@ -52,7 +71,7 @@ contract('BaseRegistrar', function (accounts) {
   })
 
   it('should allow registrations without updating the registry', async () => {
-    var tx = await registrar.registerOnly(
+    var tx = await controllerProxy.registerOnly(
       sha3('silentname'),
       registrantAccount,
       86400,
@@ -69,7 +88,9 @@ contract('BaseRegistrar', function (accounts) {
 
   it('should allow renewals', async () => {
     var oldExpires = await registrar.nameExpires(sha3('newname'))
-    await registrar.renew(sha3('newname'), 86400, { from: controllerAccount })
+    await controllerProxy.renew(sha3('newname'), 86400, {
+      from: controllerAccount,
+    })
     assert.equal(
       (await registrar.nameExpires(sha3('newname'))).toNumber(),
       oldExpires.add(toBN(86400)).toNumber(),
@@ -78,7 +99,7 @@ contract('BaseRegistrar', function (accounts) {
 
   it('should only allow the controller to register', async () => {
     await exceptions.expectFailure(
-      registrar.register(sha3('foo'), otherAccount, 86400, {
+      controllerProxy.register(sha3('foo'), otherAccount, 86400, {
         from: otherAccount,
       }),
     )
@@ -86,13 +107,13 @@ contract('BaseRegistrar', function (accounts) {
 
   it('should only allow the controller to renew', async () => {
     await exceptions.expectFailure(
-      registrar.renew(sha3('newname'), 86400, { from: otherAccount }),
+      controllerProxy.renew(sha3('newname'), 86400, { from: otherAccount }),
     )
   })
 
   it('should not permit registration of already registered names', async () => {
     await exceptions.expectFailure(
-      registrar.register(sha3('newname'), otherAccount, 86400, {
+      controllerProxy.register(sha3('newname'), otherAccount, 86400, {
         from: controllerAccount,
       }),
     )
@@ -101,7 +122,7 @@ contract('BaseRegistrar', function (accounts) {
 
   it('should not permit renewing a name that is not registered', async () => {
     await exceptions.expectFailure(
-      registrar.renew(sha3('name3'), 86400, { from: controllerAccount }),
+      controllerProxy.renew(sha3('name3'), 86400, { from: controllerAccount }),
     )
   })
 
@@ -180,7 +201,9 @@ contract('BaseRegistrar', function (accounts) {
   })
 
   it('should allow renewal during the grace period', async () => {
-    await registrar.renew(sha3('newname'), 86400, { from: controllerAccount })
+    await controllerProxy.renew(sha3('newname'), 86400, {
+      from: controllerAccount,
+    })
   })
 
   it('should allow registration of an expired domain', async () => {
@@ -188,20 +211,26 @@ contract('BaseRegistrar', function (accounts) {
     var expires = await registrar.nameExpires(sha3('newname'))
     var grace = await registrar.GRACE_PERIOD()
     await evm.advanceTime(expires.toNumber() - ts + grace.toNumber() + 3600)
+    await evm.mine()
 
-    try {
-      await registrar.ownerOf(sha3('newname'))
-      assert.fail('should throw an exception')
-    } catch (error) {}
+    await expect(registrar.ownerOf(sha3('newname'))).to.be.reverted
 
-    await registrar.register(sha3('newname'), otherAccount, 86400, {
+    await controllerProxy.register(sha3('newname'), otherAccount, 86400, {
       from: controllerAccount,
     })
     assert.equal(await registrar.ownerOf(sha3('newname')), otherAccount)
   })
 
   it('should allow the owner to set a resolver address', async () => {
-    await registrar.setResolver(accounts[1], { from: ownerAccount })
+    await admin.setResolver(accounts[1], { from: ownerAccount })
     assert.equal(await ens.resolver(namehash.hash('eth')), accounts[1])
   })
+
+  it('should not allow renewals of longer than 365000000 days', async () => {
+    await expect(
+      controllerProxy.renew(sha3('newname'), 365000000 * 86400 + 1, {
+        from: controllerAccount,
+      }),
+    ).to.be.reverted
+  })
 })
diff --git a/test/wrapper/NameWrapper.js b/test/wrapper/NameWrapper.js
index dc319022..ad82e819 100644
--- a/test/wrapper/NameWrapper.js
+++ b/test/wrapper/NameWrapper.js
@@ -9,7 +9,6 @@ const { shouldRespectConstraints } = require('./Constraints.behaviour')
 const { ZERO_ADDRESS } = require('@openzeppelin/test-helpers/src/constants')
 const { deploy } = require('../test-utils/contracts')
 const { EMPTY_BYTES32, EMPTY_ADDRESS } = require('../test-utils/constants')
-
 const abiCoder = new ethers.utils.AbiCoder()
 
 use(solidity)
@@ -53,6 +52,8 @@ describe('Name Wrapper', () => {
   let NameWrapper2
   let NameWrapperH
   let NameWrapperUpgraded
+  let NameWrappperAdmin
+  let NameWrapperControllerProxy
   let MetaDataservice
   let signers
   let accounts
@@ -140,6 +141,12 @@ describe('Name Wrapper', () => {
     NameWrapperH = NameWrapper.connect(signers[2])
     NameWrapper3 = NameWrapperH
 
+    NameWrapperAdmin = await deploy('NameWrapperAdmin', NameWrapper.address)
+    await NameWrapper.transferOwnership(NameWrapperAdmin.address)
+    NameWrapperControllerProxy = await ethers.getContractFactory(
+      'NameWrapperControllerProxy',
+    )
+
     NameWrapperUpgraded = await deploy(
       'UpgradedNameWrapperMock',
       EnsRegistry.address,
@@ -978,8 +985,11 @@ describe('Name Wrapper', () => {
 
       // Register from another address with registerAndWrap()
       await BaseRegistrar.addController(NameWrapper.address)
-      await NameWrapper.setController(account, account)
-      await NameWrapper.registerAndWrapETH2LD(
+      await NameWrapperAdmin.addController(account)
+      const NameWrapperProxy = NameWrapperControllerProxy.attach(
+        await NameWrapperAdmin.getProxyAddress(account),
+      )
+      await NameWrapperProxy.registerAndWrapETH2LD(
         label,
         account2,
         DAY,
@@ -1892,105 +1902,41 @@ describe('Name Wrapper', () => {
     it('Reverts if called by someone that is not the owner', async () => {
       // Attempt to attack the contract by setting the upgrade contract to themselves
       await expect(
-        NameWrapper2.setUpgradeContract(account2),
+        NameWrapperAdmin.connect(signers[2]).setUpgradeContract(account2),
       ).to.be.revertedWith('Ownable: caller is not the owner')
     })
-    it('Will setApprovalForAll for the upgradeContract addresses in the registrar and registry to true', async () => {
-      expect(
-        await BaseRegistrar.isApprovedForAll(
-          NameWrapper.address,
-          NameWrapperUpgraded.address,
-        ),
-      ).to.equal(false)
-      expect(
-        await EnsRegistry.isApprovedForAll(
-          NameWrapper.address,
-          NameWrapperUpgraded.address,
-        ),
-      ).to.equal(false)
-
-      //set the upgradeContract of the NameWrapper contract
-      await NameWrapper.setUpgradeContract(NameWrapperUpgraded.address)
-
-      expect(
-        await BaseRegistrar.isApprovedForAll(
-          NameWrapper.address,
-          NameWrapperUpgraded.address,
-        ),
-      ).to.equal(true)
-      expect(
-        await EnsRegistry.isApprovedForAll(
-          NameWrapper.address,
-          NameWrapperUpgraded.address,
-        ),
-      ).to.equal(true)
-    })
-    it('Will setApprovalForAll for the old upgradeContract addresses in the registrar and registry to false', async () => {
+    it('Will set the admin as the upgrade contract when one is set', async () => {
       //set the upgradeContract of the NameWrapper contract
-      await NameWrapper.setUpgradeContract(DUMMY_ADDRESS)
-
-      expect(
-        await BaseRegistrar.isApprovedForAll(
-          NameWrapper.address,
-          DUMMY_ADDRESS,
-        ),
-      ).to.equal(true)
-      expect(
-        await EnsRegistry.isApprovedForAll(NameWrapper.address, DUMMY_ADDRESS),
-      ).to.equal(true)
-
-      //set the upgradeContract of the NameWrapper contract
-      await NameWrapper.setUpgradeContract(NameWrapperUpgraded.address)
+      await NameWrapperAdmin.setUpgradeContract(NameWrapperUpgraded.address)
 
+      expect(await NameWrapper.upgradeContract()).to.equal(
+        NameWrapperAdmin.address,
+      )
+      expect(await NameWrapperAdmin.upgradeContract()).to.equal(
+        NameWrapperUpgraded.address,
+      )
       expect(
         await BaseRegistrar.isApprovedForAll(
           NameWrapper.address,
           NameWrapperUpgraded.address,
         ),
-      ).to.equal(true)
+      ).to.equal(false)
       expect(
         await EnsRegistry.isApprovedForAll(
           NameWrapper.address,
           NameWrapperUpgraded.address,
         ),
-      ).to.equal(true)
-
-      expect(
-        await BaseRegistrar.isApprovedForAll(
-          NameWrapper.address,
-          DUMMY_ADDRESS,
-        ),
-      ).to.equal(false)
-      expect(
-        await EnsRegistry.isApprovedForAll(NameWrapper.address, DUMMY_ADDRESS),
       ).to.equal(false)
     })
-    it('Will not setApprovalForAll for the new upgrade address if it is the address(0)', async () => {
+    it('Will unset the admin as the upgrade contract when the upgrade contract is removed', async () => {
       //set the upgradeContract of the NameWrapper contract
-      await NameWrapper.setUpgradeContract(NameWrapperUpgraded.address)
-
-      expect(
-        await BaseRegistrar.isApprovedForAll(
-          NameWrapper.address,
-          NameWrapperUpgraded.address,
-        ),
-      ).to.equal(true)
-      expect(
-        await EnsRegistry.isApprovedForAll(
-          NameWrapper.address,
-          NameWrapperUpgraded.address,
-        ),
-      ).to.equal(true)
+      await NameWrapperAdmin.setUpgradeContract(NameWrapperUpgraded.address)
 
       //set the upgradeContract of the NameWrapper contract
-      await NameWrapper.setUpgradeContract(ZERO_ADDRESS)
+      await NameWrapperAdmin.setUpgradeContract(ZERO_ADDRESS)
 
-      expect(
-        await BaseRegistrar.isApprovedForAll(NameWrapper.address, ZERO_ADDRESS),
-      ).to.equal(false)
-      expect(
-        await EnsRegistry.isApprovedForAll(NameWrapper.address, ZERO_ADDRESS),
-      ).to.equal(false)
+      expect(await NameWrapper.upgradeContract()).to.equal(ZERO_ADDRESS)
+      expect(await NameWrapperAdmin.upgradeContract()).to.equal(ZERO_ADDRESS)
     })
   })
 
@@ -2024,7 +1970,7 @@ describe('Name Wrapper', () => {
         )
 
         //set the upgradeContract of the NameWrapper contract
-        await NameWrapper.setUpgradeContract(NameWrapperUpgraded.address)
+        await NameWrapperAdmin.setUpgradeContract(NameWrapperUpgraded.address)
         await BaseRegistrar.isApprovedForAll(
           NameWrapper.address,
           NameWrapperUpgraded.address,
@@ -2063,7 +2009,7 @@ describe('Name Wrapper', () => {
           NameWrapper.address,
         )
 
-        await NameWrapper.setUpgradeContract(NameWrapperUpgraded.address)
+        await NameWrapperAdmin.setUpgradeContract(NameWrapperUpgraded.address)
 
         const tx = await NameWrapper2.upgrade(encodedName, 0)
 
@@ -2106,13 +2052,16 @@ describe('Name Wrapper', () => {
           CAN_DO_EVERYTHING,
           EMPTY_ADDRESS,
         )
-        await NameWrapper.setUpgradeContract(NameWrapperUpgraded.address)
+        await NameWrapperAdmin.setUpgradeContract(NameWrapperUpgraded.address)
 
         expect(await NameWrapper.upgradeContract()).to.equal(
+          NameWrapperAdmin.address,
+        )
+        expect(await NameWrapperAdmin.upgradeContract()).to.equal(
           NameWrapperUpgraded.address,
         )
 
-        await NameWrapper.setUpgradeContract(EMPTY_ADDRESS)
+        await NameWrapperAdmin.setUpgradeContract(EMPTY_ADDRESS)
         await expect(NameWrapper.upgrade(encodedName, 0)).to.be.revertedWith(
           `CannotUpgrade()`,
         )
@@ -2132,7 +2081,7 @@ describe('Name Wrapper', () => {
         )
 
         //set the upgradeContract of the NameWrapper contract
-        await NameWrapper.setUpgradeContract(NameWrapperUpgraded.address)
+        await NameWrapperAdmin.setUpgradeContract(NameWrapperUpgraded.address)
 
         const expectedExpiry = (await BaseRegistrar.nameExpires(labelHash)).add(
           GRACE_PERIOD,
@@ -2167,7 +2116,7 @@ describe('Name Wrapper', () => {
           EMPTY_ADDRESS,
         )
 
-        await NameWrapper.setUpgradeContract(NameWrapperUpgraded.address)
+        await NameWrapperAdmin.setUpgradeContract(NameWrapperUpgraded.address)
 
         await NameWrapper.upgrade(encodedName, 0)
 
@@ -2192,7 +2141,7 @@ describe('Name Wrapper', () => {
           EMPTY_ADDRESS,
         )
 
-        await NameWrapper.setUpgradeContract(NameWrapperUpgraded.address)
+        await NameWrapperAdmin.setUpgradeContract(NameWrapperUpgraded.address)
 
         await NameWrapper.upgrade(encodedName, 0)
 
@@ -2215,7 +2164,7 @@ describe('Name Wrapper', () => {
           EMPTY_ADDRESS,
         )
 
-        await NameWrapper.setUpgradeContract(NameWrapperUpgraded.address)
+        await NameWrapperAdmin.setUpgradeContract(NameWrapperUpgraded.address)
 
         const expectedExpiry = (await BaseRegistrar.nameExpires(labelHash)).add(
           GRACE_PERIOD,
@@ -2250,7 +2199,7 @@ describe('Name Wrapper', () => {
         )
 
         //set the upgradeContract of the NameWrapper contract
-        await NameWrapper.setUpgradeContract(NameWrapperUpgraded.address)
+        await NameWrapperAdmin.setUpgradeContract(NameWrapperUpgraded.address)
 
         await expect(NameWrapper2.upgrade(encodedName, 0)).to.be.revertedWith(
           `Unauthorised("${nameHash}", "${account2}")`,
@@ -2288,7 +2237,7 @@ describe('Name Wrapper', () => {
         expect(ownerOfWrapped).to.equal(account)
 
         //set the upgradeContract of the NameWrapper contract
-        await NameWrapper.setUpgradeContract(NameWrapperUpgraded.address)
+        await NameWrapperAdmin.setUpgradeContract(NameWrapperUpgraded.address)
 
         const tx = await NameWrapper.upgrade(encodedName, 0)
 
@@ -2315,7 +2264,7 @@ describe('Name Wrapper', () => {
         expect(ownerOfWrappedXYZ).to.equal(account)
 
         //set the upgradeContract of the NameWrapper contract
-        await NameWrapper.setUpgradeContract(NameWrapperUpgraded.address)
+        await NameWrapperAdmin.setUpgradeContract(NameWrapperUpgraded.address)
 
         const tx = await NameWrapper2.upgrade(encodeName('to-upgrade.xyz'), 0)
 
@@ -2374,7 +2323,7 @@ describe('Name Wrapper', () => {
         expect(ownerOfWrapped).to.equal(account)
 
         //set the upgradeContract of the NameWrapper contract
-        await NameWrapper.setUpgradeContract(NameWrapperUpgraded.address)
+        await NameWrapperAdmin.setUpgradeContract(NameWrapperUpgraded.address)
 
         const tx = await NameWrapper.upgrade(encodeName(name), 0)
 
@@ -2415,7 +2364,7 @@ describe('Name Wrapper', () => {
         expect(ownerOfWrapped).to.equal(account)
 
         //set the upgradeContract of the NameWrapper contract
-        await NameWrapper.setUpgradeContract(NameWrapperUpgraded.address)
+        await NameWrapperAdmin.setUpgradeContract(NameWrapperUpgraded.address)
 
         await NameWrapper.upgrade(encodedName, 0)
 
@@ -2448,7 +2397,7 @@ describe('Name Wrapper', () => {
         expect(ownerOfWrapped).to.equal(account)
 
         //set the upgradeContract of the NameWrapper contract
-        await NameWrapper.setUpgradeContract(NameWrapperUpgraded.address)
+        await NameWrapperAdmin.setUpgradeContract(NameWrapperUpgraded.address)
 
         await NameWrapper.upgrade(encodedName, 0)
 
@@ -2485,7 +2434,7 @@ describe('Name Wrapper', () => {
         ).to.equal(account3)
 
         // set the upgradeContract of the NameWrapper contract
-        await NameWrapper.setUpgradeContract(NameWrapperUpgraded.address)
+        await NameWrapperAdmin.setUpgradeContract(NameWrapperUpgraded.address)
 
         const tx = await NameWrapper.upgrade(encodeName('to-upgrade.xyz'), '0x')
         expect(tx)
@@ -2513,7 +2462,7 @@ describe('Name Wrapper', () => {
         expect(ownerOfWrappedXYZ).to.equal(account)
 
         //set the upgradeContract of the NameWrapper contract
-        await NameWrapper.setUpgradeContract(NameWrapperUpgraded.address)
+        await NameWrapperAdmin.setUpgradeContract(NameWrapperUpgraded.address)
 
         const tx = await NameWrapper.upgrade(
           encodeName('to-upgrade.xyz'),
@@ -2551,7 +2500,7 @@ describe('Name Wrapper', () => {
         expect(ownerOfWrappedXYZ).to.equal(account)
 
         //set the upgradeContract of the NameWrapper contract
-        await NameWrapper.setUpgradeContract(NameWrapperUpgraded.address)
+        await NameWrapperAdmin.setUpgradeContract(NameWrapperUpgraded.address)
 
         await expect(
           NameWrapper2.upgrade(encodeName('to-upgrade.xyz'), 0),
@@ -6066,14 +6015,18 @@ describe('Name Wrapper', () => {
     const label = 'register'
     const labelHash = labelhash(label)
     const wrappedTokenId = namehash(label + '.eth')
+    let NameWrapperProxy
 
     before(async () => {
       await BaseRegistrar.addController(NameWrapper.address)
-      await NameWrapper.setController(account, true)
+      await NameWrapperAdmin.addController(account)
+      NameWrapperProxy = NameWrapperControllerProxy.attach(
+        await NameWrapperAdmin.getProxyAddress(account),
+      )
     })
 
     it('should register and wrap names', async () => {
-      await NameWrapper.registerAndWrapETH2LD(
+      await NameWrapperProxy.registerAndWrapETH2LD(
         label,
         account,
         86400,
@@ -6091,7 +6044,7 @@ describe('Name Wrapper', () => {
     })
 
     it('allows specifying a resolver address', async () => {
-      await NameWrapper.registerAndWrapETH2LD(
+      await NameWrapperProxy.registerAndWrapETH2LD(
         label,
         account,
         86400,
@@ -6103,20 +6056,19 @@ describe('Name Wrapper', () => {
     })
 
     it('does not allow non controllers to register names', async () => {
-      await NameWrapper.setController(account, false)
       await expect(
-        NameWrapper.registerAndWrapETH2LD(
+        NameWrapperProxy.connect(signers[2]).registerAndWrapETH2LD(
           label,
           account,
           86400,
           EMPTY_ADDRESS,
           CAN_DO_EVERYTHING,
         ),
-      ).to.be.revertedWith('Controllable: Caller is not a controller')
+      ).to.be.reverted
     })
 
     it('Transfers the wrapped token to the target address.', async () => {
-      await NameWrapper.registerAndWrapETH2LD(
+      await NameWrapperProxy.registerAndWrapETH2LD(
         label,
         account2,
         86400,
@@ -6128,7 +6080,7 @@ describe('Name Wrapper', () => {
 
     it('Does not allow wrapping with a target address of 0x0', async () => {
       await expect(
-        NameWrapper.registerAndWrapETH2LD(
+        NameWrapperProxy.registerAndWrapETH2LD(
           label,
           EMPTY_ADDRESS,
           86400,
@@ -6140,7 +6092,7 @@ describe('Name Wrapper', () => {
 
     it('Does not allow wrapping with a target address of the wrapper contract address.', async () => {
       await expect(
-        NameWrapper.registerAndWrapETH2LD(
+        NameWrapperProxy.registerAndWrapETH2LD(
           label,
           NameWrapper.address,
           86400,
@@ -6154,7 +6106,7 @@ describe('Name Wrapper', () => {
 
     it('Does not allows fuse to be burned if CANNOT_UNWRAP has not been burned.', async () => {
       await expect(
-        NameWrapper.registerAndWrapETH2LD(
+        NameWrapperProxy.registerAndWrapETH2LD(
           label,
           account,
           86400,
@@ -6166,7 +6118,7 @@ describe('Name Wrapper', () => {
 
     it('Allows fuse to be burned if CANNOT_UNWRAP has been burned and expiry set', async () => {
       const initialFuses = CANNOT_UNWRAP | CANNOT_SET_RESOLVER
-      await NameWrapper.registerAndWrapETH2LD(
+      await NameWrapperProxy.registerAndWrapETH2LD(
         label,
         account,
         86400,
@@ -6178,7 +6130,7 @@ describe('Name Wrapper', () => {
     })
 
     it('automatically sets PARENT_CANNOT_CONTROL and IS_DOT_ETH', async () => {
-      await NameWrapper.registerAndWrapETH2LD(
+      await NameWrapperProxy.registerAndWrapETH2LD(
         label,
         account,
         86400,
@@ -6190,13 +6142,14 @@ describe('Name Wrapper', () => {
     })
 
     it('Errors when adding a number greater than uint16 for fuses', async () => {
-      const tx = await NameWrapper.populateTransaction.registerAndWrapETH2LD(
-        label,
-        account,
-        86400,
-        EMPTY_ADDRESS,
-        273,
-      )
+      const tx =
+        await NameWrapperProxy.populateTransaction.registerAndWrapETH2LD(
+          label,
+          account,
+          86400,
+          EMPTY_ADDRESS,
+          273,
+        )
 
       const rogueFuse = '40000' // 2 ** 18 in hex
       tx.data = tx.data.replace('00111', rogueFuse)
@@ -6227,7 +6180,7 @@ describe('Name Wrapper', () => {
 
     it('Will not wrap a name with an empty label', async () => {
       await expect(
-        NameWrapper.registerAndWrapETH2LD(
+        NameWrapperProxy.registerAndWrapETH2LD(
           '',
           account,
           86400,
@@ -6242,7 +6195,7 @@ describe('Name Wrapper', () => {
         'yutaioxtcsbzrqhdjmltsdfkgomogohhcchjoslfhqgkuhduhxqsldnurwrrtoicvthwxytonpcidtnkbrhccaozdtoznedgkfkifsvjukxxpkcmgcjprankyzerzqpnuteuegtfhqgzcxqwttyfewbazhyilqhyffufxrookxrnjkmjniqpmntcbrowglgdpkslzechimsaonlcvjkhhvdvkvvuztihobmivifuqtvtwinljslusvhhbwhuhzty'
       expect(longString.length).to.equal(256)
       await expect(
-        NameWrapper.registerAndWrapETH2LD(
+        NameWrapperProxy.registerAndWrapETH2LD(
           longString,
           account,
           86400,
@@ -6253,7 +6206,7 @@ describe('Name Wrapper', () => {
     })
 
     it('emits Wrap event', async () => {
-      const tx = await NameWrapper.registerAndWrapETH2LD(
+      const tx = await NameWrapperProxy.registerAndWrapETH2LD(
         label,
         account,
         86400,
@@ -6274,7 +6227,7 @@ describe('Name Wrapper', () => {
     })
 
     it('Emits TransferSingle event', async () => {
-      const tx = await NameWrapper.registerAndWrapETH2LD(
+      const tx = await NameWrapperProxy.registerAndWrapETH2LD(
         label,
         account,
         86400,
@@ -6283,7 +6236,13 @@ describe('Name Wrapper', () => {
       )
       await expect(tx)
         .to.emit(NameWrapper, 'TransferSingle')
-        .withArgs(account, EMPTY_ADDRESS, account, wrappedTokenId, 1)
+        .withArgs(
+          NameWrapperProxy.address,
+          EMPTY_ADDRESS,
+          account,
+          wrappedTokenId,
+          1,
+        )
     })
   })
 
@@ -6291,14 +6250,18 @@ describe('Name Wrapper', () => {
     const label = 'register'
     const labelHash = labelhash(label)
     const wrappedTokenId = namehash(label + '.eth')
+    let NameWrapperProxy
 
     before(async () => {
       await BaseRegistrar.addController(NameWrapper.address)
-      await NameWrapper.setController(account, true)
+      await NameWrapperAdmin.addController(account)
+      NameWrapperProxy = NameWrapperControllerProxy.attach(
+        await NameWrapperAdmin.getProxyAddress(account),
+      )
     })
 
     it('Renews names', async () => {
-      await NameWrapper.registerAndWrapETH2LD(
+      await NameWrapperProxy.registerAndWrapETH2LD(
         label,
         account,
         86400,
@@ -6306,14 +6269,14 @@ describe('Name Wrapper', () => {
         CAN_DO_EVERYTHING,
       )
       const expires = await BaseRegistrar.nameExpires(labelHash)
-      await NameWrapper.renew(labelHash, 86400)
+      await NameWrapperProxy.renew(labelHash, 86400)
       expect(await BaseRegistrar.nameExpires(labelHash)).to.equal(
         expires.toNumber() + 86400,
       )
     })
 
     it('Renews names and can extend wrapper expiry', async () => {
-      await NameWrapper.registerAndWrapETH2LD(
+      await NameWrapperProxy.registerAndWrapETH2LD(
         label,
         account,
         86400,
@@ -6322,7 +6285,7 @@ describe('Name Wrapper', () => {
       )
       const expires = await BaseRegistrar.nameExpires(labelHash)
       const expectedExpiry = expires.toNumber() + 86400
-      await NameWrapper.renew(labelHash, 86400)
+      await NameWrapperProxy.renew(labelHash, 86400)
       expect(await BaseRegistrar.nameExpires(labelHash)).to.equal(
         expires.toNumber() + 86400,
       )
@@ -6333,7 +6296,7 @@ describe('Name Wrapper', () => {
     })
 
     it('Renewing name less than required to unexpire it still has original owner/fuses', async () => {
-      await NameWrapper.registerAndWrapETH2LD(
+      await NameWrapperProxy.registerAndWrapETH2LD(
         label,
         account,
         DAY,
@@ -6351,7 +6314,7 @@ describe('Name Wrapper', () => {
       expect(expiryBefore).to.be.at.most(block1.timestamp + GRACE_PERIOD)
 
       //renew for less than the grace period
-      await NameWrapper.renew(labelHash, 1 * DAY)
+      await NameWrapperProxy.renew(labelHash, 1 * DAY)
 
       const [ownerAfter, fusesAfter, expiryAfter] = await NameWrapper.getData(
         wrappedTokenId,
@@ -6367,26 +6330,18 @@ describe('Name Wrapper', () => {
       // still expired
       expect(expiryAfter).to.be.at.most(block1.timestamp + GRACE_PERIOD)
     })
-  })
-
-  describe('Controllable', () => {
-    it('allows the owner to add and remove controllers', async () => {
-      const tx = await NameWrapper.setController(account, true)
-      expect(tx)
-        .to.emit(NameWrapper, 'ControllerChanged')
-        .withArgs(account, true)
-
-      const tx2 = await NameWrapper.setController(account, false)
-      expect(tx2)
-        .to.emit(NameWrapper, 'ControllerChanged')
-        .withArgs(account, false)
-    })
 
-    it('does not allow non-owners to add or remove controllers', async () => {
-      await NameWrapper.setController(account, true)
-
-      await expect(NameWrapper2.setController(account2, true)).to.be.reverted
-      await expect(NameWrapper2.setController(account, false)).to.be.reverted
+    it('should not allow renewals of longer than 365000000 days', async () => {
+      await NameWrapperProxy.registerAndWrapETH2LD(
+        label,
+        account,
+        86400,
+        EMPTY_ADDRESS,
+        CAN_DO_EVERYTHING,
+      )
+      await expect(
+        NameWrapperProxy.renew(wrappedTokenId, 365000000 * 86400 + 1),
+      ).to.be.reverted
     })
   })
 
@@ -6577,7 +6532,7 @@ describe('Name Wrapper', () => {
     })
 
     it('owner can set a new MetadataService', async () => {
-      await NameWrapper.setMetadataService(account2)
+      await NameWrapperAdmin.setMetadataService(account2)
       expect(await NameWrapper.metadataService()).to.equal(account2)
     })
 
@@ -7065,12 +7020,17 @@ describe('Name Wrapper', () => {
     const labelHash2 = labelhash('sub2')
     const wrappedTokenId2 = namehash('sub2.sub1.eth')
 
+    let NameWrapperProxy
+
     before(async () => {
       await BaseRegistrar.addController(NameWrapper.address)
-      await NameWrapper.setController(account, true)
+      await NameWrapperAdmin.addController(account)
+      NameWrapperProxy = NameWrapperControllerProxy.attach(
+        await NameWrapperAdmin.getProxyAddress(account),
+      )
     })
     it('Trying to burn child fuses when re-registering a name on the old controller reverts', async () => {
-      await NameWrapper.registerAndWrapETH2LD(
+      await NameWrapperProxy.registerAndWrapETH2LD(
         label1,
         hacker,
         1 * DAY,
@@ -7123,7 +7083,7 @@ describe('Name Wrapper', () => {
       ).to.be.revertedWith(`Unauthorised("${wrappedTokenId1}", "${hacker}")`)
     })
     it('Renewing a wrapped, but expired name .eth in the wrapper, but unexpired on the registrar resyncs expiry', async () => {
-      await NameWrapper.registerAndWrapETH2LD(
+      await NameWrapperProxy.registerAndWrapETH2LD(
         label1,
         account,
         1 * DAY,
@@ -7150,7 +7110,7 @@ describe('Name Wrapper', () => {
         NameWrapper.address,
       )
 
-      await NameWrapper.renew(labelHash1, 1)
+      await NameWrapperProxy.renew(labelHash1, 1)
 
       owner = await NameWrapper.ownerOf(wrappedTokenId1)
       let [, , expiry] = await NameWrapper.getData(wrappedTokenId1)
@@ -7166,6 +7126,11 @@ describe('Name Wrapper', () => {
     it('Wraps a name which get stuck forever can be recovered by ROOT owner', async () => {
       expect(await NameWrapper.ownerOf(namehash('xyz'))).to.equal(EMPTY_ADDRESS)
 
+      await NameWrapperAdmin.addController(account)
+      const NameWrapperProxy = NameWrapperControllerProxy.attach(
+        await NameWrapperAdmin.getProxyAddress(account),
+      )
+
       await EnsRegistry.setApprovalForAll(NameWrapper.address, true)
       await NameWrapper.wrap(encodeName('xyz'), account, EMPTY_ADDRESS)
       expect(await NameWrapper.ownerOf(namehash('xyz'))).to.equal(account)
