diff --git a/crates/sui-open-rpc/spec/openrpc.json b/crates/sui-open-rpc/spec/openrpc.json
index 2f03800fcf3c5..0d2bf067b22e3 100644
--- a/crates/sui-open-rpc/spec/openrpc.json
+++ b/crates/sui-open-rpc/spec/openrpc.json
@@ -1666,6 +1666,7 @@
                 "max_move_package_size": {
                   "u64": "102400"
                 },
+                "max_move_value_depth": null,
                 "max_move_vector_len": {
                   "u64": "262144"
                 },
diff --git a/crates/sui-protocol-config/src/lib.rs b/crates/sui-protocol-config/src/lib.rs
index 9251119313432..2f2a6fe4e8836 100644
--- a/crates/sui-protocol-config/src/lib.rs
+++ b/crates/sui-protocol-config/src/lib.rs
@@ -37,6 +37,7 @@ const MAX_PROTOCOL_VERSION: u64 = 11;
 //            `max_meter_ticks_per_module` limits each from 6_000_000 to 16_000_000. sui-system
 //            framework changes.
 // Version 11: Introduce `std::type_name::get_with_original_ids` to the system frameworks.
+//             Bound max depth of values within the VM.
 
 #[derive(Copy, Clone, Debug, Hash, Serialize, Deserialize, PartialEq, Eq, PartialOrd, Ord)]
 pub struct ProtocolVersion(u64);
@@ -343,6 +344,9 @@ pub struct ProtocolConfig {
     /// Maximum length of an `Identifier` in Move. Enforced by the bytecode verifier at signing.
     max_move_identifier_len: Option<u64>,
 
+    /// Maximum depth of a Move value within the VM.
+    max_move_value_depth: Option<u64>,
+
     /// Maximum number of back edges in Move function. Enforced by the bytecode verifier at signing.
     max_back_edges_per_function: Option<u64>,
 
@@ -1049,6 +1053,7 @@ impl ProtocolConfig {
 
                 // Limits the length of a Move identifier
                 max_move_identifier_len: None,
+                max_move_value_depth: None,
 
                 // When adding a new constant, set it to None in the earliest version, like this:
                 // new_constant: None,
@@ -1130,7 +1135,11 @@ impl ProtocolConfig {
                 cfg.max_meter_ticks_per_module = Some(16_000_000);
                 cfg
             }
-            11 => Self::get_for_version_impl(version - 1),
+            11 => {
+                let mut cfg = Self::get_for_version_impl(version - 1);
+                cfg.max_move_value_depth = Some(128);
+                cfg
+            }
             // Use this template when making changes:
             //
             //     // modify an existing constant.
diff --git a/crates/sui-protocol-config/src/snapshots/sui_protocol_config__test__version_11.snap b/crates/sui-protocol-config/src/snapshots/sui_protocol_config__test__version_11.snap
index 776449bf76a2d..382296c2f3269 100644
--- a/crates/sui-protocol-config/src/snapshots/sui_protocol_config__test__version_11.snap
+++ b/crates/sui-protocol-config/src/snapshots/sui_protocol_config__test__version_11.snap
@@ -57,6 +57,7 @@ max_num_transferred_move_object_ids_system_tx: 32768
 max_event_emit_size: 256000
 max_move_vector_len: 262144
 max_move_identifier_len: 128
+max_move_value_depth: 128
 max_back_edges_per_function: 10000
 max_back_edges_per_module: 10000
 max_verifier_meter_ticks_per_function: 16000000
diff --git a/external-crates/move/Cargo.toml b/external-crates/move/Cargo.toml
index 0d6af14046478..70e2c2798e906 100644
--- a/external-crates/move/Cargo.toml
+++ b/external-crates/move/Cargo.toml
@@ -104,6 +104,11 @@ debug = true
 [profile.dev]
 debug = true
 
+[profile.test.package.move-vm-integration-tests]
+# opt-level 2 for move-compiler reduces the size of some of its
+# (recursive) stack frames by up to 10x, avoiding stack overflows.
+opt-level = 3
+
 # use release settings to reduce memory pressure in the linking step in CI
 [profile.ci]
 inherits = "test"
diff --git a/external-crates/move/move-stdlib/nursery/tests/event_tests.move b/external-crates/move/move-stdlib/nursery/tests/event_tests.move
index ba354fb6071f0..3ab19d53cbe5c 100644
--- a/external-crates/move/move-stdlib/nursery/tests/event_tests.move
+++ b/external-crates/move/move-stdlib/nursery/tests/event_tests.move
@@ -73,7 +73,7 @@ module std::event_tests {
     }
 
     #[test(s = @0x42)]
-    #[expected_failure(abort_code = 0, location = std::event)]
+    #[expected_failure] // VM_MAX_VALUE_DEPTH_REACHED
     fun test_event_129(s: signer) acquires MyEvent {
         event_129(&s);
     }
diff --git a/external-crates/move/move-stdlib/tests/bcs_tests.move b/external-crates/move/move-stdlib/tests/bcs_tests.move
index 8fc8fae92eef3..0c84da6936f0b 100644
--- a/external-crates/move/move-stdlib/tests/bcs_tests.move
+++ b/external-crates/move/move-stdlib/tests/bcs_tests.move
@@ -96,7 +96,7 @@ module std::bcs_tests {
     }
 
     #[test]
-    #[expected_failure(abort_code = 453, location = std::bcs)]
+    #[expected_failure] // VM_MAX_VALUE_DEPTH_REACHED
     fun encode_129() {
         bcs::to_bytes(&Box { x: box127(true) });
     }
diff --git a/external-crates/move/move-vm/integration-tests/src/tests/depth_tests_modules.move b/external-crates/move/move-vm/integration-tests/src/tests/depth_tests_modules.move
new file mode 100644
index 0000000000000..22f0c4c9fc5b3
--- /dev/null
+++ b/external-crates/move/move-vm/integration-tests/src/tests/depth_tests_modules.move
@@ -0,0 +1,113 @@
+address 0x2 {
+module A {
+    struct S has copy, drop {
+        f1: 0x2::B::S,
+        f2: 0x2::C::S,
+    }
+
+      struct Box<T> has copy, drop, store { x: T }
+      struct Box3<T> has copy, drop, store { x: Box<Box<T>> }
+      struct Box7<T> has copy, drop, store { x: Box3<Box3<T>> }
+      struct Box15<T> has copy, drop, store { x: Box7<Box7<T>> }
+      struct Box31<T> has copy, drop, store { x: Box15<Box15<T>> }
+      struct Box63<T> has copy, drop, store { x: Box31<Box31<T>> }
+      struct Box127<T> has copy, drop, store { x: Box63<Box63<T>> }
+}
+
+module B {
+    struct S has copy, drop {
+        f1: u64,
+        f2: u128,
+    }
+}
+module C {
+    struct S has copy, drop {
+        f1: address,
+        f2: bool,
+    }
+}
+
+module D {
+    struct S has copy, drop {
+        f1: 0x2::B::S,
+    }
+}
+
+module E {
+    struct S<T> has copy, drop {
+        f1: 0x2::F::S<T>,
+        f2: u64,
+    }
+}
+
+module F {
+    struct S<T> has copy, drop {
+        f1: T,
+        f2: u64,
+    }
+}
+
+module G {
+    struct S<A, B> has copy, drop {
+        f1: 0x2::H::S<B, A>,
+        f2: u64,
+    }
+}
+
+module H {
+    struct S<A, B> has copy, drop {
+        f1: 0x2::F::S<A>,
+        f2: 0x2::E::S<B>,
+        f3: 0x2::E::S<0x2::F::S<B>>,
+        f4: A,
+        f5: B,
+        f6: u64,
+    }
+}
+
+module I {
+    struct S<A, B> {
+        f1: F<A>,
+        f2: E<B>,
+        f3: E<F<B>>,
+        f4: E<F<F<B>>>,
+        f5: E<F<F<LL<A, B>>>>,
+        f6: A,
+        f7: B,
+        f8: u64,
+    }
+
+    struct E<T> {
+        f1: F<T>,
+        f2: u64,
+    }
+
+    struct F<T> {
+        f1: T,
+        f2: u64,
+    }
+
+    struct H<T> {
+        f1: T,
+        f2: u64,
+    }
+
+    struct G<phantom T> {
+        f: H<u64>,
+    }
+
+    struct L<T> {
+        g1: G<T>,
+        g2: H<T>,
+    }
+
+    struct LL<phantom A, B> {
+        g1: G<A>,
+        g2: H<B>,
+    }
+
+    struct N<phantom Y> {
+        f: u64
+    }
+}
+}
diff --git a/external-crates/move/move-vm/integration-tests/src/tests/loader_tests.rs b/external-crates/move/move-vm/integration-tests/src/tests/loader_tests.rs
index c782b9f029a38..8011567624c86 100644
--- a/external-crates/move/move-vm/integration-tests/src/tests/loader_tests.rs
+++ b/external-crates/move/move-vm/integration-tests/src/tests/loader_tests.rs
@@ -25,7 +25,10 @@ use move_core_types::{
 };
 use move_vm_runtime::{config::VMConfig, move_vm::MoveVM, session::SerializedReturnValues};
 use move_vm_test_utils::InMemoryStorage;
-use move_vm_types::{gas::UnmeteredGasMeter, loaded_data::runtime_types::Type};
+use move_vm_types::{
+    gas::UnmeteredGasMeter,
+    loaded_data::runtime_types::{DepthFormula, StructType, Type},
+};
 
 use std::{collections::BTreeMap, path::PathBuf, str::FromStr, sync::Arc, thread};
 
@@ -201,6 +204,14 @@ impl Adapter {
             .expect("Loading type should succeed")
     }
 
+    fn load_struct(&self, module_id: &ModuleId, struct_name: &IdentStr) -> Arc<StructType> {
+        let session = self.vm.new_session(&self.store);
+        session
+            .load_struct(module_id, struct_name)
+            .expect("Loading struct should succeed")
+            .1
+    }
+
     fn get_type_tag(&self, ty: &Type) -> TypeTag {
         let session = self.vm.new_session(&self.store);
         session
@@ -368,6 +379,10 @@ fn get_loader_tests_modules() -> Vec<CompiledModule> {
     compile_modules_in_file(&get_fixture("loader_tests_modules.move")).unwrap()
 }
 
+fn get_depth_tests_modules() -> Vec<CompiledModule> {
+    compile_modules_in_file(&get_fixture("depth_tests_modules.move")).unwrap()
+}
+
 fn get_relinker_tests_modules_with_deps<'s>(
     module: &'s str,
     deps: impl IntoIterator<Item = &'s str>,
@@ -399,6 +414,213 @@ fn load() {
     adapter.call_functions();
 }
 
+#[test]
+fn test_depth() {
+    let data_store = InMemoryStorage::new();
+    let mut adapter = Adapter::new(data_store);
+    let modules = get_depth_tests_modules();
+    let structs = vec![
+        (
+            "A",
+            "Box",
+            Some(DepthFormula {
+                terms: vec![(0, 1)],
+                constant: None,
+            }),
+        ),
+        (
+            "A",
+            "Box3",
+            Some(DepthFormula {
+                terms: vec![(0, 3)],
+                constant: None,
+            }),
+        ),
+        (
+            "A",
+            "Box7",
+            Some(DepthFormula {
+                terms: vec![(0, 7)],
+                constant: None,
+            }),
+        ),
+        (
+            "A",
+            "Box15",
+            Some(DepthFormula {
+                terms: vec![(0, 15)],
+                constant: None,
+            }),
+        ),
+        (
+            "A",
+            "Box31",
+            Some(DepthFormula {
+                terms: vec![(0, 31)],
+                constant: None,
+            }),
+        ),
+        (
+            "A",
+            "Box63",
+            Some(DepthFormula {
+                terms: vec![(0, 63)],
+                constant: None,
+            }),
+        ),
+        (
+            "A",
+            "Box127",
+            Some(DepthFormula {
+                terms: vec![(0, 127)],
+                constant: None,
+            }),
+        ),
+        (
+            "A",
+            "S",
+            Some(DepthFormula {
+                terms: vec![],
+                constant: Some(3),
+            }),
+        ),
+        (
+            "B",
+            "S",
+            Some(DepthFormula {
+                terms: vec![],
+                constant: Some(2),
+            }),
+        ),
+        (
+            "C",
+            "S",
+            Some(DepthFormula {
+                terms: vec![],
+                constant: Some(2),
+            }),
+        ),
+        (
+            "D",
+            "S",
+            Some(DepthFormula {
+                terms: vec![],
+                constant: Some(3),
+            }),
+        ),
+        (
+            "E",
+            "S",
+            Some(DepthFormula {
+                terms: vec![(0, 2)],
+                constant: Some(3),
+            }),
+        ),
+        (
+            "F",
+            "S",
+            Some(DepthFormula {
+                terms: vec![(0, 1)],
+                constant: Some(2),
+            }),
+        ),
+        (
+            "G",
+            "S",
+            Some(DepthFormula {
+                terms: vec![(0, 5), (1, 3)],
+                constant: Some(6),
+            }),
+        ),
+        (
+            "H",
+            "S",
+            Some(DepthFormula {
+                terms: vec![(0, 2), (1, 4)],
+                constant: Some(5),
+            }),
+        ),
+        (
+            "I",
+            "L",
+            Some(DepthFormula {
+                terms: vec![(0, 2)],
+                constant: Some(4),
+            }),
+        ),
+        (
+            "I",
+            "G",
+            Some(DepthFormula {
+                terms: vec![],
+                constant: Some(3),
+            }),
+        ),
+        (
+            "I",
+            "H",
+            Some(DepthFormula {
+                terms: vec![(0, 1)],
+                constant: Some(2),
+            }),
+        ),
+        (
+            "I",
+            "E",
+            Some(DepthFormula {
+                terms: vec![(0, 2)],
+                constant: Some(3),
+            }),
+        ),
+        (
+            "I",
+            "F",
+            Some(DepthFormula {
+                terms: vec![(0, 1)],
+                constant: Some(2),
+            }),
+        ),
+        (
+            "I",
+            "S",
+            Some(DepthFormula {
+                terms: vec![(0, 2), (1, 7)],
+                constant: Some(9),
+            }),
+        ),
+        (
+            "I",
+            "LL",
+            Some(DepthFormula {
+                terms: vec![(1, 2)],
+                constant: Some(4),
+            }),
+        ),
+        (
+            "I",
+            "N",
+            Some(DepthFormula {
+                terms: vec![],
+                constant: Some(2),
+            }),
+        ),
+    ];
+    adapter.publish_modules(modules);
+    // loads all structs sequentially
+    for (module_name, struct_name, expected_depth) in structs.iter() {
+        let computed_depth = &adapter
+            .load_struct(
+                &ModuleId::new(
+                    DEFAULT_ACCOUNT,
+                    Identifier::new(module_name.to_string()).unwrap(),
+                ),
+                ident_str!(struct_name),
+            )
+            .depth;
+        assert_eq!(computed_depth, expected_depth);
+    }
+}
+
 #[test]
 fn load_concurrent() {
     let data_store = InMemoryStorage::new();
diff --git a/external-crates/move/move-vm/runtime/src/config.rs b/external-crates/move/move-vm/runtime/src/config.rs
index b076156a3f63f..3f9f7dc7a2318 100644
--- a/external-crates/move/move-vm/runtime/src/config.rs
+++ b/external-crates/move/move-vm/runtime/src/config.rs
@@ -4,6 +4,8 @@
 use move_binary_format::file_format_common::VERSION_MAX;
 use move_bytecode_verifier::{verifier::DEFAULT_MAX_CONSTANT_VECTOR_LEN, VerifierConfig};
 
+pub const DEFAULT_MAX_VALUE_NEST_DEPTH: u64 = 128;
+
 /// Dynamic config options for the Move VM.
 pub struct VMConfig {
     pub verifier: VerifierConfig,
@@ -36,11 +38,14 @@ impl Default for VMConfig {
 pub struct VMRuntimeLimitsConfig {
     /// Maximum number of items that can be pushed into a vec
     pub vector_len_max: u64,
+    /// Maximum value nest depth for structs
+    pub max_value_nest_depth: Option<u64>,
 }
 impl Default for VMRuntimeLimitsConfig {
     fn default() -> Self {
         Self {
             vector_len_max: DEFAULT_MAX_CONSTANT_VECTOR_LEN,
+            max_value_nest_depth: Some(DEFAULT_MAX_VALUE_NEST_DEPTH),
         }
     }
 }
diff --git a/external-crates/move/move-vm/runtime/src/interpreter.rs b/external-crates/move/move-vm/runtime/src/interpreter.rs
index eb0aca46bb5a3..ee22b39deb96d 100644
--- a/external-crates/move/move-vm/runtime/src/interpreter.rs
+++ b/external-crates/move/move-vm/runtime/src/interpreter.rs
@@ -1938,6 +1938,8 @@ impl Frame {
                     }
                     Bytecode::Pack(sd_idx) => {
                         let field_count = resolver.field_count(*sd_idx);
+                        let struct_type = resolver.get_struct_type(*sd_idx);
+                        self.check_depth_of_type(resolver, &struct_type)?;
                         gas_meter.charge_pack(
                             false,
                             interpreter.operand_stack.last_n(field_count as usize)?,
@@ -1949,6 +1951,8 @@ impl Frame {
                     }
                     Bytecode::PackGeneric(si_idx) => {
                         let field_count = resolver.field_instantiation_count(*si_idx);
+                        let ty = resolver.instantiate_generic_type(*si_idx, self.ty_args())?;
+                        self.check_depth_of_type(resolver, &ty)?;
                         gas_meter.charge_pack(
                             true,
                             interpreter.operand_stack.last_n(field_count as usize)?,
@@ -2265,6 +2269,7 @@ impl Frame {
                     }
                     Bytecode::VecPack(si, num) => {
                         let ty = resolver.instantiate_single_type(*si, self.ty_args())?;
+                        self.check_depth_of_type(resolver, &ty)?;
                         gas_meter.charge_vec_pack(
                             make_ty!(&ty),
                             interpreter.operand_stack.last_n(*num as usize)?,
@@ -2384,4 +2389,90 @@ impl Frame {
             Some(id) => Location::Module(id.clone()),
         }
     }
+
+    fn check_depth_of_type(&self, resolver: &Resolver, ty: &Type) -> PartialVMResult<u64> {
+        let Some(max_depth) = resolver
+            .loader()
+            .vm_config()
+            .runtime_limits_config
+            .max_value_nest_depth else {
+            return Ok(1);
+        };
+        self.check_depth_of_type_impl(resolver, ty, 0, max_depth)
+    }
+
+    fn check_depth_of_type_impl(
+        &self,
+        resolver: &Resolver,
+        ty: &Type,
+        current_depth: u64,
+        max_depth: u64,
+    ) -> PartialVMResult<u64> {
+        macro_rules! check_depth {
+            ($additional_depth:expr) => {
+                if current_depth.saturating_add($additional_depth) > max_depth {
+                    return Err(PartialVMError::new(StatusCode::VM_MAX_VALUE_DEPTH_REACHED));
+                } else {
+                    current_depth.saturating_add($additional_depth)
+                }
+            };
+        }
+
+        // Calculate depth of the type itself
+        let ty_depth = match ty {
+            Type::Bool
+            | Type::U8
+            | Type::U16
+            | Type::U32
+            | Type::U64
+            | Type::U128
+            | Type::U256
+            | Type::Address
+            | Type::Signer => check_depth!(1),
+            // Even though this is recursive this is OK since the depth of this recursion is
+            // bounded by the depth of the type arguments, which we have already checked.
+            Type::Reference(ty) | Type::MutableReference(ty) | Type::Vector(ty) => {
+                self.check_depth_of_type_impl(resolver, ty, check_depth!(1), max_depth)?
+            }
+            Type::Struct(si) => {
+                let struct_type = resolver.loader().get_struct_type(*si).ok_or_else(|| {
+                    PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
+                        .with_message("Struct Definition not resolved".to_string())
+                })?;
+                check_depth!(struct_type
+                    .depth
+                    .as_ref()
+                    .ok_or_else(|| { PartialVMError::new(StatusCode::VM_MAX_VALUE_DEPTH_REACHED) })?
+                    .solve(&[])?)
+            }
+            Type::StructInstantiation(si, ty_args) => {
+                // Calculate depth of all type arguments, and make sure they themselves are not too deep.
+                let ty_arg_depths = ty_args
+                    .iter()
+                    .map(|ty| {
+                        // Ty args should be fully resolved and not need any type arguments
+                        self.check_depth_of_type_impl(resolver, ty, check_depth!(0), max_depth)
+                    })
+                    .collect::<PartialVMResult<Vec<_>>>()?;
+                let struct_type = resolver.loader().get_struct_type(*si).ok_or_else(|| {
+                    PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
+                        .with_message("Struct Definition not resolved".to_string())
+                })?;
+                check_depth!(struct_type
+                    .depth
+                    .as_ref()
+                    .ok_or_else(|| { PartialVMError::new(StatusCode::VM_MAX_VALUE_DEPTH_REACHED) })?
+                    .solve(&ty_arg_depths)?)
+            }
+            // NB: substitution must be performed before calling this function
+            Type::TyParam(_) => {
+                return Err(
+                    PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
+                        .with_message("Type parameter should be fully resolved".to_string()),
+                )
+            }
+        };
+
+        Ok(ty_depth)
+    }
 }
diff --git a/external-crates/move/move-vm/runtime/src/loader.rs b/external-crates/move/move-vm/runtime/src/loader.rs
index 50ec8db606615..b8429313f9367 100644
--- a/external-crates/move/move-vm/runtime/src/loader.rs
+++ b/external-crates/move/move-vm/runtime/src/loader.rs
@@ -17,7 +17,7 @@ use move_binary_format::{
         FieldHandleIndex, FieldInstantiationIndex, FunctionDefinition, FunctionDefinitionIndex,
         FunctionHandleIndex, FunctionInstantiationIndex, Signature, SignatureIndex, SignatureToken,
         StructDefInstantiationIndex, StructDefinitionIndex, StructFieldInformation, TableIndex,
-        Visibility,
+        TypeParameterIndex, Visibility,
     },
     IndexKind,
 };
@@ -32,7 +32,7 @@ use move_core_types::{
 };
 use move_vm_types::{
     data_store::DataStore,
-    loaded_data::runtime_types::{CachedStructIndex, StructType, Type},
+    loaded_data::runtime_types::{CachedStructIndex, DepthFormula, StructType, Type},
 };
 use parking_lot::RwLock;
 use sha3::{Digest, Sha3_256};
@@ -297,6 +297,7 @@ impl ModuleCache {
                     defining_id,
                     runtime_id: runtime_id.clone(),
                     struct_def: StructDefinitionIndex(idx as u16),
+                    depth: None,
                 },
             )?;
 
@@ -319,6 +320,8 @@ impl ModuleCache {
             field_types.push(tys);
         }
 
+        let field_types_len = field_types.len();
+
         // Add the field types to the newly added structs, processing them in reverse, to line them
         // up with the structs we added at the end of the global cache.
         for (fields, struct_type) in field_types
@@ -342,6 +345,27 @@ impl ModuleCache {
             }
         }
 
+        let mut depth_cache = BTreeMap::new();
+        for struct_type in self.structs.binaries.iter().rev().take(field_types_len) {
+            self.calculate_depth_of_struct(&struct_type, &mut depth_cache)?;
+        }
+
+        debug_assert!(depth_cache.len() == field_types_len);
+        for (cache_idx, depth) in depth_cache {
+            match Arc::get_mut(self.structs.binaries.get_mut(cache_idx.0).unwrap()) {
+                Some(struct_type) => struct_type.depth = Some(depth),
+                None => {
+                    // we have pending references to the `Arc` which is impossible,
+                    // given the code that adds the `Arc` is above and no reference to
+                    // it should exist.
+                    // So in the spirit of not crashing we log the issue and move on leaving the
+                    // structs depth as `None` -- if we try to access it later we will treat this
+                    // as too deep.
+                    error!("Arc<StructType> cannot have any live reference while publishing");
+                }
+            }
+        }
+
         for (idx, func) in module.function_defs().iter().enumerate() {
             let findex = FunctionDefinitionIndex(idx as TableIndex);
             let mut function = Function::new(natives, findex, func, module);
@@ -366,9 +390,9 @@ impl ModuleCache {
             self.functions.push(Arc::new(function));
         }
 
-        let module = LoadedModule::new(cursor, link_context, storage_id, module, self)?;
+        let loaded_module = LoadedModule::new(cursor, link_context, storage_id, module, self)?;
         self.loaded_modules
-            .insert((link_context, runtime_id), module)
+            .insert((link_context, runtime_id), loaded_module)
     }
 
     // `make_type` is the entry point to "translate" a `SignatureToken` to a `Type`
@@ -383,7 +407,7 @@ impl ModuleCache {
             SignatureToken::U256 => Type::U256,
             SignatureToken::Address => Type::Address,
             SignatureToken::Signer => Type::Signer,
-            SignatureToken::TypeParameter(idx) => Type::TyParam(*idx as usize),
+            SignatureToken::TypeParameter(idx) => Type::TyParam(*idx),
             SignatureToken::Vector(inner_tok) => {
                 Type::Vector(Box::new(self.make_type(module, inner_tok)?))
             }
@@ -423,6 +447,87 @@ impl ModuleCache {
         Ok(res)
     }
 
+    fn calculate_depth_of_struct(
+        &self,
+        struct_type: &StructType,
+        depth_cache: &mut BTreeMap<CachedStructIndex, DepthFormula>,
+    ) -> PartialVMResult<DepthFormula> {
+        let def_idx = self
+            .resolve_struct_by_name(&struct_type.name, &struct_type.runtime_id)?
+            .0;
+
+        // If we've already computed this structs depth, no more work remains to be done.
+        if let Some(form) = &struct_type.depth {
+            return Ok(form.clone());
+        }
+        if let Some(form) = depth_cache.get(&def_idx) {
+            return Ok(form.clone());
+        }
+
+        let formulas = struct_type
+            .fields
+            .iter()
+            .map(|field_type| self.calculate_depth_of_type(field_type, depth_cache))
+            .collect::<PartialVMResult<Vec<_>>>()?;
+        let mut formula = DepthFormula::normalize(formulas);
+        // add 1 for the struct itself
+        formula.add(1);
+        let prev = depth_cache.insert(def_idx, formula.clone());
+        if prev.is_some() {
+            return Err(
+                PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
+                    .with_message("Recursive type?".to_owned()),
+            );
+        }
+        Ok(formula)
+    }
+
+    fn calculate_depth_of_type(
+        &self,
+        ty: &Type,
+        depth_cache: &mut BTreeMap<CachedStructIndex, DepthFormula>,
+    ) -> PartialVMResult<DepthFormula> {
+        Ok(match ty {
+            Type::Bool
+            | Type::U8
+            | Type::U64
+            | Type::U128
+            | Type::Address
+            | Type::Signer
+            | Type::U16
+            | Type::U32
+            | Type::U256 => DepthFormula::constant(1),
+            // we should not see the reference here, we could instead give an invariant violation
+            Type::Vector(ty) | Type::Reference(ty) | Type::MutableReference(ty) => {
+                let mut inner = self.calculate_depth_of_type(ty, depth_cache)?;
+                // add 1 for the vector itself
+                inner.add(1);
+                inner
+            }
+            Type::TyParam(ty_idx) => DepthFormula::type_parameter(*ty_idx),
+            Type::Struct(cache_idx) => {
+                let struct_type = self.struct_at(*cache_idx);
+                let struct_formula = self.calculate_depth_of_struct(&struct_type, depth_cache)?;
+                debug_assert!(struct_formula.terms.is_empty());
+                struct_formula
+            }
+            Type::StructInstantiation(cache_idx, ty_args) => {
+                let struct_type = self.struct_at(*cache_idx);
+                let ty_arg_map = ty_args
+                    .iter()
+                    .enumerate()
+                    .map(|(idx, ty)| {
+                        let var = idx as TypeParameterIndex;
+                        Ok((var, self.calculate_depth_of_type(ty, depth_cache)?))
+                    })
+                    .collect::<PartialVMResult<BTreeMap<_, _>>>()?;
+                let struct_formula = self.calculate_depth_of_struct(&struct_type, depth_cache)?;
+                let subst_struct_formula = struct_formula.subst(ty_arg_map)?;
+                subst_struct_formula
+            }
+        })
+    }
+
     // Given a ModuleId::struct_name, retrieve the `StructType` and the index associated.
     // Return and error if the type has not been loaded
     fn resolve_struct_by_name(
@@ -1179,7 +1284,7 @@ impl Loader {
         // If that number is larger than MAX_TYPE_INSTANTIATION_NODES, refuse to construct this type.
         // This prevents constructing larger and lager types via struct instantiation.
         if let Type::StructInstantiation(_, struct_inst) = ty {
-            let mut sum_nodes: usize = 1;
+            let mut sum_nodes = 1u64;
             for ty in ty_args.iter().chain(struct_inst.iter()) {
                 sum_nodes = sum_nodes.saturating_add(self.count_type_nodes(ty));
                 if sum_nodes > MAX_TYPE_INSTANTIATION_NODES {
@@ -1384,7 +1489,7 @@ impl<'a> Resolver<'a> {
         }
         // Check if the function instantiation over all generics is larger
         // than MAX_TYPE_INSTANTIATION_NODES.
-        let mut sum_nodes: usize = 1;
+        let mut sum_nodes = 1u64;
         for ty in type_params.iter().chain(instantiation.iter()) {
             sum_nodes = sum_nodes.saturating_add(self.loader.count_type_nodes(ty));
             if sum_nodes > MAX_TYPE_INSTANTIATION_NODES {
@@ -1428,8 +1533,8 @@ impl<'a> Resolver<'a> {
         // Before instantiating the type, count the # of nodes of all type arguments plus
         // existing type instantiation.
         // If that number is larger than MAX_TYPE_INSTANTIATION_NODES, refuse to construct this type.
-        // This prevents constructing larger and lager types via struct instantiation.
-        let mut sum_nodes: usize = 1;
+        // This prevents constructing larger and larger types via struct instantiation.
+        let mut sum_nodes = 1u64;
         for ty in ty_args.iter().chain(struct_inst.instantiation.iter()) {
             sum_nodes = sum_nodes.saturating_add(self.loader.count_type_nodes(ty));
             if sum_nodes > MAX_TYPE_INSTANTIATION_NODES {
@@ -2349,8 +2454,8 @@ struct StructInfo {
     defining_struct_tag: Option<StructTag>,
     struct_layout: Option<MoveStructLayout>,
     annotated_struct_layout: Option<MoveStructLayout>,
-    node_count: Option<usize>,
-    annotated_node_count: Option<usize>,
+    node_count: Option<u64>,
+    annotated_node_count: Option<u64>,
 }
 
 #[derive(Copy, Clone, PartialEq, Eq)]
@@ -2385,15 +2490,15 @@ impl TypeCache {
 }
 
 /// Maximal depth of a value in terms of type depth.
-const VALUE_DEPTH_MAX: usize = 128;
+pub const VALUE_DEPTH_MAX: u64 = 128;
 
 /// Maximal nodes which are allowed when converting to layout. This includes the the types of
 /// fields for struct types.
-const MAX_TYPE_TO_LAYOUT_NODES: usize = 256;
+const MAX_TYPE_TO_LAYOUT_NODES: u64 = 256;
 
 /// Maximal nodes which are all allowed when instantiating a generic type. This does not include
 /// field types of structs.
-const MAX_TYPE_INSTANTIATION_NODES: usize = 128;
+const MAX_TYPE_INSTANTIATION_NODES: u64 = 128;
 
 impl Loader {
     fn read_cached_struct_tag(
@@ -2498,7 +2603,7 @@ impl Loader {
         })
     }
 
-    fn count_type_nodes(&self, ty: &Type) -> usize {
+    fn count_type_nodes(&self, ty: &Type) -> u64 {
         let mut todo = vec![ty];
         let mut result = 0;
         while let Some(ty) = todo.pop() {
@@ -2523,8 +2628,8 @@ impl Loader {
         &self,
         gidx: CachedStructIndex,
         ty_args: &[Type],
-        count: &mut usize,
-        depth: usize,
+        count: &mut u64,
+        depth: u64,
     ) -> PartialVMResult<MoveStructLayout> {
         if let Some(struct_map) = self.type_cache.read().structs.get(&gidx) {
             if let Some(struct_info) = struct_map.get(ty_args) {
@@ -2568,8 +2673,8 @@ impl Loader {
     fn type_to_type_layout_impl(
         &self,
         ty: &Type,
-        count: &mut usize,
-        depth: usize,
+        count: &mut u64,
+        depth: u64,
     ) -> PartialVMResult<MoveTypeLayout> {
         if *count > MAX_TYPE_TO_LAYOUT_NODES {
             return Err(PartialVMError::new(StatusCode::TOO_MANY_TYPE_NODES));
@@ -2612,8 +2717,8 @@ impl Loader {
         &self,
         gidx: CachedStructIndex,
         ty_args: &[Type],
-        count: &mut usize,
-        depth: usize,
+        count: &mut u64,
+        depth: u64,
     ) -> PartialVMResult<MoveStructLayout> {
         if let Some(struct_map) = self.type_cache.read().structs.get(&gidx) {
             if let Some(struct_info) = struct_map.get(ty_args) {
@@ -2666,8 +2771,8 @@ impl Loader {
     fn type_to_fully_annotated_layout_impl(
         &self,
         ty: &Type,
-        count: &mut usize,
-        depth: usize,
+        count: &mut u64,
+        depth: u64,
     ) -> PartialVMResult<MoveTypeLayout> {
         if *count > MAX_TYPE_TO_LAYOUT_NODES {
             return Err(PartialVMError::new(StatusCode::TOO_MANY_TYPE_NODES));
diff --git a/external-crates/move/move-vm/transactional-tests/tests/recursion/runtime_layout_deeply_nested.exp b/external-crates/move/move-vm/transactional-tests/tests/recursion/runtime_layout_deeply_nested.exp
index a7ad267396026..a2f8c6fbab4fc 100644
--- a/external-crates/move/move-vm/transactional-tests/tests/recursion/runtime_layout_deeply_nested.exp
+++ b/external-crates/move/move-vm/transactional-tests/tests/recursion/runtime_layout_deeply_nested.exp
@@ -1,19 +1,28 @@
 processed 4 tasks
 
-task 2 'run'. lines 79-86:
+task 1 'run'. lines 75-83:
 Error: Script execution failed with VMError: {
     major_status: VM_MAX_VALUE_DEPTH_REACHED,
     sub_status: None,
     location: 0x42::M,
     indices: [],
-    offsets: [(FunctionDefinitionIndex(8), 3)],
+    offsets: [(FunctionDefinitionIndex(6), 2)],
 }
 
-task 3 'run'. lines 89-97:
+task 2 'run'. lines 85-92:
 Error: Script execution failed with VMError: {
     major_status: VM_MAX_VALUE_DEPTH_REACHED,
     sub_status: None,
     location: 0x42::M,
     indices: [],
-    offsets: [(FunctionDefinitionIndex(9), 4)],
+    offsets: [(FunctionDefinitionIndex(0), 1)],
+}
+
+task 3 'run'. lines 95-103:
+Error: Script execution failed with VMError: {
+    major_status: VM_MAX_VALUE_DEPTH_REACHED,
+    sub_status: None,
+    location: 0x42::M,
+    indices: [],
+    offsets: [(FunctionDefinitionIndex(0), 1)],
 }
diff --git a/external-crates/move/move-vm/transactional-tests/tests/recursion/runtime_layout_deeply_nested.mvir b/external-crates/move/move-vm/transactional-tests/tests/recursion/runtime_layout_deeply_nested.mvir
index 7f2bc48e6bf95..1c04e86cd0310 100644
--- a/external-crates/move/move-vm/transactional-tests/tests/recursion/runtime_layout_deeply_nested.mvir
+++ b/external-crates/move/move-vm/transactional-tests/tests/recursion/runtime_layout_deeply_nested.mvir
@@ -9,6 +9,7 @@ module 0x42.M {
     struct Box31<T> has store { x: Self.Box15<Self.Box15<T>> }
     struct Box63<T> has store { x: Self.Box31<Self.Box31<T>> }
     struct Box127<T> has key, store { x: Self.Box63<Self.Box63<T>> }
+    struct Box128<T> has key, store { x: Self.Box127<T> }
     struct Box255<T> has key, store { x: Self.Box127<Self.Box127<T>> }
 
     public box3<T>(x: T): Self.Box3<T> {
@@ -41,6 +42,11 @@ module 0x42.M {
         return Box127<T> { x: Self.box63<Self.Box63<T>>(Self.box63<T>(move(x))) };
     }
 
+    public box128<T>(x: T): Self.Box128<T> {
+    label b0:
+        return Box128<T> { x: Self.box127<T>(move(x)) };
+    }
+
     public box255<T>(x: T): Self.Box255<T> {
     label b0:
         return Box255<T> { x: Self.box127<Self.Box127<T>>(Self.box127<T>(move(x))) };
@@ -48,7 +54,7 @@ module 0x42.M {
 
     public publish_128(account: &signer) {
     label b0:
-        move_to<Box127<bool>>(move(account), Self.box127<bool>(true));
+        move_to<Box128<bool>>(move(account), Self.box128<bool>(true));
         return;
     }
 
@@ -71,11 +77,11 @@ import 0x42.M;
 
 main(account: signer) {
 label b0:
+    // hits VM_MAX_VALUE_DEPTH_REACHED
     M.publish_128(&account);
     return;
 }
 
-
 //# run --args @0x2
 import 0x42.M;
 
diff --git a/external-crates/move/move-vm/types/src/loaded_data/runtime_types.rs b/external-crates/move/move-vm/types/src/loaded_data/runtime_types.rs
index 25b646bc4b37a..7a694cf2d0278 100644
--- a/external-crates/move/move-vm/types/src/loaded_data/runtime_types.rs
+++ b/external-crates/move/move-vm/types/src/loaded_data/runtime_types.rs
@@ -4,15 +4,125 @@
 
 use move_binary_format::{
     errors::{PartialVMError, PartialVMResult},
-    file_format::{AbilitySet, SignatureToken, StructDefinitionIndex, StructTypeParameter},
+    file_format::{
+        AbilitySet, SignatureToken, StructDefinitionIndex, StructTypeParameter, TypeParameterIndex,
+    },
 };
 use move_core_types::{
     gas_algebra::AbstractMemorySize, identifier::Identifier, language_storage::ModuleId,
     vm_status::StatusCode,
 };
+use std::fmt::Debug;
+use std::{cmp::max, collections::BTreeMap};
 
 pub const TYPE_DEPTH_MAX: usize = 256;
 
+#[derive(PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Debug)]
+/// A formula for the maximum depth of the value for a type
+/// max(Ti + Ci, ..., CBase)
+pub struct DepthFormula {
+    /// The terms for each type parameter, if present.
+    /// Ti + Ci
+    pub terms: Vec<(TypeParameterIndex, u64)>,
+    /// The depth for any non type parameter term, if one exists.
+    /// CBase
+    pub constant: Option<u64>,
+}
+
+impl DepthFormula {
+    /// A value with no type parameters
+    pub fn constant(constant: u64) -> Self {
+        Self {
+            terms: vec![],
+            constant: Some(constant),
+        }
+    }
+
+    /// A stand alone type parameter value
+    pub fn type_parameter(tparam: TypeParameterIndex) -> Self {
+        Self {
+            terms: vec![(tparam, 0)],
+            constant: None,
+        }
+    }
+
+    /// We `max` over a list of formulas, and we normalize it to deal with duplicate terms, e.g.
+    /// `max(max(t1 + 1, t2 + 2, 2), max(t1 + 3, t2 + 1, 4))` becomes
+    /// `max(t1 + 3, t2 + 2, 4)`
+    pub fn normalize(formulas: Vec<Self>) -> Self {
+        let mut var_map = BTreeMap::new();
+        let mut constant_acc = None;
+        for formula in formulas {
+            let Self { terms, constant } = formula;
+            for (var, cur_factor) in terms {
+                var_map
+                    .entry(var)
+                    .and_modify(|prev_factor| *prev_factor = max(cur_factor, *prev_factor))
+                    .or_insert(cur_factor);
+            }
+            match (constant_acc, constant) {
+                (_, None) => (),
+                (None, Some(_)) => constant_acc = constant,
+                (Some(c1), Some(c2)) => constant_acc = Some(max(c1, c2)),
+            }
+        }
+        Self {
+            terms: var_map.into_iter().collect(),
+            constant: constant_acc,
+        }
+    }
+
+    /// Substitute in formulas for each type parameter and normalize the final formula
+    pub fn subst(
+        &self,
+        mut map: BTreeMap<TypeParameterIndex, DepthFormula>,
+    ) -> PartialVMResult<DepthFormula> {
+        let Self { terms, constant } = self;
+        let mut formulas = vec![];
+        if let Some(constant) = constant {
+            formulas.push(DepthFormula::constant(*constant))
+        }
+        for (t_i, c_i) in terms {
+            let Some(mut u_form) = map.remove(t_i) else {
+                return Err(PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR).with_message(format!("{t_i:?} missing mapping")))
+            };
+            u_form.add(*c_i);
+            formulas.push(u_form)
+        }
+        Ok(DepthFormula::normalize(formulas))
+    }
+
+    /// Given depths for each type parameter, solve the formula giving the max depth for the type
+    pub fn solve(&self, tparam_depths: &[u64]) -> PartialVMResult<u64> {
+        let Self { terms, constant } = self;
+        let mut depth = constant.as_ref().copied().unwrap_or(0);
+        for (t_i, c_i) in terms {
+            match tparam_depths.get(*t_i as usize) {
+                None => {
+                    return Err(
+                        PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
+                            .with_message(format!("{t_i:?} missing mapping")),
+                    )
+                }
+                Some(ty_depth) => depth = max(depth, ty_depth.saturating_add(*c_i)),
+            }
+        }
+        Ok(depth)
+    }
+
+    // `max(t_0 + c_0, ..., t_n + c_n, c_base) + c`. But our representation forces us to distribute
+    // the addition, so it becomes `max(t_0 + c_0 + c, ..., t_n + c_n + c, c_base + c)`
+    pub fn add(&mut self, c: u64) {
+        let Self { terms, constant } = self;
+        for (_t_i, c_i) in terms {
+            *c_i = (*c_i).saturating_add(c);
+        }
+        if let Some(cbase) = constant.as_mut() {
+            *cbase = (*cbase).saturating_add(c);
+        }
+    }
+}
+
 #[derive(Debug, Clone, Eq, Hash, Ord, PartialEq, PartialOrd)]
 pub struct StructType {
     pub fields: Vec<Type>,
@@ -23,6 +133,7 @@ pub struct StructType {
     pub defining_id: ModuleId,
     pub runtime_id: ModuleId,
     pub struct_def: StructDefinitionIndex,
+    pub depth: Option<DepthFormula>,
 }
 
 impl StructType {
@@ -47,7 +158,7 @@ pub enum Type {
     StructInstantiation(CachedStructIndex, Vec<Type>),
     Reference(Box<Type>),
     MutableReference(Box<Type>),
-    TyParam(usize),
+    TyParam(u16),
     U16,
     U32,
     U256,
@@ -60,7 +171,7 @@ impl Type {
 
     fn apply_subst<F>(&self, subst: F, depth: usize) -> PartialVMResult<Type>
     where
-        F: Fn(usize, usize) -> PartialVMResult<Type> + Copy,
+        F: Fn(u16, usize) -> PartialVMResult<Type> + Copy,
     {
         if depth > TYPE_DEPTH_MAX {
             return Err(PartialVMError::new(StatusCode::VM_MAX_TYPE_DEPTH_REACHED));
@@ -95,7 +206,7 @@ impl Type {
 
     pub fn subst(&self, ty_args: &[Type]) -> PartialVMResult<Type> {
         self.apply_subst(
-            |idx, depth| match ty_args.get(idx) {
+            |idx, depth| match ty_args.get(idx as usize) {
                 Some(ty) => ty.clone_impl(depth),
                 None => Err(
                     PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
diff --git a/sui-execution/latest/sui-adapter/src/adapter.rs b/sui-execution/latest/sui-adapter/src/adapter.rs
index 568e0c3785b89..831546e6a04b2 100644
--- a/sui-execution/latest/sui-adapter/src/adapter.rs
+++ b/sui-execution/latest/sui-adapter/src/adapter.rs
@@ -92,6 +92,7 @@ pub fn new_move_vm(
             paranoid_type_checks,
             runtime_limits_config: VMRuntimeLimitsConfig {
                 vector_len_max: protocol_config.max_move_vector_len(),
+                max_value_nest_depth: protocol_config.max_move_value_depth_as_option(),
             },
             enable_invariant_violation_check_in_swap_loc: !protocol_config
                 .disable_invariant_violation_check_in_swap_loc(),
