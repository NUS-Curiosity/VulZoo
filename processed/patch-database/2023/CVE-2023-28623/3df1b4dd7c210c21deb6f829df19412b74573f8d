diff --git a/zerver/tests/test_signup.py b/zerver/tests/test_signup.py
index 1870b779a5659..a694675c2ac5d 100644
--- a/zerver/tests/test_signup.py
+++ b/zerver/tests/test_signup.py
@@ -4997,6 +4997,70 @@ def test_ldap_populate_only_registration_from_confirmation(self) -> None:
             # EmailAuthBackend, there should be password field here.
             self.assert_in_success_response(["id_password"], result)
 
+    @override_settings(
+        AUTHENTICATION_BACKENDS=(
+            "zproject.backends.SAMLAuthBackend",
+            "zproject.backends.ZulipLDAPAuthBackend",
+            "zproject.backends.ZulipDummyBackend",
+        )
+    )
+    def test_ldap_registration_email_backend_disabled_bypass_attempt(self) -> None:
+        """
+        Tests for the case of LDAP + external auth backend being the ones enabled and
+        a user using the registration page to get a confirmation link and then trying
+        to use it to create a new account with their own email that's not authenticated
+        by either of the backends.
+        """
+        email = "no_such_user_in_ldap@example.com"
+        subdomain = "zulip"
+
+        self.init_default_ldap_database()
+        ldap_user_attr_map = {"full_name": "cn"}
+        full_name = "New LDAP fullname"
+
+        result = self.client_post("/register/", {"email": email}, subdomain=subdomain)
+
+        self.assertEqual(result.status_code, 302)
+        self.assertTrue(result["Location"].endswith(f"/accounts/send_confirm/{email}"))
+        result = self.client_get(result["Location"])
+        self.assert_in_response("Check your email", result)
+
+        with self.settings(
+            POPULATE_PROFILE_VIA_LDAP=True,
+            LDAP_APPEND_DOMAIN="zulip.com",
+            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,
+        ):
+            # Click confirmation link
+            result = self.submit_reg_form_for_user(
+                email,
+                None,
+                full_name="Ignore",
+                from_confirmation="1",
+                # Pass HTTP_HOST for the target subdomain
+                HTTP_HOST=subdomain + ".testserver",
+            )
+
+            self.assert_in_success_response(
+                ["We just need you to do one last thing.", email], result
+            )
+
+            # Submit the final form, attempting to register the user despite
+            # no match in ldap.
+            result = self.submit_reg_form_for_user(
+                email,
+                "newpassword",
+                full_name=full_name,
+                # Pass HTTP_HOST for the target subdomain
+                HTTP_HOST=subdomain + ".testserver",
+            )
+            # Didn't create an account
+            with self.assertRaises(UserProfile.DoesNotExist):
+                UserProfile.objects.get(delivery_email=email)
+            self.assertEqual(result.status_code, 302)
+            self.assertEqual(
+                result["Location"], "/accounts/login/?email=no_such_user_in_ldap%40example.com"
+            )
+
     @override_settings(
         AUTHENTICATION_BACKENDS=(
             "zproject.backends.ZulipLDAPAuthBackend",
diff --git a/zerver/views/registration.py b/zerver/views/registration.py
index aebfd85eaa73e..69a4e886d520c 100644
--- a/zerver/views/registration.py
+++ b/zerver/views/registration.py
@@ -394,9 +394,32 @@ def accounts_register(
                 return_data=return_data,
             )
             if user is None:
-                can_use_different_backend = email_auth_enabled(realm) or (
-                    len(get_external_method_dicts(realm)) > 0
-                )
+                # This logic is security-sensitive. The user has NOT been successfully authenticated
+                # with LDAP and we need to carefully decide whether they should be permitted to proceed
+                # with account creation anyway or be stopped. There are three scenarios to consider:
+                #
+                # 1. EmailAuthBackend is enabled for the realm. That explicitly means that a user
+                #    with a valid confirmation link should be able to create an account, because
+                #    they were invited or organization permissions allowed sign up.
+                # 2. EmailAuthBackend is disabled - that means the organization wants to be authenticating
+                #    users with an external source (LDAP or one of the ExternalAuthMethods). If the user
+                #    came here through one of the ExternalAuthMethods, their identity can be considered
+                #    verified and account creation can proceed.
+                # 3. EmailAuthBackend is disabled and the user did not come here through an ExternalAuthMethod.
+                #    That means they came here by entering their email address on the registration page
+                #    and clicking the confirmation link received. That means their identity needs to be
+                #    verified with LDAP - and that has just failed above. Thus the account should NOT be
+                #    created.
+                #
+                if email_auth_enabled(realm):
+                    can_use_different_backend = True
+                # We can identify the user came here through an ExternalAuthMethod by password_required
+                # being set to False on the PreregistrationUser object.
+                elif len(get_external_method_dicts(realm)) > 0 and not password_required:
+                    can_use_different_backend = True
+                else:
+                    can_use_different_backend = False
+
                 if settings.LDAP_APPEND_DOMAIN:
                     # In LDAP_APPEND_DOMAIN configurations, we don't allow making a non-LDAP account
                     # if the email matches the ldap domain.
