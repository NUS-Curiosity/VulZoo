diff --git a/deps/picotls/include/picotls.h b/deps/picotls/include/picotls.h
index b701e780b2..04b885a922 100644
--- a/deps/picotls/include/picotls.h
+++ b/deps/picotls/include/picotls.h
@@ -922,6 +922,13 @@ struct st_ptls_context_t {
      * (optional) list of supported tls12 cipher-suites terminated by NULL
      */
     ptls_cipher_suite_t **tls12_cipher_suites;
+    /**
+     * (optional) session ID Context to segment resumption
+     */
+    struct {
+        uint8_t bytes[PTLS_SHA256_DIGEST_SIZE];
+        uint8_t is_set : 1;
+    } ticket_context;
 };
 
 typedef struct st_ptls_raw_extension_t {
diff --git a/deps/picotls/lib/picotls.c b/deps/picotls/lib/picotls.c
index 34588cd167..6857188012 100644
--- a/deps/picotls/lib/picotls.c
+++ b/deps/picotls/lib/picotls.c
@@ -1706,10 +1706,13 @@ static int encode_session_identifier(ptls_context_t *ctx, ptls_buffer_t *buf, ui
         ptls_buffer_push16(buf, csid);
         /* ticket_age_add */
         ptls_buffer_push32(buf, ticket_age_add);
-        /* server-name */
+        /* session ID context */
         ptls_buffer_push_block(buf, 2, {
-            if (server_name != NULL)
+            if (ctx->ticket_context.is_set) {
+                ptls_buffer_pushv(buf, ctx->ticket_context.bytes, sizeof(ctx->ticket_context.bytes));
+            } else if (server_name != NULL) {
                 ptls_buffer_pushv(buf, server_name, strlen(server_name));
+            }
         });
         /* alpn */
         ptls_buffer_push_block(buf, 1, {
@@ -1722,7 +1725,7 @@ static int encode_session_identifier(ptls_context_t *ctx, ptls_buffer_t *buf, ui
     return ret;
 }
 
-int decode_session_identifier(uint64_t *issued_at, ptls_iovec_t *psk, uint32_t *ticket_age_add, ptls_iovec_t *server_name,
+int decode_session_identifier(uint64_t *issued_at, ptls_iovec_t *psk, uint32_t *ticket_age_add, ptls_iovec_t *ticket_ctx,
                               uint16_t *key_exchange_id, uint16_t *csid, ptls_iovec_t *negotiated_protocol, const uint8_t *src,
                               const uint8_t *const end)
 {
@@ -1748,7 +1751,7 @@ int decode_session_identifier(uint64_t *issued_at, ptls_iovec_t *psk, uint32_t *
         if ((ret = ptls_decode32(ticket_age_add, &src, end)) != 0)
             goto Exit;
         ptls_decode_open_block(src, end, 2, {
-            *server_name = ptls_iovec_init(src, end - src);
+            *ticket_ctx = ptls_iovec_init(src, end - src);
             src = end;
         });
         ptls_decode_open_block(src, end, 1, {
@@ -4006,7 +4009,7 @@ static int try_psk_handshake(ptls_t *tls, size_t *psk_index, int *accept_early_d
                              ptls_iovec_t ch_trunc)
 {
     ptls_buffer_t decbuf;
-    ptls_iovec_t ticket_psk, ticket_server_name, ticket_negotiated_protocol;
+    ptls_iovec_t ticket_psk, ticket_ctx, ticket_negotiated_protocol;
     uint64_t issue_at, now = tls->ctx->get_time->cb(tls->ctx->get_time);
     uint32_t age_add;
     uint16_t ticket_key_exchange_id, ticket_csid;
@@ -4029,7 +4032,7 @@ static int try_psk_handshake(ptls_t *tls, size_t *psk_index, int *accept_early_d
         default: /* decryption failure */
             continue;
         }
-        if (decode_session_identifier(&issue_at, &ticket_psk, &age_add, &ticket_server_name, &ticket_key_exchange_id, &ticket_csid,
+        if (decode_session_identifier(&issue_at, &ticket_psk, &age_add, &ticket_ctx, &ticket_key_exchange_id, &ticket_csid,
                                       &ticket_negotiated_protocol, decbuf.base, decbuf.base + decbuf.off) != 0)
             continue;
         /* check age */
@@ -4046,15 +4049,22 @@ static int try_psk_handshake(ptls_t *tls, size_t *psk_index, int *accept_early_d
             if (tls->ctx->max_early_data_size != 0 && delta <= PTLS_EARLY_DATA_MAX_DELAY)
                 *accept_early_data = 1;
         }
-        /* check server-name */
-        if (ticket_server_name.len != 0) {
-            if (tls->server_name == NULL)
-                continue;
-            if (!vec_is_string(ticket_server_name, tls->server_name))
+        /* check ticket context */
+        if (tls->ctx->ticket_context.is_set) {
+            if (!(ticket_ctx.len == sizeof(tls->ctx->ticket_context.bytes) &&
+                  memcmp(ticket_ctx.base, tls->ctx->ticket_context.bytes, ticket_ctx.len) == 0))
                 continue;
         } else {
-            if (tls->server_name != NULL)
-                continue;
+            /* check server-name */
+            if (ticket_ctx.len != 0) {
+                if (tls->server_name == NULL)
+                    continue;
+                if (!vec_is_string(ticket_ctx, tls->server_name))
+                    continue;
+            } else {
+                if (tls->server_name != NULL)
+                    continue;
+            }
         }
         { /* check key-exchange */
             ptls_key_exchange_algorithm_t **a;
diff --git a/h2o.xcodeproj/project.pbxproj b/h2o.xcodeproj/project.pbxproj
index 794039cb71..b5d828f97a 100644
--- a/h2o.xcodeproj/project.pbxproj
+++ b/h2o.xcodeproj/project.pbxproj
@@ -698,6 +698,7 @@
 		0821950F2685262B00E3EFCF /* cc-pico.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = "cc-pico.c"; sourceTree = "<group>"; };
 		0829879326E1F3530053638F /* rate.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = rate.h; sourceTree = "<group>"; };
 		0829879526E1F3700053638F /* rate.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = rate.c; sourceTree = "<group>"; };
+		082B0FF52AAAE83A0091B1D5 /* 80resume-context.t */ = {isa = PBXFileReference; lastKnownFileType = text; path = "80resume-context.t"; sourceTree = "<group>"; xcLanguageSpecificationIdentifier = xcode.lang.perl; };
 		082E148C2692F51000603AED /* driver.cc */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.cpp.cpp; path = driver.cc; sourceTree = "<group>"; };
 		082E1B402692F52100603AED /* driver_common.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = driver_common.h; sourceTree = "<group>"; };
 		082E1B412692F52100603AED /* quicly_mock.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = quicly_mock.h; sourceTree = "<group>"; };
@@ -2389,6 +2390,7 @@
 				10952D591C5082F7000D664C /* 80issues-from-proxy-reproxy-to-different-host.t */,
 				E9BCE6911FF326AC003CEA11 /* 80no-handler-vs-h2-post.t */,
 				109EEFD81D77B336001F11D1 /* 80one-byte-window.t */,
+				082B0FF52AAAE83A0091B1D5 /* 80resume-context.t */,
 				106530A81D8A21A7005B2C60 /* 80reverse-proxy-missing-content-length-for-post.t */,
 				E9414F8F24ED1D5300273C59 /* 80reverse-proxy-truncated-chunked.t */,
 				10B6D4501C727315005F0CF8 /* 80yaml-merge.t */,
diff --git a/src/main.c b/src/main.c
index b0efef9821..a8da6eae11 100644
--- a/src/main.c
+++ b/src/main.c
@@ -1399,6 +1399,12 @@ static const char *listener_setup_ssl_picotls(struct listener_config_t *listener
         pctx->ctx.emit_certificate = NULL;
     }
 
+    /* setup session ticket context so that resumption will succeed only against the same certificate */
+    assert(sizeof(pctx->ctx.ticket_context.bytes) == PTLS_SHA256_DIGEST_SIZE);
+    ptls_calc_hash(&ptls_openssl_sha256, pctx->ctx.ticket_context.bytes, pctx->ctx.certificates.list[0].base,
+                   pctx->ctx.certificates.list[0].len);
+    pctx->ctx.ticket_context.is_set = 1;
+
     if (listener->quic.ctx != NULL) {
 #if H2O_USE_FUSION
         /* rebuild and replace the cipher suite list, replacing the corresponding ones to fusion */
@@ -1583,6 +1589,18 @@ static int load_ssl_identity(h2o_configurator_command_t *cmd, SSL_CTX *ssl_ctx,
         assert(ret == 1);
     }
 
+    /* set session resumption context so that resumption will succeed only against the same certificate */
+    if (raw_pubkey_count == 0) {
+        uint8_t session_ctx[SSL_MAX_SID_CTX_LENGTH];
+        unsigned session_ctx_len;
+        H2O_BUILD_ASSERT(sizeof(session_ctx) == SHA256_DIGEST_LENGTH);
+        int ret = X509_digest(SSL_CTX_get0_certificate(ssl_ctx), EVP_sha256(), session_ctx, &session_ctx_len);
+        assert(ret == 1);
+        assert(session_ctx_len == sizeof(session_ctx));
+        ret = SSL_CTX_set_session_id_context(ssl_ctx, session_ctx, sizeof(session_ctx));
+        assert(ret == 1);
+    }
+
     return 0;
 }
 
@@ -2067,7 +2085,6 @@ static int listener_setup_ssl(h2o_configurator_command_t *cmd, h2o_configurator_
         }
 #endif
 
-        SSL_CTX_set_session_id_context(identity->ossl, H2O_SESSID_CTX, H2O_SESSID_CTX_LEN);
         setup_ecc_key(identity->ossl);
         if (cipher_suite != NULL && SSL_CTX_set_cipher_list(identity->ossl, (*cipher_suite)->data.scalar) != 1) {
             h2o_configurator_errprintf(cmd, *cipher_suite, "failed to setup SSL cipher suite\n");
diff --git a/src/ssl.c b/src/ssl.c
index 7e69267c23..ef377dd01c 100644
--- a/src/ssl.c
+++ b/src/ssl.c
@@ -140,7 +140,6 @@ static void setup_cache_enable(SSL_CTX **contexts, size_t num_contexts, int asyn
     size_t i;
     for (i = 0; i != num_contexts; ++i) {
         SSL_CTX_set_session_cache_mode(contexts[i], SSL_SESS_CACHE_SERVER | SSL_SESS_CACHE_NO_AUTO_CLEAR);
-        SSL_CTX_set_session_id_context(contexts[i], H2O_SESSID_CTX, H2O_SESSID_CTX_LEN);
         SSL_CTX_set_timeout(contexts[i], conf.lifetime);
         if (async_resumption)
             h2o_socket_ssl_async_resumption_setup_ctx(contexts[i]);
diff --git a/t/80resume-context.t b/t/80resume-context.t
new file mode 100644
index 0000000000..886c697bdc
--- /dev/null
+++ b/t/80resume-context.t
@@ -0,0 +1,128 @@
+use strict;
+use warnings;
+use File::Temp qw(tempdir);
+use Net::EmptyPort qw(check_port);
+use Test::More;
+use t::Util;
+
+plan skip_all => 'openssl not found'
+    unless prog_exists('openssl');
+
+my $tempdir = tempdir(CLEANUP => 1);
+
+diag `openssl version`;
+
+# first port serves index.txt, alt port serves alice.txt
+my ($local_port, $alt_port) = (empty_port(), empty_port());
+my $server = spawn_h2o_raw(<< "EOT", [$local_port, $alt_port]);
+hosts:
+  localhost.examp1e.net:
+    listen:
+      host: 127.0.0.1
+      port: $local_port
+      ssl:
+        key-file: examples/h2o/server.key
+        certificate-file: examples/h2o/server.crt
+    paths:
+      /:
+        file.file: t/assets/doc_root/index.txt
+  alternate.localhost.examp1e.net:
+    listen:
+      host: 127.0.0.1
+      port: $alt_port
+      ssl:
+        key-file: examples/h2o/alternate.key
+        certificate-file: examples/h2o/alternate.crt
+    paths:
+      /:
+        file.file: t/assets/doc_root/alice.txt
+EOT
+
+subtest "tls/1.2-session-id" => sub {
+    subtest "without-sni" => sub {
+        run_tests("-tls1_2 -no_ticket");
+    };
+    subtest "with-sni" => sub {
+        run_tests("-tls1_2 -no_ticket -servername localhost.examp1e.net");
+    };
+};
+
+subtest "tls/1.2-ticket" => sub {
+    subtest "without-sni" => sub {
+        run_tests("-tls1_2");
+    };
+    subtest "with-sni" => sub {
+        run_tests("-tls1_2 -servername localhost.examp1e.net");
+    };
+};
+subtest "tls/1.3-ticket" => sub {
+    plan skip_all => "openssl s_client does not support tls/1.3"
+        unless openssl_supports_tls13();
+    subtest "without-sni" => sub {
+        run_tests("-tls1_3");
+    };
+    subtest "with-sni" => sub {
+        run_tests("-tls1_3 -servername localhost.examp1e.net");
+    };
+};
+
+done_testing;
+
+sub run_tests {
+    my $opts = shift;
+    unlink "$tempdir/session";
+    subtest "full handshake" => sub {
+        my $output = run_client("$opts -sess_out $tempdir/session -connect 127.0.0.1:$local_port", "localhost.examp1e.net");
+        is get_common_name($output), "localhost.examp1e.net", "common name";
+        like get_resp($output), qr/^hello/s, "response";
+    };
+    subtest "resume same port" => sub {
+        my $output = run_client("$opts -sess_in $tempdir/session -connect 127.0.0.1:$local_port", "localhost.examp1e.net");
+        is get_common_name($output), "localhost.examp1e.net", "common name";
+        like get_resp($output), qr/^hello/s, "response";
+    };
+    subtest "resume alt port" => sub {
+        my $output = run_client("$opts -sess_in $tempdir/session -connect 127.0.0.1:$alt_port", "localhost.examp1e.net");
+        is get_common_name($output), "alternate.localhost.examp1e.net", "common name";
+        like get_resp($output), qr/^Alice/s, "response";
+    };
+};
+
+sub run_client {
+    my ($ossl_opts, $authority) = @_;
+
+    diag $ossl_opts;
+    #sleep 100 if $ossl_opts =~ /tls1_3.*servername.*sess_in/;
+    my $pid = open my $fh, "|-", "exec openssl s_client $ossl_opts > $tempdir/out 2>&1"
+        or die "failed to spawn s_client:$?";
+    $fh->autoflush(1);
+    print $fh "GET / HTTP/1.0\r\nHost: $authority\r\n\r\n";
+
+    while (waitpid($pid, 0) != $pid) {}
+
+    close $fh;
+
+    open $fh, "<", "$tempdir/out"
+        or die "failed to open $tempdir/out:$!";
+    my $output = do {
+        local $/;
+        <$fh>;
+    };
+    $output =~ /(.*read \d+ bytes.*)/m
+        and diag $1;
+    $output;
+}
+
+sub get_common_name {
+    my $s = shift;
+    $s =~ m{^subject=/?CN\s*=\s*(.*)}m
+        or die "failed to extract common name from text:\n$s";
+    $1;
+}
+
+sub get_resp {
+    my $s = shift;
+    $s =~ m{\nHTTP/1.1 200 OK\r\n(.*?)\r\n\r\n}s
+        or die "failed to locate HTTP response in text:\n$s";
+    $';
+}
