diff --git a/include/hermes/BCGen/HBC/BytecodeProviderFromSrc.h b/include/hermes/BCGen/HBC/BytecodeProviderFromSrc.h
index 070af43dcff..5a5020ff690 100644
--- a/include/hermes/BCGen/HBC/BytecodeProviderFromSrc.h
+++ b/include/hermes/BCGen/HBC/BytecodeProviderFromSrc.h
@@ -219,7 +219,7 @@ class BCProviderLazy final : public BCProviderBase {
 
   /// No debug information will be available without compiling it.
   void createDebugInfo() override {
-    llvm_unreachable("Accessing debug info from a lazy module");
+    hermes_fatal("Accessing debug info from a lazy module");
   }
 
  public:
@@ -234,20 +234,20 @@ class BCProviderLazy final : public BCProviderBase {
   }
 
   StringTableEntry getStringTableEntry(uint32_t index) const override {
-    llvm_unreachable("Accessing string table from a lazy module");
+    hermes_fatal("Accessing string table from a lazy module");
   }
 
   const uint8_t *getBytecode(uint32_t) const override {
-    llvm_unreachable("Accessing bytecode from a lazy module");
+    hermes_fatal("Accessing bytecode from a lazy module");
   }
 
   llvh::ArrayRef<hbc::HBCExceptionHandlerInfo> getExceptionTable(
       uint32_t) const override {
-    llvm_unreachable("Accessing exception info from a lazy module");
+    hermes_fatal("Accessing exception info from a lazy module");
   }
 
   const hbc::DebugOffsets *getDebugOffsets(uint32_t) const override {
-    llvm_unreachable("Accessing debug offsets from a lazy module");
+    hermes_fatal("Accessing debug offsets from a lazy module");
   }
 
   bool isFunctionLazy(uint32_t) const override {
diff --git a/lib/VM/JSLib/HermesInternal.cpp b/lib/VM/JSLib/HermesInternal.cpp
index d957660cd73..3d8c308a624 100644
--- a/lib/VM/JSLib/HermesInternal.cpp
+++ b/lib/VM/JSLib/HermesInternal.cpp
@@ -574,14 +574,18 @@ static CallResult<HermesValue> getCodeBlockFileName(
     const CodeBlock *codeBlock,
     OptValue<hbc::DebugSourceLocation> location) {
   RuntimeModule *runtimeModule = codeBlock->getRuntimeModule();
-  if (location) {
-    auto debugInfo = runtimeModule->getBytecode()->getDebugInfo();
-    return StringPrimitive::createEfficient(
-        runtime, debugInfo->getFilenameByID(location->filenameId));
-  } else {
-    llvh::StringRef sourceURL = runtimeModule->getSourceURL();
-    if (!sourceURL.empty()) {
-      return StringPrimitive::createEfficient(runtime, sourceURL);
+  if (!runtimeModule->getBytecode()->isLazy()) {
+    // Lazy code blocks do not have debug information (and will hermes_fatal if
+    // you try to access it), so only touch it for non-lazy blocks.
+    if (location) {
+      auto debugInfo = runtimeModule->getBytecode()->getDebugInfo();
+      return StringPrimitive::createEfficient(
+          runtime, debugInfo->getFilenameByID(location->filenameId));
+    } else {
+      llvh::StringRef sourceURL = runtimeModule->getSourceURL();
+      if (!sourceURL.empty()) {
+        return StringPrimitive::createEfficient(runtime, sourceURL);
+      }
     }
   }
   return HermesValue::encodeUndefinedValue();
@@ -803,6 +807,24 @@ hermesInternalFuzzilli(void *, Runtime &runtime, NativeArgs args) {
 }
 #endif // HERMES_ENABLE_FUZZILLI
 
+static CallResult<HermesValue>
+hermesInternalIsLazy(void *, Runtime &runtime, NativeArgs args) {
+  auto callable = args.dyncastArg<Callable>(0);
+  if (!callable) {
+    return HermesValue::encodeBoolValue(false);
+  }
+
+  auto codeBlock = getLeafCodeBlock(callable, runtime);
+  if (!codeBlock) {
+    // Native function is never lazy.
+    return HermesValue::encodeBoolValue(false);
+  }
+
+  RuntimeModule *runtimeModule = codeBlock->getRuntimeModule();
+  return HermesValue::encodeBoolValue(
+      runtimeModule && runtimeModule->getBytecode()->isLazy());
+}
+
 Handle<JSObject> createHermesInternalObject(
     Runtime &runtime,
     const JSLibFlags &flags) {
@@ -912,6 +934,7 @@ Handle<JSObject> createHermesInternalObject(
     defineInternMethod(
         P::copyDataProperties, hermesBuiltinCopyDataProperties, 3);
     defineInternMethodAndSymbol("isProxy", hermesInternalIsProxy);
+    defineInternMethodAndSymbol("isLazy", hermesInternalIsLazy);
     defineInternMethod(P::drainJobs, hermesInternalDrainJobs);
   }
 
diff --git a/test/hermes/regress-hermes-internal-get-lazy-function-location.js b/test/hermes/regress-hermes-internal-get-lazy-function-location.js
new file mode 100644
index 00000000000..3507d51c3dd
--- /dev/null
+++ b/test/hermes/regress-hermes-internal-get-lazy-function-location.js
@@ -0,0 +1,35 @@
+/**
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+// RUN: %hermes -g --lazy --Xhermes-internal-test-methods -O %s | %FileCheck %s
+// RUN: %hermes -g --lazy --Xhermes-internal-test-methods -O0 %s | %FileCheck %s
+
+"use strict";
+
+// isLazy should be able to handle native functions.
+print(HermesInternal.isLazy(print));
+// CHECK: false
+
+// isLazy should be able to handle non-callables.
+print(HermesInternal.isLazy(10));
+// CHECK: false
+
+function lazyFunc() {}
+
+print(HermesInternal.isLazy(lazyFunc));
+// CHECK: true
+
+print(JSON.stringify(HermesInternal.getFunctionLocation(lazyFunc)));
+// CHECK: {"isNative":false,"lineNumber":21,"columnNumber":1}
+
+lazyFunc();
+
+print(HermesInternal.isLazy(lazyFunc));
+// CHECK: false
+
+print(JSON.stringify(HermesInternal.getFunctionLocation(lazyFunc)));
+// CHECK: {"isNative":false,"lineNumber":21,"columnNumber":1,"fileName":"{{.*}}regress-hermes-internal-get-lazy-function-location.js"}
