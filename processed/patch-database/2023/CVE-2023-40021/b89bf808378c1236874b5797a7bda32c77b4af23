diff --git a/core/controllers/base.py b/core/controllers/base.py
index 3ccbe4e1794b..e8291c7fab7e 100755
--- a/core/controllers/base.py
+++ b/core/controllers/base.py
@@ -902,12 +902,18 @@ def init_csrf_secret(cls) -> None:
             base64.urlsafe_b64encode(os.urandom(20)))
 
     @classmethod
-    def _create_token(cls, user_id: Optional[str], issued_on: float) -> str:
+    def _create_token(
+            cls, user_id: Optional[str], issued_on: float,
+            nonce: Optional[str] = None) -> str:
         """Creates a new CSRF token.
 
         Args:
             user_id: str|None. The user_id for which the token is generated.
             issued_on: float. The timestamp at which the token was issued.
+            nonce: str|None. A token that is never reused to prevent reply
+                attacks. This argument should only be provided when validating a
+                received CSRF token, in which case the nonce in the received
+                token should be provided here.
 
         Returns:
             str. The generated CSRF token.
@@ -923,19 +929,31 @@ def _create_token(cls, user_id: Optional[str], issued_on: float) -> str:
         # Round time to seconds.
         issued_on_str = str(int(issued_on))
 
+        # Generate a nonce (number used once) to ensure that even two
+        # consecutive calls to the same endpoint in the same second generate
+        # different tokens. Note that this nonce is just for anti-collision
+        # purposes, so it's okay that the nonce is stored in the CSRF token and
+        # therefore can be controlled by an attacker. See OWASP guidance here:
+        # https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#signed-double-submit-cookie.
+        if nonce is None:
+            nonce = base64.urlsafe_b64encode(os.urandom(20)).decode('utf-8')
+
         digester = hmac.new(
             key=CSRF_SECRET.value.encode('utf-8'),
-            digestmod='md5'
+            digestmod='sha256'
         )
         digester.update(user_id.encode('utf-8'))
         digester.update(b':')
         digester.update(issued_on_str.encode('utf-8'))
+        digester.update(b':')
+        digester.update(nonce.encode('utf-8'))
 
         digest = digester.digest()
         # The b64encode returns bytes, so we first need to decode the returned
         # bytes to string.
-        token = '%s/%s' % (
-            issued_on_str, base64.urlsafe_b64encode(digest).decode('utf-8'))
+        token = '%s/%s/%s' % (
+            issued_on_str, nonce,
+            base64.urlsafe_b64encode(digest).decode('utf-8'))
 
         return token
 
@@ -973,7 +991,7 @@ def is_csrf_token_valid(cls, user_id: Optional[str], token: str) -> bool:
         """
         try:
             parts = token.split('/')
-            if len(parts) != 2:
+            if len(parts) != 3:
                 return False
 
             issued_on = int(parts[0])
@@ -981,8 +999,12 @@ def is_csrf_token_valid(cls, user_id: Optional[str], token: str) -> bool:
             if age > cls._CSRF_TOKEN_AGE_SECS:
                 return False
 
-            authentic_token = cls._create_token(user_id, issued_on)
-            if authentic_token == token:
+            nonce = parts[1]
+
+            authentic_token = cls._create_token(user_id, issued_on, nonce)
+            if hmac.compare_digest(
+                authentic_token.encode('utf-8'), token.encode('utf-8')
+            ):
                 return True
 
             return False
diff --git a/core/controllers/base_test.py b/core/controllers/base_test.py
index df3e489b7f5e..d622a93827b2 100644
--- a/core/controllers/base_test.py
+++ b/core/controllers/base_test.py
@@ -743,7 +743,7 @@ def test_create_and_validate_token(self) -> None:
         self.assertFalse(
             base.CsrfTokenManager.is_csrf_token_valid(uid, 'new_token'))
         self.assertFalse(
-            base.CsrfTokenManager.is_csrf_token_valid(uid, 'new/token'))
+            base.CsrfTokenManager.is_csrf_token_valid(uid, 'a/new/token'))
 
     def test_non_default_csrf_secret_is_used(self) -> None:
         base.CsrfTokenManager.create_csrf_token('uid')
