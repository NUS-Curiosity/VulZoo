diff --git a/.circleci/config.yml b/.circleci/config.yml
index dfc2fb9db..d10fa4f3d 100644
--- a/.circleci/config.yml
+++ b/.circleci/config.yml
@@ -519,7 +519,8 @@ jobs:
 
                     set -e
                     INTEGRATION_ID=$(uuidgen)
-                    kubectl create secret generic snyk-monitor -n snyk-monitor --from-literal=integrationId=${INTEGRATION_ID} --from-literal=dockercfg.json={}
+                    SERVICE_ACCOUNT_API_TOKEN=$(uuidgen)
+                    kubectl create secret generic snyk-monitor -n snyk-monitor --from-literal=integrationId=${INTEGRATION_ID} --from-literal=serviceAccountApiToken=${SERVICE_ACCOUNT_API_TOKEN} --from-literal=dockercfg.json={}
                 name: Configure snyk-monitor namespace
             - run:
                 command: |
diff --git a/.circleci/config/jobs/operator_upgrade_tests.yml b/.circleci/config/jobs/operator_upgrade_tests.yml
index f48ac89d0..fdb3a259e 100644
--- a/.circleci/config/jobs/operator_upgrade_tests.yml
+++ b/.circleci/config/jobs/operator_upgrade_tests.yml
@@ -120,7 +120,8 @@ steps:
 
         set -e
         INTEGRATION_ID=$(uuidgen)
-        kubectl create secret generic snyk-monitor -n snyk-monitor --from-literal=integrationId=${INTEGRATION_ID} --from-literal=dockercfg.json={}
+        SERVICE_ACCOUNT_API_TOKEN=$(uuidgen)
+        kubectl create secret generic snyk-monitor -n snyk-monitor --from-literal=integrationId=${INTEGRATION_ID} --from-literal=serviceAccountApiToken=${SERVICE_ACCOUNT_API_TOKEN} --from-literal=dockercfg.json={}
 
   - run:
       name: Install Operator
diff --git a/README.md b/README.md
index 0cc7c4d7f..893b47936 100644
--- a/README.md
+++ b/README.md
@@ -10,7 +10,7 @@ A containerized application that is deployed with Helm. Monitors the security of
 ## Prerequisites ##
 
 * 50 GiB of storage in the form of [emptyDir](https://kubernetes.io/docs/concepts/storage/volumes/#emptydir) or a [PersistentVolumeClaim](https://kubernetes.io/docs/concepts/storage/persistent-volumes/).
-* External internet access from the Kubernetes cluster to `kubernetes-upstream.snyk.io`.
+* External internet access from the Kubernetes cluster to `api.snyk.io`.
 * 1 CPU, 2 GiB RAM
 * 1 Kubernetes worker node of type `linux/amd64` - supported and tested only on the AMD64 CPU architecture
 
diff --git a/config.default.json b/config.default.json
index c8f6ae04d..072d4061c 100644
--- a/config.default.json
+++ b/config.default.json
@@ -19,7 +19,8 @@
   "REQUEST_QUEUE_LENGTH": 2,
   "QUEUE_LENGTH_LOG_FREQUENCY_MINUTES": 1,
   "INTEGRATION_ID": "",
-  "DEFAULT_KUBERNETES_UPSTREAM_URL": "https://kubernetes-upstream.snyk.io",
+  "SERVICE_ACCOUNT_API_TOKEN": "",
+  "DEFAULT_KUBERNETES_UPSTREAM_URL": "https://api.snyk.io/v2/kubernetes-upstream",
   "MAX_RETRY_BACKOFF_DURATION_SECONDS": 300,
   "USE_KEEPALIVE": true
 }
diff --git a/scripts/circleci-jobs/deploy_to_dev.sh b/scripts/circleci-jobs/deploy_to_dev.sh
index 71de46cb5..28487f10f 100755
--- a/scripts/circleci-jobs/deploy_to_dev.sh
+++ b/scripts/circleci-jobs/deploy_to_dev.sh
@@ -20,7 +20,7 @@ cp -r snyk-monitor/* $KUBERNETES_MONITOR_DEPLOYER_REPO/helm
 # Create helm values for different envs
 cat >$KUBERNETES_MONITOR_DEPLOYER_REPO/helm/values/multi-tenant-gcp-pre-production.yaml <<EOF
 clusterName: "Development cluster"
-integrationApi: https://kubernetes-upstream.dev.snyk.io
+integrationApi: "https://api.dev.snyk.io/v2/kubernetes-upstream"
 log_level: "DEBUG"
 skip_k8s_jobs: true
 
diff --git a/scripts/local-testing.sh b/scripts/local-testing.sh
index 3d17713a6..2b6c5472f 100755
--- a/scripts/local-testing.sh
+++ b/scripts/local-testing.sh
@@ -15,10 +15,15 @@ if [ "$INTEGRATION_ID" == "" ]; then
     read INTEGRATION_ID
 fi
 
+if [ "$SERVICE_ACCOUNT_API_TOKEN" == "" ]; then
+    echo "Enter your service account API token: "
+    read SERVICE_ACCOUNT_API_TOKEN
+fi
+
 kind delete cluster
 kind create cluster
 kubectl create namespace snyk-monitor
-kubectl create secret generic snyk-monitor -n snyk-monitor --from-literal=dockercfg.json={} --from-literal=integrationId=${INTEGRATION_ID}
+kubectl create secret generic snyk-monitor -n snyk-monitor --from-literal=dockercfg.json={} --from-literal=integrationId=${INTEGRATION_ID} --from-literal=serviceAccountApiToken=${SERVICE_ACCOUNT_API_TOKEN}
 helm upgrade --install snyk-monitor ./snyk-monitor --namespace snyk-monitor --set clusterName="kind localhost" --set image.tag=${LATEST_TAG} --set integrationApi=http://${IP}:9000
 
 printf "\r\n\r\nYou can now check if the pod is running using:\r\n\tkubectl get pod -n snyk-monitor\r\n"
diff --git a/snyk-monitor-deployment.yaml b/snyk-monitor-deployment.yaml
index aa93f4723..2e2ee9890 100644
--- a/snyk-monitor-deployment.yaml
+++ b/snyk-monitor-deployment.yaml
@@ -43,6 +43,11 @@ spec:
               secretKeyRef:
                 name: snyk-monitor
                 key: integrationId
+          - name: SNYK_SERVICE_ACCOUNT_API_TOKEN
+            valueFrom:
+              secretKeyRef:
+                name: snyk-monitor
+                key: serviceAccountApiToken
           - name: SNYK_WATCH_NAMESPACE
             valueFrom:
               configMapKeyRef:
diff --git a/snyk-operator-certified/README.md b/snyk-operator-certified/README.md
index e42192b58..91156b741 100644
--- a/snyk-operator-certified/README.md
+++ b/snyk-operator-certified/README.md
@@ -41,7 +41,7 @@ metadata:
   name: snyk-monitor
   namespace: snyk-monitor
 spec:
-  integrationApi: https://kubernetes-upstream.dev.snyk.io
+  integrationApi: https://api.dev.snyk.io/v2/kubernetes-upstream
   temporaryStorageSize: 20Gi
   pvc:
     enabled: true
diff --git a/snyk-operator-certified/bundle/manifests/snyk-monitor.clusterserviceversion.yaml b/snyk-operator-certified/bundle/manifests/snyk-monitor.clusterserviceversion.yaml
index 4b2df0c71..0105520b1 100644
--- a/snyk-operator-certified/bundle/manifests/snyk-monitor.clusterserviceversion.yaml
+++ b/snyk-operator-certified/bundle/manifests/snyk-monitor.clusterserviceversion.yaml
@@ -147,11 +147,11 @@ spec:
 
     ## Prerequisites
 
-    To start using the Operator and the Snyk controller that it manages, you will need to create a secret containing your Snyk integrationId and Docker config file:
+    To start using the Operator and the Snyk controller that it manages, you will need to create a secret containing your Snyk integrationId, serviceAccountApiToken and Docker config file:
 
     ```
     kubectl create namespace snyk-monitor
-    kubectl create secret generic snyk-monitor -n snyk-monitor --from-literal=dockercfg.json={} --from-literal=integrationId=${SNYK_INTEGRATION_ID}
+    kubectl create secret generic snyk-monitor -n snyk-monitor --from-literal=dockercfg.json={} --from-literal=integrationId=${SNYK_INTEGRATION_ID} --from-literal=serviceAccountApiToken=${SNYK_SERVICE_ACCOUNT_API_TOKEN}
     ```
 
     Refer to the [Snyk documentation](https://support.snyk.io/hc/en-us/articles/360003916138-Kubernetes-integration-overview) for more details.
diff --git a/snyk-operator-certified/config/manifests/bases/snyk-monitor.clusterserviceversion.yaml b/snyk-operator-certified/config/manifests/bases/snyk-monitor.clusterserviceversion.yaml
index 1ba5db2a6..044c9ff77 100644
--- a/snyk-operator-certified/config/manifests/bases/snyk-monitor.clusterserviceversion.yaml
+++ b/snyk-operator-certified/config/manifests/bases/snyk-monitor.clusterserviceversion.yaml
@@ -129,11 +129,11 @@ spec:
 
     ## Prerequisites
 
-    To start using the Operator and the Snyk controller that it manages, you will need to create a secret containing your Snyk integrationId and Docker config file:
+    To start using the Operator and the Snyk controller that it manages, you will need to create a secret containing your Snyk integrationId, serviceAccountApiToken and Docker config file:
 
     ```
     kubectl create namespace snyk-monitor
-    kubectl create secret generic snyk-monitor -n snyk-monitor --from-literal=dockercfg.json={} --from-literal=integrationId=${SNYK_INTEGRATION_ID}
+    kubectl create secret generic snyk-monitor -n snyk-monitor --from-literal=dockercfg.json={} --from-literal=integrationId=${SNYK_INTEGRATION_ID} --from-literal=serviceAccountApiToken=${SNYK_SERVICE_ACCOUNT_API_TOKEN}
     ```
 
     Refer to the [Snyk documentation](https://support.snyk.io/hc/en-us/articles/360003916138-Kubernetes-integration-overview) for more details.
diff --git a/snyk-operator-certified/helm-charts/snyk-monitor/templates/deployment.yaml b/snyk-operator-certified/helm-charts/snyk-monitor/templates/deployment.yaml
index 28c711c08..2d3cb72c1 100644
--- a/snyk-operator-certified/helm-charts/snyk-monitor/templates/deployment.yaml
+++ b/snyk-operator-certified/helm-charts/snyk-monitor/templates/deployment.yaml
@@ -95,6 +95,11 @@ spec:
               secretKeyRef:
                 name: {{ .Values.monitorSecrets }}
                 key: integrationId
+          - name: SNYK_SERVICE_ACCOUNT_API_TOKEN
+            valueFrom:
+              secretKeyRef:
+                name: snyk-monitor
+                key: serviceAccountApiToken
           - name: SNYK_WATCH_NAMESPACE
             value: {{ include "snyk-monitor.scope" . }}
           - name: SNYK_DEPLOYMENT_NAMESPACE
diff --git a/snyk-operator/certified-operator/README.md b/snyk-operator/certified-operator/README.md
index 25755701c..d5a73fbe2 100644
--- a/snyk-operator/certified-operator/README.md
+++ b/snyk-operator/certified-operator/README.md
@@ -40,7 +40,7 @@ metadata:
   name: snyk-monitor
   namespace: snyk-monitor
 spec:
-  integrationApi: https://kubernetes-upstream.dev.snyk.io
+  integrationApi: https://api.dev.snyk.io/v2/kubernetes-upstream
   temporaryStorageSize: 20Gi
   pvc:
     enabled: true
diff --git a/snyk-operator/deploy/olm-catalog/snyk-operator/0.0.0/snyk-operator.v0.0.0.clusterserviceversion.yaml b/snyk-operator/deploy/olm-catalog/snyk-operator/0.0.0/snyk-operator.v0.0.0.clusterserviceversion.yaml
index 49952a5fd..4b6b88bdc 100644
--- a/snyk-operator/deploy/olm-catalog/snyk-operator/0.0.0/snyk-operator.v0.0.0.clusterserviceversion.yaml
+++ b/snyk-operator/deploy/olm-catalog/snyk-operator/0.0.0/snyk-operator.v0.0.0.clusterserviceversion.yaml
@@ -187,11 +187,11 @@ spec:
 
     ## Prerequisites
 
-    To start using the Operator and the Snyk controller that it manages, you will need to create a secret containing your Snyk integrationId and Docker config file:
+    To start using the Operator and the Snyk controller that it manages, you will need to create a secret containing your Snyk integrationId, serviceAccountApiToken and Docker config file:
 
     ```
     kubectl create namespace snyk-monitor
-    kubectl create secret generic snyk-monitor -n snyk-monitor --from-literal=dockercfg.json={} --from-literal=integrationId=${SNYK_INTEGRATION_ID}
+    kubectl create secret generic snyk-monitor -n snyk-monitor --from-literal=dockercfg.json={} --from-literal=integrationId=${SNYK_INTEGRATION_ID} --from-literal=serviceAccountApiToken=${SNYK_SERVICE_ACCOUNT_API_TOKEN}
     ```
 
     Refer to the [Snyk documentation](https://support.snyk.io/hc/en-us/articles/360003916138-Kubernetes-integration-overview) for more details.
diff --git a/src/common/config.ts b/src/common/config.ts
index 7c79fcd31..3da8e50bf 100644
--- a/src/common/config.ts
+++ b/src/common/config.ts
@@ -39,6 +39,7 @@ function getClusterName(): string {
 config.AGENT_ID = randomUUID();
 
 config.INTEGRATION_ID = config.INTEGRATION_ID.trim();
+config.SERVICE_ACCOUNT_API_TOKEN = config.SERVICE_ACCOUNT_API_TOKEN.trim();
 config.CLUSTER_NAME = getClusterName();
 config.IMAGE_STORAGE_ROOT = '/var/tmp';
 config.POLICIES_STORAGE_ROOT = '/tmp/policies';
diff --git a/src/common/types.ts b/src/common/types.ts
index 268415ba3..9d6b8ddc6 100644
--- a/src/common/types.ts
+++ b/src/common/types.ts
@@ -19,6 +19,7 @@ export interface Config {
   REQUEST_QUEUE_LENGTH: number;
   QUEUE_LENGTH_LOG_FREQUENCY_MINUTES: number;
   INTEGRATION_ID: string;
+  SERVICE_ACCOUNT_API_TOKEN: string;
   DEFAULT_KUBERNETES_UPSTREAM_URL: string;
   MAX_RETRY_BACKOFF_DURATION_SECONDS: number;
 
diff --git a/src/transmitter/index.ts b/src/transmitter/index.ts
index e56d0c98a..30aeca3cf 100644
--- a/src/transmitter/index.ts
+++ b/src/transmitter/index.ts
@@ -21,6 +21,7 @@ import {
 import { getProxyAgent } from './proxy';
 
 import type { queueAsPromised } from 'fastq';
+import path from 'path';
 
 interface KubernetesUpstreamRequest {
   method: NeedleHttpVerbs;
@@ -32,11 +33,14 @@ interface KubernetesUpstreamRequest {
     | IDeleteWorkloadPayload
     | IClusterMetadataPayload
     | IRuntimeDataPayload;
+  options: NeedleOptions;
 }
 
 const upstreamUrl =
   config.INTEGRATION_API || config.DEFAULT_KUBERNETES_UPSTREAM_URL;
 
+const upstreamRequestVersion = '2023-02-10';
+
 let httpAgent = new HttpAgent({
   keepAlive: config.USE_KEEPALIVE,
 });
@@ -55,10 +59,29 @@ function getAgent(u: string): HttpAgent {
 const reqQueue: queueAsPromised<unknown> = fastq.promise(async function (
   req: KubernetesUpstreamRequest,
 ) {
-  return await retryRequest(req.method, req.url, req.payload);
+  return await retryRequest(req.method, req.url, req.payload, req.options);
 },
 config.REQUEST_QUEUE_LENGTH);
 
+const upstreamRequestOptions = {
+  headers: {
+    Authorization: `token ${config.SERVICE_ACCOUNT_API_TOKEN}`,
+  },
+};
+
+function constructUpstreamRequestUrl(
+  requestPath: string,
+  queryParams?: Record<string, string>,
+): string {
+  const requestUrl = new URL(upstreamUrl);
+  requestUrl.pathname = path.join(requestUrl.pathname, requestPath);
+  requestUrl.searchParams.set('version', upstreamRequestVersion);
+  for (const key in queryParams) {
+    requestUrl.searchParams.set(key, queryParams[key]);
+  }
+  return requestUrl.toString();
+}
+
 export async function sendDepGraph(
   ...payloads: IDependencyGraphPayload[]
 ): Promise<void> {
@@ -69,8 +92,9 @@ export async function sendDepGraph(
     try {
       const request: KubernetesUpstreamRequest = {
         method: 'post',
-        url: `${upstreamUrl}/api/v1/dependency-graph`,
+        url: constructUpstreamRequestUrl('/api/v1/dependency-graph'),
         payload,
+        options: upstreamRequestOptions,
       };
 
       const { response, attempt } = await reqQueue.push(request);
@@ -100,8 +124,9 @@ export async function sendScanResults(
     try {
       const request: KubernetesUpstreamRequest = {
         method: 'post',
-        url: `${upstreamUrl}/api/v1/scan-results`,
+        url: constructUpstreamRequestUrl('/api/v1/scan-results'),
         payload,
+        options: upstreamRequestOptions,
       };
 
       const { response, attempt } = await reqQueue.push(request);
@@ -136,8 +161,9 @@ export async function sendWorkloadMetadata(
 
     const request: KubernetesUpstreamRequest = {
       method: 'post',
-      url: `${upstreamUrl}/api/v1/workload`,
+      url: constructUpstreamRequestUrl('/api/v1/workload'),
       payload,
+      options: upstreamRequestOptions,
     };
 
     const { response, attempt } = await reqQueue.push(request);
@@ -172,8 +198,9 @@ export async function sendWorkloadEventsPolicy(
 
     const { response, attempt } = await retryRequest(
       'post',
-      `${upstreamUrl}/api/v1/policy`,
+      constructUpstreamRequestUrl('/api/v1/policy'),
       payload,
+      upstreamRequestOptions,
     );
     if (!isSuccessStatusCode(response.statusCode)) {
       throw new Error(`${response.statusCode} ${response.statusMessage}`);
@@ -207,11 +234,19 @@ export async function deleteWorkload(
   try {
     const { workloadLocator, agentId } = payload;
     const { userLocator, cluster, namespace, type, name } = workloadLocator;
-    const query = `userLocator=${userLocator}&cluster=${cluster}&namespace=${namespace}&type=${type}&name=${name}&agentId=${agentId}`;
+    const queryParams: Record<string, string> = {
+      userLocator,
+      cluster,
+      namespace,
+      type,
+      name,
+      agentId,
+    };
     const request: KubernetesUpstreamRequest = {
       method: 'delete',
-      url: `${upstreamUrl}/api/v1/workload?${query}`,
+      url: constructUpstreamRequestUrl('api/v1/workload', queryParams),
       payload,
+      options: upstreamRequestOptions,
     };
 
     const { response, attempt } = await reqQueue.push(request);
@@ -348,8 +383,9 @@ export async function sendClusterMetadata(): Promise<void> {
 
     const request: KubernetesUpstreamRequest = {
       method: 'post',
-      url: `${upstreamUrl}/api/v1/cluster`,
+      url: constructUpstreamRequestUrl('/api/v1/cluster'),
       payload,
+      options: upstreamRequestOptions,
     };
 
     const { response, attempt } = await reqQueue.push(request);
@@ -394,8 +430,9 @@ export async function sendRuntimeData(
 
     const request: KubernetesUpstreamRequest = {
       method: 'post',
-      url: `${upstreamUrl}/api/v1/runtime-results`,
+      url: constructUpstreamRequestUrl('/api/v1/runtime-results'),
       payload,
+      options: upstreamRequestOptions,
     };
 
     const { response, attempt } = await reqQueue.push(request);
diff --git a/test/common/config.spec.ts b/test/common/config.spec.ts
index ba35b3cbb..584d8d23a 100644
--- a/test/common/config.spec.ts
+++ b/test/common/config.spec.ts
@@ -1,8 +1,10 @@
 describe('extractNamespaceName()', () => {
+  const apiToken = '46766a0a-ed0b-4e91-84c8-ea1c827f2a73';
   beforeEach(() => {
     jest.resetModules();
     process.env.SNYK_SYSDIG_ENDPOINT = 'https://api/v1/images/';
     process.env.SNYK_SYSDIG_TOKEN = '1432gtrhtrw32raf';
+    process.env.SNYK_SERVICE_ACCOUNT_API_TOKEN = apiToken;
   });
 
   afterEach(() => {
@@ -68,6 +70,7 @@ describe('extractNamespaceName()', () => {
     const { config } = require('../../src/common/config');
     expect(config.AGENT_ID).toEqual(expect.any(String));
     expect(config.INTEGRATION_ID).toEqual(expect.any(String));
+    expect(config.SERVICE_ACCOUNT_API_TOKEN).toEqual(apiToken);
     expect(config.CLUSTER_NAME).toEqual('Default cluster');
     expect(config.IMAGE_STORAGE_ROOT).toEqual('/var/tmp');
     expect(config.EXCLUDED_NAMESPACES).toBeNull();
@@ -76,7 +79,7 @@ describe('extractNamespaceName()', () => {
     expect(config.NO_PROXY).toBeUndefined();
     expect(config.USE_KEEPALIVE).toEqual(true);
     expect(config.SKIP_K8S_JOBS).toEqual(false);
-    expect(config.WORKERS_COUNT).toEqual(10);
+    expect(config.WORKERS_COUNT).toEqual(5);
     expect(config.SKOPEO_COMPRESSION_LEVEL).toEqual(6);
     expect(config.SYSDIG_ENDPOINT).toEqual('https://api/v1/images/');
     expect(config.SYSDIG_TOKEN).toEqual('1432gtrhtrw32raf');
diff --git a/test/fixtures/operator/custom-resource-k8s.yaml b/test/fixtures/operator/custom-resource-k8s.yaml
index b2649f963..1f970566c 100644
--- a/test/fixtures/operator/custom-resource-k8s.yaml
+++ b/test/fixtures/operator/custom-resource-k8s.yaml
@@ -4,7 +4,7 @@ metadata:
   name: snyk-monitor
   namespace: marketplace
 spec:
-  integrationApi: https://kubernetes-upstream.dev.snyk.io
+  integrationApi: https://api.dev.snyk.io/v2/kubernetes-upstream
   temporaryStorageSize: 20Gi
   clusterName: ""
   pvc:
diff --git a/test/fixtures/operator/custom-resource.yaml b/test/fixtures/operator/custom-resource.yaml
index f1a5e0232..7096c91f3 100644
--- a/test/fixtures/operator/custom-resource.yaml
+++ b/test/fixtures/operator/custom-resource.yaml
@@ -4,7 +4,7 @@ metadata:
   name: snyk-monitor
   namespace: snyk-monitor
 spec:
-  integrationApi: https://kubernetes-upstream.dev.snyk.io
+  integrationApi: https://api.dev.snyk.io/v2/kubernetes-upstream
   temporaryStorageSize: 20Gi
   clusterName: ""
   pvc:
diff --git a/test/setup/deployers/helm-with-proxy.ts b/test/setup/deployers/helm-with-proxy.ts
index e6e87bd71..2508dc8ee 100644
--- a/test/setup/deployers/helm-with-proxy.ts
+++ b/test/setup/deployers/helm-with-proxy.ts
@@ -37,7 +37,7 @@ async function deployKubernetesMonitor(
       `--set image.repository=${imageName} ` +
       `--set image.tag=${imageTag} ` +
       `--set image.pullPolicy=${imagePullPolicy} ` +
-      '--set integrationApi=https://kubernetes-upstream.dev.snyk.io ' +
+      '--set integrationApi=https://api.dev.snyk.io/v2/kubernetes-upstream ' +
       `--set clusterName=${deployOptions.clusterName} ` +
       '--set https_proxy=http://forwarding-proxy:8080',
   );
diff --git a/test/setup/deployers/helm.ts b/test/setup/deployers/helm.ts
index 32d04e793..6b65065b6 100644
--- a/test/setup/deployers/helm.ts
+++ b/test/setup/deployers/helm.ts
@@ -30,7 +30,7 @@ async function deployKubernetesMonitor(
       `--set image.repository=${imageName} ` +
       `--set image.tag=${imageTag} ` +
       `--set image.pullPolicy=${imagePullPolicy} ` +
-      '--set integrationApi=https://kubernetes-upstream.dev.snyk.io ' +
+      '--set integrationApi=https://api.dev.snyk.io/v2/kubernetes-upstream ' +
       `--set clusterName=${deployOptions.clusterName} ` +
       '--set nodeSelector."kubernetes\\.io/os"=linux ' +
       '--set pvc.enabled=true ' +
diff --git a/test/setup/deployers/yaml.ts b/test/setup/deployers/yaml.ts
index e0547cd37..9b23be776 100644
--- a/test/setup/deployers/yaml.ts
+++ b/test/setup/deployers/yaml.ts
@@ -47,7 +47,7 @@ function createTestYamlDeployment(
   const envVar = container.env.find(
     (env) => env.name === 'SNYK_INTEGRATION_API',
   );
-  envVar.value = 'https://kubernetes-upstream.dev.snyk.io';
+  envVar.value = 'https://api.dev.snyk.io/v2/kubernetes-upstream';
   delete envVar.valueFrom;
 
   if (clusterName) {
diff --git a/test/setup/index.ts b/test/setup/index.ts
index adccb305b..97e5a76c8 100644
--- a/test/setup/index.ts
+++ b/test/setup/index.ts
@@ -24,6 +24,14 @@ function getClusterName(): string {
   return clusterName;
 }
 
+function getServiceAccountApiToken(): string {
+  const serviceAccountApiToken = randomUUID();
+  console.log(
+    `Generated new service account API token ${serviceAccountApiToken}`,
+  );
+  return serviceAccountApiToken;
+}
+
 function getEnvVariableOrDefault(
   envVarName: string,
   defaultValue: string,
@@ -84,6 +92,7 @@ async function createEnvironment(): Promise<void> {
 
 async function predeploy(
   integrationId: string,
+  serviceAccountApiToken: string,
   namespace: string,
 ): Promise<void> {
   try {
@@ -99,6 +108,7 @@ async function predeploy(
     await kubectl.createSecret(secretName, namespace, {
       'dockercfg.json': gcrDockercfg,
       integrationId,
+      serviceAccountApiToken,
     });
     await createRegistriesConfigMap(namespace);
     console.log(`Namespace ${namespace} and secret ${secretName} created`);
@@ -193,7 +203,8 @@ export async function deployMonitor(): Promise<{
     await createSecretForDockerHubAccess();
 
     const integrationId = getIntegrationId();
-    await predeploy(integrationId, namespace);
+    const serviceAccountApiToken = getServiceAccountApiToken();
+    await predeploy(integrationId, serviceAccountApiToken, namespace);
 
     // TODO: hack, rewrite this
     const imagePullPolicy =
diff --git a/test/unit/data-scraper/scrape-data.spec.ts b/test/unit/data-scraper/scrape-data.spec.ts
index aa3f15fd9..3d37d1fcb 100644
--- a/test/unit/data-scraper/scrape-data.spec.ts
+++ b/test/unit/data-scraper/scrape-data.spec.ts
@@ -59,8 +59,8 @@ describe('dataScraper()', () => {
       .times(1)
       .reply(200, bodyNoToken);
 
-    nock('https://kubernetes-upstream.snyk.io')
-      .post('/api/v1/runtime-results')
+    nock('https://api.snyk.io')
+      .post('/v2/kubernetes-upstream/api/v1/runtime-results?version=2023-02-10')
       .times(1)
       .reply(200, (uri, requestBody: transmitterTypes.IRuntimeDataPayload) => {
         expect(requestBody).toEqual<transmitterTypes.IRuntimeDataPayload>({
@@ -80,7 +80,7 @@ describe('dataScraper()', () => {
           ],
         });
       })
-      .post('/api/v1/runtime-results')
+      .post('/v2/kubernetes-upstream/api/v1/runtime-results?version=2023-02-10')
       .times(1)
       .reply(200, (uri, requestBody: transmitterTypes.IRuntimeDataPayload) => {
         expect(requestBody).toEqual<transmitterTypes.IRuntimeDataPayload>({
@@ -102,5 +102,12 @@ describe('dataScraper()', () => {
       });
 
     await scrapeData();
+
+    try {
+      expect(nock.isDone()).toBeTruthy();
+    } catch (err) {
+      console.error(`nock pending mocks: ${nock.pendingMocks()}`);
+      throw err;
+    }
   });
 });
