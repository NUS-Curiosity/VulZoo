diff --git a/bench/bench_bn.c b/bench/bench_bn.c
index 64c977037..e4a0f75b2 100644
--- a/bench/bench_bn.c
+++ b/bench/bench_bn.c
@@ -284,7 +284,7 @@ static void arith(void) {
 	bn_t a, b, c, d[3], e[3];
 	crt_t crt;
 	dig_t f;
-	int len;
+	size_t len;
 
 	bn_null(a);
 	bn_null(b);
@@ -891,7 +891,7 @@ static void arith(void) {
 
 	BENCH_RUN("bn_rec_naf") {
 		int8_t naf[RLC_BN_BITS + 1];
-		int len;
+		size_t len;
 		bn_rand(a, RLC_POS, RLC_BN_BITS);
 		BENCH_ADD((len = RLC_BN_BITS + 1, bn_rec_naf(naf, &len, a, 4)));
 	}
@@ -901,7 +901,7 @@ static void arith(void) {
 	if (eb_param_set_any_kbltz() == RLC_OK) {
 		BENCH_RUN("bn_rec_tnaf") {
 			int8_t tnaf[RLC_FB_BITS + 8];
-			int len = RLC_BN_BITS + 1;
+			size_t len = RLC_BN_BITS + 1;
 			eb_curve_get_ord(b);
 			bn_rand_mod(a, b);
 			if (eb_curve_opt_a() == RLC_ZERO) {
@@ -928,7 +928,7 @@ static void arith(void) {
 
 	BENCH_RUN("bn_rec_reg") {
 		int8_t naf[RLC_BN_BITS + 1];
-		int len = RLC_BN_BITS + 1;
+		size_t len = RLC_BN_BITS + 1;
 		bn_rand(a, RLC_POS, RLC_BN_BITS);
 		BENCH_ADD((len = RLC_BN_BITS + 1, bn_rec_reg(naf, &len, a, RLC_BN_BITS, 4)));
 	}
diff --git a/bench/bench_cp.c b/bench/bench_cp.c
index d34d31086..de0d843dd 100644
--- a/bench/bench_cp.c
+++ b/bench/bench_cp.c
@@ -141,6 +141,7 @@ static void benaloh(void) {
 	dig_t in, new;
 	uint8_t out[RLC_BN_BITS / 8 + 1];
 	size_t out_len;
+	dig_t prime = 0xFB;
 
 	bdpe_null(pub);
 	bdpe_null(prv);
@@ -148,13 +149,12 @@ static void benaloh(void) {
 	bdpe_new(pub);
 	bdpe_new(prv);
 
-	BENCH_ONE("cp_bdpe_gen", cp_bdpe_gen(pub, prv, bn_get_prime(47),
-		RLC_BN_BITS), 1);
+	BENCH_ONE("cp_bdpe_gen", cp_bdpe_gen(pub, prv, prime, RLC_BN_BITS), 1);
 
 	BENCH_RUN("cp_bdpe_enc") {
 		out_len = RLC_BN_BITS / 8 + 1;
 		rand_bytes(out, 1);
-		in = out[0] % bn_get_prime(47);
+		in = out[0] % prime;
 		BENCH_ADD(cp_bdpe_enc(out, &out_len, in, pub));
 		cp_bdpe_dec(&new, out, out_len, prv);
 	} BENCH_END;
@@ -162,7 +162,7 @@ static void benaloh(void) {
 	BENCH_RUN("cp_bdpe_dec") {
 		out_len = RLC_BN_BITS / 8 + 1;
 		rand_bytes(out, 1);
-		in = out[0] % bn_get_prime(47);
+		in = out[0] % prime;
 		cp_bdpe_enc(out, &out_len, in, pub);
 		BENCH_ADD(cp_bdpe_dec(&new, out, out_len, prv));
 	} BENCH_END;
diff --git a/bench/bench_epx.c b/bench/bench_epx.c
index 923f7b3ff..9df560f20 100644
--- a/bench/bench_epx.c
+++ b/bench/bench_epx.c
@@ -37,9 +37,9 @@
 static void memory2(void) {
 	ep2_t a[BENCH];
 
-	BENCH_FEW("ep2_null", ep4_null(a[i]), 1);
+	BENCH_FEW("ep2_null", ep2_null(a[i]), 1);
 
-	BENCH_FEW("ep2_new", ep4_new(a[i]), 1);
+	BENCH_FEW("ep2_new", ep2_new(a[i]), 1);
 	for (int i = 0; i < BENCH; i++) {
 		ep2_free(a[i]);
 	}
@@ -47,7 +47,7 @@ static void memory2(void) {
 	for (int i = 0; i < BENCH; i++) {
 		ep2_new(a[i]);
 	}
-	BENCH_FEW("ep2_free", ep4_free(a[i]), 1);
+	BENCH_FEW("ep2_free", ep2_free(a[i]), 1);
 
 	(void)a;
 }
diff --git a/include/relic_bn.h b/include/relic_bn.h
index 1b5b3244c..a68e82432 100644
--- a/include/relic_bn.h
+++ b/include/relic_bn.h
@@ -53,22 +53,22 @@
  * multiple precision integer must grow. Otherwise, it represents the fixed
  * fixed precision.
  */
-#define RLC_BN_BITS 	((int)BN_PRECI)
+#define RLC_BN_BITS 	((size_t)BN_PRECI)
 
 /**
  * Size in digits of a block sufficient to store the required precision.
  */
-#define RLC_BN_DIGS		((int)RLC_CEIL(BN_PRECI, RLC_DIG))
+#define RLC_BN_DIGS		((size_t)RLC_CEIL(BN_PRECI, RLC_DIG))
 
 /**
  * Size in digits of a block sufficient to store a multiple precision integer.
  */
 #if BN_MAGNI == DOUBLE
-#define RLC_BN_SIZE		((int)(2 * RLC_BN_DIGS + 2))
+#define RLC_BN_SIZE		((size_t)(2 * RLC_BN_DIGS + 2))
 #elif BN_MAGNI == CARRY
-#define RLC_BN_SIZE		((int)(RLC_BN_DIGS + 1))
+#define RLC_BN_SIZE		((size_t)(RLC_BN_DIGS + 1))
 #elif BN_MAGNI == SINGLE
-#define RLC_BN_SIZE		((int)RLC_BN_DIGS)
+#define RLC_BN_SIZE		((size_t)RLC_BN_DIGS)
 #endif
 
 /**
@@ -94,9 +94,9 @@
  */
 typedef struct {
 	/** The number of digits allocated to this multiple precision integer. */
-	int alloc;
+	size_t alloc;
 	/** The number of digits actually used. */
-	int used;
+	size_t used;
 	/** The sign of this multiple precision integer. */
 	int sign;
 #if ALLOC == DYNAMIC
@@ -457,7 +457,7 @@ typedef crt_st *crt_t;
  * @throw ERR_PRECISION		- if the required precision cannot be represented
  * 							by the library.
  */
-void bn_make(bn_t a, int digits);
+void bn_make(bn_t a, size_t digits);
 
 /**
  * Cleans a multiple precision integer.
@@ -476,7 +476,7 @@ void bn_clean(bn_t a);
  * @throw ERR_PRECISION		- if the required precision cannot be represented
  * 							by the library.
  */
-void bn_grow(bn_t a, int digits);
+void bn_grow(bn_t a, size_t digits);
 
 /**
  * Adjust the number of valid digits of a multiple precision integer.
@@ -546,7 +546,7 @@ int bn_is_even(const bn_t a);
  * @param[in] a				- the multiple precision integer.
  * @return number of bits.
  */
-int bn_bits(const bn_t a);
+size_t bn_bits(const bn_t a);
 
 /**
  * Returns the bit stored in the given position on a multiple precision integer.
@@ -555,7 +555,7 @@ int bn_bits(const bn_t a);
  * @param[in] bit			- the bit position to read.
  * @return the bit value.
  */
-int bn_get_bit(const bn_t a, int bit);
+int bn_get_bit(const bn_t a, size_t bit);
 
 /**
  * Stores a bit in a given position on a multiple precision integer.
@@ -564,7 +564,7 @@ int bn_get_bit(const bn_t a, int bit);
  * @param[in] bit			- the bit position to store.
  * @param[in] value			- the bit value.
  */
-void bn_set_bit(bn_t a, int bit, int value);
+void bn_set_bit(bn_t a, size_t bit, int value);
 
 /**
  * Returns the Hamming weight of a multiple precision integer.
@@ -572,7 +572,7 @@ void bn_set_bit(bn_t a, int bit, int value);
  * @param[in] a				- the multiple precision integer.
  * @return the number of non-zero bits.
  */
-int bn_ham(const bn_t a);
+size_t bn_ham(const bn_t a);
 
 /**
  * Reads the first digit in a multiple precision integer.
@@ -599,7 +599,7 @@ void bn_set_dig(bn_t a, dig_t digit);
  * @param[out] a			- the result.
  * @param[in] b				- the power of 2 to assign.
  */
-void bn_set_2b(bn_t a, int b);
+void bn_set_2b(bn_t a, size_t b);
 
 /**
  * Assigns a random value to a multiple precision integer.
@@ -608,7 +608,7 @@ void bn_set_2b(bn_t a, int b);
  * @param[in] sign			- the sign to be assigned (RLC_NEG or RLC_POS).
  * @param[in] bits			- the number of bits.
  */
-void bn_rand(bn_t a, int sign, int bits);
+void bn_rand(bn_t a, int sign, size_t bits);
 
 /**
  * Assigns a non-zero random value to a multiple precision integer with absolute
@@ -635,7 +635,7 @@ void bn_print(const bn_t a);
  * @throw ERR_NO_VALID		- if the radix is invalid.
  * @return the number of digits in the given radix.
  */
-int bn_size_str(const bn_t a, int radix);
+size_t bn_size_str(const bn_t a, unsigned int radix);
 
 /**
  * Reads a multiple precision integer from a string in a given radix. The radix
@@ -647,7 +647,7 @@ int bn_size_str(const bn_t a, int radix);
  * @param[in] radix			- the radix.
  * @throw ERR_NO_VALID		- if the radix is invalid.
  */
-void bn_read_str(bn_t a, const char *str, int len, int radix);
+void bn_read_str(bn_t a, const char *str, size_t len, unsigned int radix);
 
 /**
  * Writes a multiple precision integer to a string in a given radix. The radix
@@ -660,7 +660,7 @@ void bn_read_str(bn_t a, const char *str, int len, int radix);
  * @throw ERR_NO_BUFFER		- if the buffer capacity is insufficient.
  * @throw ERR_NO_VALID		- if the radix is invalid.
  */
-void bn_write_str(char *str, int len, const bn_t a, int radix);
+void bn_write_str(char *str, size_t len, const bn_t a, unsigned radix);
 
 /**
  * Returns the number of bytes necessary to store a multiple precision integer.
@@ -668,7 +668,7 @@ void bn_write_str(char *str, int len, const bn_t a, int radix);
  * @param[in] a				- the multiple precision integer.
  * @return the number of bytes.
  */
-int bn_size_bin(const bn_t a);
+size_t bn_size_bin(const bn_t a);
 
 /**
  * Reads a positive multiple precision integer from a byte vector in big-endian
@@ -678,7 +678,7 @@ int bn_size_bin(const bn_t a);
  * @param[in] bin			- the byte vector.
  * @param[in] len			- the buffer capacity.
  */
-void bn_read_bin(bn_t a, const uint8_t *bin, int len);
+void bn_read_bin(bn_t a, const uint8_t *bin, size_t len);
 
 /**
  * Writes a positive multiple precision integer to a byte vector in big-endian
@@ -689,7 +689,7 @@ void bn_read_bin(bn_t a, const uint8_t *bin, int len);
  * @param[in] a				- the multiple integer to write.
  * @throw ERR_NO_BUFFER		- if the buffer capacity is insufficient.
  */
-void bn_write_bin(uint8_t *bin, int len, const bn_t a);
+void bn_write_bin(uint8_t *bin, size_t len, const bn_t a);
 
 /**
  * Returns the number of digits necessary to store a multiple precision integer.
@@ -697,7 +697,7 @@ void bn_write_bin(uint8_t *bin, int len, const bn_t a);
  * @param[in] a				- the multiple precision integer.
  * @return the number of digits.
  */
-int bn_size_raw(const bn_t a);
+size_t bn_size_raw(const bn_t a);
 
 /**
  * Reads a positive multiple precision integer from a digit vector.
@@ -706,7 +706,7 @@ int bn_size_raw(const bn_t a);
  * @param[in] raw			- the digit vector.
  * @param[in] len			- the size of the string.
  */
-void bn_read_raw(bn_t a, const dig_t *raw, int len);
+void bn_read_raw(bn_t a, const dig_t *raw, size_t len);
 
 /**
  * Writes a positive multiple precision integer to a byte vector.
@@ -716,7 +716,7 @@ void bn_read_raw(bn_t a, const dig_t *raw, int len);
  * @param[in] a				- the multiple integer to write.
  * @throw ERR_NO_BUFFER		- if the buffer capacity is insufficient.
  */
-void bn_write_raw(dig_t *raw, int len, const bn_t a);
+void bn_write_raw(dig_t *raw, size_t len, const bn_t a);
 
 /**
  * Returns the result of an unsigned comparison between two multiple precision
@@ -870,7 +870,7 @@ void bn_hlv(bn_t c, const bn_t a);
  * @param[in] a				- the multiple precision integer to shift.
  * @param[in] bits			- the number of bits to shift.
  */
-void bn_lsh(bn_t c, const bn_t a, int bits);
+void bn_lsh(bn_t c, const bn_t a, unsigned int bits);
 
 /**
  * Shifts a multiple precision number to the right. Computes
@@ -880,7 +880,7 @@ void bn_lsh(bn_t c, const bn_t a, int bits);
  * @param[in] a				- the multiple precision integer to shift.
  * @param[in] bits			- the number of bits to shift.
  */
-void bn_rsh(bn_t c, const bn_t a, int bits);
+void bn_rsh(bn_t c, const bn_t a, unsigned int bits);
 
 /**
  * Divides a multiple precision integer by another multiple precision integer
@@ -1310,7 +1310,7 @@ int bn_is_prime_solov(const bn_t a);
  * @param[out] a			- the result.
  * @param[in] bits			- the length of the number in bits.
  */
-void bn_gen_prime_basic(bn_t a, int bits);
+void bn_gen_prime_basic(bn_t a, size_t bits);
 
 /**
  * Generates a probable prime number a with (a - 1)/2 also prime.
@@ -1318,7 +1318,7 @@ void bn_gen_prime_basic(bn_t a, int bits);
  * @param[out] a			- the result.
  * @param[in] bits			- the length of the number in bits.
  */
-void bn_gen_prime_safep(bn_t a, int bits);
+void bn_gen_prime_safep(bn_t a, size_t bits);
 
 /**
  * Generates a probable prime number with (a - 1)/2, (a + 1)/2 and
@@ -1327,7 +1327,7 @@ void bn_gen_prime_safep(bn_t a, int bits);
  * @param[out] a			- the result.
  * @param[in] bits			- the length of the number in bits.
  */
-void bn_gen_prime_stron(bn_t a, int bits);
+void bn_gen_prime_stron(bn_t a, size_t bits);
 
 /**
  * Generates a probable prime number b, with (b-1) divisible by a probable large
@@ -1338,7 +1338,7 @@ void bn_gen_prime_stron(bn_t a, int bits);
  * @param[in] abits			- the length of the factor a in bits.
  * @param[in] bbits			- the length of the result in bits.
  */
-int bn_gen_prime_factor(bn_t a, bn_t b, int abits, int bbits);
+int bn_gen_prime_factor(bn_t a, bn_t b, size_t abits, size_t bbits);
 
 
 /**
@@ -1370,7 +1370,7 @@ int bn_is_factor(bn_t c, const bn_t a);
  * @param[in] w				- the window size in bits.
  * @throw ERR_NO_BUFFER		- if the buffer capacity is insufficient.
  */
-void bn_rec_win(uint8_t *win, int *len, const bn_t k, int w);
+void bn_rec_win(uint8_t *win, size_t *len, const bn_t k, size_t w);
 
 /**
  * Recodes a positive integer in sliding window form. If a negative integer is
@@ -1382,7 +1382,7 @@ void bn_rec_win(uint8_t *win, int *len, const bn_t k, int w);
  * @param[in] w				- the window size in bits.
  * @throw ERR_NO_BUFFER		- if the buffer capacity is insufficient.
  */
-void bn_rec_slw(uint8_t *win, int *len, const bn_t k, int w);
+void bn_rec_slw(uint8_t *win, size_t *len, const bn_t k, size_t w);
 
 /**
  * Recodes a positive integer in width-w Non-Adjacent Form. If a negative
@@ -1394,7 +1394,7 @@ void bn_rec_slw(uint8_t *win, int *len, const bn_t k, int w);
  * @param[in] w				- the window size in bits.
  * @throw ERR_NO_BUFFER		- if the buffer capacity is insufficient.
  */
-void bn_rec_naf(int8_t *naf, int *len, const bn_t k, int w);
+void bn_rec_naf(int8_t *naf, size_t *len, const bn_t k, size_t w);
 
 /**
  * Recodes a positive integer in width-w \tau-NAF. If a negative integer is
@@ -1408,7 +1408,8 @@ void bn_rec_naf(int8_t *naf, int *len, const bn_t k, int w);
  * @param[in] w				- the window size in bits.
  * @throw ERR_NO_BUFFER		- if the buffer capacity is insufficient.
  */
-void bn_rec_tnaf(int8_t *tnaf, int *len, const bn_t k, int8_t u, int m, int w);
+void bn_rec_tnaf(int8_t *tnaf, size_t *len, const bn_t k, int8_t u, size_t m,
+		size_t w);
 
 /**
  * Recodes a positive integer in regular fixed-length width-w \tau-NAF.
@@ -1422,7 +1423,8 @@ void bn_rec_tnaf(int8_t *tnaf, int *len, const bn_t k, int8_t u, int m, int w);
  * @param[in] w				- the window size in bits.
  * @throw ERR_NO_BUFFER		- if the buffer capacity is insufficient.
  */
-void bn_rec_rtnaf(int8_t *tnaf, int *len, const bn_t k, int8_t u, int m, int w);
+void bn_rec_rtnaf(int8_t *tnaf, size_t *len, const bn_t k, int8_t u, size_t m,
+		size_t w);
 
 /**
  * Write the constants needed for \tau-NAF recoding as a set of \alpha_u =
@@ -1434,7 +1436,8 @@ void bn_rec_rtnaf(int8_t *tnaf, int *len, const bn_t k, int8_t u, int m, int w);
  * @param[in] u 		- the u curve parameter.
  * @param[in] w 		- the window size in bits.
  */
-void bn_rec_tnaf_get(uint8_t *t, int8_t *beta, int8_t *gama, int8_t u, int w);
+void bn_rec_tnaf_get(uint8_t *t, int8_t *beta, int8_t *gama, int8_t u,
+		size_t w);
 
 /**
  * Computes the partial reduction k partmod d = r0 + r1 * t, where
@@ -1446,7 +1449,7 @@ void bn_rec_tnaf_get(uint8_t *t, int8_t *beta, int8_t *gama, int8_t u, int w);
  * @param[in] u			- the u curve parameter.
  * @param[in] m			- the extension degree of the binary field.
  */
-void bn_rec_tnaf_mod(bn_t r0, bn_t r1, const bn_t k, int u, int m);
+void bn_rec_tnaf_mod(bn_t r0, bn_t r1, const bn_t k, int u, size_t m);
 
 /**
  * Recodes a positive integer in regular fixed-length width-w NAF. If a negative
@@ -1459,7 +1462,7 @@ void bn_rec_tnaf_mod(bn_t r0, bn_t r1, const bn_t k, int u, int m);
  * @param[in] w				- the window size in bits.
  * @throw ERR_NO_BUFFER		- if the buffer capacity is insufficient.
  */
-void bn_rec_reg(int8_t *naf, int *len, const bn_t k, int n, int w);
+void bn_rec_reg(int8_t *naf, size_t *len, const bn_t k, size_t n, size_t w);
 
 /**
  * Recodes of a pair of positive integers in Joint Sparse Form. If negative
@@ -1471,7 +1474,7 @@ void bn_rec_reg(int8_t *naf, int *len, const bn_t k, int n, int w);
  * @param[in] l				- the second integer to recode.
  * @throw ERR_NO_BUFFER		- if the buffer capacity is insufficient.
  */
-void bn_rec_jsf(int8_t *jsf, int *len, const bn_t k, const bn_t l);
+void bn_rec_jsf(int8_t *jsf, size_t *len, const bn_t k, const bn_t l);
 
 /**
  * Recodes a positive integer into two parts k0,k1 such that k = k0 + phi(k1),
diff --git a/include/relic_cp.h b/include/relic_cp.h
index 7872f19e8..1200dbb98 100644
--- a/include/relic_cp.h
+++ b/include/relic_cp.h
@@ -740,7 +740,7 @@ typedef etrs_st *etrs_t;
  * @param[in] bits			- the key length in bits.
  * @return RLC_OK if no errors occurred, RLC_ERR otherwise.
  */
-int cp_rsa_gen(rsa_t pub, rsa_t prv, int bits);
+int cp_rsa_gen(rsa_t pub, rsa_t prv, size_t bits);
 
 /**
  * Encrypts using the RSA cryptosystem.
@@ -1540,7 +1540,7 @@ int cp_bls_gen(bn_t d, g2_t q);
  * @param[in] d				- the private key.
  * @return RLC_OK if no errors occurred, RLC_ERR otherwise.
  */
-int cp_bls_sig(g1_t s, const uint8_t *msg, int len, const bn_t d);
+int cp_bls_sig(g1_t s, const uint8_t *msg, size_t len, const bn_t d);
 
 /**
  * Verifies a message signed with BLS protocol.
diff --git a/include/relic_eb.h b/include/relic_eb.h
index b43650f1f..68e47eee6 100644
--- a/include/relic_eb.h
+++ b/include/relic_eb.h
@@ -560,7 +560,7 @@ int eb_size_bin(const eb_t a, int pack);
  * @throw ERR_NO_VALID		- if the encoded point is invalid.
  * @throw ERR_NO_BUFFER		- if the buffer capacity is invalid.
  */
-void eb_read_bin(eb_t a, const uint8_t *bin, int len);
+void eb_read_bin(eb_t a, const uint8_t *bin, size_t len);
 
 /**
  * Writes a binary field element to a byte vector in big-endian format with
@@ -572,7 +572,7 @@ void eb_read_bin(eb_t a, const uint8_t *bin, int len);
  * @param[in] pack			- the flag to indicate point compression.
  * @throw ERR_NO_BUFFER		- if the buffer capacity is invalid.
  */
-void eb_write_bin(uint8_t *bin, int len, const eb_t a, int pack);
+void eb_write_bin(uint8_t *bin, size_t len, const eb_t a, int pack);
 
 /**
  * Negates a binary elliptic curve point represented by affine coordinates.
@@ -928,7 +928,7 @@ void eb_norm_sim(eb_t *r, const eb_t *t, int n);
  * @param[in] msg			- the byte array to map.
  * @param[in] len			- the array length in bytes.
  */
-void eb_map(eb_t p, const uint8_t *msg, int len);
+void eb_map(eb_t p, const uint8_t *msg, size_t len);
 
 /**
  * Compresses a point.
diff --git a/include/relic_ed.h b/include/relic_ed.h
index 4d8cbc71b..a3997b7d0 100644
--- a/include/relic_ed.h
+++ b/include/relic_ed.h
@@ -482,7 +482,7 @@ void ed_norm_sim(ed_t *r, const ed_t *t, int n);
  * @param[in] msg			- the byte array to map.
  * @param[in] len			- the array length in bytes.
  */
-void ed_map(ed_t p, const uint8_t *msg, int len);
+void ed_map(ed_t p, const uint8_t *msg, size_t len);
 
 /**
  * Maps a byte array to a point in an Edwards elliptic curve using
@@ -494,7 +494,8 @@ void ed_map(ed_t p, const uint8_t *msg, int len);
  * @param[in] dst			- the domain separation tag.
  * @param[in] dst_len		- the domain separation tag length in bytes.
  */
-void ed_map_dst(ed_t p, const uint8_t *msg, int len, const uint8_t *dst, int dst_len);
+void ed_map_dst(ed_t p, const uint8_t *msg, size_t len, const uint8_t *dst,
+		size_t dst_len);
 
 /**
  * Multiplies an Edwards elliptic curve point by an integer. Computes R = [k]P.
@@ -840,7 +841,7 @@ int ed_size_bin(const ed_t a, int pack);
  * @throw ERR_NO_VALID		- if the encoded point is invalid.
  * @throw ERR_NO_BUFFER		- if the buffer capacity is invalid.
  */
-void ed_read_bin(ed_t a, const uint8_t *bin, int len);
+void ed_read_bin(ed_t a, const uint8_t *bin, size_t len);
 
 /**
  * Writes an Edwards elliptic curve point to a byte vector in big-endian format
@@ -852,7 +853,7 @@ void ed_read_bin(ed_t a, const uint8_t *bin, int len);
  * @param[in] pack			- the flag to indicate point compression.
  * @throw ERR_NO_BUFFER		- if the buffer capacity is invalid.
  */
-void ed_write_bin(uint8_t *bin, int len, const ed_t a, int pack);
+void ed_write_bin(uint8_t *bin, size_t len, const ed_t a, int pack);
 
 /**
  * Multiplies an Edwards elliptic point by an integer using the binary method.
diff --git a/include/relic_ep.h b/include/relic_ep.h
index 506288b2f..0e8334626 100644
--- a/include/relic_ep.h
+++ b/include/relic_ep.h
@@ -811,7 +811,7 @@ int ep_size_bin(const ep_t a, int pack);
  * @throw ERR_NO_VALID		- if the encoded point is invalid.
  * @throw ERR_NO_BUFFER		- if the buffer capacity is invalid.
  */
-void ep_read_bin(ep_t a, const uint8_t *bin, int len);
+void ep_read_bin(ep_t a, const uint8_t *bin, size_t len);
 
 /**
  * Writes a prime elliptic curve point to a byte vector in big-endian format
@@ -823,7 +823,7 @@ void ep_read_bin(ep_t a, const uint8_t *bin, int len);
  * @param[in] pack			- the flag to indicate point compression.
  * @throw ERR_NO_BUFFER		- if the buffer capacity is invalid.
  */
-void ep_write_bin(uint8_t *bin, int len, const ep_t a, int pack);
+void ep_write_bin(uint8_t *bin, size_t len, const ep_t a, int pack);
 
 /**
  * Negates a prime elliptic curve point.
@@ -1215,7 +1215,7 @@ void ep_norm_sim(ep_t *r, const ep_t *t, int n);
  * @param[in] uniform_bytes		- the array of uniform bytes to map.
  * @param[in] len			- the array length in bytes.
  */
-void ep_map_from_field(ep_t p, const uint8_t *uniform_bytes, int len);
+void ep_map_from_field(ep_t p, const uint8_t *uniform_bytes, size_t len);
 
 /**
  * Maps a byte array to a point in a prime elliptic curve.
@@ -1224,7 +1224,7 @@ void ep_map_from_field(ep_t p, const uint8_t *uniform_bytes, int len);
  * @param[in] msg			- the byte array to map.
  * @param[in] len			- the array length in bytes.
  */
-void ep_map(ep_t p, const uint8_t *msg, int len);
+void ep_map(ep_t p, const uint8_t *msg, size_t len);
 
 /**
  * Maps a byte array to a point in a prime elliptic curve with specified
@@ -1236,8 +1236,8 @@ void ep_map(ep_t p, const uint8_t *msg, int len);
  * @param[in] dst			- the domain separation tag.
  * @param[in] dst_len		- the domain separation tag length in bytes.
  */
-void ep_map_dst(ep_t p, const uint8_t *msg, int len, const uint8_t *dst,
-		int dst_len);
+void ep_map_dst(ep_t p, const uint8_t *msg, size_t len, const uint8_t *dst,
+		size_t dst_len);
 
 /**
  * Compresses a point.
diff --git a/include/relic_epx.h b/include/relic_epx.h
index fb2c821c6..2b17e50af 100644
--- a/include/relic_epx.h
+++ b/include/relic_epx.h
@@ -745,7 +745,7 @@ int ep2_size_bin(const ep2_t a, int pack);
  * @throw ERR_NO_VALID		- if the encoded point is invalid.
  * @throw ERR_NO_BUFFER		- if the buffer capacity is invalid.
  */
-void ep2_read_bin(ep2_t a, const uint8_t *bin, int len);
+void ep2_read_bin(ep2_t a, const uint8_t *bin, size_t len);
 
 /**
  * Writes a prime elliptic curve pointer over a quadratic extension to a byte
@@ -757,7 +757,7 @@ void ep2_read_bin(ep2_t a, const uint8_t *bin, int len);
  * @param[in] pack			- the flag to indicate point compression.
  * @throw ERR_NO_BUFFER		- if the buffer capacity is invalid.
  */
-void ep2_write_bin(uint8_t *bin, int len, const ep2_t a, int pack);
+void ep2_write_bin(uint8_t *bin, size_t len, const ep2_t a, int pack);
 
 /**
  * Negates a point represented in affine coordinates in an elliptic curve over
@@ -1060,7 +1060,8 @@ void ep2_mul_sim_trick(ep2_t r, const ep2_t p, const bn_t k, const ep2_t q, cons
  * @param[in] q				- the second point to multiply.
  * @param[in] m				- the second integer,
  */
-void ep2_mul_sim_inter(ep2_t r, const ep2_t p, const bn_t k, const ep2_t q, const bn_t m);
+void ep2_mul_sim_inter(ep2_t r, const ep2_t p, const bn_t k, const ep2_t q,
+			const bn_t m);
 
 /**
  * Multiplies and adds two prime elliptic curve points simultaneously using
@@ -1072,7 +1073,8 @@ void ep2_mul_sim_inter(ep2_t r, const ep2_t p, const bn_t k, const ep2_t q, cons
  * @param[in] q				- the second point to multiply.
  * @param[in] m				- the second integer,
  */
-void ep2_mul_sim_joint(ep2_t r, const ep2_t p, const bn_t k, const ep2_t q, const bn_t m);
+void ep2_mul_sim_joint(ep2_t r, const ep2_t p, const bn_t k, const ep2_t q,
+			const bn_t m);
 
 /**
  * Multiplies simultaneously elements from a prime elliptic curve.
@@ -1083,7 +1085,7 @@ void ep2_mul_sim_joint(ep2_t r, const ep2_t p, const bn_t k, const ep2_t q, cons
  * @param[out] k			- the integer scalars.
  * @param[out] n			- the number of elements to multiply.
  */
-void ep2_mul_sim_lot(ep2_t r, const ep2_t p[], const bn_t k[], int n);
+void ep2_mul_sim_lot(ep2_t r, const ep2_t p[], const bn_t k[], size_t n);
 
 /**
  * Multiplies and adds the generator and a prime elliptic curve point
@@ -1105,7 +1107,7 @@ void ep2_mul_sim_gen(ep2_t r, const bn_t k, const ep2_t q, const bn_t m);
  * @param[in] k				- the small scalars.
  * @param[in] len			- the number of points to multiply.
  */
-void ep2_mul_sim_dig(ep2_t r, const ep2_t p[], const dig_t k[], int len);
+void ep2_mul_sim_dig(ep2_t r, const ep2_t p[], const dig_t k[], size_t len);
 
 /**
  * Converts a point to affine coordinates.
@@ -1134,7 +1136,7 @@ void ep2_norm_sim(ep2_t *r, const ep2_t *t, int n);
  * @param[in] uniform_bytes		- the array of uniform bytes to map.
  * @param[in] len			- the array length in bytes.
  */
-void ep2_map_from_field(ep2_t p, const uint8_t *uniform_bytes, int len);
+void ep2_map_from_field(ep2_t p, const uint8_t *uniform_bytes, size_t len);
 
 /**
  * Maps a byte array to a point in an elliptic curve over a quadratic extension.
@@ -1143,7 +1145,7 @@ void ep2_map_from_field(ep2_t p, const uint8_t *uniform_bytes, int len);
  * @param[in] msg			- the byte array to map.
  * @param[in] len			- the array length in bytes.
  */
-void ep2_map(ep2_t p, const uint8_t *msg, int len);
+void ep2_map(ep2_t p, const uint8_t *msg, size_t len);
 
 /**
  * Maps a byte array to a point in an elliptic curve over a quadratic extension
@@ -1155,7 +1157,8 @@ void ep2_map(ep2_t p, const uint8_t *msg, int len);
  * @param[in] dst			- the domain separatoin tag.
  * @param[in] dst_len		- the domain separation tag length in bytes.
  */
-void ep2_map_dst(ep2_t p, const uint8_t *msg, int len, const uint8_t *dst, int dst_len);
+void ep2_map_dst(ep2_t p, const uint8_t *msg, size_t len, const uint8_t *dst,
+		size_t dst_len);
 
 /**
  * Computes a power of the Gailbraith-Lin-Scott homomorphism of a point
@@ -1385,7 +1388,7 @@ int ep4_size_bin(const ep4_t a, int pack);
  * @throw ERR_NO_VALID		- if the encoded point is invalid.
  * @throw ERR_NO_BUFFER		- if the buffer capacity is invalid.
  */
-void ep4_read_bin(ep4_t a, const uint8_t *bin, int len);
+void ep4_read_bin(ep4_t a, const uint8_t *bin, size_t len);
 
 /**
  * Writes a prime elliptic curve pointer over a quartic extension to a byte
@@ -1397,7 +1400,7 @@ void ep4_read_bin(ep4_t a, const uint8_t *bin, int len);
  * @param[in] pack			- the flag to indicate compression.
  * @throw ERR_NO_BUFFER		- if the buffer capacity is invalid.
  */
-void ep4_write_bin(uint8_t *bin, int len, const ep4_t a, int pack);
+void ep4_write_bin(uint8_t *bin, size_t len, const ep4_t a, int pack);
 
 /**
  * Negates a point represented in affine coordinates in an elliptic curve over
@@ -1723,7 +1726,7 @@ void ep4_mul_sim_joint(ep4_t r, const ep4_t p, const bn_t k, const ep4_t q, cons
  * @param[in] k			- the integer scalars.
  * @param[in] n			- the number of elements to multiply.
  */
-void ep4_mul_sim_lot(ep4_t r, const ep4_t p[], const bn_t k[], int n);
+void ep4_mul_sim_lot(ep4_t r, const ep4_t p[], const bn_t k[], size_t n);
 
 /**
  * Multiplies and adds the generator and a prime elliptic curve point
@@ -1745,7 +1748,7 @@ void ep4_mul_sim_gen(ep4_t r, const bn_t k, const ep4_t q, const bn_t m);
  * @param[in] k				- the small scalars.
  * @param[in] len			- the number of points to multiply.
  */
-void ep4_mul_sim_dig(ep4_t r, const ep4_t p[], const dig_t k[], int len);
+void ep4_mul_sim_dig(ep4_t r, const ep4_t p[], const dig_t k[], size_t len);
 
 /**
  * Converts a point to affine coordinates.
@@ -1771,7 +1774,7 @@ void ep4_norm_sim(ep4_t *r, const ep4_t *t, int n);
  * @param[in] msg			- the byte array to map.
  * @param[in] len			- the array length in bytes.
  */
-void ep4_map(ep4_t p, const uint8_t *msg, int len);
+void ep4_map(ep4_t p, const uint8_t *msg, size_t len);
 
 /**
  * Maps a byte array to a point in an elliptic curve over a quartic extension
@@ -1783,7 +1786,8 @@ void ep4_map(ep4_t p, const uint8_t *msg, int len);
  * @param[in] dst			- the domain separatoin tag.
  * @param[in] dst_len		- the domain separation tag length in bytes.
  */
-void ep4_map_dst(ep4_t p, const uint8_t *msg, int len, const uint8_t *dst, int dst_len);
+void ep4_map_dst(ep4_t p, const uint8_t *msg, size_t len, const uint8_t *dst,
+		size_t dst_len);
 
 /**
  * Computes a power of the Gailbraith-Lin-Scott homomorphism of a point
diff --git a/include/relic_fb.h b/include/relic_fb.h
index 48fe45b80..690d7d459 100644
--- a/include/relic_fb.h
+++ b/include/relic_fb.h
@@ -48,17 +48,17 @@
 /**
  * Precision in bits of a binary field element.
  */
-#define RLC_FB_BITS 	((int)FB_POLYN)
+#define RLC_FB_BITS 	((size_t)FB_POLYN)
 
 /**
  * Size in digits of a block sufficient to store a binary field element.
  */
-#define RLC_FB_DIGS		((int)RLC_CEIL(RLC_FB_BITS, RLC_DIG))
+#define RLC_FB_DIGS		((size_t)RLC_CEIL(RLC_FB_BITS, RLC_DIG))
 
 /**
  * Size in bytes of a block sufficient to store a binary field element.
  */
-#define RLC_FB_BYTES 	((int)RLC_CEIL(RLC_FB_BITS, 8))
+#define RLC_FB_BYTES 	((size_t)RLC_CEIL(RLC_FB_BITS, 8))
 
 /**
  * Finite field identifiers.
@@ -538,7 +538,7 @@ int fb_is_zero(const fb_t a);
  * @param[in] bit			- the bit position.
  * @return the bit value.
  */
-int fb_get_bit(const fb_t a, int bit);
+int fb_get_bit(const fb_t a, size_t bit);
 
 /**
  * Stores a bit in a given position on a binary field element.
@@ -547,7 +547,7 @@ int fb_get_bit(const fb_t a, int bit);
  * @param[in] bit			- the bit position.
  * @param[in] value			- the bit value.
  */
-void fb_set_bit(fb_t a, int bit, int value);
+void fb_set_bit(fb_t a, size_t bit, int value);
 
 /**
  * Assigns a small positive polynomial to a binary field element.
@@ -565,7 +565,7 @@ void fb_set_dig(fb_t c, dig_t a);
  * @param[in] a				- the binary field element.
  * @return the number of bits.
  */
-int fb_bits(const fb_t a);
+size_t fb_bits(const fb_t a);
 
 /**
  * Assigns a random value to a binary field element.
@@ -590,7 +590,7 @@ void fb_print(const fb_t a);
  * @throw ERR_NO_VALID		- if the radix is invalid.
  * @return the number of digits in the given radix.
  */
-int fb_size_str(const fb_t a, int radix);
+size_t fb_size_str(const fb_t a, unsigned int radix);
 
 /**
  * Reads a binary field element from a string in a given radix. The radix must
@@ -603,7 +603,7 @@ int fb_size_str(const fb_t a, int radix);
  * @throw ERR_NO_VALID		- if the radix is invalid.
  * @throw ERR_NO_BUFFER		- if the string is too long.
  */
-void fb_read_str(fb_t a, const char *str, int len, int radix);
+void fb_read_str(fb_t a, const char *str, size_t len, unsigned int radix);
 
 /**
  * Writes a binary field element to a string in a given radix. The radix must
@@ -616,17 +616,17 @@ void fb_read_str(fb_t a, const char *str, int len, int radix);
  * @throw ERR_NO_VALID		- if the radix is invalid.
  * @throw ERR_NO_BUFFER		- if the buffer capacity is insufficient.
  */
-void fb_write_str(char *str, int len, const fb_t a, int radix);
+void fb_write_str(char *str, size_t len, const fb_t a, unsigned int radix);
 
 /**
  * Reads a binary field element from a byte vector in big-endian format.
  *
  * @param[out] a			- the result.
- * @param[in] bin			- the byte vector.
+ * @param[in] bin			- the byte vector.,
  * @param[in] len			- the buffer capacity.
  * @throw ERR_NO_BUFFER		- if the buffer capacity is not RLC_FP_BYTES.
  */
-void fb_read_bin(fb_t a, const uint8_t *bin, int len);
+void fb_read_bin(fb_t a, const uint8_t *bin, size_t len);
 
 /**
  * Writes a binary field element to a byte vector in big-endian format.
@@ -636,7 +636,7 @@ void fb_read_bin(fb_t a, const uint8_t *bin, int len);
  * @param[in] a				- the binary field element to write.
  * @throw ERR_NO_BUFFER		- if the buffer capacity is not RLC_FP_BYTES.
  */
-void fb_write_bin(uint8_t *bin, int len, const fb_t a);
+void fb_write_bin(uint8_t *bin, size_t len, const fb_t a);
 
 /**
  * Returns the result of a comparison between two binary field elements.
diff --git a/include/relic_fp.h b/include/relic_fp.h
index 609948604..b78fe2e4d 100644
--- a/include/relic_fp.h
+++ b/include/relic_fp.h
@@ -48,17 +48,17 @@
 /**
  * Precision in bits of a prime field element.
  */
-#define RLC_FP_BITS 	((int)FP_PRIME)
+#define RLC_FP_BITS 	((size_t)FP_PRIME)
 
 /**
  * Size in digits of a block sufficient to store a prime field element.
  */
-#define RLC_FP_DIGS 	((int)RLC_CEIL(RLC_FP_BITS, RLC_DIG))
+#define RLC_FP_DIGS 	((size_t)RLC_CEIL(RLC_FP_BITS, RLC_DIG))
 
 /**
  * Size in bytes of a block sufficient to store a binary field element.
  */
-#define RLC_FP_BYTES 	((int)RLC_CEIL(RLC_FP_BITS, 8))
+#define RLC_FP_BYTES 	((size_t)RLC_CEIL(RLC_FP_BITS, 8))
 
 /*
  * Finite field identifiers.
@@ -501,10 +501,10 @@ void fp_prime_set_dense(const bn_t p);
  * @param[in] spars		- the list of powers of 2 describing the prime.
  * @param[in] len		- the number of powers.
  */
-void fp_prime_set_pmers(const int *spars, int len);
+void fp_prime_set_pmers(const int *spars, size_t len);
 
 /**
-* Assigns the prime field modulus to a parametrization from a family of
+ * Assigns the prime field modulus to a parametrization from a family of
  * pairing-friendly curves.
  */
 void fp_prime_set_pairf(const bn_t x, int pairf);
@@ -653,7 +653,7 @@ int fp_is_even(const fp_t a);
  * @param[in] bit			- the bit position.
  * @return the bit value.
  */
-int fp_get_bit(const fp_t a, int bit);
+int fp_get_bit(const fp_t a, size_t bit);
 
 /**
  * Stores a bit in a given position on a prime field element.
@@ -662,7 +662,7 @@ int fp_get_bit(const fp_t a, int bit);
  * @param[in] bit			- the bit position.
  * @param[in] value			- the bit value.
  */
-void fp_set_bit(fp_t a, int bit, int value);
+void fp_set_bit(fp_t a, size_t bit, int value);
 
 /**
  * Assigns a small positive constant to a prime field element.
@@ -681,7 +681,7 @@ void fp_set_dig(fp_t c, dig_t a);
  * @param[in] a				- the prime field element.
  * @return the number of bits.
  */
-int fp_bits(const fp_t a);
+size_t fp_bits(const fp_t a);
 
 /**
  * Assigns a random value to a prime field element.
@@ -706,7 +706,7 @@ void fp_print(const fp_t a);
  * @throw ERR_NO_VALID		- if the radix is invalid.
  * @return the number of digits in the given radix.
  */
-int fp_size_str(const fp_t a, int radix);
+size_t fp_size_str(const fp_t a, unsigned int radix);
 
 /**
  * Reads a prime field element from a string in a given radix. The radix must
@@ -718,7 +718,7 @@ int fp_size_str(const fp_t a, int radix);
  * @param[in] radix			- the radix.
  * @throw ERR_NO_VALID		- if the radix is invalid.
  */
-void fp_read_str(fp_t a, const char *str, int len, int radix);
+void fp_read_str(fp_t a, const char *str, size_t len, unsigned int radix);
 
 /**
  * Writes a prime field element to a string in a given radix. The radix must
@@ -731,7 +731,7 @@ void fp_read_str(fp_t a, const char *str, int len, int radix);
  * @throw ERR_BUFFER		- if the buffer capacity is insufficient.
  * @throw ERR_NO_VALID		- if the radix is invalid.
  */
-void fp_write_str(char *str, int len, const fp_t a, int radix);
+void fp_write_str(char *str, size_t len, const fp_t a, unsigned int radix);
 
 /**
  * Reads a prime field element from a byte vector in big-endian format.
@@ -741,7 +741,7 @@ void fp_write_str(char *str, int len, const fp_t a, int radix);
  * @param[in] len			- the buffer capacity.
  * @throw ERR_NO_BUFFER		- if the buffer capacity is not RLC_FP_BYTES.
  */
-void fp_read_bin(fp_t a, const uint8_t *bin, int len);
+void fp_read_bin(fp_t a, const uint8_t *bin, size_t len);
 
 /**
  * Writes a prime field element to a byte vector in big-endian format.
@@ -751,7 +751,7 @@ void fp_read_bin(fp_t a, const uint8_t *bin, int len);
  * @param[in] a				- the prime field element to write.
  * @throw ERR_NO_BUFFER		- if the buffer capacity is not RLC_FP_BYTES.
  */
-void fp_write_bin(uint8_t *bin, int len, const fp_t a);
+void fp_write_bin(uint8_t *bin, size_t len, const fp_t a);
 
 /**
  * Returns the result of a comparison between two prime field elements.
diff --git a/include/relic_fpx.h b/include/relic_fpx.h
index 8da844833..acdb6a7d0 100644
--- a/include/relic_fpx.h
+++ b/include/relic_fpx.h
@@ -1332,7 +1332,7 @@ int fp2_size_bin(fp2_t a, int pack);
  * @param[in] len			- the buffer capacity.
  * @throw ERR_NO_BUFFER		- if the buffer capacity is not correct.
  */
-void fp2_read_bin(fp2_t a, const uint8_t *bin, int len);
+void fp2_read_bin(fp2_t a, const uint8_t *bin, size_t len);
 
 /**
  * Writes a quadratic extension field element to a byte vector in big-endian
@@ -1344,7 +1344,7 @@ void fp2_read_bin(fp2_t a, const uint8_t *bin, int len);
  * @param[in] pack			- the flag to indicate compression.
  * @throw ERR_NO_BUFFER		- if the buffer capacity is not correct.
  */
-void fp2_write_bin(uint8_t *bin, int len, const fp2_t a, int pack);
+void fp2_write_bin(uint8_t *bin, size_t len, const fp2_t a, int pack);
 
 /**
  * Returns the result of a comparison between two quadratic extension field
@@ -1690,7 +1690,7 @@ int fp3_size_bin(fp3_t a);
  * @param[in] len			- the buffer capacity.
  * @throw ERR_NO_BUFFER		- if the buffer capacity is not correct.
  */
-void fp3_read_bin(fp3_t a, const uint8_t *bin, int len);
+void fp3_read_bin(fp3_t a, const uint8_t *bin, size_t len);
 
 /**
  * Writes a cubic extension field element to a byte vector in big-endian
@@ -1701,7 +1701,7 @@ void fp3_read_bin(fp3_t a, const uint8_t *bin, int len);
  * @param[in] a				- the extension field element to write.
  * @throw ERR_NO_BUFFER		- if the buffer capacity is not correct.
  */
-void fp3_write_bin(uint8_t *bin, int len, const fp3_t a);
+void fp3_write_bin(uint8_t *bin, size_t len, const fp3_t a);
 
 /**
  * Returns the result of a comparison between two cubic extension field
@@ -1956,7 +1956,7 @@ int fp4_size_bin(fp4_t a);
  * @param[in] len			- the buffer capacity.
  * @throw ERR_NO_BUFFER		- if the buffer capacity is not correct.
  */
-void fp4_read_bin(fp4_t a, const uint8_t *bin, int len);
+void fp4_read_bin(fp4_t a, const uint8_t *bin, size_t len);
 
 /**
  * Writes a quartic extension field element to a byte vector in big-endian
@@ -1967,7 +1967,7 @@ void fp4_read_bin(fp4_t a, const uint8_t *bin, int len);
  * @param[in] a				- the extension field element to write.
  * @throw ERR_NO_BUFFER		- if the buffer capacity is not correct.
  */
-void fp4_write_bin(uint8_t *bin, int len, const fp4_t a);
+void fp4_write_bin(uint8_t *bin, size_t len, const fp4_t a);
 
 /**
  * Returns the result of a comparison between two quartic extension field
@@ -2226,7 +2226,7 @@ int fp6_size_bin(fp6_t a);
  * @param[in] len			- the buffer capacity.
  * @throw ERR_NO_BUFFER		- if the buffer capacity is not correct.
  */
-void fp6_read_bin(fp6_t a, const uint8_t *bin, int len);
+void fp6_read_bin(fp6_t a, const uint8_t *bin, size_t len);
 
 /**
  * Writes a sextic extension field element to a byte vector in big-endian
@@ -2237,7 +2237,7 @@ void fp6_read_bin(fp6_t a, const uint8_t *bin, int len);
  * @param[in] a				- the extension field element to write.
  * @throw ERR_NO_BUFFER		- if the buffer capacity is not correct.
  */
-void fp6_write_bin(uint8_t *bin, int len, const fp6_t a);
+void fp6_write_bin(uint8_t *bin, size_t len, const fp6_t a);
 
 /**
  * Returns the result of a comparison between two sextic extension field
@@ -2456,7 +2456,7 @@ int fp8_size_bin(fp8_t a, int pack);
  * @param[in] len			- the buffer capacity.
  * @throw ERR_NO_BUFFER		- if the buffer capacity is not correct.
  */
-void fp8_read_bin(fp8_t a, const uint8_t *bin, int len);
+void fp8_read_bin(fp8_t a, const uint8_t *bin, size_t len);
 
 /**
  * Writes an octic extension field element to a byte vector in big-endian
@@ -2467,7 +2467,7 @@ void fp8_read_bin(fp8_t a, const uint8_t *bin, int len);
  * @param[in] a				- the extension field element to write.
  * @throw ERR_NO_BUFFER		- if the buffer capacity is not correct.
  */
-void fp8_write_bin(uint8_t *bin, int len, const fp8_t a);
+void fp8_write_bin(uint8_t *bin, size_t len, const fp8_t a);
 
 /**
  * Returns the result of a comparison between two octic extension field
@@ -2739,7 +2739,7 @@ int fp9_size_bin(fp9_t a);
  * @param[in] len			- the buffer capacity.
  * @throw ERR_NO_BUFFER		- if the buffer capacity is not correct.
  */
-void fp9_read_bin(fp9_t a, const uint8_t *bin, int len);
+void fp9_read_bin(fp9_t a, const uint8_t *bin, size_t len);
 
 /**
  * Writes a nonic extension field element to a byte vector in big-endian
@@ -2750,7 +2750,7 @@ void fp9_read_bin(fp9_t a, const uint8_t *bin, int len);
  * @param[in] a				- the extension field element to write.
  * @throw ERR_NO_BUFFER		- if the buffer capacity is not correct.
  */
-void fp9_write_bin(uint8_t *bin, int len, const fp9_t a);
+void fp9_write_bin(uint8_t *bin, size_t len, const fp9_t a);
 
 /**
  * Returns the result of a comparison between two nonic extension field
@@ -2978,7 +2978,7 @@ int fp12_size_bin(fp12_t a, int pack);
  * @param[in] len			- the buffer capacity.
  * @throw ERR_NO_BUFFER		- if the buffer capacity is not correct.
  */
-void fp12_read_bin(fp12_t a, const uint8_t *bin, int len);
+void fp12_read_bin(fp12_t a, const uint8_t *bin, size_t len);
 
 /**
  * Writes a dodecic extension field element to a byte vector in big-endian
@@ -2990,7 +2990,7 @@ void fp12_read_bin(fp12_t a, const uint8_t *bin, int len);
  * @param[in] pack			- the flag to indicate compression.
  * @throw ERR_NO_BUFFER		- if the buffer capacity is not correct.
  */
-void fp12_write_bin(uint8_t *bin, int len, const fp12_t a, int pack);
+void fp12_write_bin(uint8_t *bin, size_t len, const fp12_t a, int pack);
 
 /**
  * Returns the result of a comparison between two dodecic extension field
@@ -3282,7 +3282,8 @@ void fp12_exp_cyc(fp12_t c, const fp12_t a, const bn_t b);
  * @param[in] c				- the second element to exponentiate.
  * @param[in] d				- the second exponent.
  */
-void fp2_exp_cyc_sim(fp2_t e, const fp2_t a, const bn_t b, const fp2_t c, const bn_t d);
+void fp2_exp_cyc_sim(fp2_t e, const fp2_t a, const bn_t b, const fp2_t c,
+		const bn_t d);
 
 /**
  * Computes a power of a cyclotomic dodecic extension field element.
@@ -3293,7 +3294,8 @@ void fp2_exp_cyc_sim(fp2_t e, const fp2_t a, const bn_t b, const fp2_t c, const
  * @param[in] c				- the second element to exponentiate.
  * @param[in] d				- the second exponent.
  */
-void fp12_exp_cyc_sim(fp12_t e, const fp12_t a, const bn_t b, const fp12_t c, const bn_t d);
+void fp12_exp_cyc_sim(fp12_t e, const fp12_t a, const bn_t b, const fp12_t c,
+		const bn_t d);
 
 /**
  * Computes a power of a cyclotomic dodecic extension field element.
@@ -3304,7 +3306,7 @@ void fp12_exp_cyc_sim(fp12_t e, const fp12_t a, const bn_t b, const fp12_t c, co
  * @param[in] l				- the length of the exponent in sparse form.
  * @param[in] s				- the sign of the exponent.
  */
-void fp12_exp_cyc_sps(fp12_t c, const fp12_t a, const int *b, int l, int s);
+void fp12_exp_cyc_sps(fp12_t c, const fp12_t a, const int *b, size_t l, int s);
 
 /**
  * Compresses a dodecic extension field element.
@@ -3395,7 +3397,7 @@ int fp18_size_bin(fp18_t a);
  * @param[in] len			- the buffer capacity.
  * @throw ERR_NO_BUFFER		- if the buffer capacity is not correct.
  */
-void fp18_read_bin(fp18_t a, const uint8_t *bin, int len);
+void fp18_read_bin(fp18_t a, const uint8_t *bin, size_t len);
 
 /**
  * Writes an octdecic extension field element to a byte vector in big-endian
@@ -3406,7 +3408,7 @@ void fp18_read_bin(fp18_t a, const uint8_t *bin, int len);
  * @param[in] a				- the extension field element to write.
  * @throw ERR_NO_BUFFER		- if the buffer capacity is not correct.
  */
-void fp18_write_bin(uint8_t *bin, int len, const fp18_t a);
+void fp18_write_bin(uint8_t *bin, size_t len, const fp18_t a);
 
 /**
  * Returns the result of a comparison between two octdecic extension field
@@ -3657,7 +3659,7 @@ int fp24_size_bin(fp24_t a, int pack);
  * @param[in] len			- the buffer capacity.
  * @throw ERR_NO_BUFFER		- if the buffer capacity is not correct.
  */
-void fp24_read_bin(fp24_t a, const uint8_t *bin, int len);
+void fp24_read_bin(fp24_t a, const uint8_t *bin, size_t len);
 
 /**
  * Writes a 24-degree extension field element to a byte vector in big-endian
@@ -3669,7 +3671,7 @@ void fp24_read_bin(fp24_t a, const uint8_t *bin, int len);
  * @param[in] pack			- the flag to indicate compression.
  * @throw ERR_NO_BUFFER		- if the buffer capacity is not correct.
  */
-void fp24_write_bin(uint8_t *bin, int len, const fp24_t a, int pack);
+void fp24_write_bin(uint8_t *bin, size_t len, const fp24_t a, int pack);
 
 /**
  * Returns the result of a comparison between two 24-degree extension field
@@ -3961,7 +3963,7 @@ void fp24_exp_cyc_sim(fp24_t e, const fp24_t a, const bn_t b, const fp24_t c, co
  * @param[in] l				- the length of the exponent in sparse form.
  * @param[in] s				- the sign of the exponent.
  */
-void fp24_exp_cyc_sps(fp24_t c, const fp24_t a, const int *b, int l, int s);
+void fp24_exp_cyc_sps(fp24_t c, const fp24_t a, const int *b, size_t l, int s);
 
 /**
  * Compresses a 24-extension field element.
@@ -4036,7 +4038,7 @@ int fp48_size_bin(fp48_t a, int pack);
  * @param[in] len			- the buffer capacity.
  * @throw ERR_NO_BUFFER		- if the buffer capacity is not correct.
  */
-void fp48_read_bin(fp48_t a, const uint8_t *bin, int len);
+void fp48_read_bin(fp48_t a, const uint8_t *bin, size_t len);
 
 /**
  * Writes a 48-extension field element to a byte vector in big-endian
@@ -4048,7 +4050,7 @@ void fp48_read_bin(fp48_t a, const uint8_t *bin, int len);
  * @param[in] pack			- the flag to indicate compression.
  * @throw ERR_NO_BUFFER		- if the buffer capacity is not correct.
  */
-void fp48_write_bin(uint8_t *bin, int len, const fp48_t a, int pack);
+void fp48_write_bin(uint8_t *bin, size_t len, const fp48_t a, int pack);
 
 /**
  * Returns the result of a comparison between two 48-extension field
@@ -4312,7 +4314,7 @@ void fp48_exp_cyc(fp48_t c, const fp48_t a, const bn_t b);
  * @param[in] l				- the length of the exponent in sparse form.
  * @param[in] s				- the sign of the exponent.
  */
-void fp48_exp_cyc_sps(fp48_t c, const fp48_t a, const int *b, int l, int s);
+void fp48_exp_cyc_sps(fp48_t c, const fp48_t a, const int *b, size_t l, int s);
 
 /**
  * Compresses a 48-extension field element.
@@ -4387,7 +4389,7 @@ int fp54_size_bin(fp54_t a, int pack);
  * @param[in] len			- the buffer capacity.
  * @throw ERR_NO_BUFFER		- if the buffer capacity is not correct.
  */
-void fp54_read_bin(fp54_t a, const uint8_t *bin, int len);
+void fp54_read_bin(fp54_t a, const uint8_t *bin, size_t len);
 
 /**
  * Writes a 54-extension field element to a byte vector in big-endian
@@ -4399,7 +4401,7 @@ void fp54_read_bin(fp54_t a, const uint8_t *bin, int len);
  * @param[in] pack			- the flag to indicate compression.
  * @throw ERR_NO_BUFFER		- if the buffer capacity is not correct.
  */
-void fp54_write_bin(uint8_t *bin, int len, const fp54_t a, int pack);
+void fp54_write_bin(uint8_t *bin, size_t len, const fp54_t a, int pack);
 
 /**
  * Returns the result of a comparison between two 54-extension field
@@ -4663,7 +4665,7 @@ void fp54_exp_cyc(fp54_t c, const fp54_t a, const bn_t b);
  * @param[in] l				- the length of the exponent in sparse form.
  * @param[in] s				- the sign of the exponent.
  */
-void fp54_exp_cyc_sps(fp54_t c, const fp54_t a, const int *b, int l, int s);
+void fp54_exp_cyc_sps(fp54_t c, const fp54_t a, const int *b, size_t l, int s);
 
 /**
  * Compresses a 54-extension field element.
diff --git a/include/relic_md.h b/include/relic_md.h
index a624b66cc..5ec5d28b6 100644
--- a/include/relic_md.h
+++ b/include/relic_md.h
@@ -134,7 +134,7 @@ enum {
  * @param[in] msg				- the message to hash.
  * @param[in] len				- the message length in bytes.
  */
-void md_map_sh224(uint8_t *hash, const uint8_t *msg, int len);
+void md_map_sh224(uint8_t *hash, const uint8_t *msg, size_t len);
 
 /**
  * Computes the SHA-256 hash function.
@@ -143,7 +143,7 @@ void md_map_sh224(uint8_t *hash, const uint8_t *msg, int len);
  * @param[in] msg				- the message to hash.
  * @param[in] len				- the message length in bytes.
  */
-void md_map_sh256(uint8_t *hash, const uint8_t *msg, int len);
+void md_map_sh256(uint8_t *hash, const uint8_t *msg, size_t len);
 
 /**
  * Computes the SHA-384 hash function.
@@ -152,7 +152,7 @@ void md_map_sh256(uint8_t *hash, const uint8_t *msg, int len);
  * @param[in] msg				- the message to hash.
  * @param[in] len				- the message length in bytes.
  */
-void md_map_sh384(uint8_t *hash, const uint8_t *msg, int len);
+void md_map_sh384(uint8_t *hash, const uint8_t *msg, size_t len);
 
 /**
  * Computes the SHA-512 hash function.
@@ -161,7 +161,7 @@ void md_map_sh384(uint8_t *hash, const uint8_t *msg, int len);
  * @param[in] msg				- the message to hash.
  * @param[in] len				- the message length in bytes.
  */
-void md_map_sh512(uint8_t *hash, const uint8_t *msg, int len);
+void md_map_sh512(uint8_t *hash, const uint8_t *msg, size_t len);
 
 /**
  * Computes the BLAKE2s-160 hash function.
@@ -170,7 +170,7 @@ void md_map_sh512(uint8_t *hash, const uint8_t *msg, int len);
  * @param[in] msg				- the message to hash.
  * @param[in] len				- the message length in bytes.
  */
-void md_map_b2s160(uint8_t *hash, const uint8_t *msg, int len);
+void md_map_b2s160(uint8_t *hash, const uint8_t *msg, size_t len);
 
 /**
  * Computes the BLAKE2s-256 hash function.
@@ -179,7 +179,7 @@ void md_map_b2s160(uint8_t *hash, const uint8_t *msg, int len);
  * @param[in] msg				- the message to hash.
  * @param[in] len				- the message length in bytes.
  */
-void md_map_b2s256(uint8_t *hash, const uint8_t *msg, int len);
+void md_map_b2s256(uint8_t *hash, const uint8_t *msg, size_t len);
 
 /**
  * Derives a key from shared secret material through the standardized KDF2
@@ -190,7 +190,7 @@ void md_map_b2s256(uint8_t *hash, const uint8_t *msg, int len);
  * @param[in] in				- the shared secret.
  * @param[in] in_len			- the length of the shared secret in bytes.
  */
-void md_kdf(uint8_t *key, int key_len, const uint8_t *in, int in_len);
+void md_kdf(uint8_t *key, size_t key_len, const uint8_t *in, size_t in_len);
 
 /**
  * Derives a mask from shared secret material through the PKCS#1 2.1 MGF1
@@ -201,7 +201,7 @@ void md_kdf(uint8_t *key, int key_len, const uint8_t *in, int in_len);
  * @param[in] in				- the shared secret.
  * @param[in] in_len			- the length of the shared secret in bytes.
  */
-void md_mgf(uint8_t *mask, int mask_len, const uint8_t *in, int in_len);
+void md_mgf(uint8_t *mask, size_t mask_len, const uint8_t *in, size_t in_len);
 
 /**
  * Computes a Message Authentication Code through HMAC.
@@ -212,8 +212,8 @@ void md_mgf(uint8_t *mask, int mask_len, const uint8_t *in, int in_len);
  * @param[in] key				- the cryptographic key.
  * @param[in] key_len			- the size of the key in bytes.
  */
-void md_hmac(uint8_t *mac, const uint8_t *in, int in_len, const uint8_t *key,
-		int key_len);
+void md_hmac(uint8_t *mac, const uint8_t *in, size_t in_len, const uint8_t *key,
+		size_t key_len);
 
 /**
  * Map a byte vector and optional domain separation tag to an arbitrary-length
@@ -226,8 +226,8 @@ void md_hmac(uint8_t *mac, const uint8_t *in, int in_len, const uint8_t *key,
  * @param[in] dst					- the domain separation tag.
  * @param[in] dst_len				- the domain separation tag length in bytes.
  */
-void md_xmd_sh224(uint8_t *buf, int buf_len, const uint8_t *in, int in_len,
-		const uint8_t *dst, int dst_len);
+void md_xmd_sh224(uint8_t *buf, size_t buf_len, const uint8_t *in,
+		size_t in_len, const uint8_t *dst, size_t dst_len);
 
 /**
  * Map a byte vector and optional domain separation tag to an arbitrary-length
@@ -240,8 +240,8 @@ void md_xmd_sh224(uint8_t *buf, int buf_len, const uint8_t *in, int in_len,
  * @param[in] dst					- the domain separation tag.
  * @param[in] dst_len				- the domain separation tag length in bytes.
  */
-void md_xmd_sh256(uint8_t *buf, int buf_len, const uint8_t *in, int in_len,
-		const uint8_t *dst, int dst_len);
+void md_xmd_sh256(uint8_t *buf, size_t buf_len, const uint8_t *in,
+		size_t in_len, const uint8_t *dst, size_t dst_len);
 
 /**
  * Map a byte vector and optional domain separation tag to an arbitrary-length
@@ -254,8 +254,8 @@ void md_xmd_sh256(uint8_t *buf, int buf_len, const uint8_t *in, int in_len,
  * @param[in] dst					- the domain separation tag.
  * @param[in] dst_len				- the domain separation tag length in bytes.
  */
-void md_xmd_sh384(uint8_t *buf, int buf_len, const uint8_t *in, int in_len,
-		const uint8_t *dst, int dst_len);
+void md_xmd_sh384(uint8_t *buf, size_t buf_len, const uint8_t *in,
+		size_t in_len, const uint8_t *dst, size_t dst_len);
 
 /**
  * Map a byte vector and optional domain separation tag to an arbitrary-length
@@ -268,7 +268,7 @@ void md_xmd_sh384(uint8_t *buf, int buf_len, const uint8_t *in, int in_len,
  * @param[in] dst					- the domain separation tag.
  * @param[in] dst_len				- the domain separation tag length in bytes.
  */
-void md_xmd_sh512(uint8_t *buf, int buf_len, const uint8_t *in, int in_len,
-		const uint8_t *dst, int dst_len);
+void md_xmd_sh512(uint8_t *buf, size_t buf_len, const uint8_t *in,
+		size_t in_len, const uint8_t *dst, size_t dst_len);
 
 #endif /* !RLC_MD_H */
diff --git a/include/relic_rand.h b/include/relic_rand.h
index bf92ac376..7138ff9de 100644
--- a/include/relic_rand.h
+++ b/include/relic_rand.h
@@ -89,7 +89,7 @@ void rand_clean(void);
  * @param[in] size			- the number of bytes.
  * @throw ERR_NO_VALID		- if the entropy length is too small or too large.
  */
-void rand_seed(uint8_t *buf, int size);
+void rand_seed(uint8_t *buf, size_t size);
 
 #else
 
@@ -100,7 +100,7 @@ void rand_seed(uint8_t *buf, int size);
  * @param[in] callback		- the callback to call.
  * @param[in] arg			- the argument for the callback.
  */
-void rand_seed(void (*callback)(uint8_t *, int, void *), void *arg);
+void rand_seed(void (*callback)(uint8_t *, size_t, void *), void *arg);
 
 #endif
 
@@ -112,7 +112,7 @@ void rand_seed(void (*callback)(uint8_t *, int, void *), void *arg);
  * @param[in] size			- the number of bytes to check.
  * @throw ERR_NO_RAND       - if the pseudo-random number generator is stuck.
  */
-int rand_check(uint8_t *buf, int size);
+int rand_check(uint8_t *buf, size_t size);
 
 /**
  * Gathers pseudo-random bytes from the pseudo-random number generator.
@@ -123,6 +123,6 @@ int rand_check(uint8_t *buf, int size);
  * @throw ERR_NO_READ		- it the pseudo-random number generator cannot
  * 							generate the specified number of bytes.
  */
-void rand_bytes(uint8_t *buf, int size);
+void rand_bytes(uint8_t *buf, size_t size);
 
 #endif /* !RLC_RAND_H */
diff --git a/include/relic_util.h b/include/relic_util.h
index 806983349..48d956eb9 100644
--- a/include/relic_util.h
+++ b/include/relic_util.h
@@ -285,7 +285,7 @@ char util_conv_char(dig_t i);
  * @param[in] a				- the digit.
  * @return the position of the highest bit set.
  */
-int util_bits_dig(dig_t a);
+size_t util_bits_dig(dig_t a);
 
 /**
  * Compares two buffers in constant time.
diff --git a/src/bn/relic_bn_gcd.c b/src/bn/relic_bn_gcd.c
index bc49b1185..8f4992735 100644
--- a/src/bn/relic_bn_gcd.c
+++ b/src/bn/relic_bn_gcd.c
@@ -202,9 +202,14 @@ void bn_gcd_lehme(bn_t c, const bn_t a, const bn_t b) {
 			bn_abs(y, a);
 		}
 		while (y->used > 1) {
-			bn_rsh(u, x, bn_bits(x) - RLC_DIG);
+			if (bn_bits(x) > RLC_DIG) {
+				bn_rsh(u, x, bn_bits(x) - RLC_DIG);
+				bn_rsh(v, y, bn_bits(x) - RLC_DIG);
+			} else {
+				bn_copy(u, x);
+				bn_copy(v, y);
+			}
 			_x = u->dp[0];
-			bn_rsh(v, y, bn_bits(x) - RLC_DIG);
 			_y = v->dp[0];
 			_a = _d = 1;
 			_b = _c = 0;
@@ -237,8 +242,13 @@ void bn_gcd_lehme(bn_t c, const bn_t a, const bn_t b) {
 				bn_copy(x, y);
 				bn_copy(y, t0);
 			} else {
-				bn_rsh(u, x, bn_bits(x) - 2 * RLC_DIG);
-				bn_rsh(v, y, bn_bits(x) - 2 * RLC_DIG);
+				if (bn_bits(x) > 2 * RLC_DIG) {
+					bn_rsh(u, x, bn_bits(x) - 2 * RLC_DIG);
+					bn_rsh(v, y, bn_bits(x) - 2 * RLC_DIG);
+				} else {
+					bn_copy(u, x);
+					bn_copy(v, y);
+				}
 				if (_a < 0) {
 					bn_mul_dig(t0, u, -_a);
 					bn_neg(t0, t0);
@@ -265,9 +275,14 @@ void bn_gcd_lehme(bn_t c, const bn_t a, const bn_t b) {
 				}
 				bn_add(u, t0, t1);
 				bn_add(v, t2, t3);
-				bn_rsh(t0, u, bn_bits(u) - RLC_DIG);
+				if (bn_bits(u) > RLC_DIG) {
+					bn_rsh(t0, u, bn_bits(u) - RLC_DIG);
+					bn_rsh(t1, v, bn_bits(u) - RLC_DIG);
+				} else {
+					bn_copy(t0, u);
+					bn_copy(t1, v);
+				}
 				_x = t0->dp[0];
-				bn_rsh(t1, v, bn_bits(u) - RLC_DIG);
 				_y = t1->dp[0];
 				t = 0;
 				if (_y != 0) {
@@ -400,9 +415,14 @@ void bn_gcd_ext_lehme(bn_t c, bn_t d, bn_t e, const bn_t a, const bn_t b) {
 		bn_set_dig(d, 1);
 
 		while (y->used > 1) {
-			bn_rsh(u, x, bn_bits(x) - RLC_DIG);
+			if (bn_bits(x) > RLC_DIG) {
+				bn_rsh(u, x, bn_bits(x) - RLC_DIG);
+				bn_rsh(v, y, bn_bits(x) - RLC_DIG);
+			} else {
+				bn_copy(u, x);
+				bn_copy(v, y);
+			}
 			_x = u->dp[0];
-			bn_rsh(v, y, bn_bits(x) - RLC_DIG);
 			_y = v->dp[0];
 			_a = _d = 1;
 			_b = _c = 0;
@@ -439,8 +459,13 @@ void bn_gcd_ext_lehme(bn_t c, bn_t d, bn_t e, const bn_t a, const bn_t b) {
 				bn_copy(t4, d);
 				bn_copy(d, t1);
 			} else {
-				bn_rsh(u, x, bn_bits(x) - 2 * RLC_DIG);
-				bn_rsh(v, y, bn_bits(x) - 2 * RLC_DIG);
+				if (bn_bits(x) > 2 * RLC_DIG) {
+					bn_rsh(u, x, bn_bits(x) - 2 * RLC_DIG);
+					bn_rsh(v, y, bn_bits(x) - 2 * RLC_DIG);
+				} else {
+					bn_copy(u, x);
+					bn_copy(v, y);
+				}
 				if (_a < 0) {
 					bn_mul_dig(t0, u, -_a);
 					bn_neg(t0, t0);
@@ -467,9 +492,14 @@ void bn_gcd_ext_lehme(bn_t c, bn_t d, bn_t e, const bn_t a, const bn_t b) {
 				}
 				bn_add(u, t0, t1);
 				bn_add(v, t2, t3);
-				bn_rsh(t0, u, bn_bits(u) - RLC_DIG);
+				if (bn_bits(u) > RLC_DIG) {
+					bn_rsh(t0, u, bn_bits(u) - RLC_DIG);
+					bn_rsh(t1, v, bn_bits(u) - RLC_DIG);
+				} else {
+					bn_copy(t0, u);
+					bn_copy(t1, v);
+				}
 				_x = t0->dp[0];
-				bn_rsh(t1, v, bn_bits(u) - RLC_DIG);
 				_y = t1->dp[0];
 				t = 0;
 				if (_y != 0) {
diff --git a/src/bn/relic_bn_mem.c b/src/bn/relic_bn_mem.c
index f378432ad..2d4fead7f 100644
--- a/src/bn/relic_bn_mem.c
+++ b/src/bn/relic_bn_mem.c
@@ -41,7 +41,7 @@
 /* Public definitions                                                         */
 /*============================================================================*/
 
-void bn_make(bn_t a, int digits) {
+void bn_make(bn_t a, size_t digits) {
 	if (digits < 0) {
 		RLC_THROW(ERR_NO_VALID);
 	}
@@ -112,7 +112,7 @@ void bn_clean(bn_t a) {
 	}
 }
 
-void bn_grow(bn_t a, int digits) {
+void bn_grow(bn_t a, size_t digits) {
 #if ALLOC == DYNAMIC
 	dig_t *t;
 
@@ -143,7 +143,7 @@ void bn_trim(bn_t a) {
 			--(a->used);
 		}
 		/* Zero can't be negative. */
-		if (a->used <= 0) {
+		if (a->used == 0) {
 			a->used = 1;
 			a->dp[0] = 0;
 			a->sign = RLC_POS;
diff --git a/src/bn/relic_bn_mxp.c b/src/bn/relic_bn_mxp.c
index 6fa870999..3f4c1abcc 100644
--- a/src/bn/relic_bn_mxp.c
+++ b/src/bn/relic_bn_mxp.c
@@ -116,7 +116,7 @@ void bn_mxp_basic(bn_t c, const bn_t a, const bn_t b, const bn_t m) {
 
 void bn_mxp_slide(bn_t c, const bn_t a, const bn_t b, const bn_t m) {
 	bn_t tab[RLC_TABLE_SIZE], t, u, r;
-	int i, j, l, w = 1;
+	size_t l, w = 1;
 	uint8_t *win = RLC_ALLOCA(uint8_t, bn_bits(b));
 
 	if (win == NULL) {
@@ -140,28 +140,28 @@ void bn_mxp_slide(bn_t c, const bn_t a, const bn_t b, const bn_t m) {
 	bn_null(u);
 	bn_null(r);
 	/* Initialize table. */
-	for (i = 0; i < RLC_TABLE_SIZE; i++) {
+	for (size_t i = 0; i < RLC_TABLE_SIZE; i++) {
 		bn_null(tab[i]);
 	}
 
 	/* Find window size. */
-	i = bn_bits(b);
-	if (i <= 21) {
+	l = bn_bits(b);
+	if (l <= 21) {
 		w = 2;
-	} else if (i <= 32) {
+	} else if (l <= 32) {
 		w = 3;
-	} else if (i <= 128) {
+	} else if (l <= 128) {
 		w = 4;
-	} else if (i <= 256) {
+	} else if (l <= 256) {
 		w = 5;
-	} else if (i <= 512) {
+	} else if (l <= 512) {
 		w = 6;
 	} else {
 		w = 7;
 	}
 
 	RLC_TRY {
-		for (i = 0; i < (1 << (w - 1)); i++) {
+		for (size_t i = 0; i < (1 << (w - 1)); i++) {
 			bn_new(tab[i]);
 		}
 
@@ -183,19 +183,18 @@ void bn_mxp_slide(bn_t c, const bn_t a, const bn_t b, const bn_t m) {
 		bn_sqr(t, tab[0]);
 		bn_mod(t, t, m, u);
 		/* Create table. */
-		for (i = 1; i < 1 << (w - 1); i++) {
+		for (size_t i = 1; i < 1 << (w - 1); i++) {
 			bn_mul(tab[i], tab[i - 1], t);
 			bn_mod(tab[i], tab[i], m, u);
 		}
 
-		l = bn_bits(b);
 		bn_rec_slw(win, &l, b, w);
-		for (i = 0; i < l; i++) {
+		for (size_t i = 0; i < l; i++) {
 			if (win[i] == 0) {
 				bn_sqr(r, r);
 				bn_mod(r, r, m, u);
 			} else {
-				for (j = 0; j < util_bits_dig(win[i]); j++) {
+				for (size_t j = 0; j < util_bits_dig(win[i]); j++) {
 					bn_sqr(r, r);
 					bn_mod(r, r, m, u);
 				}
@@ -218,7 +217,7 @@ void bn_mxp_slide(bn_t c, const bn_t a, const bn_t b, const bn_t m) {
 		RLC_THROW(ERR_CAUGHT);
 	}
 	RLC_FINALLY {
-		for (i = 0; i < (1 << (w - 1)); i++) {
+		for (size_t i = 0; i < (1 << (w - 1)); i++) {
 			bn_free(tab[i]);
 		}
 		bn_free(u);
diff --git a/src/bn/relic_bn_prime.c b/src/bn/relic_bn_prime.c
index ed232457a..b1aed2da4 100644
--- a/src/bn/relic_bn_prime.c
+++ b/src/bn/relic_bn_prime.c
@@ -276,7 +276,7 @@ int bn_is_prime_rabin(const bn_t a) {
 		bn_sub_dig(n1, a, 1);
 		bn_copy(r, n1);
 		s = 0;
-		while (bn_is_even(r)) {
+		while (!bn_is_zero(r) && bn_is_even(r)) {
 			s++;
 			bn_rsh(r, r, 1);
 		}
@@ -401,7 +401,7 @@ int bn_is_prime_solov(const bn_t a) {
 
 #if BN_GEN == BASIC || !defined(STRIP)
 
-void bn_gen_prime_basic(bn_t a, int bits) {
+void bn_gen_prime_basic(bn_t a, size_t bits) {
 	while (1) {
 		do {
 			bn_rand(a, RLC_POS, bits);
@@ -416,7 +416,7 @@ void bn_gen_prime_basic(bn_t a, int bits) {
 
 #if BN_GEN == SAFEP || !defined(STRIP)
 
-void bn_gen_prime_safep(bn_t a, int bits) {
+void bn_gen_prime_safep(bn_t a, size_t bits) {
 	while (1) {
 		do {
 			bn_rand(a, RLC_POS, bits);
@@ -440,7 +440,7 @@ void bn_gen_prime_safep(bn_t a, int bits) {
 
 #if BN_GEN == STRON || !defined(STRIP)
 
-void bn_gen_prime_stron(bn_t a, int bits) {
+void bn_gen_prime_stron(bn_t a, size_t bits) {
 	dig_t i, j;
 	int found, k;
 	bn_t r, s, t;
@@ -519,7 +519,7 @@ void bn_gen_prime_stron(bn_t a, int bits) {
 
 #endif
 
-int bn_gen_prime_factor(bn_t a, bn_t b, int abits, int bbits) {
+int bn_gen_prime_factor(bn_t a, bn_t b, size_t abits, size_t bbits) {
 	bn_t t;
 	int result = RLC_OK;
 
diff --git a/src/bn/relic_bn_rec.c b/src/bn/relic_bn_rec.c
index bdd29dabc..9115b7f7c 100644
--- a/src/bn/relic_bn_rec.c
+++ b/src/bn/relic_bn_rec.c
@@ -43,7 +43,7 @@
  * @param[in] to			- the last bit position, inclusive.
  * @return the bits in the chosen positions.
  */
-static char get_bits(const bn_t a, int from, int to) {
+static char get_bits(const bn_t a, size_t from, size_t to) {
 	int f, t;
 	dig_t mf, mt;
 
@@ -91,7 +91,7 @@ static char get_bits(const bn_t a, int from, int to) {
 /* Public definitions                                                         */
 /*============================================================================*/
 
-void bn_rec_win(uint8_t *win, int *len, const bn_t k, int w) {
+void bn_rec_win(uint8_t *win, size_t *len, const bn_t k, size_t w) {
 	int i, j, l;
 
 	l = bn_bits(k);
@@ -112,7 +112,7 @@ void bn_rec_win(uint8_t *win, int *len, const bn_t k, int w) {
 	*len = j;
 }
 
-void bn_rec_slw(uint8_t *win, int *len, const bn_t k, int w) {
+void bn_rec_slw(uint8_t *win, size_t *len, const bn_t k, size_t w) {
 	int i, j, l, s;
 
 	l = bn_bits(k);
@@ -143,7 +143,7 @@ void bn_rec_slw(uint8_t *win, int *len, const bn_t k, int w) {
 	*len = j;
 }
 
-void bn_rec_naf(int8_t *naf, int *len, const bn_t k, int w) {
+void bn_rec_naf(int8_t *naf, size_t *len, const bn_t k, size_t w) {
 	int i, l;
 	bn_t t;
 	dig_t t0, mask;
@@ -217,7 +217,8 @@ void bn_rec_naf(int8_t *naf, int *len, const bn_t k, int w) {
 	}
 }
 
-void bn_rec_tnaf_get(uint8_t *t, int8_t *beta, int8_t *gama, int8_t u, int w) {
+void bn_rec_tnaf_get(uint8_t *t, int8_t *beta, int8_t *gama, int8_t u,
+		size_t w) {
 	if (u == -1) {
 		switch (w) {
 			case 2:
@@ -349,7 +350,7 @@ void bn_rec_tnaf_get(uint8_t *t, int8_t *beta, int8_t *gama, int8_t u, int w) {
 	}
 }
 
-void bn_rec_tnaf_mod(bn_t r0, bn_t r1, const bn_t k, int u, int m) {
+void bn_rec_tnaf_mod(bn_t r0, bn_t r1, const bn_t k, int u, size_t m) {
 	bn_t t, t0, t1, t2, t3;
 
 	bn_null(t);
@@ -421,7 +422,8 @@ void bn_rec_tnaf_mod(bn_t r0, bn_t r1, const bn_t k, int u, int m) {
 	}
 }
 
-void bn_rec_tnaf(int8_t *tnaf, int *len, const bn_t k, int8_t u, int m, int w) {
+void bn_rec_tnaf(int8_t *tnaf, size_t *len, const bn_t k, int8_t u, size_t m,
+		size_t w) {
 	int i, l;
 	bn_t tmp, r0, r1;
 	int8_t beta[64], gama[64];
@@ -551,7 +553,8 @@ void bn_rec_tnaf(int8_t *tnaf, int *len, const bn_t k, int8_t u, int m, int w) {
 	}
 }
 
-void bn_rec_rtnaf(int8_t *tnaf, int *len, const bn_t k, int8_t u, int m, int w) {
+void bn_rec_rtnaf(int8_t *tnaf, size_t *len, const bn_t k, int8_t u, size_t m,
+		size_t w) {
 	int i, l;
 	bn_t tmp, r0, r1;
 	int8_t beta[64], gama[64];
@@ -693,7 +696,7 @@ void bn_rec_rtnaf(int8_t *tnaf, int *len, const bn_t k, int8_t u, int m, int w)
 	}
 }
 
-void bn_rec_reg(int8_t *naf, int *len, const bn_t k, int n, int w) {
+void bn_rec_reg(int8_t *naf, size_t *len, const bn_t k, size_t n, size_t w) {
 	int i, l;
 	bn_t t;
 	dig_t t0, mask;
@@ -746,7 +749,7 @@ void bn_rec_reg(int8_t *naf, int *len, const bn_t k, int n, int w) {
 	}
 }
 
-void bn_rec_jsf(int8_t *jsf, int *len, const bn_t k, const bn_t l) {
+void bn_rec_jsf(int8_t *jsf, size_t *len, const bn_t k, const bn_t l) {
 	bn_t n0, n1;
 	dig_t l0, l1;
 	int8_t u0, u1, d0, d1;
@@ -828,7 +831,8 @@ void bn_rec_jsf(int8_t *jsf, int *len, const bn_t k, const bn_t l) {
 void bn_rec_glv(bn_t k0, bn_t k1, const bn_t k, const bn_t n, const bn_t *v1,
 		const bn_t *v2) {
 	bn_t t, b1, b2;
-	int r1, r2, bits;
+	int r1, r2;
+	size_t bits;
 
 	bn_null(b1);
 	bn_null(b2);
diff --git a/src/bn/relic_bn_shift.c b/src/bn/relic_bn_shift.c
index bf010d9ab..7dfe3df41 100644
--- a/src/bn/relic_bn_shift.c
+++ b/src/bn/relic_bn_shift.c
@@ -63,16 +63,12 @@ void bn_hlv(bn_t c, const bn_t a) {
 	bn_trim(c);
 }
 
-void bn_lsh(bn_t c, const bn_t a, int bits) {
+void bn_lsh(bn_t c, const bn_t a, unsigned int bits) {
 	int digits;
 	dig_t carry;
 
 	bn_copy(c, a);
 
-	if (bits <= 0) {
-		return;
-	}
-
 	RLC_RIP(bits, digits, bits);
 
 	RLC_TRY {
@@ -101,21 +97,22 @@ void bn_lsh(bn_t c, const bn_t a, int bits) {
 	}
 }
 
-void bn_rsh(bn_t c, const bn_t a, int bits) {
+void bn_rsh(bn_t c, const bn_t a, unsigned int bits) {
 	int digits = 0;
 
 	bn_copy(c, a);
 
-	if (bits <= 0) {
-		return;
-	}
-
 	RLC_RIP(bits, digits, bits);
 
 	if (digits > 0) {
 		dv_rshd(c->dp, a->dp, a->used, digits);
 	}
-	c->used = a->used - digits;
+
+	if (a->used > digits) {
+		c->used = a->used - digits;
+	} else {
+		c->used = 0;
+	}
 	c->sign = a->sign;
 
 	if (c->used > 0 && bits > 0) {
diff --git a/src/bn/relic_bn_smb.c b/src/bn/relic_bn_smb.c
index 6c297608a..98f74dd82 100644
--- a/src/bn/relic_bn_smb.c
+++ b/src/bn/relic_bn_smb.c
@@ -121,7 +121,7 @@ int bn_smb_jac(const bn_t a, const bn_t b) {
 			}
 			/* Write t0 as 2^h * t0. */
 			h = 0;
-			while (bn_is_even(t0)) {
+			while (bn_is_even(t0) && !bn_is_zero(t0)) {
 				h++;
 				bn_rsh(t0, t0, 1);
 			}
diff --git a/src/bn/relic_bn_srt.c b/src/bn/relic_bn_srt.c
index ae347bf47..4cde73a58 100644
--- a/src/bn/relic_bn_srt.c
+++ b/src/bn/relic_bn_srt.c
@@ -38,7 +38,8 @@
 
 void bn_srt(bn_t c, bn_t a) {
 	bn_t h, l, m, t;
-	int bits, cmp;
+	size_t bits;
+	int cmp;
 
 	if (bn_sign(a) == RLC_NEG) {
 		RLC_THROW(ERR_NO_VALID);
@@ -58,8 +59,11 @@ void bn_srt(bn_t c, bn_t a) {
 		bn_new(m);
 		bn_new(t);
 
+		bn_zero(l);
 		bn_set_2b(h, bits >> 1);
-		bn_set_2b(l, (bits >> 1) - 1);
+		if (bits >= 2) {
+			bn_set_2b(l, (bits >> 1) - 1);
+		}
 
 		/* Trivial binary search approach. */
 		do {
diff --git a/src/bn/relic_bn_util.c b/src/bn/relic_bn_util.c
index 4020f57c1..0a4e1e0cd 100644
--- a/src/bn/relic_bn_util.c
+++ b/src/bn/relic_bn_util.c
@@ -105,7 +105,7 @@ int bn_is_even(const bn_t a) {
 	return 0;
 }
 
-int bn_bits(const bn_t a) {
+size_t bn_bits(const bn_t a) {
 	int bits;
 
 	if (bn_is_zero(a)) {
@@ -118,7 +118,7 @@ int bn_bits(const bn_t a) {
 	return bits + util_bits_dig(a->dp[a->used - 1]);
 }
 
-int bn_get_bit(const bn_t a, int bit) {
+int bn_get_bit(const bn_t a, size_t bit) {
 	int d;
 
 	if (bit < 0) {
@@ -139,7 +139,7 @@ int bn_get_bit(const bn_t a, int bit) {
 	}
 }
 
-void bn_set_bit(bn_t a, int bit, int value) {
+void bn_set_bit(bn_t a, size_t bit, int value) {
 	int d;
 
 	if (bit < 0) {
@@ -162,7 +162,7 @@ void bn_set_bit(bn_t a, int bit, int value) {
 	}
 }
 
-int bn_ham(const bn_t a) {
+size_t bn_ham(const bn_t a) {
 	int c = 0;
 
 	for (int i = 0; i < bn_bits(a); i++) {
@@ -183,11 +183,11 @@ void bn_set_dig(bn_t a, dig_t digit) {
 	a->sign = RLC_POS;
 }
 
-void bn_set_2b(bn_t a, int b) {
+void bn_set_2b(bn_t a, size_t b) {
 	int i, d;
 
-	if (b < 0) {
-		bn_zero(a);
+	if (b >= RLC_BN_SIZE * RLC_DIG) {
+		RLC_THROW(ERR_NO_VALID);
 	} else {
 		RLC_RIP(b, d, b);
 
@@ -201,7 +201,7 @@ void bn_set_2b(bn_t a, int b) {
 	}
 }
 
-void bn_rand(bn_t a, int sign, int bits) {
+void bn_rand(bn_t a, int sign, size_t bits) {
 	int digits;
 
 	RLC_RIP(bits, digits, bits);
@@ -264,7 +264,7 @@ void bn_print(const bn_t a) {
 	}
 }
 
-int bn_size_str(const bn_t a, int radix) {
+size_t bn_size_str(const bn_t a, unsigned int radix) {
 	int digits = 0;
 	bn_t t;
 
@@ -308,7 +308,7 @@ int bn_size_str(const bn_t a, int radix) {
 	return digits + 1;
 }
 
-void bn_read_str(bn_t a, const char *str, int len, int radix) {
+void bn_read_str(bn_t a, const char *str, size_t len, unsigned int radix) {
 	int sign, i, j;
 	char c;
 
@@ -357,7 +357,7 @@ void bn_read_str(bn_t a, const char *str, int len, int radix) {
 	}
 }
 
-void bn_write_str(char *str, int len, const bn_t a, int radix) {
+void bn_write_str(char *str, size_t len, const bn_t a, unsigned int radix) {
 	bn_t t;
 	dig_t d;
 	int digits, l, i, j;
@@ -426,7 +426,7 @@ void bn_write_str(char *str, int len, const bn_t a, int radix) {
 	}
 }
 
-int bn_size_bin(const bn_t a) {
+size_t bn_size_bin(const bn_t a) {
 	dig_t d;
 	int digits;
 
@@ -440,7 +440,7 @@ int bn_size_bin(const bn_t a) {
 	return digits;
 }
 
-void bn_read_bin(bn_t a, const uint8_t *bin, int len) {
+void bn_read_bin(bn_t a, const uint8_t *bin, size_t len) {
 	int i, j;
 	dig_t d = (RLC_DIG / 8);
 	int digs = (len % d == 0 ? len / d : len / d + 1);
@@ -470,7 +470,7 @@ void bn_read_bin(bn_t a, const uint8_t *bin, int len) {
 	bn_trim(a);
 }
 
-void bn_write_bin(uint8_t *bin, int len, const bn_t a) {
+void bn_write_bin(uint8_t *bin, size_t len, const bn_t a) {
 	int size, k;
 	dig_t d;
 
@@ -501,11 +501,11 @@ void bn_write_bin(uint8_t *bin, int len, const bn_t a) {
 	}
 }
 
-int bn_size_raw(const bn_t a) {
+size_t bn_size_raw(const bn_t a) {
 	return a->used;
 }
 
-void bn_read_raw(bn_t a, const dig_t *raw, int len) {
+void bn_read_raw(bn_t a, const dig_t *raw, size_t len) {
 	RLC_TRY {
 		bn_grow(a, len);
 		a->used = len;
@@ -517,7 +517,7 @@ void bn_read_raw(bn_t a, const dig_t *raw, int len) {
 	}
 }
 
-void bn_write_raw(dig_t *raw, int len, const bn_t a) {
+void bn_write_raw(dig_t *raw, size_t len, const bn_t a) {
 	int i, size;
 
 	size = a->used;
diff --git a/src/cp/relic_cp_bls.c b/src/cp/relic_cp_bls.c
index 1ac4de28f..fac290e3e 100644
--- a/src/cp/relic_cp_bls.c
+++ b/src/cp/relic_cp_bls.c
@@ -57,7 +57,7 @@ int cp_bls_gen(bn_t d, g2_t q) {
 	return result;
 }
 
-int cp_bls_sig(g1_t s, const uint8_t *msg, int len, const bn_t d) {
+int cp_bls_sig(g1_t s, const uint8_t *msg, size_t len, const bn_t d) {
 	g1_t p;
 	int result = RLC_OK;
 
diff --git a/src/cp/relic_cp_cmlhs.c b/src/cp/relic_cp_cmlhs.c
index e6d899f44..83b8c0980 100644
--- a/src/cp/relic_cp_cmlhs.c
+++ b/src/cp/relic_cp_cmlhs.c
@@ -65,13 +65,9 @@ int cp_cmlhs_gen(bn_t x[], gt_t hs[], size_t len, uint8_t prf[], size_t plen,
 		pc_map(gt, g1, g2);
 
 		rand_bytes(prf, plen);
-		if (bls) {
-			cp_bls_gen(sk, pk);
-		} else {
-			cp_ecdsa_gen(sk, g1);
-			fp_copy(pk->x[0], g1->x);
-			fp_copy(pk->y[0], g1->y);
-		}
+
+		bn_rand_mod(d, n);
+		g2_mul_gen(y, d);
 
 		/* Generate elements for n tags. */
 		for (int i = 0; i < len; i++) {
@@ -79,8 +75,16 @@ int cp_cmlhs_gen(bn_t x[], gt_t hs[], size_t len, uint8_t prf[], size_t plen,
 			gt_exp(hs[i], gt, x[i]);
 		}
 
-		bn_rand_mod(d, n);
-		g2_mul_gen(y, d);
+		if (bls) {
+			result = cp_bls_gen(sk, pk);
+		} else {
+			if (cp_ecdsa_gen(sk, g1) == RLC_OK) {
+				fp_copy(pk->x[0], g1->x);
+				fp_copy(pk->y[0], g1->y);
+			} else {
+				result = RLC_ERR;
+			}
+		}
 	}
 	RLC_CATCH_ANY {
 		result = RLC_ERR;
@@ -101,8 +105,9 @@ int cp_cmlhs_sig(g1_t sig, g2_t z, g1_t a, g1_t c, g1_t r, g2_t s,
 	bn_t k, m, n;
 	g1_t t;
 	uint8_t mac[RLC_MD_LEN];
-	int len, dlen = strlen(data), result = RLC_OK;
+	size_t len, dlen = strlen(data);
 	uint8_t *buf = RLC_ALLOCA(uint8_t, 1 + 8 * RLC_PC_BYTES + dlen);
+	int result = RLC_OK;
 
 	bn_null(k);
 	bn_null(m);
@@ -211,8 +216,9 @@ int cp_cmlhs_ver(const g1_t r, const g2_t s, const g1_t sig[], const g2_t z[],
 	g2_t g2;
 	gt_t e, u, v;
 	bn_t k, n;
-	int len, dlen = strlen(data), result = 1;
+	size_t len, dlen = strlen(data);
 	uint8_t *buf = RLC_ALLOCA(uint8_t, 1 + 8 * RLC_PC_BYTES + dlen);
+	int result = 1;
 
 	g1_null(g1);
 	g2_null(g2);
@@ -331,8 +337,9 @@ int cp_cmlhs_onv(const g1_t r, const g2_t s, const g1_t sig[], const g2_t z[],
 	g2_t g2;
 	gt_t e, u, v;
 	bn_t k, n;
-	int len, dlen = strlen(data), result = 1;
+	size_t len, dlen = strlen(data);
 	uint8_t *buf = RLC_ALLOCA(uint8_t, 1 + 8 * RLC_FP_BYTES + dlen);
+	int result = 1;
 
 	g1_null(g1);
 	g2_null(g2);
diff --git a/src/cp/relic_cp_pbpsi.c b/src/cp/relic_cp_pbpsi.c
index acc6fafe1..fcd32fa28 100644
--- a/src/cp/relic_cp_pbpsi.c
+++ b/src/cp/relic_cp_pbpsi.c
@@ -114,6 +114,7 @@ int cp_pbpsi_ask(g2_t d[], bn_t r, const bn_t x[], const g2_t s[], size_t m) {
 			bn_free(_x[i]);
 		}
 		RLC_FREE(p);
+		RLC_FREE(_x);
 	}
 	return result;
 }
diff --git a/src/cp/relic_cp_rsa.c b/src/cp/relic_cp_rsa.c
index 7121f0800..eb5565a00 100644
--- a/src/cp/relic_cp_rsa.c
+++ b/src/cp/relic_cp_rsa.c
@@ -244,9 +244,10 @@ static uint8_t *hash_id(int md, int *len) {
  * @param[in] operation	- flag to indicate the operation type.
  * @return RLC_ERR if errors occurred, RLC_OK otherwise.
  */
-static int pad_pkcs1(bn_t m, int *p_len, int m_len, int k_len, int operation) {
+static int pad_pkcs1(bn_t m, int *p_len, size_t m_len, size_t k_len, int op) {
 	uint8_t *id, pad = 0;
-	int len, result = RLC_ERR;
+	size_t len;
+	int result = RLC_ERR;
 	bn_t t;
 
 	bn_null(t);
@@ -254,7 +255,7 @@ static int pad_pkcs1(bn_t m, int *p_len, int m_len, int k_len, int operation) {
 	RLC_TRY {
 		bn_new(t);
 
-		switch (operation) {
+		switch (op) {
 			case RSA_ENC:
 				/* EB = 00 | 02 | PS | 00 | D. */
 				bn_zero(m);
@@ -419,7 +420,7 @@ static int pad_pkcs1(bn_t m, int *p_len, int m_len, int k_len, int operation) {
  * @param[in] operation	- flag to indicate the operation type.
  * @return RLC_ERR if errors occurred, RLC_OK otherwise.
  */
-static int pad_pkcs2(bn_t m, int *p_len, int m_len, int k_len, int operation) {
+static int pad_pkcs2(bn_t m, int *p_len, size_t m_len, size_t k_len, int op) {
 	uint8_t pad, h1[RLC_MD_LEN], h2[RLC_MD_LEN];
 	uint8_t *mask = RLC_ALLOCA(uint8_t, k_len);
 	int result = RLC_ERR;
@@ -430,7 +431,7 @@ static int pad_pkcs2(bn_t m, int *p_len, int m_len, int k_len, int operation) {
 	RLC_TRY {
 		bn_new(t);
 
-		switch (operation) {
+		switch (op) {
 			case RSA_ENC:
 				/* DB = lHash | PS | 01 | D. */
 				md_map(h1, NULL, 0);
@@ -578,7 +579,7 @@ static int pad_pkcs2(bn_t m, int *p_len, int m_len, int k_len, int operation) {
 /* Public definitions                                                         */
 /*============================================================================*/
 
-int cp_rsa_gen(rsa_t pub, rsa_t prv, int bits) {
+int cp_rsa_gen(rsa_t pub, rsa_t prv, size_t bits) {
 	bn_t t, r;
 	int result = RLC_OK;
 
diff --git a/src/cp/relic_cp_sokaka.c b/src/cp/relic_cp_sokaka.c
index 54ef3edb0..5902f2cb5 100644
--- a/src/cp/relic_cp_sokaka.c
+++ b/src/cp/relic_cp_sokaka.c
@@ -72,8 +72,8 @@ int cp_sokaka_gen_prv(sokaka_t k, const char *id, bn_t master) {
 
 int cp_sokaka_key(uint8_t *key, size_t key_len, const char *id1,
 		const sokaka_t k, const char *id2) {
-	int len1 = strlen(id1), len2 = strlen(id2);
-	int size, first = 0, result = RLC_OK;
+	size_t size, len1 = strlen(id1), len2 = strlen(id2);
+	int first = 0, result = RLC_OK;
 	uint8_t *buf;
 	g1_t p;
 	g2_t q;
diff --git a/src/cp/relic_cp_vbnn.c b/src/cp/relic_cp_vbnn.c
index 7734da6f3..bc99aa64a 100644
--- a/src/cp/relic_cp_vbnn.c
+++ b/src/cp/relic_cp_vbnn.c
@@ -73,9 +73,10 @@ int cp_vbnn_gen(bn_t msk, ec_t mpk) {
 int cp_vbnn_gen_prv(bn_t sk, ec_t pk, const bn_t msk, const uint8_t *id,
 		size_t id_len) {
 	uint8_t hash[RLC_MD_LEN];
-	int len, result = RLC_OK;
+	size_t len;
 	uint8_t *buf = NULL;
 	bn_t n, r;
+	int result = RLC_OK;
 
 	/* zero variables */
 	bn_null(n);
@@ -125,10 +126,11 @@ int cp_vbnn_gen_prv(bn_t sk, ec_t pk, const bn_t msk, const uint8_t *id,
 
 int cp_vbnn_sig(ec_t r, bn_t z, bn_t h, const uint8_t *id, size_t id_len,
 		const uint8_t *msg, int msg_len, const bn_t sk, const ec_t pk) {
-	int len, result = RLC_OK;
+	size_t len;
 	uint8_t *buf = NULL, *buf_i, hash[RLC_MD_LEN];
 	bn_t n, y;
 	ec_t t;
+	int result = RLC_OK;
 
 	/* zero variables */
 	bn_null(n);
@@ -189,11 +191,11 @@ int cp_vbnn_sig(ec_t r, bn_t z, bn_t h, const uint8_t *id, size_t id_len,
 
 int cp_vbnn_ver(const ec_t r, const bn_t z, const bn_t h, const uint8_t *id,
 		size_t id_len, const uint8_t *msg, int msg_len, const ec_t mpk) {
-	int len, result = 0;
+	size_t len;
 	uint8_t *buf = NULL, *buf_i, hash[RLC_MD_LEN];
 	bn_t n, c, _h;
-	ec_t Z;
-	ec_t t;
+	ec_t Z, t;
+	int result = 0;
 
 	/* zero variables */
 	bn_null(n);
diff --git a/src/eb/relic_eb_map.c b/src/eb/relic_eb_map.c
index 73116a78b..69b8a7498 100644
--- a/src/eb/relic_eb_map.c
+++ b/src/eb/relic_eb_map.c
@@ -37,7 +37,7 @@
 /* Public definitions                                                         */
 /*============================================================================*/
 
-void eb_map(eb_t p, const uint8_t *msg, int len) {
+void eb_map(eb_t p, const uint8_t *msg, size_t len) {
 	bn_t k;
 	fb_t t0, t1;
 	int i;
diff --git a/src/eb/relic_eb_mul.c b/src/eb/relic_eb_mul.c
index cd3cdb02c..378765f53 100644
--- a/src/eb/relic_eb_mul.c
+++ b/src/eb/relic_eb_mul.c
@@ -49,9 +49,10 @@
  * @param[in] k					- the integer.
  */
 static void eb_mul_ltnaf_imp(eb_t r, const eb_t p, const bn_t k) {
-	int i, l, n;
+	int i, n;
 	int8_t tnaf[RLC_FB_BITS + 8], u;
 	eb_t t[1 << (EB_WIDTH - 2)];
+	size_t l;
 
 	if (eb_curve_opt_a() == RLC_ZERO) {
 		u = -1;
@@ -120,9 +121,10 @@ static void eb_mul_ltnaf_imp(eb_t r, const eb_t p, const bn_t k) {
  * @param[in] k					- the integer.
  */
 static void eb_mul_lnaf_imp(eb_t r, const eb_t p, const bn_t k) {
-	int i, l, n;
+	int i, n;
 	int8_t naf[RLC_FB_BITS + 1];
 	eb_t t[1 << (EB_WIDTH - 2)];
+	size_t l;
 
 	RLC_TRY {
 		/* Prepare the precomputation table. */
@@ -190,9 +192,10 @@ static void eb_mul_lnaf_imp(eb_t r, const eb_t p, const bn_t k) {
  * @param[in] k					- the integer.
  */
 static void eb_mul_rtnaf_imp(eb_t r, const eb_t p, const bn_t k) {
-	int i, l, n;
+	int i, n;
 	int8_t tnaf[RLC_FB_BITS + 8], u;
 	eb_t t[1 << (EB_WIDTH - 2)];
+	size_t l;
 
 	if (eb_curve_opt_a() == RLC_ZERO) {
 		u = -1;
@@ -489,9 +492,10 @@ static void eb_mul_rtnaf_imp(eb_t r, const eb_t p, const bn_t k) {
  * @param[in] k					- the integer.
  */
 static void eb_mul_rnaf_imp(eb_t r, const eb_t p, const bn_t k) {
-	int i, l, n;
+	int i, n;
 	int8_t naf[RLC_FB_BITS + 1];
 	eb_t t[1 << (EB_WIDTH - 2)];
+	size_t l;
 
 	RLC_TRY {
 		/* Prepare the accumulator table. */
@@ -650,10 +654,10 @@ void eb_mul_basic(eb_t r, const eb_t p, const bn_t k) {
 #if EB_MUL == LODAH || !defined(STRIP)
 
 void eb_mul_lodah(eb_t r, const eb_t p, const bn_t k) {
-	int bits, i, j;
 	dv_t x1, z1, x2, z2, r1, r2, r3, r4, r5;
 	const dig_t *b;
 	bn_t t, n;
+	size_t bits;
 
 	if (bn_is_zero(k)) {
 		eb_set_infty(r);
@@ -721,8 +725,8 @@ void eb_mul_lodah(eb_t r, const eb_t p, const bn_t k) {
 		fb_mul(z2, z2, r1);
 		fb_mul(x2, x2, r1);
 
-		for (i = bits - 1; i >= 0; i--) {
-			j = bn_get_bit(t, i);
+		for (int i = bits - 1; i >= 0; i--) {
+			int j = bn_get_bit(t, i);
 			fb_mul(r1, x1, z2);
 			fb_mul(r2, x2, z1);
 			fb_add(r3, r1, r2);
@@ -889,11 +893,12 @@ void eb_mul_rwnaf(eb_t r, const eb_t p, const bn_t k) {
 #if EB_MUL == HALVE || !defined(STRIP)
 
 void eb_mul_halve(eb_t r, const eb_t p, const bn_t k) {
-	int i, j, l, trc, cof;
+	int i, j, trc, cof;
 	int8_t naf[RLC_FB_BITS + 1], *_k;
 	eb_t q, s, t[1 << (EB_WIDTH - 2)];
 	bn_t n, m;
 	fb_t u, v, w, z;
+	size_t l;
 
 	if (bn_is_zero(k) || eb_is_infty(p)) {
 		eb_set_infty(r);
diff --git a/src/eb/relic_eb_mul_sim.c b/src/eb/relic_eb_mul_sim.c
index 31d878ea8..a496d6430 100644
--- a/src/eb/relic_eb_mul_sim.c
+++ b/src/eb/relic_eb_mul_sim.c
@@ -54,10 +54,11 @@
  */
 static void eb_mul_sim_kbltz(eb_t r, const eb_t p, const bn_t k, const eb_t q,
 		const bn_t m, const eb_t *t) {
-	int i, l, l0, l1, n0, n1, w, g;
+	int i, n0, n1, w, g;
 	int8_t u, tnaf0[RLC_FB_BITS + 8], tnaf1[RLC_FB_BITS + 8], *_k, *_m;
 	eb_t t0[1 << (EB_WIDTH - 2)];
 	eb_t t1[1 << (EB_WIDTH - 2)];
+	size_t l, l0, l1;
 
 	for (i =  0; i < (1 << (EB_WIDTH - 2)); i++) {
 		eb_null(t0[i]);
@@ -183,10 +184,11 @@ static void eb_mul_sim_kbltz(eb_t r, const eb_t p, const bn_t k, const eb_t q,
  */
 static void eb_mul_sim_plain(eb_t r, const eb_t p, const bn_t k, const eb_t q,
 		const bn_t m, const eb_t *t) {
-	int i, l, l0, l1, n0, n1, w, g;
+	int i, n0, n1, w, g;
 	int8_t naf0[RLC_FB_BITS + 1], naf1[RLC_FB_BITS + 1], *_k, *_m;
 	eb_t t0[1 << (EB_WIDTH - 2)];
 	eb_t t1[1 << (EB_WIDTH - 2)];
+	size_t l, l0, l1;
 
 	for (i =  0; i < (1 << (EB_WIDTH - 2)); i++) {
 		eb_null(t0[i]);
@@ -310,7 +312,7 @@ void eb_mul_sim_basic(eb_t r, const eb_t p, const bn_t k, const eb_t q,
 void eb_mul_sim_trick(eb_t r, const eb_t p, const bn_t k, const eb_t q,
 		const bn_t m) {
 	eb_t t0[1 << (EB_WIDTH / 2)], t1[1 << (EB_WIDTH / 2)], t[1 << EB_WIDTH];
-	int l0, l1, w = EB_WIDTH / 2;
+	size_t l0, l1, w = EB_WIDTH / 2;
 	uint8_t w0[RLC_FB_BITS], w1[RLC_FB_BITS];
 	bn_t n;
 
@@ -436,8 +438,9 @@ void eb_mul_sim_inter(eb_t r, const eb_t p, const bn_t k, const eb_t q,
 void eb_mul_sim_joint(eb_t r, const eb_t p, const bn_t k, const eb_t q,
 		const bn_t m) {
 	eb_t t[5];
-	int i, u_i, len, offset;
+	int i, u_i, offset;
 	int8_t jsf[2 * (RLC_FB_BITS + 1)];
+	size_t len;
 
 	if (bn_is_zero(k) || eb_is_infty(p)) {
 		eb_mul(r, q, m);
diff --git a/src/eb/relic_eb_util.c b/src/eb/relic_eb_util.c
index 0671fbb0e..87f048715 100644
--- a/src/eb/relic_eb_util.c
+++ b/src/eb/relic_eb_util.c
@@ -500,7 +500,7 @@ int eb_size_bin(const eb_t a, int pack) {
 	return size;
 }
 
-void eb_read_bin(eb_t a, const uint8_t *bin, int len) {
+void eb_read_bin(eb_t a, const uint8_t *bin, size_t len) {
 	if (len == 1) {
 		if (bin[0] == 0) {
 			eb_set_infty(a);
@@ -550,7 +550,7 @@ void eb_read_bin(eb_t a, const uint8_t *bin, int len) {
 	}
 }
 
-void eb_write_bin(uint8_t *bin, int len, const eb_t a, int pack) {
+void eb_write_bin(uint8_t *bin, size_t len, const eb_t a, int pack) {
 	eb_t t;
 
 	eb_null(t);
diff --git a/src/ed/relic_ed_map.c b/src/ed/relic_ed_map.c
index 260d98dbe..e95f3da73 100644
--- a/src/ed/relic_ed_map.c
+++ b/src/ed/relic_ed_map.c
@@ -187,7 +187,8 @@ void ed_map_ell2_5mod8(ed_t p, fp_t t) {
 /* Public definitions                                                         */
 /*============================================================================*/
 
-void ed_map_dst(ed_t p, const uint8_t *msg, int len, const uint8_t *dst, int dst_len) {
+void ed_map_dst(ed_t p, const uint8_t *msg, size_t len, const uint8_t *dst,
+		size_t dst_len) {
 	bn_t k;
 	fp_t t;
 	ed_t q;
@@ -254,6 +255,6 @@ void ed_map_dst(ed_t p, const uint8_t *msg, int len, const uint8_t *dst, int dst
 	}
 }
 
-void ed_map(ed_t p, const uint8_t *msg, int len) {
+void ed_map(ed_t p, const uint8_t *msg, size_t len) {
 	ed_map_dst(p, msg, len, (const uint8_t *)"RELIC", 5);
 }
diff --git a/src/ed/relic_ed_mul.c b/src/ed/relic_ed_mul.c
index 725401590..e5eec2f40 100644
--- a/src/ed/relic_ed_mul.c
+++ b/src/ed/relic_ed_mul.c
@@ -39,9 +39,10 @@
 #if ED_MUL == LWNAF || !defined(STRIP)
 
 static void ed_mul_naf_imp(ed_t r, const ed_t p, const bn_t k) {
-	int l, i, n;
+	int i, n;
 	int8_t naf[RLC_FP_BITS + 1];
 	ed_t t[1 << (ED_WIDTH - 2)];
+	size_t l;
 
 	if (bn_is_zero(k)) {
 		ed_set_infty(r);
@@ -110,9 +111,10 @@ static void ed_mul_naf_imp(ed_t r, const ed_t p, const bn_t k) {
 
 static void ed_mul_reg_imp(ed_t r, const ed_t p, const bn_t k) {
 	bn_t _k;
-	int i, j, l, n;
+	int i, j, n;
 	int8_t s, reg[RLC_CEIL(RLC_FP_BITS + 1, ED_WIDTH - 1)];
 	ed_t t[1 << (ED_WIDTH - 2)], u, v;
+	size_t l;
 
 	bn_null(_k);
 	if (bn_is_zero(k)) {
@@ -233,8 +235,8 @@ void ed_mul_basic(ed_t r, const ed_t p, const bn_t k) {
 
 void ed_mul_slide(ed_t r, const ed_t p, const bn_t k) {
 	ed_t t[1 << (EP_WIDTH - 1)], q;
-	int i, j, l;
 	uint8_t win[RLC_FP_BITS + 1];
+	size_t l;
 
 	ed_null(q);
 
@@ -244,7 +246,7 @@ void ed_mul_slide(ed_t r, const ed_t p, const bn_t k) {
 	}
 
 	RLC_TRY {
-		for (i = 0; i < (1 << (EP_WIDTH - 1)); i ++) {
+		for (size_t i = 0; i < (1 << (EP_WIDTH - 1)); i ++) {
 			ed_null(t[i]);
 			ed_new(t[i]);
 		}
@@ -259,7 +261,7 @@ void ed_mul_slide(ed_t r, const ed_t p, const bn_t k) {
 #endif
 
 		/* Create table. */
-		for (i = 1; i < (1 << (EP_WIDTH - 1)); i++) {
+		for (size_t i = 1; i < (1 << (EP_WIDTH - 1)); i++) {
 			ed_add(t[i], t[i - 1], q);
 		}
 
@@ -270,11 +272,11 @@ void ed_mul_slide(ed_t r, const ed_t p, const bn_t k) {
 		ed_set_infty(q);
 		l = RLC_FP_BITS + 1;
 		bn_rec_slw(win, &l, k, EP_WIDTH);
-		for (i = 0; i < l; i++) {
+		for (size_t i = 0; i < l; i++) {
 			if (win[i] == 0) {
 				ed_dbl(q, q);
 			} else {
-				for (j = 0; j < util_bits_dig(win[i]); j++) {
+				for (size_t j = 0; j < util_bits_dig(win[i]); j++) {
 					ed_dbl(q, q);
 				}
 				ed_add(q, q, t[win[i] >> 1]);
@@ -290,7 +292,7 @@ void ed_mul_slide(ed_t r, const ed_t p, const bn_t k) {
 		RLC_THROW(ERR_CAUGHT);
 	}
 	RLC_FINALLY {
-		for (i = 0; i < (1 << (EP_WIDTH - 1)); i++) {
+		for (size_t i = 0; i < (1 << (EP_WIDTH - 1)); i++) {
 			ed_free(t[i]);
 		}
 		ed_free(q);
@@ -409,7 +411,7 @@ void ed_mul_dig(ed_t r, const ed_t p, dig_t k) {
 	ed_t t;
 	bn_t _k;
 	int8_t u, naf[RLC_DIG + 1];
-	int l;
+	size_t l;
 
 	ed_null(t);
 	bn_null(_k);
diff --git a/src/ed/relic_ed_mul_fix.c b/src/ed/relic_ed_mul_fix.c
index 175a759af..0e0f6863a 100644
--- a/src/ed/relic_ed_mul_fix.c
+++ b/src/ed/relic_ed_mul_fix.c
@@ -47,8 +47,9 @@
  * @param[in] k					- the integer.
  */
 static void ed_mul_fix_plain(ed_t r, const ed_t * t, const bn_t k) {
-	int l, i, n;
+	int i, n;
 	int8_t naf[RLC_FP_BITS + 1], *_k;
+	size_t l;
 
 	/* Compute the w-TNAF representation of k. */
 	l = RLC_FP_BITS + 1;
diff --git a/src/ed/relic_ed_mul_sim.c b/src/ed/relic_ed_mul_sim.c
index b03e556ad..68980fd1e 100644
--- a/src/ed/relic_ed_mul_sim.c
+++ b/src/ed/relic_ed_mul_sim.c
@@ -53,10 +53,11 @@
  */
 static void ed_mul_sim_plain(ed_t r, const ed_t p, const bn_t k, const ed_t q,
 		const bn_t m, const ed_t *t) {
-	int i, l, l0, l1, n0, n1, w, gen;
+	int i, n0, n1, w, gen;
 	int8_t naf0[RLC_FP_BITS + 1], naf1[RLC_FP_BITS + 1], *_k, *_m;
 	ed_t t0[1 << (ED_WIDTH - 2)];
 	ed_t t1[1 << (ED_WIDTH - 2)];
+	size_t l, l0, l1;
 
 	RLC_TRY {
 		gen = (t == NULL ? 0 : 1);
@@ -176,7 +177,7 @@ void ed_mul_sim_trick(ed_t r, const ed_t p, const bn_t k, const ed_t q,
 		const bn_t m) {
 	ed_t t0[1 << (ED_WIDTH / 2)], t1[1 << (ED_WIDTH / 2)], t[1 << ED_WIDTH];
 	bn_t n;
-	int l0, l1, w = ED_WIDTH / 2;
+	size_t l0, l1, w = ED_WIDTH / 2;
 	uint8_t w0[RLC_FP_BITS + 1], w1[RLC_FP_BITS + 1];
 
 	bn_null(n);
@@ -293,8 +294,9 @@ void ed_mul_sim_inter(ed_t r, const ed_t p, const bn_t k, const ed_t q,
 void ed_mul_sim_joint(ed_t r, const ed_t p, const bn_t k, const ed_t q,
 		const bn_t m) {
 	ed_t t[5];
-	int i, l, u_i, offset;
+	int i, u_i, offset;
 	int8_t jsf[2 * (RLC_FP_BITS + 1)];
+	size_t l;
 
 	if (bn_is_zero(k) || ed_is_infty(p)) {
 		ed_mul(r, q, m);
@@ -398,9 +400,10 @@ void ed_mul_sim_gen(ed_t r, const bn_t k, const ed_t q, const bn_t m) {
 }
 
 void ed_mul_sim_lot(ed_t r, const ed_t p[], const bn_t k[], int n) {
-	int i, j, l, *_l = RLC_ALLOCA(int, n);
-	ed_t *_p = RLC_ALLOCA(ed_t, n);
+	int i, j;
 	int8_t *naf = NULL;
+	ed_t *_p = RLC_ALLOCA(ed_t, n);
+	size_t l, *_l = RLC_ALLOCA(size_t, n);
 
 	RLC_TRY {
 		l = 0;
diff --git a/src/ed/relic_ed_util.c b/src/ed/relic_ed_util.c
index 55c3d68d5..b9dd43b35 100644
--- a/src/ed/relic_ed_util.c
+++ b/src/ed/relic_ed_util.c
@@ -242,7 +242,7 @@ int ed_size_bin(const ed_t a, int pack) {
 	return size;
 }
 
-void ed_read_bin(ed_t a, const uint8_t *bin, int len) {
+void ed_read_bin(ed_t a, const uint8_t *bin, size_t len) {
 	if (len == 1) {
 		if (bin[0] == 0) {
 			ed_set_infty(a);
@@ -297,7 +297,7 @@ void ed_read_bin(ed_t a, const uint8_t *bin, int len) {
 	}
 }
 
-void ed_write_bin(uint8_t *bin, int len, const ed_t a, int pack) {
+void ed_write_bin(uint8_t *bin, size_t len, const ed_t a, int pack) {
 	ed_t t;
 
 	ed_null(t);
diff --git a/src/ep/relic_ep_map.c b/src/ep/relic_ep_map.c
index 53e1d3ea1..c34d3a4cc 100644
--- a/src/ep/relic_ep_map.c
+++ b/src/ep/relic_ep_map.c
@@ -48,25 +48,31 @@
  * @param[in] coeffs	- the vector of coefficients in the polynomial.
  * @param[in] deg 		- the degree of the polynomial.
  */
-TMPL_MAP_HORNER(fp, fp_st)
+TMPL_MAP_HORNER(fp, fp_st);
+
 /**
  * Generic isogeny map evaluation for use with SSWU map.
  */
-		TMPL_MAP_ISOGENY_MAP(ep, fp, iso)
+TMPL_MAP_ISOGENY_MAP(ep, fp, iso);
+
 #endif /* EP_CTMAP */
+
+#define EP_MAP_COPY_COND(O, I, C) dv_copy_cond(O, I, RLC_FP_DIGS, C)
 /**
  * Simplified SWU mapping from Section 4 of
  * "Fast and simple constant-time hashing to the BLS12-381 Elliptic Curve"
  */
-#define EP_MAP_COPY_COND(O, I, C) dv_copy_cond(O, I, RLC_FP_DIGS, C)
-		TMPL_MAP_SSWU(ep, fp, dig_t, EP_MAP_COPY_COND)
+TMPL_MAP_SSWU(ep, fp, dig_t, EP_MAP_COPY_COND);
+
 /**
  * Shallue--van de Woestijne map, based on the definition from
  * draft-irtf-cfrg-hash-to-curve-06, Section 6.6.1
  */
-TMPL_MAP_SVDW(ep, fp, dig_t, EP_MAP_COPY_COND)
+TMPL_MAP_SVDW(ep, fp, dig_t, EP_MAP_COPY_COND);
+
 #undef EP_MAP_COPY_COND
-/* caution: this function overwrites k, which it uses as an auxiliary variable */
+
+/* caution: this function overwrites k, which used as an auxiliary variable */
 static inline int fp_sgn0(const fp_t t, bn_t k) {
 	fp_prime_back(k, t);
 	return bn_get_bit(k, 0);
@@ -76,7 +82,7 @@ static inline int fp_sgn0(const fp_t t, bn_t k) {
 /* Public definitions                                                         */
 /*============================================================================*/
 
-void ep_map_from_field(ep_t p, const uint8_t *uniform_bytes, int len) {
+void ep_map_from_field(ep_t p, const uint8_t *uniform_bytes, size_t len) {
 	bn_t k;
 	fp_t t;
 	ep_t q;
@@ -100,26 +106,26 @@ void ep_map_from_field(ep_t p, const uint8_t *uniform_bytes, int len) {
 		/* figure out which hash function to use */
 		const int abNeq0 = (ep_curve_opt_a() != RLC_ZERO) &&
 				(ep_curve_opt_b() != RLC_ZERO);
-		void (*const map_fn)(ep_t, fp_t) =(ep_curve_is_ctmap() ||
+		void (*const map_fn)(ep_t, fp_t) = (ep_curve_is_ctmap() ||
 				abNeq0) ? ep_map_sswu : ep_map_svdw;
 
-#define EP_MAP_CONVERT_BYTES(IDX)                                       \
-    do {                                                                \
-      bn_read_bin(k, uniform_bytes + IDX * len_per_elm, len_per_elm);   \
-      fp_prime_conv(t, k);                                              \
-    } while (0)
-
-#define EP_MAP_APPLY_MAP(PT)                                    \
-    do {                                                        \
-      /* check sign of t */                                     \
-      neg = fp_sgn0(t, k);                                      \
-      /* convert */                                             \
-      map_fn(PT, t);                                            \
-      /* compare sign of y and sign of t; fix if necessary */   \
-      neg = neg != fp_sgn0(PT->y, k);                             \
-      fp_neg(t, PT->y);                                          \
-      dv_copy_cond(PT->y, t, RLC_FP_DIGS, neg);                  \
-    } while (0)
+#define EP_MAP_CONVERT_BYTES(IDX)											\
+		do {																\
+			bn_read_bin(k, uniform_bytes + IDX * len_per_elm, len_per_elm);	\
+			fp_prime_conv(t, k);											\
+		} while (0)
+
+#define EP_MAP_APPLY_MAP(PT)												\
+		do {																\
+			/* check sign of t */											\
+			neg = fp_sgn0(t, k);											\
+			/* convert */													\
+			map_fn(PT, t);													\
+			/* compare sign of y and sign of t; fix if necessary */			\
+			neg = neg != fp_sgn0(PT->y, k);									\
+			fp_neg(t, PT->y);												\
+			dv_copy_cond(PT->y, t, RLC_FP_DIGS, neg);						\
+		} while (0)
 
 		/* first map invocation */
 		EP_MAP_CONVERT_BYTES(0);
@@ -179,8 +185,8 @@ void ep_map_from_field(ep_t p, const uint8_t *uniform_bytes, int len) {
 	}
 }
 
-void ep_map_dst(ep_t p, const uint8_t *msg, int len, const uint8_t *dst,
-		int dst_len) {
+void ep_map_dst(ep_t p, const uint8_t *msg, size_t len, const uint8_t *dst,
+		size_t dst_len) {
 
 	/* enough space for two field elements plus extra bytes for uniformity */
 	const int len_per_elm = (FP_PRIME + ep_param_level() + 7) / 8;
@@ -202,6 +208,6 @@ void ep_map_dst(ep_t p, const uint8_t *msg, int len, const uint8_t *dst,
 	}
 }
 
-void ep_map(ep_t p, const uint8_t *msg, int len) {
+void ep_map(ep_t p, const uint8_t *msg, size_t len) {
 	ep_map_dst(p, msg, len, (const uint8_t *)"RELIC", 5);
 }
diff --git a/src/ep/relic_ep_mul.c b/src/ep/relic_ep_mul.c
index d73353c3b..772f34068 100644
--- a/src/ep/relic_ep_mul.c
+++ b/src/ep/relic_ep_mul.c
@@ -40,10 +40,11 @@
 #if defined(EP_ENDOM)
 
 static void ep_mul_glv_imp(ep_t r, const ep_t p, const bn_t k) {
-	int l, l0, l1, i, n0, n1, s0, s1;
+	int i, n0, n1, s0, s1;
 	int8_t naf0[RLC_FP_BITS + 1], naf1[RLC_FP_BITS + 1], *t0, *t1;
 	bn_t n, _k, k0, k1, v1[3], v2[3];
 	ep_t q, t[1 << (EP_WIDTH - 2)];
+	size_t l, l0, l1;
 
 	bn_null(n);
 	bn_null(_k);
@@ -153,11 +154,11 @@ static void ep_mul_glv_imp(ep_t r, const ep_t p, const bn_t k) {
 #if defined(EP_PLAIN) || defined(EP_SUPER)
 
 static void ep_mul_naf_imp(ep_t r, const ep_t p, const bn_t k) {
-	int i, l;
 	/* Some of the supported prime curves have order > field. */
 	int8_t u, naf[RLC_FP_BITS + 2];
 	ep_t t[1 << (EP_WIDTH - 2)];
 	bn_t _k, n;
+	size_t l;
 
 	bn_null(n);
 	bn_null(_k);
@@ -166,7 +167,7 @@ static void ep_mul_naf_imp(ep_t r, const ep_t p, const bn_t k) {
 		bn_new(n);
 		bn_new(_k);
 		/* Prepare the precomputation table. */
-		for (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {
+		for (int i = 0; i < (1 << (EP_WIDTH - 2)); i++) {
 			ep_null(t[i]);
 			ep_new(t[i]);
 		}
@@ -182,7 +183,7 @@ static void ep_mul_naf_imp(ep_t r, const ep_t p, const bn_t k) {
 		bn_rec_naf(naf, &l, _k, EP_WIDTH);
 
 		ep_set_infty(r);
-		for (i = l - 1; i >= 0; i--) {
+		for (int i = l - 1; i >= 0; i--) {
 			ep_dbl(r, r);
 
 			u = naf[i];
@@ -205,7 +206,7 @@ static void ep_mul_naf_imp(ep_t r, const ep_t p, const bn_t k) {
 		bn_free(n);
 		bn_free(_k);
 		/* Free the precomputation table. */
-		for (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {
+		for (int i = 0; i < (1 << (EP_WIDTH - 2)); i++) {
 			ep_free(t[i]);
 		}
 	}
@@ -219,10 +220,11 @@ static void ep_mul_naf_imp(ep_t r, const ep_t p, const bn_t k) {
 #if defined(EP_ENDOM)
 
 static void ep_mul_reg_glv(ep_t r, const ep_t p, const bn_t k) {
-	int i, j, l, n0, n1, s0, s1, b0, b1;
+	int i, j, n0, n1, s0, s1, b0, b1;
 	int8_t _s0, _s1, reg0[RLC_FP_BITS + 1], reg1[RLC_FP_BITS + 1];
 	bn_t n, _k, k0, k1, v1[3], v2[3];
 	ep_t q, t[1 << (EP_WIDTH - 2)], u, v, w;
+	size_t l;
 
 	bn_null(n);
 	bn_null(_k);
@@ -371,9 +373,10 @@ static void ep_mul_reg_glv(ep_t r, const ep_t p, const bn_t k) {
 
 static void ep_mul_reg_imp(ep_t r, const ep_t p, const bn_t k) {
 	bn_t _k;
-	int i, j, l, n;
+	int i, j, n;
 	int8_t s, reg[1 + RLC_CEIL(RLC_FP_BITS + 1, EP_WIDTH - 1)];
 	ep_t t[1 << (EP_WIDTH - 2)], u, v;
+	size_t l;
 
 	if (bn_is_zero(k)) {
 		ep_set_infty(r);
@@ -502,8 +505,8 @@ void ep_mul_basic(ep_t r, const ep_t p, const bn_t k) {
 void ep_mul_slide(ep_t r, const ep_t p, const bn_t k) {
 	bn_t _k, n;
 	ep_t t[1 << (EP_WIDTH - 1)], q;
-	int i, j, l;
 	uint8_t win[RLC_FP_BITS + 1];
+	size_t l;
 
 	if (bn_is_zero(k) || ep_is_infty(p)) {
 		ep_set_infty(r);
@@ -517,7 +520,7 @@ void ep_mul_slide(ep_t r, const ep_t p, const bn_t k) {
 	RLC_TRY {
 		bn_new(n);
 		bn_new(_k);
-		for (i = 0; i < (1 << (EP_WIDTH - 1)); i ++) {
+		for (size_t i = 0; i < (1 << (EP_WIDTH - 1)); i ++) {
 			ep_null(t[i]);
 			ep_new(t[i]);
 		}
@@ -534,7 +537,7 @@ void ep_mul_slide(ep_t r, const ep_t p, const bn_t k) {
 		bn_mod(_k, k, n);
 
 		/* Create table. */
-		for (i = 1; i < (1 << (EP_WIDTH - 1)); i++) {
+		for (size_t i = 1; i < (1 << (EP_WIDTH - 1)); i++) {
 			ep_add(t[i], t[i - 1], q);
 		}
 
@@ -545,11 +548,11 @@ void ep_mul_slide(ep_t r, const ep_t p, const bn_t k) {
 		ep_set_infty(q);
 		l = RLC_FP_BITS + 1;
 		bn_rec_slw(win, &l, _k, EP_WIDTH);
-		for (i = 0; i < l; i++) {
+		for (size_t i = 0; i < l; i++) {
 			if (win[i] == 0) {
 				ep_dbl(q, q);
 			} else {
-				for (j = 0; j < util_bits_dig(win[i]); j++) {
+				for (size_t j = 0; j < util_bits_dig(win[i]); j++) {
 					ep_dbl(q, q);
 				}
 				ep_add(q, q, t[win[i] >> 1]);
@@ -567,7 +570,7 @@ void ep_mul_slide(ep_t r, const ep_t p, const bn_t k) {
 	RLC_FINALLY {
 		bn_free(n);
 		bn_free(_k);
-		for (i = 0; i < (1 << (EP_WIDTH - 1)); i++) {
+		for (size_t i = 0; i < (1 << (EP_WIDTH - 1)); i++) {
 			ep_free(t[i]);
 		}
 		ep_free(q);
@@ -579,9 +582,9 @@ void ep_mul_slide(ep_t r, const ep_t p, const bn_t k) {
 #if EP_MUL == MONTY || !defined(STRIP)
 
 void ep_mul_monty(ep_t r, const ep_t p, const bn_t k) {
-	int i, j, bits;
 	ep_t t[2];
 	bn_t n, l, _k;
+	size_t bits;
 
 	bn_null(n);
 	bn_null(l);
@@ -619,8 +622,8 @@ void ep_mul_monty(ep_t r, const ep_t p, const bn_t k) {
 		ep_blind(t[0], t[0]);
 		ep_blind(t[1], t[1]);
 
-		for (i = bits - 1; i >= 0; i--) {
-			j = bn_get_bit(l, i);
+		for (int i = bits - 1; i >= 0; i--) {
+			int j = bn_get_bit(l, i);
 			dv_swap_cond(t[0]->x, t[1]->x, RLC_FP_DIGS, j ^ 1);
 			dv_swap_cond(t[0]->y, t[1]->y, RLC_FP_DIGS, j ^ 1);
 			dv_swap_cond(t[0]->z, t[1]->z, RLC_FP_DIGS, j ^ 1);
@@ -723,7 +726,7 @@ void ep_mul_dig(ep_t r, const ep_t p, dig_t k) {
 	ep_t t;
 	bn_t _k;
 	int8_t u, naf[RLC_DIG + 1];
-	int l;
+	size_t l;
 
 	ep_null(t);
 	bn_null(_k);
diff --git a/src/ep/relic_ep_mul_fix.c b/src/ep/relic_ep_mul_fix.c
index 913c392d7..ea309ad55 100644
--- a/src/ep/relic_ep_mul_fix.c
+++ b/src/ep/relic_ep_mul_fix.c
@@ -46,8 +46,9 @@
  * @param[in] k					- the integer.
  */
 static void ep_mul_fix_plain(ep_t r, const ep_t *t, const bn_t k) {
-	int l, i, n;
+	int i, n;
 	int8_t naf[RLC_FP_BITS + 1];
+	size_t l;
 
 	/* Compute the w-TNAF representation of k. */
 	l = RLC_FP_BITS + 1;
diff --git a/src/ep/relic_ep_mul_sim.c b/src/ep/relic_ep_mul_sim.c
index efba4b9c9..c4c78e3fb 100644
--- a/src/ep/relic_ep_mul_sim.c
+++ b/src/ep/relic_ep_mul_sim.c
@@ -54,7 +54,7 @@
  */
 static void ep_mul_sim_endom(ep_t r, const ep_t p, const bn_t k, const ep_t q,
 		const bn_t m, const ep_t *t) {
-	int i, l, l0, l1, l2, l3, sk0, sk1, sl0, sl1, w, g = 0;
+	int i, sk0, sk1, sl0, sl1, w, g = 0;
 	int8_t naf0[RLC_FP_BITS + 1], naf1[RLC_FP_BITS + 1], *t0, *t1, u;
 	int8_t naf2[RLC_FP_BITS + 1], naf3[RLC_FP_BITS + 1], *t2, *t3;
 	bn_t n, k0, k1, m0, m1;
@@ -62,6 +62,7 @@ static void ep_mul_sim_endom(ep_t r, const ep_t p, const bn_t k, const ep_t q,
 	ep_t v;
 	ep_t tab0[1 << (EP_WIDTH - 2)];
 	ep_t tab1[1 << (EP_WIDTH - 2)];
+	size_t l, l0, l1, l2, l3;
 
 	bn_null(n);
 	bn_null(k0);
@@ -264,9 +265,10 @@ static void ep_mul_sim_endom(ep_t r, const ep_t p, const bn_t k, const ep_t q,
  */
 void ep_mul_sim_lot_endom(ep_t r, const ep_t p[], const bn_t k[], int n) {
 	const int len = RLC_FP_BITS + 1;
-	int i, j, m, l, _l[2], sk;
+	int i, j, m, sk;
 	bn_t _k[2], q, v1[3], v2[3];
 	int8_t ptr, *naf = RLC_ALLOCA(int8_t, 2 * n * len);
+	size_t l, _l[2];
 
 	bn_null(q);
 
@@ -486,10 +488,11 @@ void ep_mul_sim_lot_endom(ep_t r, const ep_t p[], const bn_t k[], int n) {
  */
 static void ep_mul_sim_plain(ep_t r, const ep_t p, const bn_t k, const ep_t q,
 		const bn_t m, const ep_t *t) {
-	int i, l, l0, l1, w, gen;
+	int i, w, gen;
 	int8_t naf0[RLC_FP_BITS + 1], naf1[RLC_FP_BITS + 1], n0, n1, *u, *v;
 	ep_t t0[1 << (EP_WIDTH - 2)];
 	ep_t t1[1 << (EP_WIDTH - 2)];
+	size_t l, l0, l1;
 
 	RLC_TRY {
 		gen = (t == NULL ? 0 : 1);
@@ -583,9 +586,10 @@ static void ep_mul_sim_plain(ep_t r, const ep_t p, const bn_t k, const ep_t q,
  * @param[out] n			- the number of elements to multiply.
  */
 void ep_mul_sim_lot_plain(ep_t r, const ep_t p[], const bn_t k[], int n) {
-	int i, j, l, *_l = RLC_ALLOCA(int, n);
-	ep_t *_p = RLC_ALLOCA(ep_t, n);
+	int i, j;
 	int8_t *naf = NULL;
+	ep_t *_p = RLC_ALLOCA(ep_t, n);
+	size_t l, *_l = RLC_ALLOCA(size_t, n);
 
 	RLC_TRY {
 		l = 0;
@@ -677,7 +681,7 @@ void ep_mul_sim_trick(ep_t r, const ep_t p, const bn_t k, const ep_t q,
 		const bn_t m) {
 	ep_t t0[1 << (EP_WIDTH / 2)], t1[1 << (EP_WIDTH / 2)], t[1 << EP_WIDTH];
 	bn_t n, _k, _m;
-	int l0, l1, w = EP_WIDTH / 2;
+	size_t l0, l1, w = EP_WIDTH / 2;
 	uint8_t w0[RLC_FP_BITS + 1], w1[RLC_FP_BITS + 1];
 
 	if (bn_is_zero(k) || ep_is_infty(p)) {
@@ -838,8 +842,9 @@ void ep_mul_sim_joint(ep_t r, const ep_t p, const bn_t k, const ep_t q,
 		const bn_t m) {
 	bn_t n, _k, _m;
 	ep_t t[5];
-	int i, l, u_i, offset;
+	int i, u_i, offset;
 	int8_t jsf[2 * (RLC_FP_BITS + 1)];
+	size_t l;
 
 	if (bn_is_zero(k) || ep_is_infty(p)) {
 		ep_mul(r, q, m);
diff --git a/src/ep/relic_ep_util.c b/src/ep/relic_ep_util.c
index 54b13eab9..2d2d5871c 100644
--- a/src/ep/relic_ep_util.c
+++ b/src/ep/relic_ep_util.c
@@ -234,7 +234,7 @@ int ep_size_bin(const ep_t a, int pack) {
 	return size;
 }
 
-void ep_read_bin(ep_t a, const uint8_t *bin, int len) {
+void ep_read_bin(ep_t a, const uint8_t *bin, size_t len) {
 	if (len == 1) {
 		if (bin[0] == 0) {
 			ep_set_infty(a);
@@ -284,7 +284,7 @@ void ep_read_bin(ep_t a, const uint8_t *bin, int len) {
 	}
 }
 
-void ep_write_bin(uint8_t *bin, int len, const ep_t a, int pack) {
+void ep_write_bin(uint8_t *bin, size_t len, const ep_t a, int pack) {
 	ep_t t;
 
 	ep_null(t);
diff --git a/src/epx/relic_ep2_map.c b/src/epx/relic_ep2_map.c
index 7764679ab..8a130c0fc 100644
--- a/src/epx/relic_ep2_map.c
+++ b/src/epx/relic_ep2_map.c
@@ -48,29 +48,25 @@
  * @param[in] len			- the degree of the polynomial.
  */
 TMPL_MAP_HORNER(fp2, fp2_t)
-
 /**
  * Generic isogeny map evaluation for use with SSWU map.
  */
 TMPL_MAP_ISOGENY_MAP(ep2, fp2, iso2)
 #endif /* EP_CTMAP */
-
 /**
  * Simplified SWU mapping.
  */
-#define EP2_MAP_COPY_COND(O, I, C)                                                       \
-	do {                                                                                 \
-		dv_copy_cond(O[0], I[0], RLC_FP_DIGS, C);                                        \
-		dv_copy_cond(O[1], I[1], RLC_FP_DIGS, C);                                        \
+#define EP2_MAP_COPY_COND(O, I, C)											\
+	do {																	\
+		dv_copy_cond(O[0], I[0], RLC_FP_DIGS, C);							\
+		dv_copy_cond(O[1], I[1], RLC_FP_DIGS, C);							\
 	} while (0)
 TMPL_MAP_SSWU(ep2, fp2, fp_t, EP2_MAP_COPY_COND)
-
 /**
  * Shallue--van de Woestijne map.
  */
 TMPL_MAP_SVDW(ep2, fp2, fp_t, EP2_MAP_COPY_COND)
 #undef EP2_MAP_COPY_COND
-
 /* caution: this function overwrites k, which it uses as an auxiliary variable */
 static inline int fp2_sgn0(const fp2_t t, bn_t k) {
 	const int t_0_zero = fp_is_zero(t[0]);
@@ -89,105 +85,106 @@ static inline int fp2_sgn0(const fp2_t t, bn_t k) {
 /* Public definitions                                                         */
 /*============================================================================*/
 
-void ep2_map_from_field(ep2_t p, const uint8_t *uniform_bytes, int len) {
-        bn_t k;
-        fp2_t t;
-        ep2_t q;
-        int neg;
-        /* enough space for two extension field elements plus extra bytes for uniformity */
-        const int len_per_elm = (FP_PRIME + ep_param_level() + 7) / 8;
-
-        bn_null(k);
-        fp2_null(t);
-        ep2_null(q);
-
-        RLC_TRY {
-                if (len != 2* len_per_elm) {
-                  RLC_THROW(ERR_NO_VALID);
-                }
-
-                bn_new(k);
-                fp2_new(t);
-                ep2_new(q);
-
-                /* which hash function should we use? */
-                const int abNeq0 = (ep2_curve_opt_a() != RLC_ZERO) && (ep2_curve_opt_b() != RLC_ZERO);
-                void (*const map_fn)(ep2_t, fp2_t) = (ep2_curve_is_ctmap() || abNeq0) ? ep2_map_sswu : ep2_map_svdw;
-
-#define EP2_MAP_CONVERT_BYTES(IDX)                                                       \
-        do {                                                                                 \
-                bn_read_bin(k, uniform_bytes + 2 * IDX * len_per_elm, len_per_elm);        \
-                fp_prime_conv(t[0], k);                                                          \
-                bn_read_bin(k, uniform_bytes + (2 * IDX + 1) * len_per_elm, len_per_elm);  \
-                fp_prime_conv(t[1], k);                                                          \
-        } while (0)
-
-#define EP2_MAP_APPLY_MAP(PT)                                                            \
-        do {                                                                                 \
-                /* sign of t */                                                                  \
-                neg = fp2_sgn0(t, k);                                                            \
-                /* convert */                                                                    \
-                map_fn(PT, t);                                                                   \
-                /* compare sign of y to sign of t; fix if necessary */                           \
-                neg = neg != fp2_sgn0(PT->y, k);                                                 \
-                fp2_neg(t, PT->y);                                                               \
-                dv_copy_cond(PT->y[0], t[0], RLC_FP_DIGS, neg);                                  \
-                dv_copy_cond(PT->y[1], t[1], RLC_FP_DIGS, neg);                                  \
-        } while (0)
-
-                /* first map invocation */
-                EP2_MAP_CONVERT_BYTES(0);
-                EP2_MAP_APPLY_MAP(p);
-                TMPL_MAP_CALL_ISOMAP(ep2, p);
-
-                /* second map invocation */
-                EP2_MAP_CONVERT_BYTES(1);
-                EP2_MAP_APPLY_MAP(q);
-                TMPL_MAP_CALL_ISOMAP(ep2, q);
-
-                /* XXX(rsw) could add p and q and then apply isomap,
-                 * but need ep_add to support addition on isogeny curves */
+void ep2_map_from_field(ep2_t p, const uint8_t *uniform_bytes, size_t len) {
+	bn_t k;
+	fp2_t t;
+	ep2_t q;
+	int neg;
+	/* enough space for two extension field elements plus extra bytes for uniformity */
+	const int lpe = (FP_PRIME + ep_param_level() + 7) / 8;
+
+	bn_null(k);
+	fp2_null(t);
+	ep2_null(q);
+
+	RLC_TRY {
+		if (len != 2 * lpe) {
+			RLC_THROW(ERR_NO_VALID);
+		}
+
+		bn_new(k);
+		fp2_new(t);
+		ep2_new(q);
+
+		/* which hash function should we use? */
+		const int abNeq0 = (ep2_curve_opt_a() != RLC_ZERO) &&
+				(ep2_curve_opt_b() != RLC_ZERO);
+		void (*const map_fn)(ep2_t, fp2_t) = (ep2_curve_is_ctmap() ||
+				abNeq0) ? ep2_map_sswu : ep2_map_svdw;
+
+#define EP2_MAP_CONVERT_BYTES(IDX)											\
+		do {																\
+			bn_read_bin(k, uniform_bytes + 2 * IDX * lpe, lpe);				\
+			fp_prime_conv(t[0], k);											\
+			bn_read_bin(k, uniform_bytes + (2 * IDX + 1) * lpe, lpe);		\
+			fp_prime_conv(t[1], k);											\
+	    } while (0)
+
+#define EP2_MAP_APPLY_MAP(PT)												\
+		do {																\
+            /* sign of t */													\
+            neg = fp2_sgn0(t, k);											\
+            /* convert */													\
+            map_fn(PT, t);													\
+            /* compare sign of y to sign of t; fix if necessary */			\
+            neg = neg != fp2_sgn0(PT->y, k);								\
+            fp2_neg(t, PT->y);												\
+            dv_copy_cond(PT->y[0], t[0], RLC_FP_DIGS, neg);					\
+            dv_copy_cond(PT->y[1], t[1], RLC_FP_DIGS, neg);					\
+		} while (0)
+
+		/* first map invocation */
+		EP2_MAP_CONVERT_BYTES(0);
+		EP2_MAP_APPLY_MAP(p);
+		TMPL_MAP_CALL_ISOMAP(ep2, p);
+
+		/* second map invocation */
+		EP2_MAP_CONVERT_BYTES(1);
+		EP2_MAP_APPLY_MAP(q);
+		TMPL_MAP_CALL_ISOMAP(ep2, q);
+
+		/* XXX(rsw) could add p and q and then apply isomap,
+		 * but need ep_add to support addition on isogeny curves */
 
 #undef EP2_MAP_CONVERT_BYTES
 #undef EP2_MAP_APPLY_MAP
 
-                /* sum the result */
-                ep2_add(p, p, q);
-                ep2_norm(p, p);
-                ep2_mul_cof(p, p);
-        }
-        RLC_CATCH_ANY {
-                RLC_THROW(ERR_CAUGHT);
-        }
-        RLC_FINALLY {
-                bn_free(k);
-                fp2_free(t);
-                ep2_free(q);
-        }
+		/* sum the result */
+		ep2_add(p, p, q);
+		ep2_norm(p, p);
+		ep2_mul_cof(p, p);
+	}
+	RLC_CATCH_ANY {
+		RLC_THROW(ERR_CAUGHT);
+	}
+	RLC_FINALLY {
+		bn_free(k);
+		fp2_free(t);
+		ep2_free(q);
+	}
 }
 
 
-void ep2_map_dst(ep2_t p, const uint8_t *msg, int len, const uint8_t *dst, int dst_len) {
-
-        /* enough space for two field elements plus extra bytes for uniformity */
-        const int len_per_elm = (FP_PRIME + ep_param_level() + 7) / 8;
-        uint8_t *pseudo_random_bytes = RLC_ALLOCA(uint8_t, 4 * len_per_elm);
-
-        RLC_TRY {
-
-                /* XXX(rsw) See note in ep/relic_ep_map.c about using MD_MAP. */
-                /* hash to a pseudorandom string using md_xmd */
-                md_xmd(pseudo_random_bytes, 4 * len_per_elm, msg, len, dst, dst_len);
-                ep2_map_from_field(p, pseudo_random_bytes, 2 * len_per_elm);
-        }
-        RLC_CATCH_ANY {
-                RLC_THROW(ERR_CAUGHT);
-        }
-        RLC_FINALLY {
-                RLC_FREE(pseudo_random_bytes);
-        }
+void ep2_map_dst(ep2_t p, const uint8_t *msg, size_t len, const uint8_t *dst,
+		size_t dst_len) {
+	/* enough space for two field elements plus extra bytes for uniformity */
+	const int lpe = (FP_PRIME + ep_param_level() + 7) / 8;
+	uint8_t *pseudo_random_bytes = RLC_ALLOCA(uint8_t, 4 * lpe);
+
+	RLC_TRY {
+		/* XXX(rsw) See note in ep/relic_ep_map.c about using MD_MAP. */
+		/* hash to a pseudorandom string using md_xmd */
+		md_xmd(pseudo_random_bytes, 4 * lpe, msg, len, dst, dst_len);
+		ep2_map_from_field(p, pseudo_random_bytes, 2 * lpe);
+	}
+	RLC_CATCH_ANY {
+		RLC_THROW(ERR_CAUGHT);
+	}
+	RLC_FINALLY {
+		RLC_FREE(pseudo_random_bytes);
+	}
 }
 
-void ep2_map(ep2_t p, const uint8_t *msg, int len) {
+void ep2_map(ep2_t p, const uint8_t *msg, size_t len) {
 	ep2_map_dst(p, msg, len, (const uint8_t *)"RELIC", 5);
 }
diff --git a/src/epx/relic_ep2_mul.c b/src/epx/relic_ep2_mul.c
index 684b5eb50..1d45f9cc7 100644
--- a/src/epx/relic_ep2_mul.c
+++ b/src/epx/relic_ep2_mul.c
@@ -41,7 +41,7 @@
 #if defined(EP_ENDOM)
 
 static void ep2_mul_glv_imp(ep2_t r, const ep2_t p, const bn_t k) {
-	int i, j, l, _l[4];
+	size_t l, _l[4];
 	bn_t n, _k[4], u;
 	int8_t naf[4][RLC_FP_BITS + 1];
 	ep2_t q[4];
@@ -52,7 +52,7 @@ static void ep2_mul_glv_imp(ep2_t r, const ep2_t p, const bn_t k) {
 	RLC_TRY {
 		bn_new(n);
 		bn_new(u);
-		for (i = 0; i < 4; i++) {
+		for (int i = 0; i < 4; i++) {
 			bn_null(_k[i]);
 			ep2_null(q[i]);
 			bn_new(_k[i]);
@@ -70,7 +70,7 @@ static void ep2_mul_glv_imp(ep2_t r, const ep2_t p, const bn_t k) {
 		ep2_frb(q[3], q[2], 1);
 
 		l = 0;
-		for (i = 0; i < 4; i++) {
+		for (int i = 0; i < 4; i++) {
 			if (bn_sign(_k[i]) == RLC_NEG) {
 				ep2_neg(q[i], q[i]);
 			}
@@ -80,10 +80,10 @@ static void ep2_mul_glv_imp(ep2_t r, const ep2_t p, const bn_t k) {
 		}
 
 		ep2_set_infty(r);
-		for (j = l - 1; j >= 0; j--) {
+		for (int j = l - 1; j >= 0; j--) {
 			ep2_dbl(r, r);
 
-			for (i = 0; i < 4; i++) {
+			for (int i = 0; i < 4; i++) {
 				if (naf[i][j] > 0) {
 					ep2_add(r, r, q[i]);
 				}
@@ -102,7 +102,7 @@ static void ep2_mul_glv_imp(ep2_t r, const ep2_t p, const bn_t k) {
 	RLC_FINALLY {
 		bn_free(n);
 		bn_free(u);
-		for (i = 0; i < 4; i++) {
+		for (int i = 0; i < 4; i++) {
 			bn_free(_k[i]);
 			ep2_free(q[i]);
 		}
@@ -113,13 +113,13 @@ static void ep2_mul_glv_imp(ep2_t r, const ep2_t p, const bn_t k) {
 #endif /* EP_ENDOM */
 
 static void ep2_mul_naf_imp(ep2_t r, const ep2_t p, const bn_t k) {
-	int l, i, n;
+	size_t l, n;
 	int8_t naf[RLC_FP_BITS + 1];
 	ep2_t t[1 << (EP_WIDTH - 2)];
 
 	RLC_TRY {
 		/* Prepare the precomputation table. */
-		for (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {
+		for (int i = 0; i < (1 << (EP_WIDTH - 2)); i++) {
 			ep2_null(t[i]);
 			ep2_new(t[i]);
 		}
@@ -131,7 +131,7 @@ static void ep2_mul_naf_imp(ep2_t r, const ep2_t p, const bn_t k) {
 		bn_rec_naf(naf, &l, k, EP_WIDTH);
 
 		ep2_set_infty(r);
-		for (i = l - 1; i >= 0; i--) {
+		for (int i = l - 1; i >= 0; i--) {
 			ep2_dbl(r, r);
 
 			n = naf[i];
@@ -153,7 +153,7 @@ static void ep2_mul_naf_imp(ep2_t r, const ep2_t p, const bn_t k) {
 	}
 	RLC_FINALLY {
 		/* Free the precomputation table. */
-		for (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {
+		for (int i = 0; i < (1 << (EP_WIDTH - 2)); i++) {
 			ep2_free(t[i]);
 		}
 	}
@@ -166,7 +166,7 @@ static void ep2_mul_naf_imp(ep2_t r, const ep2_t p, const bn_t k) {
 /*============================================================================*/
 
 void ep2_mul_basic(ep2_t r, const ep2_t p, const bn_t k) {
-	int i, l;
+	size_t l;
 	ep2_t t;
 
 	ep2_null(t);
@@ -186,7 +186,7 @@ void ep2_mul_basic(ep2_t r, const ep2_t p, const bn_t k) {
 			ep2_set_infty(t);
 		}
 
-		for (i = l - 2; i >= 0; i--) {
+		for (int i = l - 2; i >= 0; i--) {
 			ep2_dbl(t, t);
 			if (bn_get_bit(k, i)) {
 				ep2_add(t, t, p);
@@ -211,8 +211,8 @@ void ep2_mul_basic(ep2_t r, const ep2_t p, const bn_t k) {
 
 void ep2_mul_slide(ep2_t r, const ep2_t p, const bn_t k) {
 	ep2_t t[1 << (EP_WIDTH - 1)], q;
-	int i, j, l;
 	uint8_t win[RLC_FP_BITS + 1];
+	size_t l;
 
 	ep2_null(q);
 
@@ -222,7 +222,7 @@ void ep2_mul_slide(ep2_t r, const ep2_t p, const bn_t k) {
 	}
 
 	RLC_TRY {
-		for (i = 0; i < (1 << (EP_WIDTH - 1)); i ++) {
+		for (int i = 0; i < (1 << (EP_WIDTH - 1)); i ++) {
 			ep2_null(t[i]);
 			ep2_new(t[i]);
 		}
@@ -237,7 +237,7 @@ void ep2_mul_slide(ep2_t r, const ep2_t p, const bn_t k) {
 #endif
 
 		/* Create table. */
-		for (i = 1; i < (1 << (EP_WIDTH - 1)); i++) {
+		for (size_t i = 1; i < (1 << (EP_WIDTH - 1)); i++) {
 			ep2_add(t[i], t[i - 1], q);
 		}
 
@@ -248,11 +248,11 @@ void ep2_mul_slide(ep2_t r, const ep2_t p, const bn_t k) {
 		ep2_set_infty(q);
 		l = RLC_FP_BITS + 1;
 		bn_rec_slw(win, &l, k, EP_WIDTH);
-		for (i = 0; i < l; i++) {
+		for (size_t i = 0; i < l; i++) {
 			if (win[i] == 0) {
 				ep2_dbl(q, q);
 			} else {
-				for (j = 0; j < util_bits_dig(win[i]); j++) {
+				for (size_t j = 0; j < util_bits_dig(win[i]); j++) {
 					ep2_dbl(q, q);
 				}
 				ep2_add(q, q, t[win[i] >> 1]);
@@ -268,7 +268,7 @@ void ep2_mul_slide(ep2_t r, const ep2_t p, const bn_t k) {
 		RLC_THROW(ERR_CAUGHT);
 	}
 	RLC_FINALLY {
-		for (i = 0; i < (1 << (EP_WIDTH - 1)); i++) {
+		for (size_t i = 0; i < (1 << (EP_WIDTH - 1)); i++) {
 			ep2_free(t[i]);
 		}
 		ep2_free(q);
@@ -387,7 +387,7 @@ void ep2_mul_dig(ep2_t r, const ep2_t p, const dig_t k) {
 	ep2_t t;
 	bn_t _k;
 	int8_t u, naf[RLC_DIG + 1];
-	int l;
+	size_t l;
 
 	ep2_null(t);
 	bn_null(_k);
diff --git a/src/epx/relic_ep2_mul_fix.c b/src/epx/relic_ep2_mul_fix.c
index e2effd678..9ba36c39c 100644
--- a/src/epx/relic_ep2_mul_fix.c
+++ b/src/epx/relic_ep2_mul_fix.c
@@ -47,8 +47,9 @@
  * @param[in] k					- the integer.
  */
 static void ep2_mul_fix_plain(ep2_t r, const ep2_t *table, const bn_t k) {
-	int len, i, n;
 	int8_t naf[2 * RLC_FP_BITS + 1], *t;
+	size_t len;
+	int n;
 
 	if (bn_is_zero(k)) {
 		ep2_set_infty(r);
@@ -61,7 +62,7 @@ static void ep2_mul_fix_plain(ep2_t r, const ep2_t *table, const bn_t k) {
 
 	t = naf + len - 1;
 	ep2_set_infty(r);
-	for (i = len - 1; i >= 0; i--, t--) {
+	for (int i = len - 1; i >= 0; i--, t--) {
 		ep2_dbl(r, r);
 
 		n = *t;
diff --git a/src/epx/relic_ep2_mul_sim.c b/src/epx/relic_ep2_mul_sim.c
index 0371975e5..d2016d94e 100644
--- a/src/epx/relic_ep2_mul_sim.c
+++ b/src/epx/relic_ep2_mul_sim.c
@@ -54,7 +54,7 @@
  */
 static void ep2_mul_sim_endom(ep2_t r, const ep2_t p, const bn_t k, ep2_t q,
 		const bn_t m) {
-	int i, j, l, _l[4];
+	size_t l, _l[4];
 	bn_t _k[4], _m[4], n, u;
 	int8_t naf0[4][RLC_FP_BITS + 1];
 	int8_t naf1[4][RLC_FP_BITS + 1];
@@ -66,7 +66,7 @@ static void ep2_mul_sim_endom(ep2_t r, const ep2_t p, const bn_t k, ep2_t q,
 	RLC_TRY {
 		bn_new(n);
 		bn_new(u);
-		for (i = 0; i < 4; i++) {
+		for (int i = 0; i < 4; i++) {
 			bn_null(_k[i]);
 			bn_new(_k[i]);
 			bn_null(_m[i]);
@@ -94,7 +94,7 @@ static void ep2_mul_sim_endom(ep2_t r, const ep2_t p, const bn_t k, ep2_t q,
 		bn_rec_frb(_m, 4, _m[0], u, n, ep_curve_is_pairf() == EP_BN);
 
 		l = 0;
-		for (i = 0; i < 4; i++) {
+		for (int i = 0; i < 4; i++) {
 			_l[i] = RLC_FP_BITS + 1;
 			bn_rec_naf(naf0[i], &_l[i], _k[i], 2);
 			if (bn_sign(_k[i]) == RLC_NEG) {
@@ -110,9 +110,9 @@ static void ep2_mul_sim_endom(ep2_t r, const ep2_t p, const bn_t k, ep2_t q,
 		}
 
 		ep2_set_infty(r);
-		for (i = l - 1; i >= 0; i--) {
+		for (int i = l - 1; i >= 0; i--) {
 			ep2_dbl(r, r);
-			for (j = 0; j < 4; j++) {
+			for (int j = 0; j < 4; j++) {
 				if (naf0[j][i] > 0) {
 					ep2_add(r, r, _p[j]);
 				}
@@ -135,7 +135,7 @@ static void ep2_mul_sim_endom(ep2_t r, const ep2_t p, const bn_t k, ep2_t q,
 	} RLC_FINALLY {
 		bn_free(n);
 		bn_free(u);
-		for (i = 0; i < 4; i++) {
+		for (int i = 0; i < 4; i++) {
 			bn_free(_k[i]);
 			bn_free(_m[i]);
 			ep2_free(_p[i]);
@@ -162,10 +162,11 @@ static void ep2_mul_sim_endom(ep2_t r, const ep2_t p, const bn_t k, ep2_t q,
  */
 static void ep2_mul_sim_plain(ep2_t r, const ep2_t p, const bn_t k,
 		const ep2_t q, const bn_t m, const ep2_t *t) {
-	int i, l, l0, l1, n0, n1, w, gen;
+	int i, n0, n1, w, gen;
 	int8_t naf0[2 * RLC_FP_BITS + 1], naf1[2 * RLC_FP_BITS + 1], *_k, *_m;
 	ep2_t t0[1 << (EP_WIDTH - 2)];
 	ep2_t t1[1 << (EP_WIDTH - 2)];
+	size_t l, l0, l1;
 
 	RLC_TRY {
 		gen = (t == NULL ? 0 : 1);
@@ -289,7 +290,7 @@ void ep2_mul_sim_trick(ep2_t r, const ep2_t p, const bn_t k, const ep2_t q,
 	ep2_t t1[1 << (EP_WIDTH / 2)];
 	ep2_t t[1 << EP_WIDTH];
 	bn_t n, _k, _m;
-	int l0, l1, w = EP_WIDTH / 2;
+	size_t l0, l1, w = EP_WIDTH / 2;
 	uint8_t w0[2 * RLC_FP_BITS], w1[2 * RLC_FP_BITS];
 
 	bn_null(n);
@@ -451,8 +452,9 @@ void ep2_mul_sim_joint(ep2_t r, const ep2_t p, const bn_t k, const ep2_t q,
 		const bn_t m) {
 	bn_t n, _k, _m;
 	ep2_t t[5];
-	int i, l, u_i, offset;
+	int i, u_i, offset;
 	int8_t jsf[2 * (RLC_FP_BITS + 1)];
+	size_t l;
 
 	if (bn_is_zero(k) || ep2_is_infty(p)) {
 		ep2_mul(r, q, m);
@@ -601,7 +603,7 @@ void ep2_mul_sim_gen(ep2_t r, const bn_t k, const ep2_t q, const bn_t m) {
 	}
 }
 
-void ep2_mul_sim_dig(ep2_t r, const ep2_t p[], const dig_t k[], int len) {
+void ep2_mul_sim_dig(ep2_t r, const ep2_t p[], const dig_t k[], size_t len) {
 	ep2_t t;
 	int max;
 
@@ -635,11 +637,12 @@ void ep2_mul_sim_dig(ep2_t r, const ep2_t p[], const dig_t k[], int len) {
 	}
 }
 
-void ep2_mul_sim_lot(ep2_t r, const ep2_t p[], const bn_t k[], int n) {
-	const int len = RLC_FP_BITS + 1;
-	int i, j, m, l, _l[4];
+void ep2_mul_sim_lot(ep2_t r, const ep2_t p[], const bn_t k[], size_t n) {
+	const size_t len = RLC_FP_BITS + 1;
+	int i, j, m;
 	bn_t _k[4], q, x;
 	int8_t ptr, *naf = RLC_ALLOCA(int8_t, 4 * n * len);
+	size_t l, _l[4];
 
 	if (n == 0) {
 		ep2_set_infty(r);
diff --git a/src/epx/relic_ep2_util.c b/src/epx/relic_ep2_util.c
index 2df0fd6c7..a76682435 100644
--- a/src/epx/relic_ep2_util.c
+++ b/src/epx/relic_ep2_util.c
@@ -243,7 +243,7 @@ int ep2_size_bin(const ep2_t a, int pack) {
 	return size;
 }
 
-void ep2_read_bin(ep2_t a, const uint8_t *bin, int len) {
+void ep2_read_bin(ep2_t a, const uint8_t *bin, size_t len) {
 	if (len == 1) {
 		if (bin[0] == 0) {
 			ep2_set_infty(a);
@@ -293,7 +293,7 @@ void ep2_read_bin(ep2_t a, const uint8_t *bin, int len) {
 	}
 }
 
-void ep2_write_bin(uint8_t *bin, int len, const ep2_t a, int pack) {
+void ep2_write_bin(uint8_t *bin, size_t len, const ep2_t a, int pack) {
 	ep2_t t;
 
 	ep2_null(t);
diff --git a/src/epx/relic_ep4_map.c b/src/epx/relic_ep4_map.c
index 4fc73ed84..6701e8fbd 100644
--- a/src/epx/relic_ep4_map.c
+++ b/src/epx/relic_ep4_map.c
@@ -37,7 +37,7 @@
 /* Public definitions                                                         */
 /*============================================================================*/
 
-void ep4_map(ep4_t p, const uint8_t *msg, int len) {
+void ep4_map(ep4_t p, const uint8_t *msg, size_t len) {
 	bn_t x;
 	fp4_t t0;
 	uint8_t digest[RLC_MD_LEN];
diff --git a/src/epx/relic_ep4_mul.c b/src/epx/relic_ep4_mul.c
index ca871d90a..6109da91e 100644
--- a/src/epx/relic_ep4_mul.c
+++ b/src/epx/relic_ep4_mul.c
@@ -41,10 +41,11 @@
 #if defined(EP_ENDOM)
 
 static void ep4_mul_glv_imp(ep4_t r, const ep4_t p, const bn_t k) {
-	int sign, i, j, l, _l[8];
+	int sign, i, j;
 	bn_t n, _k[8], u, v;
 	int8_t naf[8][RLC_FP_BITS + 1];
 	ep4_t q[8];
+	size_t l, _l[8];
 
 	bn_null(n);
 	bn_null(u);
@@ -131,9 +132,10 @@ static void ep4_mul_glv_imp(ep4_t r, const ep4_t p, const bn_t k) {
 #endif /* EP_ENDOM */
 
 static void ep4_mul_naf_imp(ep4_t r, const ep4_t p, const bn_t k) {
-	int l, i, n;
+	int i, n;
 	int8_t naf[RLC_FP_BITS + 1];
 	ep4_t t[1 << (EP_WIDTH - 2)];
+	size_t l;
 
 	RLC_TRY {
 		/* Prepare the precomputation table. */
@@ -229,8 +231,8 @@ void ep4_mul_basic(ep4_t r, const ep4_t p, const bn_t k) {
 
 void ep4_mul_slide(ep4_t r, const ep4_t p, const bn_t k) {
 	ep4_t t[1 << (EP_WIDTH - 1)], q;
-	int i, j, l;
 	uint8_t win[RLC_FP_BITS + 1];
+	size_t l;
 
 	ep4_null(q);
 
@@ -240,7 +242,7 @@ void ep4_mul_slide(ep4_t r, const ep4_t p, const bn_t k) {
 	}
 
 	RLC_TRY {
-		for (i = 0; i < (1 << (EP_WIDTH - 1)); i ++) {
+		for (size_t i = 0; i < (1 << (EP_WIDTH - 1)); i ++) {
 			ep4_null(t[i]);
 			ep4_new(t[i]);
 		}
@@ -255,7 +257,7 @@ void ep4_mul_slide(ep4_t r, const ep4_t p, const bn_t k) {
 #endif
 
 		/* Create table. */
-		for (i = 1; i < (1 << (EP_WIDTH - 1)); i++) {
+		for (size_t i = 1; i < (1 << (EP_WIDTH - 1)); i++) {
 			ep4_add(t[i], t[i - 1], q);
 		}
 
@@ -266,11 +268,11 @@ void ep4_mul_slide(ep4_t r, const ep4_t p, const bn_t k) {
 		ep4_set_infty(q);
 		l = RLC_FP_BITS + 1;
 		bn_rec_slw(win, &l, k, EP_WIDTH);
-		for (i = 0; i < l; i++) {
+		for (size_t i = 0; i < l; i++) {
 			if (win[i] == 0) {
 				ep4_dbl(q, q);
 			} else {
-				for (j = 0; j < util_bits_dig(win[i]); j++) {
+				for (size_t j = 0; j < util_bits_dig(win[i]); j++) {
 					ep4_dbl(q, q);
 				}
 				ep4_add(q, q, t[win[i] >> 1]);
@@ -286,7 +288,7 @@ void ep4_mul_slide(ep4_t r, const ep4_t p, const bn_t k) {
 		RLC_THROW(ERR_CAUGHT);
 	}
 	RLC_FINALLY {
-		for (i = 0; i < (1 << (EP_WIDTH - 1)); i++) {
+		for (size_t i = 0; i < (1 << (EP_WIDTH - 1)); i++) {
 			ep4_free(t[i]);
 		}
 		ep4_free(q);
diff --git a/src/epx/relic_ep4_mul_fix.c b/src/epx/relic_ep4_mul_fix.c
index c9b7c20af..0f54510b7 100644
--- a/src/epx/relic_ep4_mul_fix.c
+++ b/src/epx/relic_ep4_mul_fix.c
@@ -45,8 +45,6 @@
  * @param[in] p					- the point to multiply.
  */
 static void ep4_mul_pre_ordin(ep4_t *t, const ep4_t p) {
-	int i;
-
 	ep4_dbl(t[0], p);
 #if defined(EP_MIXED)
 	ep4_norm(t[0], t[0]);
@@ -54,12 +52,12 @@ static void ep4_mul_pre_ordin(ep4_t *t, const ep4_t p) {
 
 #if EP_DEPTH > 2
 	ep4_add(t[1], t[0], p);
-	for (i = 2; i < (1 << (EP_DEPTH - 2)); i++) {
+	for (int i = 2; i < (1 << (EP_DEPTH - 2)); i++) {
 		ep4_add(t[i], t[i - 1], t[0]);
 	}
 
 #if defined(EP_MIXED)
-	for (i = 1; i < (1 << (EP_DEPTH - 2)); i++) {
+	for (int i = 1; i < (1 << (EP_DEPTH - 2)); i++) {
 		ep4_norm(t[i], t[i]);
 	}
 #endif
@@ -77,8 +75,9 @@ static void ep4_mul_pre_ordin(ep4_t *t, const ep4_t p) {
  * @param[in] k					- the integer.
  */
 static void ep4_mul_fix_ordin(ep4_t r, const ep4_t *table, const bn_t k) {
-	int len, i, n;
 	int8_t naf[2 * RLC_FP_BITS + 1], *t;
+	size_t len;
+	int n;
 
 	if (bn_is_zero(k)) {
 		ep4_set_infty(r);
@@ -91,7 +90,7 @@ static void ep4_mul_fix_ordin(ep4_t r, const ep4_t *table, const bn_t k) {
 
 	t = naf + len - 1;
 	ep4_set_infty(r);
-	for (i = len - 1; i >= 0; i--, t--) {
+	for (int i = len - 1; i >= 0; i--, t--) {
 		ep4_dbl(r, r);
 
 		n = *t;
diff --git a/src/epx/relic_ep4_mul_sim.c b/src/epx/relic_ep4_mul_sim.c
index fdc4cd579..0e0ae873e 100644
--- a/src/epx/relic_ep4_mul_sim.c
+++ b/src/epx/relic_ep4_mul_sim.c
@@ -52,10 +52,11 @@
  */
 static void ep4_mul_sim_plain(ep4_t r, const ep4_t p, const bn_t k,
 		const ep4_t q, const bn_t m, ep4_t *t) {
-	int i, l, l0, l1, n0, n1, w, gen;
+	int i, n0, n1, w, gen;
 	int8_t naf0[2 * RLC_FP_BITS + 1], naf1[2 * RLC_FP_BITS + 1], *_k, *_m;
 	ep4_t t0[1 << (EP_WIDTH - 2)];
 	ep4_t t1[1 << (EP_WIDTH - 2)];
+	size_t l, l0, l1;
 
 	RLC_TRY {
 		gen = (t == NULL ? 0 : 1);
@@ -177,7 +178,7 @@ void ep4_mul_sim_trick(ep4_t r, const ep4_t p, const bn_t k, const ep4_t q,
 	ep4_t t1[1 << (EP_WIDTH / 2)];
 	ep4_t t[1 << EP_WIDTH];
 	bn_t n;
-	int l0, l1, w = EP_WIDTH / 2;
+	size_t l0, l1, w = EP_WIDTH / 2;
 	uint8_t w0[2 * RLC_FP_BITS], w1[2 * RLC_FP_BITS];
 
 	bn_null(n);
@@ -293,8 +294,9 @@ void ep4_mul_sim_inter(ep4_t r, const ep4_t p, const bn_t k, const ep4_t q,
 void ep4_mul_sim_joint(ep4_t r, const ep4_t p, const bn_t k, const ep4_t q,
 		const bn_t m) {
 	ep4_t t[5];
-	int i, l, u_i, offset;
+	int i, u_i, offset;
 	int8_t jsf[4 * (RLC_FP_BITS + 1)];
+	size_t l;
 
 	if (bn_is_zero(k) || ep4_is_infty(p)) {
 		ep4_mul(r, q, m);
@@ -396,7 +398,7 @@ void ep4_mul_sim_gen(ep4_t r, const bn_t k, const ep4_t q, const bn_t m) {
 	}
 }
 
-void ep4_mul_sim_dig(ep4_t r, const ep4_t p[], const dig_t k[], int len) {
+void ep4_mul_sim_dig(ep4_t r, const ep4_t p[], const dig_t k[], size_t len) {
 	ep4_t t;
 	int max;
 
@@ -430,11 +432,12 @@ void ep4_mul_sim_dig(ep4_t r, const ep4_t p[], const dig_t k[], int len) {
 	}
 }
 
-void ep4_mul_sim_lot(ep4_t r, const ep4_t p[], const bn_t k[], int n) {
-	const int len = RLC_FP_BITS + 1;
-	int i, j, m, l, *_l = RLC_ALLOCA(int, 8 * n);
+void ep4_mul_sim_lot(ep4_t r, const ep4_t p[], const bn_t k[], size_t n) {
+	const size_t len = RLC_FP_BITS + 1;
+	int i, j, m;
 	bn_t _k[8], q, x;
 	int8_t *naf = RLC_ALLOCA(int8_t, 8 * n * len);
+	size_t l, *_l = RLC_ALLOCA(size_t, 8 * n);
 
 	bn_null(q);
 	bn_null(x);
diff --git a/src/epx/relic_ep4_util.c b/src/epx/relic_ep4_util.c
index 51b1dafe4..d7db36fe0 100644
--- a/src/epx/relic_ep4_util.c
+++ b/src/epx/relic_ep4_util.c
@@ -254,7 +254,7 @@ int ep4_size_bin(const ep4_t a, int pack) {
 	return size;
 }
 
-void ep4_read_bin(ep4_t a, const uint8_t *bin, int len) {
+void ep4_read_bin(ep4_t a, const uint8_t *bin, size_t len) {
 	if (len == 1) {
 		if (bin[0] == 0) {
 			ep4_set_infty(a);
@@ -288,7 +288,7 @@ void ep4_read_bin(ep4_t a, const uint8_t *bin, int len) {
 	}
 }
 
-void ep4_write_bin(uint8_t *bin, int len, const ep4_t a, int pack) {
+void ep4_write_bin(uint8_t *bin, size_t len, const ep4_t a, int pack) {
 	ep4_t t;
 
 	ep4_null(t);
diff --git a/src/fb/relic_fb_exp.c b/src/fb/relic_fb_exp.c
index 6b3e31461..6ecb5f04d 100644
--- a/src/fb/relic_fb_exp.c
+++ b/src/fb/relic_fb_exp.c
@@ -44,7 +44,7 @@
 #if FB_EXP == BASIC || !defined(STRIP)
 
 void fb_exp_basic(fb_t c, const fb_t a, const bn_t b) {
-	int i, l;
+	size_t l;
 	fb_t r;
 
 	if (bn_is_zero(b)) {
@@ -61,7 +61,7 @@ void fb_exp_basic(fb_t c, const fb_t a, const bn_t b) {
 
 		fb_copy(r, a);
 
-		for (i = l - 2; i >= 0; i--) {
+		for (int i = l - 2; i >= 0; i--) {
 			fb_sqr(r, r);
 			if (bn_get_bit(b, i)) {
 				fb_mul(r, r, a);
@@ -88,8 +88,8 @@ void fb_exp_basic(fb_t c, const fb_t a, const bn_t b) {
 
 void fb_exp_slide(fb_t c, const fb_t a, const bn_t b) {
 	fb_t t[1 << (FB_WIDTH - 1)], r;
-	int i, j, l;
 	uint8_t win[RLC_FB_BITS + 1];
+	size_t l;
 
 	fb_null(r);
 
@@ -100,12 +100,12 @@ void fb_exp_slide(fb_t c, const fb_t a, const bn_t b) {
 
 
 	/* Initialize table. */
-	for (i = 0; i < (1 << (FB_WIDTH - 1)); i++) {
+	for (size_t i = 0; i < (1 << (FB_WIDTH - 1)); i++) {
 		fb_null(t[i]);
 	}
 
 	RLC_TRY {
-		for (i = 0; i < (1 << (FB_WIDTH - 1)); i ++) {
+		for (size_t i = 0; i < (1 << (FB_WIDTH - 1)); i ++) {
 			fb_new(t[i]);
 		}
 		fb_new(r);
@@ -114,18 +114,18 @@ void fb_exp_slide(fb_t c, const fb_t a, const bn_t b) {
 		fb_sqr(r, a);
 
 		/* Create table. */
-		for (i = 1; i < 1 << (FB_WIDTH - 1); i++) {
+		for (size_t i = 1; i < 1 << (FB_WIDTH - 1); i++) {
 			fb_mul(t[i], t[i - 1], r);
 		}
 
 		fb_set_dig(r, 1);
 		l = RLC_FB_BITS + 1;
 		bn_rec_slw(win, &l, b, FB_WIDTH);
-		for (i = 0; i < l; i++) {
+		for (size_t i = 0; i < l; i++) {
 			if (win[i] == 0) {
 				fb_sqr(r, r);
 			} else {
-				for (j = 0; j < util_bits_dig(win[i]); j++) {
+				for (size_t j = 0; j < util_bits_dig(win[i]); j++) {
 					fb_sqr(r, r);
 				}
 				fb_mul(r, r, t[win[i] >> 1]);
@@ -142,7 +142,7 @@ void fb_exp_slide(fb_t c, const fb_t a, const bn_t b) {
 		RLC_THROW(ERR_CAUGHT);
 	}
 	RLC_FINALLY {
-		for (i = 0; i < (1 << (FB_WIDTH - 1)); i++) {
+		for (size_t i = 0; i < (1 << (FB_WIDTH - 1)); i++) {
 			fb_free(t[i]);
 		}
 		fb_free(r);
diff --git a/src/fb/relic_fb_util.c b/src/fb/relic_fb_util.c
index b576c8bab..d84eb292e 100644
--- a/src/fb/relic_fb_util.c
+++ b/src/fb/relic_fb_util.c
@@ -45,7 +45,7 @@
  * @param[in] radix				- the radix to check.
  * @return if radix is a valid radix.
  */
-static int valid_radix(int radix) {
+static int valid_radix(unsigned int radix) {
 	while (radix > 0) {
 		if (radix != 1 && radix % 2 == 1)
 			return 0;
@@ -60,7 +60,7 @@ static int valid_radix(int radix) {
  * @param[in] radix				- the valid radix.
  * @return the logarithm of the radix in basis two.
  */
-static int log_radix(int radix) {
+static int log_radix(unsigned int radix) {
 	int l = 0;
 
 	while (radix > 0) {
@@ -93,7 +93,7 @@ int fb_is_zero(const fb_t a) {
 	return !t;
 }
 
-int fb_get_bit(const fb_t a, int bit) {
+int fb_get_bit(const fb_t a, size_t bit) {
 	int d;
 
 	RLC_RIP(bit, d, bit);
@@ -101,7 +101,7 @@ int fb_get_bit(const fb_t a, int bit) {
 	return (a[d] >> bit) & 1;
 }
 
-void fb_set_bit(fb_t a, int bit, int value) {
+void fb_set_bit(fb_t a, size_t bit, int value) {
 	int d;
 	dig_t mask;
 
@@ -116,7 +116,7 @@ void fb_set_bit(fb_t a, int bit, int value) {
 	}
 }
 
-int fb_bits(const fb_t a) {
+size_t fb_bits(const fb_t a) {
 	int i = RLC_FB_DIGS - 1;
 
 	while (i >= 0 && a[i] == 0) {
@@ -136,7 +136,7 @@ void fb_set_dig(fb_t c, dig_t a) {
 }
 
 void fb_rand(fb_t a) {
-	int bits, digits;
+	size_t bits, digits;
 
 	rand_bytes((uint8_t *)a, RLC_FB_DIGS * sizeof(dig_t));
 
@@ -148,11 +148,9 @@ void fb_rand(fb_t a) {
 }
 
 void fb_print(const fb_t a) {
-	int i;
-
 	/* Suppress possible unused parameter warning. */
 	(void)a;
-	for (i = RLC_FB_DIGS - 1; i > 0; i--) {
+	for (int i = RLC_FB_DIGS - 1; i > 0; i--) {
 		util_print_dig(a[i], 1);
 		util_print(" ");
 	}
@@ -160,9 +158,9 @@ void fb_print(const fb_t a) {
 	util_print("\n");
 }
 
-int fb_size_str(const fb_t a, int radix) {
+size_t fb_size_str(const fb_t a, unsigned int radix) {
 	bn_t t;
-	int digits = 0;
+	size_t digits = 0;
 
 	bn_null(t);
 
@@ -188,7 +186,7 @@ int fb_size_str(const fb_t a, int radix) {
 	return digits;
 }
 
-void fb_read_str(fb_t a, const char *str, int len, int radix) {
+void fb_read_str(fb_t a, const char *str, size_t len, unsigned int radix) {
 	bn_t t;
 
 	bn_null(t);
@@ -217,7 +215,7 @@ void fb_read_str(fb_t a, const char *str, int len, int radix) {
 	}
 }
 
-void fb_write_str(char *str, int len, const fb_t a, int radix) {
+void fb_write_str(char *str, size_t len, const fb_t a, unsigned int radix) {
 	fb_t t;
 	int d, l, i, j;
 	char c;
@@ -276,7 +274,7 @@ void fb_write_str(char *str, int len, const fb_t a, int radix) {
 	}
 }
 
-void fb_read_bin(fb_t a, const uint8_t *bin, int len) {
+void fb_read_bin(fb_t a, const uint8_t *bin, size_t len) {
 	bn_t t;
 
 	bn_null(t);
@@ -301,7 +299,7 @@ void fb_read_bin(fb_t a, const uint8_t *bin, int len) {
 	}
 }
 
-void fb_write_bin(uint8_t *bin, int len, const fb_t a) {
+void fb_write_bin(uint8_t *bin, size_t len, const fb_t a) {
 	bn_t t;
 
 	bn_null(t);
diff --git a/src/fp/relic_fp_exp.c b/src/fp/relic_fp_exp.c
index 54cc11cac..9290689a1 100644
--- a/src/fp/relic_fp_exp.c
+++ b/src/fp/relic_fp_exp.c
@@ -39,7 +39,7 @@
 #if FP_EXP == BASIC || !defined(STRIP)
 
 void fp_exp_basic(fp_t c, const fp_t a, const bn_t b) {
-	int i, l;
+	size_t l;
 	fp_t r;
 
 	fp_null(r);
@@ -56,7 +56,7 @@ void fp_exp_basic(fp_t c, const fp_t a, const bn_t b) {
 
 		fp_copy(r, a);
 
-		for (i = l - 2; i >= 0; i--) {
+		for (int i = l - 2; i >= 0; i--) {
 			fp_sqr(r, r);
 			if (bn_get_bit(b, i)) {
 				fp_mul(r, r, a);
@@ -83,8 +83,8 @@ void fp_exp_basic(fp_t c, const fp_t a, const bn_t b) {
 
 void fp_exp_slide(fp_t c, const fp_t a, const bn_t b) {
 	fp_t t[1 << (FP_WIDTH - 1)], r;
-	int i, j, l;
 	uint8_t win[RLC_FP_BITS + 1];
+	size_t l;
 
 	fp_null(r);
 
@@ -95,12 +95,12 @@ void fp_exp_slide(fp_t c, const fp_t a, const bn_t b) {
 
 
 	/* Initialize table. */
-	for (i = 0; i < (1 << (FP_WIDTH - 1)); i++) {
+	for (size_t i = 0; i < (1 << (FP_WIDTH - 1)); i++) {
 		fp_null(t[i]);
 	}
 
 	RLC_TRY {
-		for (i = 0; i < (1 << (FP_WIDTH - 1)); i ++) {
+		for (size_t i = 0; i < (1 << (FP_WIDTH - 1)); i ++) {
 			fp_new(t[i]);
 		}
 		fp_new(r);
@@ -109,18 +109,18 @@ void fp_exp_slide(fp_t c, const fp_t a, const bn_t b) {
 		fp_sqr(r, a);
 
 		/* Create table. */
-		for (i = 1; i < 1 << (FP_WIDTH - 1); i++) {
+		for (size_t i = 1; i < 1 << (FP_WIDTH - 1); i++) {
 			fp_mul(t[i], t[i - 1], r);
 		}
 
 		fp_set_dig(r, 1);
 		l = RLC_FP_BITS + 1;
 		bn_rec_slw(win, &l, b, FP_WIDTH);
-		for (i = 0; i < l; i++) {
+		for (size_t i = 0; i < l; i++) {
 			if (win[i] == 0) {
 				fp_sqr(r, r);
 			} else {
-				for (j = 0; j < util_bits_dig(win[i]); j++) {
+				for (size_t j = 0; j < util_bits_dig(win[i]); j++) {
 					fp_sqr(r, r);
 				}
 				fp_mul(r, r, t[win[i] >> 1]);
@@ -137,7 +137,7 @@ void fp_exp_slide(fp_t c, const fp_t a, const bn_t b) {
 		RLC_THROW(ERR_CAUGHT);
 	}
 	RLC_FINALLY {
-		for (i = 0; i < (1 << (FP_WIDTH - 1)); i++) {
+		for (size_t i = 0; i < (1 << (FP_WIDTH - 1)); i++) {
 			fp_free(t[i]);
 		}
 		fp_free(r);
diff --git a/src/fp/relic_fp_prime.c b/src/fp/relic_fp_prime.c
index 7cbdbcb29..1dbbf634d 100644
--- a/src/fp/relic_fp_prime.c
+++ b/src/fp/relic_fp_prime.c
@@ -296,7 +296,7 @@ void fp_prime_set_dense(const bn_t p) {
 void fp_prime_set_pairf(const bn_t x, int pairf) {
 	bn_t p, t0, t1;
 	ctx_t *ctx = core_get();
-	int len = bn_bits(x) + 1;
+	size_t len = bn_bits(x) + 1;
 	int8_t s[RLC_FP_BITS + 1];
 
 	bn_null(p);
@@ -459,7 +459,7 @@ void fp_prime_set_pairf(const bn_t x, int pairf) {
 	}
 }
 
-void fp_prime_set_pmers(const int *f, int len) {
+void fp_prime_set_pmers(const int *f, size_t len) {
 	bn_t p, t;
 
 	bn_null(p);
diff --git a/src/fp/relic_fp_util.c b/src/fp/relic_fp_util.c
index 84d2c50ac..2ee180021 100644
--- a/src/fp/relic_fp_util.c
+++ b/src/fp/relic_fp_util.c
@@ -62,7 +62,7 @@ int fp_is_even(const fp_t a) {
 	return 0;
 }
 
-int fp_get_bit(const fp_t a, int bit) {
+int fp_get_bit(const fp_t a, size_t bit) {
 	int d;
 
 	RLC_RIP(bit, d, bit);
@@ -70,7 +70,7 @@ int fp_get_bit(const fp_t a, int bit) {
 	return (a[d] >> bit) & 1;
 }
 
-void fp_set_bit(fp_t a, int bit, int value) {
+void fp_set_bit(fp_t a, size_t bit, int value) {
 	int d;
 	dig_t mask;
 
@@ -85,7 +85,7 @@ void fp_set_bit(fp_t a, int bit, int value) {
 	}
 }
 
-int fp_bits(const fp_t a) {
+size_t fp_bits(const fp_t a) {
 	int i = RLC_FP_DIGS - 1;
 
 	while (i >= 0 && a[i] == 0) {
@@ -157,9 +157,9 @@ void fp_print(const fp_t a) {
 	}
 }
 
-int fp_size_str(const fp_t a, int radix) {
+size_t fp_size_str(const fp_t a, unsigned int radix) {
 	bn_t t;
-	int digits = 0;
+	size_t digits = 0;
 
 	bn_null(t);
 
@@ -179,7 +179,7 @@ int fp_size_str(const fp_t a, int radix) {
 	return digits;
 }
 
-void fp_read_str(fp_t a, const char *str, int len, int radix) {
+void fp_read_str(fp_t a, const char *str, size_t len, unsigned int radix) {
 	bn_t t;
 
 	bn_null(t);
@@ -208,7 +208,7 @@ void fp_read_str(fp_t a, const char *str, int len, int radix) {
 	}
 }
 
-void fp_write_str(char *str, int len, const fp_t a, int radix) {
+void fp_write_str(char *str, size_t len, const fp_t a, unsigned int radix) {
 	bn_t t;
 
 	bn_null(t);
@@ -227,7 +227,7 @@ void fp_write_str(char *str, int len, const fp_t a, int radix) {
 	}
 }
 
-void fp_read_bin(fp_t a, const uint8_t *bin, int len) {
+void fp_read_bin(fp_t a, const uint8_t *bin, size_t len) {
 	bn_t t;
 
 	bn_null(t);
@@ -253,7 +253,7 @@ void fp_read_bin(fp_t a, const uint8_t *bin, int len) {
 				} else {
 					fp_prime_conv(a, t);
 				}
-			}	
+			}
 		}
 	}
 	RLC_CATCH_ANY {
@@ -264,7 +264,7 @@ void fp_read_bin(fp_t a, const uint8_t *bin, int len) {
 	}
 }
 
-void fp_write_bin(uint8_t *bin, int len, const fp_t a) {
+void fp_write_bin(uint8_t *bin, size_t len, const fp_t a) {
 	bn_t t;
 
 	bn_null(t);
diff --git a/src/fpx/relic_fpx_cyc.c b/src/fpx/relic_fpx_cyc.c
index 459c195d9..5d54a0fb1 100644
--- a/src/fpx/relic_fpx_cyc.c
+++ b/src/fpx/relic_fpx_cyc.c
@@ -83,8 +83,8 @@ int fp2_test_cyc(const fp2_t a) {
 
 void fp2_exp_cyc(fp2_t c, const fp2_t a, const bn_t b) {
 	fp2_t r, s, t[1 << (FP_WIDTH - 2)];
-	int i, l;
 	int8_t naf[RLC_FP_BITS + 1], *k;
+	size_t l;
 
 	if (bn_is_zero(b)) {
 		return fp2_set_dig(c, 1);
@@ -96,7 +96,7 @@ void fp2_exp_cyc(fp2_t c, const fp2_t a, const bn_t b) {
 	RLC_TRY {
 		fp2_new(r);
 		fp2_new(s);
-		for (i = 0; i < (1 << (FP_WIDTH - 2)); i ++) {
+		for (int i = 0; i < (1 << (FP_WIDTH - 2)); i ++) {
 			fp2_null(t[i]);
 			fp2_new(t[i]);
 		}
@@ -116,7 +116,7 @@ void fp2_exp_cyc(fp2_t c, const fp2_t a, const bn_t b) {
 
 		k = naf + l - 1;
 
-		for (i = l - 1; i >= 0; i--, k--) {
+		for (int i = l - 1; i >= 0; i--, k--) {
 			fp2_sqr(r, r);
 
 			if (*k > 0) {
@@ -140,7 +140,7 @@ void fp2_exp_cyc(fp2_t c, const fp2_t a, const bn_t b) {
 	RLC_FINALLY {
 		fp2_free(r);
 		fp2_free(s);
-		for (i = 0; i < (1 << (FP_WIDTH - 2)); i++) {
+		for (int i = 0; i < (1 << (FP_WIDTH - 2)); i++) {
 			fp2_free(t[i]);
 		}
 	}
@@ -193,8 +193,8 @@ int fp8_test_cyc(const fp8_t a) {
 
 void fp8_exp_cyc(fp8_t c, const fp8_t a, const bn_t b) {
 	fp8_t r, s, t[1 << (FP_WIDTH - 2)];
-	int i, l;
 	int8_t naf[RLC_FP_BITS + 1], *k;
+	size_t l;
 
 	if (bn_is_zero(b)) {
 		return fp8_set_dig(c, 1);
@@ -206,7 +206,7 @@ void fp8_exp_cyc(fp8_t c, const fp8_t a, const bn_t b) {
 	RLC_TRY {
 		fp8_new(r);
 		fp8_new(s);
-		for (i = 0; i < (1 << (FP_WIDTH - 2)); i ++) {
+		for (int i = 0; i < (1 << (FP_WIDTH - 2)); i ++) {
 			fp8_null(t[i]);
 			fp8_new(t[i]);
 		}
@@ -226,7 +226,7 @@ void fp8_exp_cyc(fp8_t c, const fp8_t a, const bn_t b) {
 
 		k = naf + l - 1;
 
-		for (i = l - 1; i >= 0; i--, k--) {
+		for (int i = l - 1; i >= 0; i--, k--) {
 			fp8_sqr_cyc(r, r);
 
 			if (*k > 0) {
@@ -250,7 +250,7 @@ void fp8_exp_cyc(fp8_t c, const fp8_t a, const bn_t b) {
 	RLC_FINALLY {
 		fp8_free(r);
 		fp8_free(s);
-		for (i = 0; i < (1 << (FP_WIDTH - 2)); i++) {
+		for (int i = 0; i < (1 << (FP_WIDTH - 2)); i++) {
 			fp8_free(t[i]);
 		}
 	}
@@ -470,14 +470,14 @@ void fp12_back_cyc_sim(fp12_t c[], const fp12_t a[], int n) {
 }
 
 void fp12_exp_cyc(fp12_t c, const fp12_t a, const bn_t b) {
-	int i, j, k, l, w = bn_ham(b);
+	size_t j, k, l, w = bn_ham(b);
 
 	if (bn_is_zero(b)) {
 		return fp12_set_dig(c, 1);
 	}
 
 	if ((bn_bits(b) > RLC_DIG) && ((w << 3) > bn_bits(b))) {
-		int _l[4];
+		size_t _l[4];
 		int8_t naf[4][RLC_FP_BITS + 1];
 		fp12_t t[4];
 		bn_t _b[4], n, u;
@@ -488,7 +488,7 @@ void fp12_exp_cyc(fp12_t c, const fp12_t a, const bn_t b) {
 		RLC_TRY {
 			bn_new(n);
 			bn_new(u);
-			for (i = 0; i < 4; i++) {
+			for (int i = 0; i < 4; i++) {
 				bn_null(_b[i]);
 				bn_new(_b[i]);
 				fp12_null(t[i]);
@@ -506,7 +506,7 @@ void fp12_exp_cyc(fp12_t c, const fp12_t a, const bn_t b) {
 				fp12_frb(t[3], t[2], 1);
 
 				l = 0;
-				for (i = 0; i < 4; i++) {
+				for (int i = 0; i < 4; i++) {
 					if (bn_sign(_b[i]) == RLC_NEG) {
 						fp12_inv_cyc(t[i], t[i]);
 					}
@@ -516,9 +516,9 @@ void fp12_exp_cyc(fp12_t c, const fp12_t a, const bn_t b) {
 				}
 
 				fp12_set_dig(c, 1);
-				for (i = l - 1; i >= 0; i--) {
+				for (int i = l - 1; i >= 0; i--) {
 					fp12_sqr_cyc(c, c);
-					for (j = 0; j < 4; j++) {
+					for (int j = 0; j < 4; j++) {
 						if (naf[j][i] > 0) {
 							fp12_mul(c, c, t[j]);
 						}
@@ -532,7 +532,7 @@ void fp12_exp_cyc(fp12_t c, const fp12_t a, const bn_t b) {
 			} else {
 				fp12_copy(t[0], a);
 
-				for (i = bn_bits(b) - 2; i >= 0; i--) {
+				for (int i = bn_bits(b) - 2; i >= 0; i--) {
 					fp12_sqr_cyc(t[0], t[0]);
 					if (bn_get_bit(b, i)) {
 						fp12_mul(t[0], t[0], a);
@@ -551,7 +551,7 @@ void fp12_exp_cyc(fp12_t c, const fp12_t a, const bn_t b) {
 		RLC_FINALLY {
 			bn_free(n);
 			bn_free(u);
-			for (i = 0; i < 4; i++) {
+			for (int i = 0; i < 4; i++) {
 				bn_free(_b[i]);
 				fp12_free(t[i]);
 			}
@@ -565,7 +565,7 @@ void fp12_exp_cyc(fp12_t c, const fp12_t a, const bn_t b) {
 			if (u == NULL) {
 				RLC_THROW(ERR_NO_MEMORY);
 			}
-			for (i = 0; i < w; i++) {
+			for (int i = 0; i < w; i++) {
 				fp12_null(u[i]);
 				fp12_new(u[i]);
 			}
@@ -573,7 +573,7 @@ void fp12_exp_cyc(fp12_t c, const fp12_t a, const bn_t b) {
 
 			j = 0;
 			fp12_copy(t, a);
-			for (i = 1; i < bn_bits(b); i++) {
+			for (size_t i = 1; i < bn_bits(b); i++) {
 				fp12_sqr_pck(t, t);
 				if (bn_get_bit(b, i)) {
 					fp12_copy(u[j++], t);
@@ -596,7 +596,7 @@ void fp12_exp_cyc(fp12_t c, const fp12_t a, const bn_t b) {
 				fp12_copy(c, u[0]);
 			}
 
-			for (i = j; i < k; i++) {
+			for (size_t i = j; i < k; i++) {
 				fp12_mul(c, c, u[i]);
 			}
 
@@ -608,7 +608,7 @@ void fp12_exp_cyc(fp12_t c, const fp12_t a, const bn_t b) {
 			RLC_THROW(ERR_CAUGHT);
 		}
 		RLC_FINALLY {
-			for (i = 0; i < w; i++) {
+			for (size_t i = 0; i < w; i++) {
 				fp12_free(u[i]);
 			}
 			fp12_free(t);
@@ -618,10 +618,11 @@ void fp12_exp_cyc(fp12_t c, const fp12_t a, const bn_t b) {
 }
 
 void fp2_exp_cyc_sim(fp2_t e, const fp2_t a, const bn_t b, const fp2_t c, const bn_t d) {
-	int i, l, n0, n1, l0, l1;
+	int n0, n1;
 	int8_t naf0[RLC_FP_BITS + 1], naf1[RLC_FP_BITS + 1], *_k, *_m;
 	fp2_t r, t0[1 << (EP_WIDTH - 2)];
 	fp2_t s, t1[1 << (EP_WIDTH - 2)];
+	size_t l, l0, l1;
 
 	if (bn_is_zero(b)) {
 		return fp2_exp_cyc(e, c, d);
@@ -637,7 +638,7 @@ void fp2_exp_cyc_sim(fp2_t e, const fp2_t a, const bn_t b, const fp2_t c, const
 	RLC_TRY {
 		fp2_new(r);
 		fp2_new(s);
-		for (i = 0; i < (1 << (FP_WIDTH - 2)); i ++) {
+		for (int i = 0; i < (1 << (FP_WIDTH - 2)); i ++) {
 			fp2_null(t0[i]);
 			fp2_null(t1[i]);
 			fp2_new(t0[i]);
@@ -666,12 +667,12 @@ void fp2_exp_cyc_sim(fp2_t e, const fp2_t a, const bn_t b, const fp2_t c, const
 
 		l = RLC_MAX(l0, l1);
 		if (bn_sign(b) == RLC_NEG) {
-			for (i = 0; i < l0; i++) {
+			for (size_t i = 0; i < l0; i++) {
 				naf0[i] = -naf0[i];
 			}
 		}
 		if (bn_sign(d) == RLC_NEG) {
-			for (i = 0; i < l1; i++) {
+			for (size_t i = 0; i < l1; i++) {
 				naf1[i] = -naf1[i];
 			}
 		}
@@ -680,7 +681,7 @@ void fp2_exp_cyc_sim(fp2_t e, const fp2_t a, const bn_t b, const fp2_t c, const
 		_m = naf1 + l - 1;
 
 		fp2_set_dig(r, 1);
-		for (i = l - 1; i >= 0; i--, _k--, _m--) {
+		for (int i = l - 1; i >= 0; i--, _k--, _m--) {
 			fp2_sqr(r, r);
 
 			n0 = *_k;
@@ -710,7 +711,7 @@ void fp2_exp_cyc_sim(fp2_t e, const fp2_t a, const bn_t b, const fp2_t c, const
 	RLC_FINALLY {
 		fp2_free(r);
 		fp2_free(s);
-		for (i = 0; i < (1 << (FP_WIDTH - 2)); i++) {
+		for (int i = 0; i < (1 << (FP_WIDTH - 2)); i++) {
 			fp2_free(t0[i]);
 			fp2_free(t1[i]);
 		}
@@ -820,8 +821,9 @@ void fp12_exp_cyc_sim(fp12_t e, const fp12_t a, const bn_t b, const fp12_t c, co
 	}
 }
 
-void fp12_exp_cyc_sps(fp12_t c, const fp12_t a, const int *b, int len, int sign) {
-	int i, j, k, w = len;
+void fp12_exp_cyc_sps(fp12_t c, const fp12_t a, const int *b, size_t len,
+		int sign) {
+	size_t i, j, k, w = len;
     fp12_t t, *u = RLC_ALLOCA(fp12_t, w);
 
 	if (len == 0) {
@@ -1097,7 +1099,7 @@ void fp24_back_cyc_sim(fp24_t c[], const fp24_t a[], int n) {
 }
 
 void fp24_exp_cyc(fp24_t c, const fp24_t a, const bn_t b) {
-	int i, j, k, w = bn_ham(b);
+	size_t j, k, w = bn_ham(b);
 
 	if (bn_is_zero(b)) {
 		fp24_set_dig(c, 1);
@@ -1105,7 +1107,7 @@ void fp24_exp_cyc(fp24_t c, const fp24_t a, const bn_t b) {
 	}
 
 	if ((bn_bits(b) > RLC_DIG) && ((w << 3) > bn_bits(b))) {
-		int l, _l[8];
+		size_t l, _l[8];
 		int8_t naf[8][RLC_FP_BITS + 1];
 		fp24_t t[8];
 		bn_t _b[8], n, x;
@@ -1116,7 +1118,7 @@ void fp24_exp_cyc(fp24_t c, const fp24_t a, const bn_t b) {
 		RLC_TRY {
 			bn_new(n);
 			bn_new(x);
-			for (i = 0; i < 8; i++) {
+			for (int i = 0; i < 8; i++) {
 				bn_null(_b[i]);
 				bn_new(_b[i]);
 				fp24_null(t[i]);
@@ -1131,7 +1133,7 @@ void fp24_exp_cyc(fp24_t c, const fp24_t a, const bn_t b) {
 				l = 0;
 
 				fp24_copy(t[0], a);
-				for (i = 0; i < 8; i++) {
+				for (int i = 0; i < 8; i++) {
 					_l[i] = RLC_FP_BITS + 1;
 					bn_rec_naf(naf[i], &_l[i], _b[i], 2);
 					l = RLC_MAX(l, _l[i]);
@@ -1140,16 +1142,16 @@ void fp24_exp_cyc(fp24_t c, const fp24_t a, const bn_t b) {
 					}
 				}
 
-				for (i = 0; i < 8; i++) {
+				for (int i = 0; i < 8; i++) {
 					if (bn_sign(_b[i]) == RLC_NEG) {
 						fp24_inv_cyc(t[i], t[i]);
 					}
 				}
 
 				fp24_set_dig(c, 1);
-				for (i = l - 1; i >= 0; i--) {
+				for (int i = l - 1; i >= 0; i--) {
 					fp24_sqr_cyc(c, c);
-					for (j = 0; j < 8; j++) {
+					for (int j = 0; j < 8; j++) {
 						if (naf[j][i] > 0) {
 							fp24_mul(c, c, t[j]);
 						}
@@ -1163,7 +1165,7 @@ void fp24_exp_cyc(fp24_t c, const fp24_t a, const bn_t b) {
 			} else {
 				fp24_copy(t[0], a);
 
-				for (i = bn_bits(b) - 2; i >= 0; i--) {
+				for (int i = bn_bits(b) - 2; i >= 0; i--) {
 					fp24_sqr_cyc(t[0], t[0]);
 					if (bn_get_bit(b, i)) {
 						fp24_mul(t[0], t[0], a);
@@ -1182,7 +1184,7 @@ void fp24_exp_cyc(fp24_t c, const fp24_t a, const bn_t b) {
 		RLC_FINALLY {
 			bn_free(n);
 			bn_free(x);
-			for (i = 0; i < 8; i++) {
+			for (int i = 0; i < 8; i++) {
 				bn_free(_b[i]);
 				fp24_free(t[i]);
 			}
@@ -1196,7 +1198,7 @@ void fp24_exp_cyc(fp24_t c, const fp24_t a, const bn_t b) {
 			if (u == NULL) {
 				RLC_THROW(ERR_NO_MEMORY);
 			}
-			for (i = 0; i < w; i++) {
+			for (size_t i = 0; i < w; i++) {
 				fp24_null(u[i]);
 				fp24_new(u[i]);
 			}
@@ -1204,7 +1206,7 @@ void fp24_exp_cyc(fp24_t c, const fp24_t a, const bn_t b) {
 
 			j = 0;
 			fp24_copy(t, a);
-			for (i = 1; i < bn_bits(b); i++) {
+			for (size_t i = 1; i < bn_bits(b); i++) {
 				fp24_sqr_pck(t, t);
 				if (bn_get_bit(b, i)) {
 					fp24_copy(u[j++], t);
@@ -1227,7 +1229,7 @@ void fp24_exp_cyc(fp24_t c, const fp24_t a, const bn_t b) {
 				fp24_copy(c, u[0]);
 			}
 
-			for (i = j; i < k; i++) {
+			for (size_t i = j; i < k; i++) {
 				fp24_mul(c, c, u[i]);
 			}
 
@@ -1239,7 +1241,7 @@ void fp24_exp_cyc(fp24_t c, const fp24_t a, const bn_t b) {
 			RLC_THROW(ERR_CAUGHT);
 		}
 		RLC_FINALLY {
-			for (i = 0; i < w; i++) {
+			for (size_t i = 0; i < w; i++) {
 				fp24_free(u[i]);
 			}
 			fp24_free(t);
@@ -1249,10 +1251,11 @@ void fp24_exp_cyc(fp24_t c, const fp24_t a, const bn_t b) {
 }
 
 void fp24_exp_cyc_sim(fp24_t e, const fp24_t a, const bn_t b, const fp24_t c, const bn_t d) {
-	int i, l, n0, n1, l0, l1;
+	int n0, n1;
 	int8_t naf0[RLC_FP_BITS + 1], naf1[RLC_FP_BITS + 1], *_k, *_m;
 	fp24_t r, t0[1 << (EP_WIDTH - 2)];
 	fp24_t s, t1[1 << (EP_WIDTH - 2)];
+	size_t l, l0, l1;
 
 	if (bn_is_zero(b)) {
 		return fp24_exp_cyc(e, c, d);
@@ -1268,7 +1271,7 @@ void fp24_exp_cyc_sim(fp24_t e, const fp24_t a, const bn_t b, const fp24_t c, co
 	RLC_TRY {
 		fp24_new(r);
 		fp24_new(s);
-		for (i = 0; i < (1 << (FP_WIDTH - 2)); i ++) {
+		for (int i = 0; i < (1 << (FP_WIDTH - 2)); i ++) {
 			fp24_null(t0[i]);
 			fp24_null(t1[i]);
 			fp24_new(t0[i]);
@@ -1297,12 +1300,12 @@ void fp24_exp_cyc_sim(fp24_t e, const fp24_t a, const bn_t b, const fp24_t c, co
 
 		l = RLC_MAX(l0, l1);
 		if (bn_sign(b) == RLC_NEG) {
-			for (i = 0; i < l0; i++) {
+			for (size_t i = 0; i < l0; i++) {
 				naf0[i] = -naf0[i];
 			}
 		}
 		if (bn_sign(d) == RLC_NEG) {
-			for (i = 0; i < l1; i++) {
+			for (size_t i = 0; i < l1; i++) {
 				naf1[i] = -naf1[i];
 			}
 		}
@@ -1311,7 +1314,7 @@ void fp24_exp_cyc_sim(fp24_t e, const fp24_t a, const bn_t b, const fp24_t c, co
 		_m = naf1 + l - 1;
 
 		fp24_set_dig(r, 1);
-		for (i = l - 1; i >= 0; i--, _k--, _m--) {
+		for (int i = l - 1; i >= 0; i--, _k--, _m--) {
 			fp24_sqr(r, r);
 
 			n0 = *_k;
@@ -1341,15 +1344,16 @@ void fp24_exp_cyc_sim(fp24_t e, const fp24_t a, const bn_t b, const fp24_t c, co
 	RLC_FINALLY {
 		fp24_free(r);
 		fp24_free(s);
-		for (i = 0; i < (1 << (FP_WIDTH - 2)); i++) {
+		for (int i = 0; i < (1 << (FP_WIDTH - 2)); i++) {
 			fp24_free(t0[i]);
 			fp24_free(t1[i]);
 		}
 	}
 }
 
-void fp24_exp_cyc_sps(fp24_t c, const fp24_t a, const int *b, int len, int sign) {
-	int i, j, k, w = len;
+void fp24_exp_cyc_sps(fp24_t c, const fp24_t a, const int *b, size_t len,
+		int sign) {
+	size_t i, j, k, w = len;
     fp24_t t, *u = RLC_ALLOCA(fp24_t, w);
 
 	if (len == 0) {
@@ -1719,8 +1723,9 @@ void fp48_exp_cyc(fp48_t c, const fp48_t a, const bn_t b) {
 	}
 }
 
-void fp48_exp_cyc_sps(fp48_t c, const fp48_t a, const int *b, int len, int sign) {
-	int i, j, k, w = len;
+void fp48_exp_cyc_sps(fp48_t c, const fp48_t a, const int *b, size_t len,
+		int sign) {
+	size_t i, j, k, w = len;
     fp48_t t, *u = RLC_ALLOCA(fp48_t, w);
 
 	if (len == 0) {
@@ -2090,8 +2095,9 @@ void fp54_exp_cyc(fp54_t c, const fp54_t a, const bn_t b) {
 	}
 }
 
-void fp54_exp_cyc_sps(fp54_t c, const fp54_t a, const int *b, int len, int sign) {
-	int i, j, k, w = len;
+void fp54_exp_cyc_sps(fp54_t c, const fp54_t a, const int *b, size_t len,
+		int sign) {
+	size_t i, j, k, w = len;
     fp54_t t, *u = RLC_ALLOCA(fp54_t, w);
 
 	if (len == 0) {
diff --git a/src/fpx/relic_fpx_exp.c b/src/fpx/relic_fpx_exp.c
index 02d4a62c7..f586bdb8e 100644
--- a/src/fpx/relic_fpx_exp.c
+++ b/src/fpx/relic_fpx_exp.c
@@ -329,7 +329,7 @@ void fp12_exp_dig(fp12_t c, const fp12_t a, dig_t b) {
 	bn_t _b;
 	fp12_t t, v;
 	int8_t u, naf[RLC_DIG + 1];
-	int l;
+	size_t l;
 
 	if (b == 0) {
 		fp12_set_dig(c, 1);
@@ -461,7 +461,7 @@ void fp24_exp_dig(fp24_t c, const fp24_t a, dig_t b) {
 	bn_t _b;
 	fp24_t t, v;
 	int8_t u, naf[RLC_DIG + 1];
-	int l;
+	size_t l;
 
 	if (b == 0) {
 		fp24_set_dig(c, 1);
@@ -561,7 +561,7 @@ void fp48_exp_dig(fp48_t c, const fp48_t a, dig_t b) {
 	bn_t _b;
 	fp48_t t, v;
 	int8_t u, naf[RLC_DIG + 1];
-	int l;
+	size_t l;
 
 	if (b == 0) {
 		fp48_set_dig(c, 1);
@@ -657,7 +657,7 @@ void fp54_exp_dig(fp54_t c, const fp54_t a, dig_t b) {
 	bn_t _b;
 	fp54_t t, v;
 	int8_t u, naf[RLC_DIG + 1];
-	int l;
+	size_t l;
 
 	if (b == 0) {
 		fp54_set_dig(c, 1);
diff --git a/src/fpx/relic_fpx_util.c b/src/fpx/relic_fpx_util.c
index 7f0c9459a..168142bb6 100644
--- a/src/fpx/relic_fpx_util.c
+++ b/src/fpx/relic_fpx_util.c
@@ -72,7 +72,7 @@ int fp2_size_bin(fp2_t a, int pack) {
 	}
 }
 
-void fp2_read_bin(fp2_t a, const uint8_t *bin, int len) {
+void fp2_read_bin(fp2_t a, const uint8_t *bin, size_t len) {
 	if (len != RLC_FP_BYTES + 1 && len != 2 * RLC_FP_BYTES) {
 		RLC_THROW(ERR_NO_BUFFER);
 		return;
@@ -89,7 +89,7 @@ void fp2_read_bin(fp2_t a, const uint8_t *bin, int len) {
 	}
 }
 
-void fp2_write_bin(uint8_t *bin, int len, const fp2_t a, int pack) {
+void fp2_write_bin(uint8_t *bin, size_t len, const fp2_t a, int pack) {
 	fp2_t t;
 
 	fp2_null(t);
@@ -160,7 +160,7 @@ int fp3_size_bin(fp3_t a) {
 	return 3 * RLC_FP_BYTES;
 }
 
-void fp3_read_bin(fp3_t a, const uint8_t *bin, int len) {
+void fp3_read_bin(fp3_t a, const uint8_t *bin, size_t len) {
 	if (len != 3 * RLC_FP_BYTES) {
 		RLC_THROW(ERR_NO_BUFFER);
 		return;
@@ -170,7 +170,7 @@ void fp3_read_bin(fp3_t a, const uint8_t *bin, int len) {
 	fp_read_bin(a[2], bin + 2 * RLC_FP_BYTES, RLC_FP_BYTES);
 }
 
-void fp3_write_bin(uint8_t *bin, int len, const fp3_t a) {
+void fp3_write_bin(uint8_t *bin, size_t len, const fp3_t a) {
 	if (len != 3 * RLC_FP_BYTES) {
 		RLC_THROW(ERR_NO_BUFFER);
 		return;
@@ -214,7 +214,7 @@ int fp4_size_bin(fp4_t a) {
 	return 4 * RLC_FP_BYTES;
 }
 
-void fp4_read_bin(fp4_t a, const uint8_t *bin, int len) {
+void fp4_read_bin(fp4_t a, const uint8_t *bin, size_t len) {
 	if (len != 4 * RLC_FP_BYTES) {
 		RLC_THROW(ERR_NO_BUFFER);
 		return;
@@ -223,7 +223,7 @@ void fp4_read_bin(fp4_t a, const uint8_t *bin, int len) {
 	fp2_read_bin(a[1], bin + 2 * RLC_FP_BYTES, 2 * RLC_FP_BYTES);
 }
 
-void fp4_write_bin(uint8_t *bin, int len, const fp4_t a) {
+void fp4_write_bin(uint8_t *bin, size_t len, const fp4_t a) {
 	if (len != 4 * RLC_FP_BYTES) {
 		RLC_THROW(ERR_NO_BUFFER);
 		return;
@@ -269,7 +269,7 @@ int fp6_size_bin(fp6_t a) {
 	return 6 * RLC_FP_BYTES;
 }
 
-void fp6_read_bin(fp6_t a, const uint8_t *bin, int len) {
+void fp6_read_bin(fp6_t a, const uint8_t *bin, size_t len) {
 	if (len != 6 * RLC_FP_BYTES) {
 		RLC_THROW(ERR_NO_BUFFER);
 		return;
@@ -279,7 +279,7 @@ void fp6_read_bin(fp6_t a, const uint8_t *bin, int len) {
 	fp2_read_bin(a[2], bin + 4 * RLC_FP_BYTES, 2 * RLC_FP_BYTES);
 }
 
-void fp6_write_bin(uint8_t *bin, int len, const fp6_t a) {
+void fp6_write_bin(uint8_t *bin, size_t len, const fp6_t a) {
 	if (len != 6 * RLC_FP_BYTES) {
 		RLC_THROW(ERR_NO_BUFFER);
 		return;
@@ -331,7 +331,7 @@ int fp8_size_bin(fp8_t a, int pack) {
 	}
 }
 
-void fp8_read_bin(fp8_t a, const uint8_t *bin, int len) {
+void fp8_read_bin(fp8_t a, const uint8_t *bin, size_t len) {
 	if (len != 8 * RLC_FP_BYTES) {
 		RLC_THROW(ERR_NO_BUFFER);
 		return;
@@ -340,7 +340,7 @@ void fp8_read_bin(fp8_t a, const uint8_t *bin, int len) {
 	fp4_read_bin(a[1], bin + 4 * RLC_FP_BYTES, 4 * RLC_FP_BYTES);
 }
 
-void fp8_write_bin(uint8_t *bin, int len, const fp8_t a) {
+void fp8_write_bin(uint8_t *bin, size_t len, const fp8_t a) {
 	if (len != 8 * RLC_FP_BYTES) {
 		RLC_THROW(ERR_NO_BUFFER);
 		return;
@@ -386,7 +386,7 @@ int fp9_size_bin(fp9_t a) {
 	return 9 * RLC_FP_BYTES;
 }
 
-void fp9_read_bin(fp9_t a, const uint8_t *bin, int len) {
+void fp9_read_bin(fp9_t a, const uint8_t *bin, size_t len) {
 	if (len != 9 * RLC_FP_BYTES) {
 		RLC_THROW(ERR_NO_BUFFER);
 		return;
@@ -396,7 +396,7 @@ void fp9_read_bin(fp9_t a, const uint8_t *bin, int len) {
 	fp3_read_bin(a[2], bin + 6 * RLC_FP_BYTES, 3 * RLC_FP_BYTES);
 }
 
-void fp9_write_bin(uint8_t *bin, int len, const fp9_t a) {
+void fp9_write_bin(uint8_t *bin, size_t len, const fp9_t a) {
 	if (len != 9 * RLC_FP_BYTES) {
 		RLC_THROW(ERR_NO_BUFFER);
 		return;
@@ -448,7 +448,7 @@ int fp12_size_bin(fp12_t a, int pack) {
 	}
 }
 
-void fp12_read_bin(fp12_t a, const uint8_t *bin, int len) {
+void fp12_read_bin(fp12_t a, const uint8_t *bin, size_t len) {
 	if (len != 8 * RLC_FP_BYTES && len != 12 * RLC_FP_BYTES) {
 		RLC_THROW(ERR_NO_BUFFER);
 		return;
@@ -468,7 +468,7 @@ void fp12_read_bin(fp12_t a, const uint8_t *bin, int len) {
 	}
 }
 
-void fp12_write_bin(uint8_t *bin, int len, const fp12_t a, int pack) {
+void fp12_write_bin(uint8_t *bin, size_t len, const fp12_t a, int pack) {
 	fp12_t t;
 
 	fp12_null(t);
@@ -532,7 +532,7 @@ int fp18_size_bin(fp18_t a) {
 	return 18 * RLC_FP_BYTES;
 }
 
-void fp18_read_bin(fp18_t a, const uint8_t *bin, int len) {
+void fp18_read_bin(fp18_t a, const uint8_t *bin, size_t len) {
 	if (len != 18 * RLC_FP_BYTES) {
 		RLC_THROW(ERR_NO_BUFFER);
 		return;
@@ -541,7 +541,7 @@ void fp18_read_bin(fp18_t a, const uint8_t *bin, int len) {
 	fp9_read_bin(a[1], bin + 9 * RLC_FP_BYTES, 9 * RLC_FP_BYTES);
 }
 
-void fp18_write_bin(uint8_t *bin, int len, const fp18_t a) {
+void fp18_write_bin(uint8_t *bin, size_t len, const fp18_t a) {
 	if (len != 18 * RLC_FP_BYTES) {
 		RLC_THROW(ERR_NO_BUFFER);
 		return;
@@ -595,7 +595,7 @@ int fp24_size_bin(fp24_t a, int pack) {
 	}
 }
 
-void fp24_read_bin(fp24_t a, const uint8_t *bin, int len) {
+void fp24_read_bin(fp24_t a, const uint8_t *bin, size_t len) {
 	if (len != 16 * RLC_FP_BYTES && len != 24 * RLC_FP_BYTES) {
 		RLC_THROW(ERR_NO_BUFFER);
 		return;
@@ -616,7 +616,7 @@ void fp24_read_bin(fp24_t a, const uint8_t *bin, int len) {
 	}
 }
 
-void fp24_write_bin(uint8_t *bin, int len, const fp24_t a, int pack) {
+void fp24_write_bin(uint8_t *bin, size_t len, const fp24_t a, int pack) {
 	fp24_t t;
 
 	fp24_null(t);
@@ -690,7 +690,7 @@ int fp48_size_bin(fp48_t a, int pack) {
 	}
 }
 
-void fp48_read_bin(fp48_t a, const uint8_t *bin, int len) {
+void fp48_read_bin(fp48_t a, const uint8_t *bin, size_t len) {
 	if (len != 32 * RLC_FP_BYTES && len != 48 * RLC_FP_BYTES) {
 		RLC_THROW(ERR_NO_BUFFER);
 		return;
@@ -710,7 +710,7 @@ void fp48_read_bin(fp48_t a, const uint8_t *bin, int len) {
 	}
 }
 
-void fp48_write_bin(uint8_t *bin, int len, const fp48_t a, int pack) {
+void fp48_write_bin(uint8_t *bin, size_t len, const fp48_t a, int pack) {
 	fp48_t t;
 
 	fp48_null(t);
@@ -786,7 +786,7 @@ int fp54_size_bin(fp54_t a, int pack) {
 	}
 }
 
-void fp54_read_bin(fp54_t a, const uint8_t *bin, int len) {
+void fp54_read_bin(fp54_t a, const uint8_t *bin, size_t len) {
 	if (len != 36 * RLC_FP_BYTES && len != 54 * RLC_FP_BYTES) {
 		RLC_THROW(ERR_NO_BUFFER);
 		return;
@@ -807,7 +807,7 @@ void fp54_read_bin(fp54_t a, const uint8_t *bin, int len) {
 	}
 }
 
-void fp54_write_bin(uint8_t *bin, int len, const fp54_t a, int pack) {
+void fp54_write_bin(uint8_t *bin, size_t len, const fp54_t a, int pack) {
 	fp54_t t;
 
 	fp54_null(t);
diff --git a/src/md/relic_md_blake2s.c b/src/md/relic_md_blake2s.c
index cf0b79b54..2ba759ad3 100644
--- a/src/md/relic_md_blake2s.c
+++ b/src/md/relic_md_blake2s.c
@@ -43,7 +43,7 @@
 
 #if MD_MAP == B2S160 || !defined(STRIP)
 
-void md_map_b2s160(uint8_t *hash, const uint8_t *msg, int len) {
+void md_map_b2s160(uint8_t *hash, const uint8_t *msg, size_t len) {
 	memset(hash, 0, RLC_MD_LEN_B2S160);
 	blake2s(hash, RLC_MD_LEN_B2S160, msg, len, NULL, 0);
 }
@@ -52,7 +52,7 @@ void md_map_b2s160(uint8_t *hash, const uint8_t *msg, int len) {
 
 #if MD_MAP == B2S256 || !defined(STRIP)
 
-void md_map_b2s256(uint8_t *hash, const uint8_t *msg, int len) {
+void md_map_b2s256(uint8_t *hash, const uint8_t *msg, size_t len) {
 	memset(hash, 0, RLC_MD_LEN_B2S256);
 	blake2s(hash, RLC_MD_LEN_B2S256, msg, len, NULL, 0);
 }
diff --git a/src/md/relic_md_hmac.c b/src/md/relic_md_hmac.c
index 00b7e63b5..0d524f273 100644
--- a/src/md/relic_md_hmac.c
+++ b/src/md/relic_md_hmac.c
@@ -40,8 +40,8 @@
 /* Public definitions                                                         */
 /*============================================================================*/
 
-void md_hmac(uint8_t *mac, const uint8_t *in, int in_len, const uint8_t *key,
-    int key_len) {
+void md_hmac(uint8_t *mac, const uint8_t *in, size_t in_len, const uint8_t *key,
+    size_t key_len) {
 #if MD_MAP == SH224 || MD_MAP == SH256 || MD_MAP == B2S160 || MD_MAP == B2S256
   #define block_size 64
 #elif MD_MAP == SH384 || MD_MAP == SH512
diff --git a/src/md/relic_md_kdf.c b/src/md/relic_md_kdf.c
index 47c42cfbf..0c3df427a 100644
--- a/src/md/relic_md_kdf.c
+++ b/src/md/relic_md_kdf.c
@@ -40,8 +40,7 @@
 /* Public definitions                                                         */
 /*============================================================================*/
 
-void md_kdf(uint8_t *key, int key_len, const uint8_t *in,
-		int in_len) {
+void md_kdf(uint8_t *key, size_t key_len, const uint8_t *in, size_t in_len) {
 	uint32_t i, j, d;
 	uint8_t* buffer = RLC_ALLOCA(uint8_t, in_len + sizeof(uint32_t));
 	uint8_t* t = RLC_ALLOCA(uint8_t, key_len + RLC_MD_LEN);
diff --git a/src/md/relic_md_mgf.c b/src/md/relic_md_mgf.c
index 1c7737636..100f66a36 100644
--- a/src/md/relic_md_mgf.c
+++ b/src/md/relic_md_mgf.c
@@ -40,8 +40,7 @@
 /* Public definitions                                                         */
 /*============================================================================*/
 
-void md_mgf(uint8_t *key, int key_len, const uint8_t *in,
-		int in_len) {
+void md_mgf(uint8_t *key, size_t key_len, const uint8_t *in, size_t in_len) {
 	uint32_t i, j, d;
 	uint8_t *buffer = RLC_ALLOCA(uint8_t, in_len + sizeof(uint32_t));
 	uint8_t *t = RLC_ALLOCA(uint8_t, key_len + RLC_MD_LEN);
diff --git a/src/md/relic_md_sha224.c b/src/md/relic_md_sha224.c
index 7009f00aa..67989b3dc 100644
--- a/src/md/relic_md_sha224.c
+++ b/src/md/relic_md_sha224.c
@@ -40,7 +40,7 @@
 
 #if MD_MAP == SH224 || !defined(STRIP)
 
-void md_map_sh224(uint8_t *hash, const uint8_t *msg, int len) {
+void md_map_sh224(uint8_t *hash, const uint8_t *msg, size_t len) {
 	SHA224Context ctx;
 
 	if (SHA224Reset(&ctx) != shaSuccess) {
diff --git a/src/md/relic_md_sha256.c b/src/md/relic_md_sha256.c
index 2e589cb74..06db34876 100644
--- a/src/md/relic_md_sha256.c
+++ b/src/md/relic_md_sha256.c
@@ -40,7 +40,7 @@
 
 #if MD_MAP == SH256 || !defined(STRIP)
 
-void md_map_sh256(uint8_t *hash, const uint8_t *msg, int len) {
+void md_map_sh256(uint8_t *hash, const uint8_t *msg, size_t len) {
 	SHA256Context ctx;
 
 	if (SHA256Reset(&ctx) != shaSuccess) {
diff --git a/src/md/relic_md_sha384.c b/src/md/relic_md_sha384.c
index cc93c8b2b..5b4cddc29 100644
--- a/src/md/relic_md_sha384.c
+++ b/src/md/relic_md_sha384.c
@@ -40,7 +40,7 @@
 
 #if MD_MAP == SH384 || !defined(STRIP)
 
-void md_map_sh384(uint8_t *hash, const uint8_t *msg, int len) {
+void md_map_sh384(uint8_t *hash, const uint8_t *msg, size_t len) {
 	SHA384Context ctx;
 
 	if (SHA384Reset(&ctx) != shaSuccess) {
diff --git a/src/md/relic_md_sha512.c b/src/md/relic_md_sha512.c
index 5d2cd3b3f..329fda866 100644
--- a/src/md/relic_md_sha512.c
+++ b/src/md/relic_md_sha512.c
@@ -40,7 +40,7 @@
 
 #if MD_MAP == SH512 || !defined(STRIP)
 
-void md_map_sh512(uint8_t *hash, const uint8_t *msg, int len) {
+void md_map_sh512(uint8_t *hash, const uint8_t *msg, size_t len) {
 	SHA512Context ctx;
 
 	if (SHA512Reset(&ctx) != shaSuccess) {
diff --git a/src/pp/relic_pp_map_k12.c b/src/pp/relic_pp_map_k12.c
index 4f2287633..2446a083f 100644
--- a/src/pp/relic_pp_map_k12.c
+++ b/src/pp/relic_pp_map_k12.c
@@ -52,7 +52,8 @@ static void pp_mil_k12(fp12_t r, ep2_t *t, ep2_t *q, ep_t *p, int m, bn_t a) {
 	fp12_t l;
 	ep_t *_p = RLC_ALLOCA(ep_t, m);
 	ep2_t *_q = RLC_ALLOCA(ep2_t, m);
-	int i, j, len = bn_bits(a) + 1;
+	size_t len = bn_bits(a) + 1;
+	int i, j;
 	int8_t s[RLC_FP_BITS + 1];
 
 	if (m == 0) {
diff --git a/src/pp/relic_pp_map_k24.c b/src/pp/relic_pp_map_k24.c
index 26ebe9cd2..91701eee0 100644
--- a/src/pp/relic_pp_map_k24.c
+++ b/src/pp/relic_pp_map_k24.c
@@ -52,7 +52,8 @@ static void pp_mil_k24(fp24_t r, ep4_t *t, ep4_t *q, ep_t *p, int m, bn_t a) {
 	fp24_t l;
 	ep_t *_p = RLC_ALLOCA(ep_t, m);
 	ep4_t *_q = RLC_ALLOCA(ep4_t, m);
-	int i, j, len = bn_bits(a) + 1;
+	size_t len = bn_bits(a) + 1;
+	int i, j;
 	int8_t s[RLC_FP_BITS + 1];
 
 	if (m == 0) {
diff --git a/src/pp/relic_pp_map_k48.c b/src/pp/relic_pp_map_k48.c
index e17d28c72..e47e5028e 100644
--- a/src/pp/relic_pp_map_k48.c
+++ b/src/pp/relic_pp_map_k48.c
@@ -42,7 +42,8 @@ static void pp_mil_k48(fp48_t r, const fp8_t qx, const fp8_t qy, const ep_t p,
 	fp48_t l;
 	ep_t _p;
 	fp8_t rx, ry, rz, qn;
-	int i, len = bn_bits(a) + 1;
+	size_t len = bn_bits(a) + 1;
+	int i;
 	int8_t s[RLC_FP_BITS + 1];
 
 	fp48_null(l);
diff --git a/src/pp/relic_pp_map_k54.c b/src/pp/relic_pp_map_k54.c
index f5184d54f..4f869cf33 100644
--- a/src/pp/relic_pp_map_k54.c
+++ b/src/pp/relic_pp_map_k54.c
@@ -42,7 +42,8 @@ static void pp_mil_k54(fp54_t r, const fp9_t qx, const fp9_t qy, const ep_t p,
 	fp54_t l;
 	ep_t _p;
 	fp9_t rx, ry, rz, sx, sy, sz, qn;
-	int i, len = bn_bits(a) + 1;
+	size_t len = bn_bits(a) + 1;
+	int i;
 	int8_t s[RLC_FP_BITS + 1];
 
 	fp54_null(l);
diff --git a/src/pp/relic_pp_map_k8.c b/src/pp/relic_pp_map_k8.c
index 28e42a71d..0d5e2ee8f 100644
--- a/src/pp/relic_pp_map_k8.c
+++ b/src/pp/relic_pp_map_k8.c
@@ -53,7 +53,8 @@ static void pp_mil_k8(fp8_t r, ep2_t *t, ep2_t *q, ep_t *p, int m, bn_t a) {
 	fp8_t l;
 	ep_t *_p = RLC_ALLOCA(ep_t, m);
 	ep2_t *_q = RLC_ALLOCA(ep2_t, m);
-	int i, j, len = bn_bits(a) + 1;
+	size_t len = bn_bits(a) + 1;
+	int i, j;
 	int8_t s[RLC_FP_BITS + 1];
 
 	if (m == 0) {
diff --git a/src/rand/relic_rand_core.c b/src/rand/relic_rand_core.c
index 10f8929f8..c21c5a908 100644
--- a/src/rand/relic_rand_core.c
+++ b/src/rand/relic_rand_core.c
@@ -183,7 +183,7 @@ void rand_init(void) {
 #endif
 }
 
-int rand_check(uint8_t *buf, int size) {
+int rand_check(uint8_t *buf, size_t size) {
 	int count = 0;
 
 	for (int i = 1; i < size; i++) {
diff --git a/src/rand/relic_rand_hashd.c b/src/rand/relic_rand_hashd.c
index f91414a37..0b0b753dd 100644
--- a/src/rand/relic_rand_hashd.c
+++ b/src/rand/relic_rand_hashd.c
@@ -53,9 +53,10 @@
  * param[in] in         - the input string.
  * param[in] in_len     - the number of bytes in the input.
  */
-static void rand_hash(uint8_t *out, int out_len, uint8_t *in, int in_len) {
+static void rand_hash(uint8_t *out, size_t out_len, uint8_t *in,
+		size_t in_len) {
 	uint32_t j = util_conv_big(8 * out_len);
-	int len = RLC_CEIL(out_len, RLC_MD_LEN);
+	size_t len = RLC_CEIL(out_len, RLC_MD_LEN);
 	uint8_t* buf = RLC_ALLOCA(uint8_t, 1 + sizeof(uint32_t) + in_len);
 	uint8_t hash[RLC_MD_LEN];
 
@@ -88,7 +89,7 @@ static void rand_hash(uint8_t *out, int out_len, uint8_t *in, int in_len) {
  * @param[in,out] state		- the internal state.
  * @param[in] digit			- the small integer.
  */
-static int rand_inc(uint8_t *data, int size, int digit) {
+static int rand_inc(uint8_t *data, size_t size, int digit) {
 	int carry = digit;
 	for (int i = size - 1; i >= 0; i--) {
 		int16_t s;
@@ -105,7 +106,7 @@ static int rand_inc(uint8_t *data, int size, int digit) {
  * @param[in,out] state		- the internal state.
  * @param[in] hash			- the hash value.
  */
-static int rand_add(uint8_t *state, uint8_t *hash, int size) {
+static int rand_add(uint8_t *state, uint8_t *hash, size_t size) {
 	int carry = 0;
 	for (int i = size - 1; i >= 0; i--) {
 		/* Make sure carries are detected. */
@@ -123,7 +124,7 @@ static int rand_add(uint8_t *state, uint8_t *hash, int size) {
  * @param[out] out 			- the buffer to write.
  * @param[in] out_len		- the number of bytes to write.
  */
-static void rand_gen(uint8_t *out, int out_len) {
+static void rand_gen(uint8_t *out, size_t out_len) {
 	int m = RLC_CEIL(out_len, RLC_MD_LEN);
 	uint8_t hash[RLC_MD_LEN], data[(RLC_RAND_SIZE - 1)/2];
 	ctx_t *ctx = core_get();
@@ -150,7 +151,7 @@ static void rand_gen(uint8_t *out, int out_len) {
 
 #if RAND == HASHD
 
-void rand_bytes(uint8_t *buf, int size) {
+void rand_bytes(uint8_t *buf, size_t size) {
 	uint8_t hash[RLC_MD_LEN];
 	int carry, len  = (RLC_RAND_SIZE - 1)/2;
 	ctx_t *ctx = core_get();
@@ -173,9 +174,9 @@ void rand_bytes(uint8_t *buf, int size) {
 	ctx->counter = ctx->counter + 1;
 }
 
-void rand_seed(uint8_t *buf, int size) {
+void rand_seed(uint8_t *buf, size_t size) {
 	ctx_t *ctx = core_get();
-	int len = (RLC_RAND_SIZE - 1) / 2;
+	size_t len = (RLC_RAND_SIZE - 1) / 2;
 
 	if (size <= 0) {
 		RLC_THROW(ERR_NO_VALID);
diff --git a/src/relic_util.c b/src/relic_util.c
index ba7840f75..06a47d51a 100644
--- a/src/relic_util.c
+++ b/src/relic_util.c
@@ -134,7 +134,7 @@ char util_conv_char(dig_t i) {
 #endif
 }
 
-int util_bits_dig(dig_t a) {
+size_t util_bits_dig(dig_t a) {
     return RLC_DIG - arch_lzcnt(a);
 }
 
diff --git a/test/test_bn.c b/test/test_bn.c
index 30a925362..a9cfb5fae 100644
--- a/test/test_bn.c
+++ b/test/test_bn.c
@@ -234,7 +234,7 @@ static int util(void) {
 		} TEST_END;
 
 		TEST_CASE("reading and writing a positive number are consistent") {
-			int len = RLC_CEIL(RLC_BN_BITS, 8);
+			size_t len = RLC_CEIL(RLC_BN_BITS, 8);
 			bn_rand(a, RLC_POS, RLC_BN_BITS);
 			for (int j = 2; j <= 64; j++) {
 				bits = bn_size_str(a, j);
@@ -262,7 +262,7 @@ static int util(void) {
 		TEST_END;
 
 		TEST_CASE("reading and writing a negative number are consistent") {
-			int len = RLC_CEIL(RLC_BN_BITS, 8);
+			size_t len = RLC_CEIL(RLC_BN_BITS, 8);
 			bn_rand(a, RLC_NEG, RLC_BN_BITS);
 			for (int j = 2; j <= 64; j++) {
 				bits = bn_size_str(a, j);
@@ -1139,8 +1139,9 @@ static int exponentiation(void) {
 }
 
 static int square_root(void) {
-	int bits, code = RLC_ERR;
+	size_t bits;
 	bn_t a, b, c;
+	int code = RLC_ERR;
 
 	bn_null(a);
 	bn_null(b);
@@ -1938,9 +1939,10 @@ static int factor(void) {
 static int recoding(void) {
 	int code = RLC_ERR;
 	bn_t a, b, c, v1[3], v2[3];
-	int w, k, l;
+	int w, k;
 	uint8_t d[RLC_BN_BITS + 1];
 	int8_t e[2 * (RLC_BN_BITS + 1)];
+	size_t l;
 
 	bn_null(a);
 	bn_null(b);
diff --git a/test/test_core.c b/test/test_core.c
index a7642f08f..12678dc0b 100644
--- a/test/test_core.c
+++ b/test/test_core.c
@@ -123,6 +123,7 @@ int main(void) {
 		}
 		TEST_ASSERT(code == RLC_OK, end);
 
+		core_clean();
 		core_init();
 #pragma omp parallel copyin(core_ctx) shared(code)
 		{
diff --git a/test/test_pc.c b/test/test_pc.c
index dff4fab84..d743aff74 100644
--- a/test/test_pc.c
+++ b/test/test_pc.c
@@ -1245,7 +1245,7 @@ static int memory(void) {
 }
 
 int util(void) {
-	int l, code = RLC_ERR;
+	int code = RLC_ERR;
 	gt_t a, b, c;
 	uint8_t bin[24 * RLC_PC_BYTES];
 
diff --git a/test/test_rand.c b/test/test_rand.c
index e3de369d3..7f90ab8f8 100644
--- a/test/test_rand.c
+++ b/test/test_rand.c
@@ -363,7 +363,7 @@ static int test(void) {
 
 static int test(void) {
 	uint8_t out[64];
-	int len = sizeof(out) / 2, code = RLC_ERR;
+	size_t len = sizeof(out) / 2, code = RLC_ERR;
 
 	TEST_ONCE("rdrand hardware generator is non-trivial") {
 		memset(out, 0, 2 * len);
