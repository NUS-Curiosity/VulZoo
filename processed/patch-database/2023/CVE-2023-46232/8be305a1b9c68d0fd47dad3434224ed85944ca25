diff --git a/CHANGELOG.md b/CHANGELOG.md
index 620d5d8..9062897 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,5 +1,11 @@
 # The `zkvyper` changelog
 
+## [1.3.10] - 2023-09-13
+
+### Fixed
+
+- An issue with uninitialized immutable values
+
 ## [1.3.9] - 2023-07-03
 
 ### Fixed
@@ -21,7 +27,7 @@
 ### Added
 
 - The zkEVM assembly compilation mode (`--zkasm`)
-- The vyper v1.3.9 support
+- The vyper v0.3.9 support
 
 ### Fixed
 
diff --git a/Cargo.lock b/Cargo.lock
index 50b2fbc..28f0fb8 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -4,18 +4,18 @@ version = 3
 
 [[package]]
 name = "aho-corasick"
-version = "1.0.2"
+version = "1.0.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "43f6cb1bf222025340178f382c426f13757b2960e89779dfcb319c32542a5a41"
+checksum = "0c378d78423fdad8089616f827526ee33c19f2fddbd5de1629152c9593ba4783"
 dependencies = [
  "memchr",
 ]
 
 [[package]]
 name = "anyhow"
-version = "1.0.72"
+version = "1.0.75"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3b13c32d80ecc7ab747b80c3784bce54ee8a7a0cc4fbda9bf4cda2cf6fe90854"
+checksum = "a4668cab20f66d8d020e1fbc0ebe47217433c1b6c8f2040faf858554e394ace6"
 
 [[package]]
 name = "arrayvec"
@@ -60,15 +60,15 @@ checksum = "bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a"
 
 [[package]]
 name = "bitflags"
-version = "2.3.3"
+version = "2.4.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "630be753d4e58660abd17930c71b647fe46c27ea6b63cc59e1e3851406972e42"
+checksum = "b4682ae6287fcf752ecaabbfcc7b6f9b72aa33933dc23a554d853aea8eea8635"
 
 [[package]]
 name = "bitvec"
-version = "0.20.4"
+version = "1.0.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7774144344a4faa177370406a7ff5f1da24303817368584c6206c8303eb07848"
+checksum = "1bc2832c24239b0141d5674bb9174f9d68a8b5b3f2753311927c172ca46f7e9c"
 dependencies = [
  "funty",
  "radium",
@@ -108,15 +108,18 @@ checksum = "14c189c53d098945499cdfa7ecc63567cf3886b3332b312a5b4585d8d3a6a610"
 
 [[package]]
 name = "bytes"
-version = "1.4.0"
+version = "1.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "89b2fd2a0dcf38d7971e2194b6b6eebab45ae01067456a7fd93d5547a61b70be"
+checksum = "a2bd12c1caf447e69cd4528f47f94d203fd2582878ecb9e9465484c4148a8223"
 
 [[package]]
 name = "cc"
-version = "1.0.79"
+version = "1.0.83"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "50d30906286121d95be3d479533b458f87493b30a4b5f79a607db8f5d11aa91f"
+checksum = "f1174fb0b6ec23863f8b971027804a42614e347eafb0a95bf0b12cdae21fc4d0"
+dependencies = [
+ "libc",
+]
 
 [[package]]
 name = "cfg-if"
@@ -148,13 +151,13 @@ dependencies = [
 
 [[package]]
 name = "compiler-common"
-version = "1.3.1"
-source = "git+https://github.com/matter-labs/era-compiler-common?branch=main#a6c5b02e4f149f82f1c3821a6f258363308abd2a"
+version = "1.3.3"
+source = "git+https://github.com/matter-labs/era-compiler-common?branch=main#aac58a37982885dd09f7d4fa838c16a96ef23683"
 
 [[package]]
 name = "compiler-llvm-context"
 version = "1.3.2"
-source = "git+https://github.com/matter-labs/era-compiler-llvm-context?branch=main#7d20d1323787ff50fb043cb4f798b3d9a9369ae8"
+source = "git+https://github.com/matter-labs/era-compiler-llvm-context?branch=main#419bd6067c1e1f0bc64acb7cb5307d8398dfbe2a"
 dependencies = [
  "anyhow",
  "compiler-common",
@@ -175,7 +178,7 @@ dependencies = [
 
 [[package]]
 name = "compiler-vyper"
-version = "1.3.9"
+version = "1.3.10"
 dependencies = [
  "anyhow",
  "colored",
@@ -193,15 +196,16 @@ dependencies = [
  "serde_stacker",
  "sha3",
  "structopt",
+ "which",
  "zkevm-assembly",
  "zkevm_opcode_defs",
 ]
 
 [[package]]
 name = "const-oid"
-version = "0.9.4"
+version = "0.9.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "795bc6e66a8e340f075fcf6227e417a2dc976b92b91f3cdc778bb858778b6747"
+checksum = "28c122c3980598d243d63d9a704629a2d748d101f278052ff068be5a4423ab6f"
 
 [[package]]
 name = "cpufeatures"
@@ -318,9 +322,9 @@ dependencies = [
 
 [[package]]
 name = "either"
-version = "1.8.1"
+version = "1.9.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7fcaabb2fef8c910e7f4c7ce9f67a1283a1715879a7c230ca9d6d1ae31f16d91"
+checksum = "a26ae43d7bcc3b814de94796a5e736d4029efb0ee900c12e2d54c993ad1a1e07"
 
 [[package]]
 name = "elliptic-curve"
@@ -363,9 +367,9 @@ checksum = "5443807d6dff69373d433ab9ef5378ad8df50ca6298caf15de6e52e24aaf54d5"
 
 [[package]]
 name = "errno"
-version = "0.3.1"
+version = "0.3.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4bcfec3a70f97c962c307b2d2c56e358cf1d00b558d74262b5f929ee8cc7e73a"
+checksum = "136526188508e25c6fef639d7927dfb3e0e3084488bf202267829cf7fc23dbdd"
 dependencies = [
  "errno-dragonfly",
  "libc",
@@ -384,9 +388,9 @@ dependencies = [
 
 [[package]]
 name = "ethbloom"
-version = "0.11.1"
+version = "0.13.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bfb684ac8fa8f6c5759f788862bb22ec6fe3cb392f6bfd08e3c64b603661e3f8"
+checksum = "c22d4b5885b6aa2fe5e8b9329fb8d232bf739e434e6b87347c63bdd00c120f60"
 dependencies = [
  "crunchy",
  "fixed-hash",
@@ -397,9 +401,9 @@ dependencies = [
 
 [[package]]
 name = "ethereum-types"
-version = "0.12.1"
+version = "0.14.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "05136f7057fe789f06e6d41d07b34e6f70d8c86e5693b60f97aaa6553553bdaf"
+checksum = "02d215cbf040552efcbe99a38372fe80ab9d00268e20012b79fcd0f073edd8ee"
 dependencies = [
  "ethbloom",
  "fixed-hash",
@@ -421,9 +425,9 @@ dependencies = [
 
 [[package]]
 name = "fixed-hash"
-version = "0.7.0"
+version = "0.8.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "cfcf0ed7fe52a17a03854ec54a9f76d6d84508d1c0e66bc1793301c73fc8493c"
+checksum = "835c052cb0c08c1acf6ffd71c022172e18723949c8282f2b9f27efbc51e64534"
 dependencies = [
  "byteorder",
  "rand",
@@ -433,9 +437,9 @@ dependencies = [
 
 [[package]]
 name = "funty"
-version = "1.1.0"
+version = "2.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "fed34cd105917e91daa4da6b3728c47b068749d6a62c59811f06ed2ac71d9da7"
+checksum = "e6d5a32815ae3f33302d95fdcb2ce17862f8c65363dcfd29360480ba1001fc9c"
 
 [[package]]
 name = "generic-array"
@@ -514,6 +518,15 @@ dependencies = [
  "digest",
 ]
 
+[[package]]
+name = "home"
+version = "0.5.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5444c27eef6923071f7ebcc33e3444508466a76f7a2b93da00ed6e19f30c1ddb"
+dependencies = [
+ "windows-sys",
+]
+
 [[package]]
 name = "humantime"
 version = "2.1.0"
@@ -522,9 +535,9 @@ checksum = "9a3a5bfb195931eeb336b2a7b4d761daec841b97f947d34394601737a7bba5e4"
 
 [[package]]
 name = "impl-codec"
-version = "0.5.1"
+version = "0.6.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "161ebdfec3c8e3b52bf61c4f3550a1eea4f9579d10dc1b936f3171ebdcd6c443"
+checksum = "ba6a270039626615617f3f36d15fc827041df3b78c439da2cadfa47455a77f2f"
 dependencies = [
  "parity-scale-codec",
 ]
@@ -540,9 +553,9 @@ dependencies = [
 
 [[package]]
 name = "impl-serde"
-version = "0.3.2"
+version = "0.4.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4551f042f3438e64dbd6226b20527fc84a6e1fe65688b58746a2f53623f25f5c"
+checksum = "ebc88fc67028ae3db0c853baa36269d398d5f45b6982f95549ff5def78c935cd"
 dependencies = [
  "serde",
 ]
@@ -647,15 +660,15 @@ checksum = "e2abad23fbc42b3700f2f279844dc832adb2b2eb069b2df918f455c4e18cc646"
 
 [[package]]
 name = "libc"
-version = "0.2.147"
+version = "0.2.148"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b4668fb0ea861c1df094127ac5f1da3409a82116a4ba74fca2e58ef927159bb3"
+checksum = "9cdc71e17332e86d2e1d38c1f99edcb6288ee11b815fb1a4b049eaa2114d369b"
 
 [[package]]
 name = "libmimalloc-sys"
-version = "0.1.33"
+version = "0.1.35"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f4ac0e912c8ef1b735e92369695618dc5b1819f5a7bf3f167301a3ba1cea515e"
+checksum = "3979b5c37ece694f1f5e51e7ecc871fdb0f517ed04ee45f88d15d6d553cb9664"
 dependencies = [
  "cc",
  "libc",
@@ -663,9 +676,9 @@ dependencies = [
 
 [[package]]
 name = "linux-raw-sys"
-version = "0.4.3"
+version = "0.4.7"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "09fc20d2ca12cb9f044c93e3bd6d32d523e6e2ec3db4f7b2939cd99026ecd3f0"
+checksum = "1a9bad9f94746442c783ca431b22403b519cd7fbeed0533fdd6328b2f2212128"
 
 [[package]]
 name = "llvm-sys"
@@ -691,9 +704,9 @@ dependencies = [
 
 [[package]]
 name = "log"
-version = "0.4.19"
+version = "0.4.20"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b06a4cde4c0f271a446782e3eff8de789548ce57dbc8eca9292c27f4a42004b4"
+checksum = "b5e6163cb8c49088c2c36f57875e58ccd8c87c7427f7fbd50ea6710b2f3f2e8f"
 
 [[package]]
 name = "md5"
@@ -703,9 +716,9 @@ checksum = "490cc448043f947bae3cbee9c203358d62dbee0db12107a74be5c30ccfd09771"
 
 [[package]]
 name = "memchr"
-version = "2.5.0"
+version = "2.6.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "2dffe52ecf27772e601905b7522cb4ef790d2cc203488bbd0e2fe85fcb74566d"
+checksum = "8f232d6ef707e1956a43342693d2a31e72989554d58299d7a88738cc95b0d35c"
 
 [[package]]
 name = "memoffset"
@@ -718,9 +731,9 @@ dependencies = [
 
 [[package]]
 name = "mimalloc"
-version = "0.1.37"
+version = "0.1.39"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4e2894987a3459f3ffb755608bd82188f8ed00d0ae077f1edea29c068d639d98"
+checksum = "fa01922b5ea280a911e323e4d2fd24b7fe5cc4042e0d2cda3c40775cdc4bdc9c"
 dependencies = [
  "libmimalloc-sys",
 ]
@@ -757,9 +770,9 @@ dependencies = [
 
 [[package]]
 name = "num-bigint"
-version = "0.4.3"
+version = "0.4.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f93ab6289c7b344a8a9f60f88d80aa20032336fe78da341afc91c8a2341fc75f"
+checksum = "608e7659b5c3d7cba262d894801b9ec9d00de989e8a82bd4bef91d08da45cdc0"
 dependencies = [
  "autocfg",
  "num-integer",
@@ -768,9 +781,9 @@ dependencies = [
 
 [[package]]
 name = "num-complex"
-version = "0.4.3"
+version = "0.4.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "02e0d21255c828d6f128a1e41534206671e8c3ea0c62f32291e808dc82cff17d"
+checksum = "1ba157ca0885411de85d6ca030ba7e2a83a28636056c7c699b07c8b6f7383214"
 dependencies = [
  "num-traits",
 ]
@@ -810,9 +823,9 @@ dependencies = [
 
 [[package]]
 name = "num-traits"
-version = "0.2.15"
+version = "0.2.16"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "578ede34cf02f8924ab9447f50c28075b4d3e5b269972345e7e0372b38c6cdcd"
+checksum = "f30b0abd723be7e2ffca1272140fac1a2f084c77ec3e123c192b66af1ee9e6c2"
 dependencies = [
  "autocfg",
 ]
@@ -835,9 +848,9 @@ checksum = "dd8b5dd2ae5ed71462c540258bedcb51965123ad7e7ccf4b9a8cafaa4a63576d"
 
 [[package]]
 name = "parity-scale-codec"
-version = "2.3.1"
+version = "3.6.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "373b1a4c1338d9cd3d1fa53b3a11bdab5ab6bd80a20f7f7becd76953ae2be909"
+checksum = "0dec8a8073036902368c2cdc0387e85ff9a37054d7e7c98e592145e0c92cd4fb"
 dependencies = [
  "arrayvec",
  "bitvec",
@@ -849,9 +862,9 @@ dependencies = [
 
 [[package]]
 name = "parity-scale-codec-derive"
-version = "2.3.1"
+version = "3.6.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1557010476e0595c9b568d16dcfb81b93cdeb157612726f5170d31aa707bed27"
+checksum = "312270ee71e1cd70289dacf597cab7b207aa107d2f28191c2ae45b2ece18a260"
 dependencies = [
  "proc-macro-crate",
  "proc-macro2",
@@ -900,9 +913,9 @@ checksum = "5b40af805b3121feab8a3c29f04d8ad262fa8e0561883e7653e024ae4479e6de"
 
 [[package]]
 name = "primitive-types"
-version = "0.10.1"
+version = "0.12.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "05e4722c697a58a99d5d06a08c30821d7c082a4632198de1eaa5a6c22ef42373"
+checksum = "9f3486ccba82358b11a77516035647c34ba167dfa53312630de83b12bd4f3d66"
 dependencies = [
  "fixed-hash",
  "impl-codec",
@@ -947,9 +960,9 @@ dependencies = [
 
 [[package]]
 name = "proc-macro2"
-version = "1.0.66"
+version = "1.0.67"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "18fb31db3f9bddb2ea821cde30a9f70117e3f119938b5ee630b7403aa6e2ead9"
+checksum = "3d433d9f1a3e8c1263d9456598b16fec66f4acc9a74dacffd35c7bb09b3a1328"
 dependencies = [
  "unicode-ident",
 ]
@@ -965,18 +978,18 @@ dependencies = [
 
 [[package]]
 name = "quote"
-version = "1.0.31"
+version = "1.0.33"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5fe8a65d69dd0808184ebb5f836ab526bb259db23c657efa38711b1072ee47f0"
+checksum = "5267fca4496028628a95160fc423a33e8b2e6af8a5302579e322e4b520293cae"
 dependencies = [
  "proc-macro2",
 ]
 
 [[package]]
 name = "radium"
-version = "0.6.2"
+version = "0.7.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "643f8f41a8ebc4c5dc4515c82bb8abd397b527fc20fd681b7c011c2aee5d44fb"
+checksum = "dc33ff2d4973d518d823d61aa239014831e521c75da58e3df4840d3f47749d09"
 
 [[package]]
 name = "rand"
@@ -1041,9 +1054,9 @@ dependencies = [
 
 [[package]]
 name = "regex"
-version = "1.9.1"
+version = "1.9.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b2eae68fc220f7cf2532e4494aded17545fce192d59cd996e0fe7887f4ceb575"
+checksum = "697061221ea1b4a94a624f67d0ae2bfe4e22b8a17b6a192afb11046542cc8c47"
 dependencies = [
  "aho-corasick",
  "memchr",
@@ -1053,9 +1066,9 @@ dependencies = [
 
 [[package]]
 name = "regex-automata"
-version = "0.3.3"
+version = "0.3.8"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "39354c10dd07468c2e73926b23bb9c2caca74c5501e38a35da70406f1d923310"
+checksum = "c2f401f4955220693b56f8ec66ee9c78abffd8d1c4f23dc41a23839eb88f0795"
 dependencies = [
  "aho-corasick",
  "memchr",
@@ -1064,9 +1077,9 @@ dependencies = [
 
 [[package]]
 name = "regex-syntax"
-version = "0.7.4"
+version = "0.7.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e5ea92a5b6195c6ef2a0295ea818b312502c6fc94dde986c5553242e18fd4ce2"
+checksum = "dbb5fb1acd8a1a18b3dd5be62d25485eb770e05afb408a9627d14d451bae12da"
 
 [[package]]
 name = "rfc6979"
@@ -1097,11 +1110,11 @@ checksum = "3e75f6a532d0fd9f7f13144f392b6ad56a32696bfcd9c78f797f16bbb6f072d6"
 
 [[package]]
 name = "rustix"
-version = "0.38.4"
+version = "0.38.13"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "0a962918ea88d644592894bc6dc55acc6c0956488adcebbfb6e273506b7fd6e5"
+checksum = "d7db8590df6dfcd144d22afd1b83b36c21a18d7cbc1dc4bb5295a8712e9eb662"
 dependencies = [
- "bitflags 2.3.3",
+ "bitflags 2.4.0",
  "errno",
  "libc",
  "linux-raw-sys",
@@ -1116,9 +1129,9 @@ checksum = "1ad4cc8da4ef723ed60bced201181d83791ad433213d8c24efffda1eec85d741"
 
 [[package]]
 name = "scopeguard"
-version = "1.1.0"
+version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d29ab0c6d3fc0ee92fe66e2d99f700eab17a8d57d1c1d3b748380fb20baa78cd"
+checksum = "94143f37725109f92c262ed2cf5e59bce7498c01bcc1502d7b9afe439a4e9f49"
 
 [[package]]
 name = "sec1"
@@ -1145,29 +1158,29 @@ dependencies = [
 
 [[package]]
 name = "serde"
-version = "1.0.171"
+version = "1.0.188"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "30e27d1e4fd7659406c492fd6cfaf2066ba8773de45ca75e855590f856dc34a9"
+checksum = "cf9e0fcba69a370eed61bcf2b728575f726b50b55cba78064753d708ddc7549e"
 dependencies = [
  "serde_derive",
 ]
 
 [[package]]
 name = "serde_derive"
-version = "1.0.171"
+version = "1.0.188"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "389894603bd18c46fa56231694f8d827779c0951a667087194cf9de94ed24682"
+checksum = "4eca7ac642d82aa35b60049a6eccb4be6be75e599bd2e9adb5f875a737654af2"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 2.0.26",
+ "syn 2.0.33",
 ]
 
 [[package]]
 name = "serde_json"
-version = "1.0.103"
+version = "1.0.107"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d03b412469450d4404fe8499a268edd7f8b79fecb074b0d812ad64ca21f4031b"
+checksum = "6b420ce6e3d8bd882e9b243c6eed35dbc9a6110c9769e74b584e0d68d1f20c65"
 dependencies = [
  "itoa",
  "ryu",
@@ -1293,9 +1306,9 @@ dependencies = [
 
 [[package]]
 name = "syn"
-version = "2.0.26"
+version = "2.0.33"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "45c3457aacde3c65315de5031ec191ce46604304d2446e803d71ade03308d970"
+checksum = "9caece70c63bfba29ec2fed841a09851b14a235c60010fa4de58089b6c025668"
 dependencies = [
  "proc-macro2",
  "quote",
@@ -1328,22 +1341,22 @@ dependencies = [
 
 [[package]]
 name = "thiserror"
-version = "1.0.43"
+version = "1.0.48"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a35fc5b8971143ca348fa6df4f024d4d55264f3468c71ad1c2f365b0a4d58c42"
+checksum = "9d6d7a740b8a666a7e828dd00da9c0dc290dff53154ea77ac109281de90589b7"
 dependencies = [
  "thiserror-impl",
 ]
 
 [[package]]
 name = "thiserror-impl"
-version = "1.0.43"
+version = "1.0.48"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "463fe12d7993d3b327787537ce8dd4dfa058de32fc2b195ef3cde03dc4771e8f"
+checksum = "49922ecae66cc8a249b77e68d1d0623c1b2c514f0060c27cdc68bd62a1219d35"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 2.0.26",
+ "syn 2.0.33",
 ]
 
 [[package]]
@@ -1363,9 +1376,9 @@ checksum = "7cda73e2f1397b1262d6dfdcef8aafae14d1de7748d66822d3bfeeb6d03e5e4b"
 
 [[package]]
 name = "toml_edit"
-version = "0.19.14"
+version = "0.19.15"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f8123f27e969974a3dfba720fdb560be359f57b44302d280ba72e76a74480e8a"
+checksum = "1b5bb770da30e5cbfde35a2d7b9b8a2c4b8ef89548a7a6aeab5c9a576e3e7421"
 dependencies = [
  "indexmap",
  "toml_datetime",
@@ -1392,9 +1405,9 @@ dependencies = [
 
 [[package]]
 name = "unicode-ident"
-version = "1.0.11"
+version = "1.0.12"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "301abaae475aa91687eb82514b328ab47a211a533026cb25fc3e519b86adfc3c"
+checksum = "3354b9ac3fae1ff6755cb6db53683adb661634f67557942dea4facebec0fee4b"
 
 [[package]]
 name = "unicode-segmentation"
@@ -1420,6 +1433,18 @@ version = "0.11.0+wasi-snapshot-preview1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423"
 
+[[package]]
+name = "which"
+version = "4.4.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "87ba24419a2078cd2b0f2ede2691b6c66d8e47836da3b6db8265ebad47afbfc7"
+dependencies = [
+ "either",
+ "home",
+ "once_cell",
+ "rustix",
+]
+
 [[package]]
 name = "winapi"
 version = "0.3.9"
@@ -1462,9 +1487,9 @@ dependencies = [
 
 [[package]]
 name = "windows-targets"
-version = "0.48.1"
+version = "0.48.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "05d4b17490f70499f20b9e791dcf6a299785ce8af4d709018206dc5b4953e95f"
+checksum = "9a2fa6e2155d7247be68c096456083145c183cbbbc2764150dda45a87197940c"
 dependencies = [
  "windows_aarch64_gnullvm",
  "windows_aarch64_msvc",
@@ -1477,60 +1502,63 @@ dependencies = [
 
 [[package]]
 name = "windows_aarch64_gnullvm"
-version = "0.48.0"
+version = "0.48.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "91ae572e1b79dba883e0d315474df7305d12f569b400fcf90581b06062f7e1bc"
+checksum = "2b38e32f0abccf9987a4e3079dfb67dcd799fb61361e53e2882c3cbaf0d905d8"
 
 [[package]]
 name = "windows_aarch64_msvc"
-version = "0.48.0"
+version = "0.48.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b2ef27e0d7bdfcfc7b868b317c1d32c641a6fe4629c171b8928c7b08d98d7cf3"
+checksum = "dc35310971f3b2dbbf3f0690a219f40e2d9afcf64f9ab7cc1be722937c26b4bc"
 
 [[package]]
 name = "windows_i686_gnu"
-version = "0.48.0"
+version = "0.48.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "622a1962a7db830d6fd0a69683c80a18fda201879f0f447f065a3b7467daa241"
+checksum = "a75915e7def60c94dcef72200b9a8e58e5091744960da64ec734a6c6e9b3743e"
 
 [[package]]
 name = "windows_i686_msvc"
-version = "0.48.0"
+version = "0.48.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4542c6e364ce21bf45d69fdd2a8e455fa38d316158cfd43b3ac1c5b1b19f8e00"
+checksum = "8f55c233f70c4b27f66c523580f78f1004e8b5a8b659e05a4eb49d4166cca406"
 
 [[package]]
 name = "windows_x86_64_gnu"
-version = "0.48.0"
+version = "0.48.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ca2b8a661f7628cbd23440e50b05d705db3686f894fc9580820623656af974b1"
+checksum = "53d40abd2583d23e4718fddf1ebec84dbff8381c07cae67ff7768bbf19c6718e"
 
 [[package]]
 name = "windows_x86_64_gnullvm"
-version = "0.48.0"
+version = "0.48.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7896dbc1f41e08872e9d5e8f8baa8fdd2677f29468c4e156210174edc7f7b953"
+checksum = "0b7b52767868a23d5bab768e390dc5f5c55825b6d30b86c844ff2dc7414044cc"
 
 [[package]]
 name = "windows_x86_64_msvc"
-version = "0.48.0"
+version = "0.48.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1a515f5799fe4961cb532f983ce2b23082366b898e52ffbce459c86f67c8378a"
+checksum = "ed94fce61571a4006852b7389a063ab983c02eb1bb37b47f8272ce92d06d9538"
 
 [[package]]
 name = "winnow"
-version = "0.5.0"
+version = "0.5.15"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "81fac9742fd1ad1bd9643b991319f72dd031016d44b77039a26977eb667141e7"
+checksum = "7c2e3184b9c4e92ad5167ca73039d0c42476302ab603e2fec4487511f38ccefc"
 dependencies = [
  "memchr",
 ]
 
 [[package]]
 name = "wyz"
-version = "0.2.0"
+version = "0.5.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "85e60b0d1b5f99db2556934e21937020776a5d31520bf169e851ac44e6420214"
+checksum = "05f360fc0b24296329c78fda852a1e9ae82de9cf7b27dae4b7f62f118f77b9ed"
+dependencies = [
+ "tap",
+]
 
 [[package]]
 name = "zeroize"
@@ -1560,9 +1588,9 @@ dependencies = [
 [[package]]
 name = "zkevm_opcode_defs"
 version = "1.3.2"
-source = "git+https://github.com/matter-labs/era-zkevm_opcode_defs?branch=v1.3.2#2f69c6975a272e8c31d2d82c136a4ea81df25115"
+source = "git+https://github.com/matter-labs/era-zkevm_opcode_defs?branch=v1.3.2#a40648727910621b46a1023d940befefb0469cba"
 dependencies = [
- "bitflags 2.3.3",
+ "bitflags 2.4.0",
  "blake2",
  "ethereum-types",
  "k256",
diff --git a/Cargo.toml b/Cargo.toml
index 03ed767..4b84112 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -1,8 +1,8 @@
 [package]
 name = "compiler-vyper"
-version = "1.3.9"
+version = "1.3.10"
 authors = [
-    "Alex Zarudnyy <a.zarudnyy@matterlabs.dev>",
+    "Oleksandr Zarudnyi <a.zarudnyy@matterlabs.dev>",
 ]
 license = "MIT OR Apache-2.0"
 edition = "2021"
@@ -23,12 +23,13 @@ anyhow = "1.0"
 rayon = "1.7"
 
 serde = { version = "1.0", "features" = [ "derive" ] }
-serde_json = { version = "1.0", features = [ "arbitrary_precision", "unbounded_depth" ]}
+serde_json = { version = "1.0", features = [ "arbitrary_precision", "unbounded_depth" ] }
 serde_stacker = "0.1"
-once_cell = "1.17"
 lazy_static = "1.4"
+once_cell = "1.17"
 hex = "0.4"
 sha3 = "0.10"
+which = "4.4"
 semver = { version = "1.0", features = [ "serde" ] }
 
 zkevm_opcode_defs = { git = "https://github.com/matter-labs/era-zkevm_opcode_defs", branch = "v1.3.2" }
diff --git a/README.md b/README.md
index c9013c1..d73819d 100644
--- a/README.md
+++ b/README.md
@@ -111,18 +111,20 @@ Specify the path to the `vyper` executable. By default, the one in `${PATH}` is
 In LLVM IR mode `vyper` is unused.  
 
 #### `-f <format>`
-An extra output format string.
-See `vyper --help` for available options.
+An extra output format string.  
+See `vyper --help` for available options including combined JSON mode.
 
 #### `--llvm-ir`
 Switch to LLVM IR mode.  
 Only one input LLVM IR file is allowed.  
-Cannot be used with combined or standard JSON modes.  
+Cannot be used with combined JSON mode.  
+Use this mode at your own risk, as LLVM IR input validation is not implemented.  
 
 #### `--zkasm`
 Switch to zkEVM assembly mode.  
 Only one input zkEVM assembly file is allowed.  
-Cannot be used with combined or standard JSON modes.  
+Cannot be used with combined JSON mode.  
+Use this mode at your own risk, as EraVM assembly input validation is not implemented.  
 
 #### `--metadata-hash`
 Set metadata hash mode: `keccak256` | `none`.
diff --git a/src/build/contract.rs b/src/build/contract.rs
index 2a7ac6f..2d00366 100644
--- a/src/build/contract.rs
+++ b/src/build/contract.rs
@@ -17,14 +17,14 @@ use crate::vyper::combined_json::contract::Contract as CombinedJsonContract;
 #[derive(Debug, Serialize, Deserialize)]
 pub struct Contract {
     /// The LLVM module build.
-    pub build: compiler_llvm_context::Build,
+    pub build: compiler_llvm_context::EraVMBuild,
 }
 
 impl Contract {
     ///
     /// A shortcut constructor.
     ///
-    pub fn new(build: compiler_llvm_context::Build) -> Self {
+    pub fn new(build: compiler_llvm_context::EraVMBuild) -> Self {
         Self { build }
     }
 
@@ -42,7 +42,7 @@ impl Contract {
         let assembly_file_name = format!(
             "{}.{}",
             contract_name,
-            compiler_common::EXTENSION_ZKEVM_ASSEMBLY
+            compiler_common::EXTENSION_ERAVM_ASSEMBLY
         );
         let mut assembly_file_path = output_directory.to_owned();
         assembly_file_path.push(assembly_file_name);
@@ -65,7 +65,7 @@ impl Contract {
         let binary_file_name = format!(
             "{}.{}",
             contract_name,
-            compiler_common::EXTENSION_ZKEVM_BINARY
+            compiler_common::EXTENSION_ERAVM_BINARY
         );
         let mut binary_file_path = output_directory.to_owned();
         binary_file_path.push(binary_file_name);
diff --git a/src/project/contract/llvm_ir.rs b/src/project/contract/llvm_ir.rs
index c4f8b24..92c297d 100644
--- a/src/project/contract/llvm_ir.rs
+++ b/src/project/contract/llvm_ir.rs
@@ -60,7 +60,9 @@ impl Contract {
         let module = llvm
             .create_module_from_ir(memory_buffer)
             .map_err(|error| anyhow::anyhow!(error.to_string()))?;
-        let context = compiler_llvm_context::Context::<compiler_llvm_context::DummyDependency>::new(
+        let context = compiler_llvm_context::EraVMContext::<
+            compiler_llvm_context::EraVMDummyDependency,
+        >::new(
             &llvm,
             module,
             optimizer,
diff --git a/src/project/contract/vyper/expression/instruction/assert.rs b/src/project/contract/vyper/expression/instruction/assert.rs
index 494d49b..49d3e0c 100644
--- a/src/project/contract/vyper/expression/instruction/assert.rs
+++ b/src/project/contract/vyper/expression/instruction/assert.rs
@@ -19,10 +19,10 @@ impl Assert {
     ///
     pub fn into_llvm_value<D>(
         self,
-        context: &mut compiler_llvm_context::Context<D>,
+        context: &mut compiler_llvm_context::EraVMContext<D>,
     ) -> anyhow::Result<()>
     where
-        D: compiler_llvm_context::Dependency + Clone,
+        D: compiler_llvm_context::EraVMDependency + Clone,
     {
         let [condition] = self.0;
 
diff --git a/src/project/contract/vyper/expression/instruction/clamp.rs b/src/project/contract/vyper/expression/instruction/clamp.rs
index f4a5d65..8eea625 100644
--- a/src/project/contract/vyper/expression/instruction/clamp.rs
+++ b/src/project/contract/vyper/expression/instruction/clamp.rs
@@ -8,14 +8,14 @@ use inkwell::values::BasicValue;
 /// Translates the two-sides bounded clamp.
 ///
 pub fn ordinary<'ctx, D>(
-    context: &mut compiler_llvm_context::Context<'ctx, D>,
+    context: &mut compiler_llvm_context::EraVMContext<'ctx, D>,
     operand_1: inkwell::values::IntValue<'ctx>,
     operand_2: inkwell::values::IntValue<'ctx>,
     operand_3: inkwell::values::IntValue<'ctx>,
     is_signed: bool,
 ) -> anyhow::Result<inkwell::values::BasicValueEnum<'ctx>>
 where
-    D: compiler_llvm_context::Dependency + Clone,
+    D: compiler_llvm_context::EraVMDependency + Clone,
 {
     let error_block = context.append_basic_block("if_error");
     let join_block = context.append_basic_block("if_join");
@@ -59,13 +59,13 @@ where
 /// Translates the one-side bounded clamp with predicate.
 ///
 pub fn with_predicate<'ctx, D>(
-    context: &mut compiler_llvm_context::Context<'ctx, D>,
+    context: &mut compiler_llvm_context::EraVMContext<'ctx, D>,
     operand_1: inkwell::values::IntValue<'ctx>,
     operand_2: inkwell::values::IntValue<'ctx>,
     predicate: inkwell::IntPredicate,
 ) -> anyhow::Result<inkwell::values::BasicValueEnum<'ctx>>
 where
-    D: compiler_llvm_context::Dependency + Clone,
+    D: compiler_llvm_context::EraVMDependency + Clone,
 {
     let error_block = context.append_basic_block("clamp_single_error");
     let join_block = context.append_basic_block("clamp_single_join");
diff --git a/src/project/contract/vyper/expression/instruction/create.rs b/src/project/contract/vyper/expression/instruction/create.rs
index 1e3d80c..d90fb1d 100644
--- a/src/project/contract/vyper/expression/instruction/create.rs
+++ b/src/project/contract/vyper/expression/instruction/create.rs
@@ -10,13 +10,13 @@
 /// of the forwarder's constructor.
 ///
 pub fn create<'ctx, D>(
-    context: &mut compiler_llvm_context::Context<'ctx, D>,
+    context: &mut compiler_llvm_context::EraVMContext<'ctx, D>,
     value: inkwell::values::IntValue<'ctx>,
     input_offset: inkwell::values::IntValue<'ctx>,
     salt: Option<inkwell::values::IntValue<'ctx>>,
 ) -> anyhow::Result<inkwell::values::BasicValueEnum<'ctx>>
 where
-    D: compiler_llvm_context::Dependency + Clone,
+    D: compiler_llvm_context::EraVMDependency + Clone,
 {
     let success_block = context.append_basic_block("create_success_block");
     let failure_block = context.append_basic_block("create_failure_block");
@@ -27,9 +27,9 @@ where
         context.field_const(19),
         "create_address_offset",
     );
-    let address_dirty_pointer = compiler_llvm_context::Pointer::new_with_offset(
+    let address_dirty_pointer = compiler_llvm_context::EraVMPointer::new_with_offset(
         context,
-        compiler_llvm_context::AddressSpace::Heap,
+        compiler_llvm_context::EraVMAddressSpace::Heap,
         context.field_type(),
         address_offset,
         "create_address_dirty_pointer",
@@ -45,10 +45,11 @@ where
         "create_address",
     );
 
-    let calldata_offset = context.field_const(compiler_llvm_context::HEAP_AUX_OFFSET_EXTERNAL_CALL);
+    let calldata_offset =
+        context.field_const(compiler_llvm_context::eravm_const::HEAP_AUX_OFFSET_EXTERNAL_CALL);
     let calldata_length = context.field_const(
-        (compiler_llvm_context::DEPLOYER_CALL_HEADER_SIZE + compiler_common::BYTE_LENGTH_FIELD)
-            as u64,
+        (compiler_llvm_context::eravm_const::DEPLOYER_CALL_HEADER_SIZE
+            + compiler_common::BYTE_LENGTH_FIELD) as u64,
     );
 
     let hash_input_offset = context.builder().build_int_add(
@@ -58,9 +59,9 @@ where
         ),
         "create_hash_input_offset",
     );
-    let hash_input_offset_pointer = compiler_llvm_context::Pointer::new_with_offset(
+    let hash_input_offset_pointer = compiler_llvm_context::EraVMPointer::new_with_offset(
         context,
-        compiler_llvm_context::AddressSpace::HeapAuxiliary,
+        compiler_llvm_context::EraVMAddressSpace::HeapAuxiliary,
         context.field_type(),
         hash_input_offset,
         "create_hash_input_offset_pointer",
@@ -73,12 +74,12 @@ where
 
     let address_input_offset = context.builder().build_int_add(
         calldata_offset,
-        context.field_const(compiler_llvm_context::DEPLOYER_CALL_HEADER_SIZE as u64),
+        context.field_const(compiler_llvm_context::eravm_const::DEPLOYER_CALL_HEADER_SIZE as u64),
         "create_address_input_offset",
     );
-    let address_input_offset_pointer = compiler_llvm_context::Pointer::new_with_offset(
+    let address_input_offset_pointer = compiler_llvm_context::EraVMPointer::new_with_offset(
         context,
-        compiler_llvm_context::AddressSpace::HeapAuxiliary,
+        compiler_llvm_context::EraVMAddressSpace::HeapAuxiliary,
         context.field_type(),
         address_input_offset,
         "create_address_input_offset_pointer",
@@ -88,16 +89,19 @@ where
     let result_pointer = context.build_alloca(context.field_type(), "create_result_pointer");
     context.build_store(result_pointer, context.field_const(0));
     let address_or_status_code = match salt {
-        Some(salt) => compiler_llvm_context::create::create2(
+        Some(salt) => compiler_llvm_context::eravm_evm_create::create2(
             context,
             value,
             calldata_offset,
             calldata_length,
             Some(salt),
         ),
-        None => {
-            compiler_llvm_context::create::create(context, value, calldata_offset, calldata_length)
-        }
+        None => compiler_llvm_context::eravm_evm_create::create(
+            context,
+            value,
+            calldata_offset,
+            calldata_length,
+        ),
     }?;
     let address_or_status_code_is_zero = context.builder().build_int_compare(
         inkwell::IntPredicate::EQ,
@@ -112,8 +116,9 @@ where
     context.build_unconditional_branch(join_block);
 
     context.set_basic_block(failure_block);
-    let return_data_size = context.get_global(compiler_llvm_context::GLOBAL_RETURN_DATA_SIZE)?;
-    compiler_llvm_context::return_data::copy(
+    let return_data_size =
+        context.get_global(compiler_llvm_context::eravm_const::GLOBAL_RETURN_DATA_SIZE)?;
+    compiler_llvm_context::eravm_evm_return_data::copy(
         context,
         context.field_const(0),
         context.field_const(0),
diff --git a/src/project/contract/vyper/expression/instruction/exit_to.rs b/src/project/contract/vyper/expression/instruction/exit_to.rs
index ad4c0cd..5c70cad 100644
--- a/src/project/contract/vyper/expression/instruction/exit_to.rs
+++ b/src/project/contract/vyper/expression/instruction/exit_to.rs
@@ -19,10 +19,10 @@ impl ExitTo {
     ///
     pub fn into_llvm_value<D>(
         mut self,
-        context: &mut compiler_llvm_context::Context<D>,
+        context: &mut compiler_llvm_context::EraVMContext<D>,
     ) -> anyhow::Result<()>
     where
-        D: compiler_llvm_context::Dependency + Clone,
+        D: compiler_llvm_context::EraVMDependency + Clone,
     {
         let label_name = self.0.remove(0).try_into_identifier()?;
         if label_name.as_str() == crate::r#const::VARIABLE_IDENTIFIER_RETURN_PC {
@@ -31,13 +31,7 @@ impl ExitTo {
         }
         let label_name = label_name
             .strip_prefix(crate::r#const::LABEL_DESTINATION_PREFIX)
-            .ok_or_else(|| {
-                anyhow::anyhow!(
-                    "Block `{}` has no `{}` prefix",
-                    label_name,
-                    crate::r#const::LABEL_DESTINATION_PREFIX
-                )
-            })?;
+            .unwrap_or(label_name.as_str());
 
         let block = context
             .current_function()
diff --git a/src/project/contract/vyper/expression/instruction/goto.rs b/src/project/contract/vyper/expression/instruction/goto.rs
index 3bfe802..dd83f95 100644
--- a/src/project/contract/vyper/expression/instruction/goto.rs
+++ b/src/project/contract/vyper/expression/instruction/goto.rs
@@ -26,11 +26,11 @@ impl Goto {
     ///
     pub fn into_function_call<'ctx, D>(
         self,
-        context: &mut compiler_llvm_context::Context<D>,
+        context: &mut compiler_llvm_context::EraVMContext<D>,
         label_name: String,
     ) -> anyhow::Result<Option<inkwell::values::BasicValueEnum<'ctx>>>
     where
-        D: compiler_llvm_context::Dependency + Clone,
+        D: compiler_llvm_context::EraVMDependency + Clone,
     {
         let function = context
             .get_function(label_name.as_str())
@@ -43,9 +43,9 @@ impl Goto {
                     continue;
                 }
             }
-
-            let value = expression.into_llvm_value(context)?.expect("Always exists");
-            arguments.push(value);
+            if let Some(value) = expression.into_llvm_value(context)? {
+                arguments.push(value);
+            }
         }
 
         context.build_call(
@@ -62,11 +62,11 @@ impl Goto {
     ///
     pub fn into_block_call<'ctx, D>(
         self,
-        context: &mut compiler_llvm_context::Context<D>,
+        context: &mut compiler_llvm_context::EraVMContext<D>,
         label_name: String,
     ) -> anyhow::Result<Option<inkwell::values::BasicValueEnum<'ctx>>>
     where
-        D: compiler_llvm_context::Dependency + Clone,
+        D: compiler_llvm_context::EraVMDependency + Clone,
     {
         let block = context
             .current_function()
@@ -106,10 +106,10 @@ impl Goto {
     ///
     pub fn into_llvm_value<'ctx, D>(
         mut self,
-        context: &mut compiler_llvm_context::Context<D>,
+        context: &mut compiler_llvm_context::EraVMContext<D>,
     ) -> anyhow::Result<Option<inkwell::values::BasicValueEnum<'ctx>>>
     where
-        D: compiler_llvm_context::Dependency + Clone,
+        D: compiler_llvm_context::EraVMDependency + Clone,
     {
         let label_name = self.0.remove(0).try_into_identifier()?;
 
diff --git a/src/project/contract/vyper/expression/instruction/if.rs b/src/project/contract/vyper/expression/instruction/if.rs
index 8d75286..aa7dd71 100644
--- a/src/project/contract/vyper/expression/instruction/if.rs
+++ b/src/project/contract/vyper/expression/instruction/if.rs
@@ -36,10 +36,10 @@ impl If {
     ///
     pub fn into_llvm_value<'ctx, D>(
         mut self,
-        context: &mut compiler_llvm_context::Context<'ctx, D>,
+        context: &mut compiler_llvm_context::EraVMContext<'ctx, D>,
     ) -> anyhow::Result<Option<inkwell::values::BasicValueEnum<'ctx>>>
     where
-        D: compiler_llvm_context::Dependency + Clone,
+        D: compiler_llvm_context::EraVMDependency + Clone,
     {
         let main_block = context.append_basic_block("if_main");
         let join_block = context.append_basic_block("if_join");
diff --git a/src/project/contract/vyper/expression/instruction/immutable.rs b/src/project/contract/vyper/expression/instruction/immutable.rs
index 4562fd5..6f0b95c 100644
--- a/src/project/contract/vyper/expression/instruction/immutable.rs
+++ b/src/project/contract/vyper/expression/instruction/immutable.rs
@@ -9,13 +9,13 @@
 /// from the immutable storage system contract to the heap.
 ///
 pub fn load_bytes<'ctx, D>(
-    context: &mut compiler_llvm_context::Context<'ctx, D>,
+    context: &mut compiler_llvm_context::EraVMContext<'ctx, D>,
     heap_offset: inkwell::values::IntValue<'ctx>,
     immutable_offset: inkwell::values::IntValue<'ctx>,
     length: inkwell::values::IntValue<'ctx>,
 ) -> anyhow::Result<()>
 where
-    D: compiler_llvm_context::Dependency + Clone,
+    D: compiler_llvm_context::EraVMDependency + Clone,
 {
     let condition_block = context.append_basic_block("immutable_load_bytes_repeat_condition");
     let body_block = context.append_basic_block("immutable_load_bytes_repeat_body");
@@ -57,16 +57,18 @@ where
         immutable_offset_pointer,
         "immutable_load_bytes_immutable_offset_value",
     );
-    let immutable_value =
-        compiler_llvm_context::immutable::load(context, immutable_offset_value.into_int_value())?;
+    let immutable_value = compiler_llvm_context::eravm_evm_immutable::load(
+        context,
+        immutable_offset_value.into_int_value(),
+    )?;
 
     let heap_offset_value = context.build_load(
         heap_offset_pointer,
         "immutable_load_bytes_heap_offset_value",
     );
-    let heap_pointer = compiler_llvm_context::Pointer::new_with_offset(
+    let heap_pointer = compiler_llvm_context::EraVMPointer::new_with_offset(
         context,
-        compiler_llvm_context::AddressSpace::Heap,
+        compiler_llvm_context::EraVMAddressSpace::Heap,
         context.field_type(),
         heap_offset_value.into_int_value(),
         "immutable_load_bytes_heap_pointer",
diff --git a/src/project/contract/vyper/expression/instruction/label.rs b/src/project/contract/vyper/expression/instruction/label.rs
index 3cb3283..fdcd18e 100644
--- a/src/project/contract/vyper/expression/instruction/label.rs
+++ b/src/project/contract/vyper/expression/instruction/label.rs
@@ -98,9 +98,12 @@ impl Label {
     ///
     /// Declares the label block, so all the blocks are predeclared before translating the bodies.
     ///
-    pub fn declare<D>(&self, context: &mut compiler_llvm_context::Context<D>) -> anyhow::Result<()>
+    pub fn declare<D>(
+        &self,
+        context: &mut compiler_llvm_context::EraVMContext<D>,
+    ) -> anyhow::Result<()>
     where
-        D: compiler_llvm_context::Dependency + Clone,
+        D: compiler_llvm_context::EraVMDependency + Clone,
     {
         if self.is_empty() || self.can_block_be_ignored() {
             return Ok(());
@@ -156,10 +159,10 @@ impl Label {
     ///
     pub fn into_llvm_value<D>(
         mut self,
-        context: &mut compiler_llvm_context::Context<D>,
+        context: &mut compiler_llvm_context::EraVMContext<D>,
     ) -> anyhow::Result<()>
     where
-        D: compiler_llvm_context::Dependency + Clone,
+        D: compiler_llvm_context::EraVMDependency + Clone,
     {
         if self.is_empty() || self.can_block_be_ignored() {
             return Ok(());
@@ -194,7 +197,7 @@ impl Label {
             && label_name.ends_with(crate::r#const::LABEL_SUFFIX_CLEANUP)
             && is_block_empty_sequence
         {
-            compiler_llvm_context::r#return::stop(context)?;
+            compiler_llvm_context::eravm_evm_return::stop(context)?;
         }
 
         context.set_basic_block(current_block);
diff --git a/src/project/contract/vyper/expression/instruction/mod.rs b/src/project/contract/vyper/expression/instruction/mod.rs
index 1f06f71..a227f72 100644
--- a/src/project/contract/vyper/expression/instruction/mod.rs
+++ b/src/project/contract/vyper/expression/instruction/mod.rs
@@ -78,6 +78,8 @@ pub enum Instruction {
     Pass,
     /// The LLL IR `deploy` instruction.
     Deploy(Deploy),
+    /// The LLL IR `symbol` instruction.
+    Symbol([Box<Expression>; 1]),
     /// The LLL IR `unique_symbol` instruction.
     Unique_Symbol([Box<Expression>; 1]),
 
@@ -321,10 +323,10 @@ impl Instruction {
     ///
     fn translate_arguments_llvm<'ctx, D, const N: usize>(
         arguments: [Box<Expression>; N],
-        context: &mut compiler_llvm_context::Context<'ctx, D>,
+        context: &mut compiler_llvm_context::EraVMContext<'ctx, D>,
     ) -> anyhow::Result<[inkwell::values::BasicValueEnum<'ctx>; N]>
     where
-        D: compiler_llvm_context::Dependency + Clone,
+        D: compiler_llvm_context::EraVMDependency + Clone,
     {
         let debug_string = format!("`{arguments:?}`");
 
@@ -391,10 +393,10 @@ impl Instruction {
     ///
     pub fn into_llvm_value<'ctx, D>(
         self,
-        context: &mut compiler_llvm_context::Context<'ctx, D>,
+        context: &mut compiler_llvm_context::EraVMContext<'ctx, D>,
     ) -> anyhow::Result<Option<inkwell::values::BasicValueEnum<'ctx>>>
     where
-        D: compiler_llvm_context::Dependency + Clone,
+        D: compiler_llvm_context::EraVMDependency + Clone,
     {
         match self {
             Self::With(inner) => inner.into_llvm_value(context),
@@ -425,6 +427,7 @@ impl Instruction {
             }
             Self::Pass => Ok(None),
             Self::Deploy(_inner) => Ok(None),
+            Self::Symbol(_inner) => Ok(None),
             Self::Unique_Symbol(_inner) => Ok(None),
 
             Self::UCLAMP(arguments) => {
@@ -572,7 +575,7 @@ impl Instruction {
 
             Self::ADD(arguments) => {
                 let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;
-                compiler_llvm_context::arithmetic::addition(
+                compiler_llvm_context::eravm_evm_arithmetic::addition(
                     context,
                     arguments[0].into_int_value(),
                     arguments[1].into_int_value(),
@@ -581,7 +584,7 @@ impl Instruction {
             }
             Self::SUB(arguments) => {
                 let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;
-                compiler_llvm_context::arithmetic::subtraction(
+                compiler_llvm_context::eravm_evm_arithmetic::subtraction(
                     context,
                     arguments[0].into_int_value(),
                     arguments[1].into_int_value(),
@@ -590,7 +593,7 @@ impl Instruction {
             }
             Self::MUL(arguments) => {
                 let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;
-                compiler_llvm_context::arithmetic::multiplication(
+                compiler_llvm_context::eravm_evm_arithmetic::multiplication(
                     context,
                     arguments[0].into_int_value(),
                     arguments[1].into_int_value(),
@@ -599,7 +602,7 @@ impl Instruction {
             }
             Self::DIV(arguments) => {
                 let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;
-                compiler_llvm_context::arithmetic::division(
+                compiler_llvm_context::eravm_evm_arithmetic::division(
                     context,
                     arguments[0].into_int_value(),
                     arguments[1].into_int_value(),
@@ -608,7 +611,7 @@ impl Instruction {
             }
             Self::MOD(arguments) => {
                 let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;
-                compiler_llvm_context::arithmetic::remainder(
+                compiler_llvm_context::eravm_evm_arithmetic::remainder(
                     context,
                     arguments[0].into_int_value(),
                     arguments[1].into_int_value(),
@@ -617,7 +620,7 @@ impl Instruction {
             }
             Self::SDIV(arguments) => {
                 let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;
-                compiler_llvm_context::arithmetic::division_signed(
+                compiler_llvm_context::eravm_evm_arithmetic::division_signed(
                     context,
                     arguments[0].into_int_value(),
                     arguments[1].into_int_value(),
@@ -626,7 +629,7 @@ impl Instruction {
             }
             Self::SMOD(arguments) => {
                 let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;
-                compiler_llvm_context::arithmetic::remainder_signed(
+                compiler_llvm_context::eravm_evm_arithmetic::remainder_signed(
                     context,
                     arguments[0].into_int_value(),
                     arguments[1].into_int_value(),
@@ -636,7 +639,7 @@ impl Instruction {
 
             Self::LT(arguments) => {
                 let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;
-                compiler_llvm_context::comparison::compare(
+                compiler_llvm_context::eravm_evm_comparison::compare(
                     context,
                     arguments[0].into_int_value(),
                     arguments[1].into_int_value(),
@@ -646,7 +649,7 @@ impl Instruction {
             }
             Self::LE(arguments) => {
                 let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;
-                compiler_llvm_context::comparison::compare(
+                compiler_llvm_context::eravm_evm_comparison::compare(
                     context,
                     arguments[0].into_int_value(),
                     arguments[1].into_int_value(),
@@ -656,7 +659,7 @@ impl Instruction {
             }
             Self::GT(arguments) => {
                 let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;
-                compiler_llvm_context::comparison::compare(
+                compiler_llvm_context::eravm_evm_comparison::compare(
                     context,
                     arguments[0].into_int_value(),
                     arguments[1].into_int_value(),
@@ -666,7 +669,7 @@ impl Instruction {
             }
             Self::GE(arguments) => {
                 let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;
-                compiler_llvm_context::comparison::compare(
+                compiler_llvm_context::eravm_evm_comparison::compare(
                     context,
                     arguments[0].into_int_value(),
                     arguments[1].into_int_value(),
@@ -676,7 +679,7 @@ impl Instruction {
             }
             Self::EQ(arguments) => {
                 let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;
-                compiler_llvm_context::comparison::compare(
+                compiler_llvm_context::eravm_evm_comparison::compare(
                     context,
                     arguments[0].into_int_value(),
                     arguments[1].into_int_value(),
@@ -686,7 +689,7 @@ impl Instruction {
             }
             Self::NE(arguments) => {
                 let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;
-                compiler_llvm_context::comparison::compare(
+                compiler_llvm_context::eravm_evm_comparison::compare(
                     context,
                     arguments[0].into_int_value(),
                     arguments[1].into_int_value(),
@@ -696,7 +699,7 @@ impl Instruction {
             }
             Self::ISZERO(arguments) => {
                 let arguments = Self::translate_arguments_llvm::<D, 1>(arguments, context)?;
-                compiler_llvm_context::comparison::compare(
+                compiler_llvm_context::eravm_evm_comparison::compare(
                     context,
                     arguments[0].into_int_value(),
                     context.field_const(0),
@@ -706,7 +709,7 @@ impl Instruction {
             }
             Self::SLT(arguments) => {
                 let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;
-                compiler_llvm_context::comparison::compare(
+                compiler_llvm_context::eravm_evm_comparison::compare(
                     context,
                     arguments[0].into_int_value(),
                     arguments[1].into_int_value(),
@@ -716,7 +719,7 @@ impl Instruction {
             }
             Self::SLE(arguments) => {
                 let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;
-                compiler_llvm_context::comparison::compare(
+                compiler_llvm_context::eravm_evm_comparison::compare(
                     context,
                     arguments[0].into_int_value(),
                     arguments[1].into_int_value(),
@@ -726,7 +729,7 @@ impl Instruction {
             }
             Self::SGT(arguments) => {
                 let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;
-                compiler_llvm_context::comparison::compare(
+                compiler_llvm_context::eravm_evm_comparison::compare(
                     context,
                     arguments[0].into_int_value(),
                     arguments[1].into_int_value(),
@@ -736,7 +739,7 @@ impl Instruction {
             }
             Self::SGE(arguments) => {
                 let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;
-                compiler_llvm_context::comparison::compare(
+                compiler_llvm_context::eravm_evm_comparison::compare(
                     context,
                     arguments[0].into_int_value(),
                     arguments[1].into_int_value(),
@@ -747,7 +750,7 @@ impl Instruction {
 
             Self::OR(arguments) => {
                 let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;
-                compiler_llvm_context::bitwise::or(
+                compiler_llvm_context::eravm_evm_bitwise::or(
                     context,
                     arguments[0].into_int_value(),
                     arguments[1].into_int_value(),
@@ -756,7 +759,7 @@ impl Instruction {
             }
             Self::XOR(arguments) => {
                 let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;
-                compiler_llvm_context::bitwise::xor(
+                compiler_llvm_context::eravm_evm_bitwise::xor(
                     context,
                     arguments[0].into_int_value(),
                     arguments[1].into_int_value(),
@@ -765,7 +768,7 @@ impl Instruction {
             }
             Self::NOT(arguments) => {
                 let arguments = Self::translate_arguments_llvm::<D, 1>(arguments, context)?;
-                compiler_llvm_context::bitwise::xor(
+                compiler_llvm_context::eravm_evm_bitwise::xor(
                     context,
                     arguments[0].into_int_value(),
                     context.field_type().const_all_ones(),
@@ -774,7 +777,7 @@ impl Instruction {
             }
             Self::AND(arguments) => {
                 let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;
-                compiler_llvm_context::bitwise::and(
+                compiler_llvm_context::eravm_evm_bitwise::and(
                     context,
                     arguments[0].into_int_value(),
                     arguments[1].into_int_value(),
@@ -783,7 +786,7 @@ impl Instruction {
             }
             Self::SHL(arguments) => {
                 let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;
-                compiler_llvm_context::bitwise::shift_left(
+                compiler_llvm_context::eravm_evm_bitwise::shift_left(
                     context,
                     arguments[0].into_int_value(),
                     arguments[1].into_int_value(),
@@ -792,7 +795,7 @@ impl Instruction {
             }
             Self::SHR(arguments) => {
                 let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;
-                compiler_llvm_context::bitwise::shift_right(
+                compiler_llvm_context::eravm_evm_bitwise::shift_right(
                     context,
                     arguments[0].into_int_value(),
                     arguments[1].into_int_value(),
@@ -801,7 +804,7 @@ impl Instruction {
             }
             Self::SAR(arguments) => {
                 let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;
-                compiler_llvm_context::bitwise::shift_right_arithmetic(
+                compiler_llvm_context::eravm_evm_bitwise::shift_right_arithmetic(
                     context,
                     arguments[0].into_int_value(),
                     arguments[1].into_int_value(),
@@ -810,7 +813,7 @@ impl Instruction {
             }
             Self::BYTE(arguments) => {
                 let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;
-                compiler_llvm_context::bitwise::byte(
+                compiler_llvm_context::eravm_evm_bitwise::byte(
                     context,
                     arguments[0].into_int_value(),
                     arguments[1].into_int_value(),
@@ -820,7 +823,7 @@ impl Instruction {
 
             Self::ADDMOD(arguments) => {
                 let arguments = Self::translate_arguments_llvm::<D, 3>(arguments, context)?;
-                compiler_llvm_context::math::add_mod(
+                compiler_llvm_context::eravm_evm_math::add_mod(
                     context,
                     arguments[0].into_int_value(),
                     arguments[1].into_int_value(),
@@ -830,7 +833,7 @@ impl Instruction {
             }
             Self::MULMOD(arguments) => {
                 let arguments = Self::translate_arguments_llvm::<D, 3>(arguments, context)?;
-                compiler_llvm_context::math::mul_mod(
+                compiler_llvm_context::eravm_evm_math::mul_mod(
                     context,
                     arguments[0].into_int_value(),
                     arguments[1].into_int_value(),
@@ -840,7 +843,7 @@ impl Instruction {
             }
             Self::EXP(arguments) => {
                 let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;
-                compiler_llvm_context::math::exponent(
+                compiler_llvm_context::eravm_evm_math::exponent(
                     context,
                     arguments[0].into_int_value(),
                     arguments[1].into_int_value(),
@@ -849,7 +852,7 @@ impl Instruction {
             }
             Self::SIGNEXTEND(arguments) => {
                 let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;
-                compiler_llvm_context::math::sign_extend(
+                compiler_llvm_context::eravm_evm_math::sign_extend(
                     context,
                     arguments[0].into_int_value(),
                     arguments[1].into_int_value(),
@@ -862,7 +865,7 @@ impl Instruction {
                 let input_offset = arguments[0].into_int_value();
                 let input_length = arguments[1].into_int_value();
 
-                let function = compiler_llvm_context::Runtime::keccak256(context);
+                let function = compiler_llvm_context::EraVMRuntime::keccak256(context);
                 Ok(context.build_call(
                     function,
                     &[
@@ -875,16 +878,16 @@ impl Instruction {
             Self::SHA3_32(arguments) => {
                 let arguments = Self::translate_arguments_llvm::<D, 1>(arguments, context)?;
 
-                let pointer_one = compiler_llvm_context::Pointer::new_with_offset(
+                let pointer_one = compiler_llvm_context::EraVMPointer::new_with_offset(
                     context,
-                    compiler_llvm_context::AddressSpace::Heap,
+                    compiler_llvm_context::EraVMAddressSpace::Heap,
                     context.field_type(),
                     context.field_const(crate::r#const::OFFSET_FREE_VAR_SPACE as u64),
                     "sha3_pointer_one",
                 );
                 context.build_store(pointer_one, arguments[0]);
 
-                let function = compiler_llvm_context::Runtime::keccak256(context);
+                let function = compiler_llvm_context::EraVMRuntime::keccak256(context);
                 Ok(context.build_call(
                     function,
                     &[
@@ -901,24 +904,24 @@ impl Instruction {
             Self::SHA3_64(arguments) => {
                 let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;
 
-                let pointer_one = compiler_llvm_context::Pointer::new_with_offset(
+                let pointer_one = compiler_llvm_context::EraVMPointer::new_with_offset(
                     context,
-                    compiler_llvm_context::AddressSpace::Heap,
+                    compiler_llvm_context::EraVMAddressSpace::Heap,
                     context.field_type(),
                     context.field_const(crate::r#const::OFFSET_FREE_VAR_SPACE as u64),
                     "sha3_pointer_one",
                 );
                 context.build_store(pointer_one, arguments[0]);
-                let pointer_two = compiler_llvm_context::Pointer::new_with_offset(
+                let pointer_two = compiler_llvm_context::EraVMPointer::new_with_offset(
                     context,
-                    compiler_llvm_context::AddressSpace::Heap,
+                    compiler_llvm_context::EraVMAddressSpace::Heap,
                     context.field_type(),
                     context.field_const(crate::r#const::OFFSET_FREE_VAR_SPACE2 as u64),
                     "sha3_pointer_two",
                 );
                 context.build_store(pointer_two, arguments[1]);
 
-                let function = compiler_llvm_context::Runtime::keccak256(context);
+                let function = compiler_llvm_context::EraVMRuntime::keccak256(context);
                 Ok(context.build_call(
                     function,
                     &[
@@ -935,12 +938,15 @@ impl Instruction {
 
             Self::MLOAD(arguments) => {
                 let arguments = Self::translate_arguments_llvm::<D, 1>(arguments, context)?;
-                compiler_llvm_context::memory::load(context, arguments[0].into_int_value())
-                    .map(Some)
+                compiler_llvm_context::eravm_evm_memory::load(
+                    context,
+                    arguments[0].into_int_value(),
+                )
+                .map(Some)
             }
             Self::MSTORE(arguments) => {
                 let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;
-                compiler_llvm_context::memory::store(
+                compiler_llvm_context::eravm_evm_memory::store(
                     context,
                     arguments[0].into_int_value(),
                     arguments[1].into_int_value(),
@@ -949,7 +955,7 @@ impl Instruction {
             }
             Self::MSTORE8(arguments) => {
                 let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;
-                compiler_llvm_context::memory::store_byte(
+                compiler_llvm_context::eravm_evm_memory::store_byte(
                     context,
                     arguments[0].into_int_value(),
                     arguments[1].into_int_value(),
@@ -959,12 +965,15 @@ impl Instruction {
 
             Self::SLOAD(arguments) => {
                 let arguments = Self::translate_arguments_llvm::<D, 1>(arguments, context)?;
-                compiler_llvm_context::storage::load(context, arguments[0].into_int_value())
-                    .map(Some)
+                compiler_llvm_context::eravm_evm_storage::load(
+                    context,
+                    arguments[0].into_int_value(),
+                )
+                .map(Some)
             }
             Self::SSTORE(arguments) => {
                 let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;
-                compiler_llvm_context::storage::store(
+                compiler_llvm_context::eravm_evm_storage::store(
                     context,
                     arguments[0].into_int_value(),
                     arguments[1].into_int_value(),
@@ -974,12 +983,15 @@ impl Instruction {
 
             Self::ILOAD(arguments) => {
                 let arguments = Self::translate_arguments_llvm::<D, 1>(arguments, context)?;
-                compiler_llvm_context::immutable::load(context, arguments[0].into_int_value())
-                    .map(Some)
+                compiler_llvm_context::eravm_evm_immutable::load(
+                    context,
+                    arguments[0].into_int_value(),
+                )
+                .map(Some)
             }
             Self::ISTORE(arguments) => {
                 let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;
-                compiler_llvm_context::immutable::store(
+                compiler_llvm_context::eravm_evm_immutable::store(
                     context,
                     arguments[0].into_int_value(),
                     arguments[1].into_int_value(),
@@ -994,11 +1006,11 @@ impl Instruction {
                     .code_type()
                     .ok_or_else(|| anyhow::anyhow!("The contract code part type is undefined"))?
                 {
-                    compiler_llvm_context::CodeType::Deploy => {
+                    compiler_llvm_context::EraVMCodeType::Deploy => {
                         Ok(Some(context.field_const(0).as_basic_value_enum()))
                     }
-                    compiler_llvm_context::CodeType::Runtime => {
-                        compiler_llvm_context::calldata::load(
+                    compiler_llvm_context::EraVMCodeType::Runtime => {
+                        compiler_llvm_context::eravm_evm_calldata::load(
                             context,
                             arguments[0].into_int_value(),
                         )
@@ -1011,11 +1023,11 @@ impl Instruction {
                     .code_type()
                     .ok_or_else(|| anyhow::anyhow!("The contract code part type is undefined"))?
                 {
-                    compiler_llvm_context::CodeType::Deploy => {
+                    compiler_llvm_context::EraVMCodeType::Deploy => {
                         Ok(Some(context.field_const(0).as_basic_value_enum()))
                     }
-                    compiler_llvm_context::CodeType::Runtime => {
-                        compiler_llvm_context::calldata::size(context).map(Some)
+                    compiler_llvm_context::EraVMCodeType::Runtime => {
+                        compiler_llvm_context::eravm_evm_calldata::size(context).map(Some)
                     }
                 }
             }
@@ -1026,16 +1038,16 @@ impl Instruction {
                     .code_type()
                     .ok_or_else(|| anyhow::anyhow!("The contract code part type is undefined"))?
                 {
-                    compiler_llvm_context::CodeType::Deploy => {
-                        compiler_llvm_context::calldata::size(context)?
+                    compiler_llvm_context::EraVMCodeType::Deploy => {
+                        compiler_llvm_context::eravm_evm_calldata::size(context)?
                     }
-                    compiler_llvm_context::CodeType::Runtime => {
+                    compiler_llvm_context::EraVMCodeType::Runtime => {
                         arguments[1].into_int_value().as_basic_value_enum()
                     }
                 }
                 .into_int_value();
 
-                compiler_llvm_context::calldata::copy(
+                compiler_llvm_context::eravm_evm_calldata::copy(
                     context,
                     arguments[0].into_int_value(),
                     source_offset,
@@ -1052,14 +1064,14 @@ impl Instruction {
                             "Immutables are not available if the contract part is undefined"
                         );
                     }
-                    Some(compiler_llvm_context::CodeType::Deploy) => {
-                        compiler_llvm_context::calldata::load(
+                    Some(compiler_llvm_context::EraVMCodeType::Deploy) => {
+                        compiler_llvm_context::eravm_evm_calldata::load(
                             context,
                             arguments[0].into_int_value(),
                         )
                     }
-                    Some(compiler_llvm_context::CodeType::Runtime) => {
-                        compiler_llvm_context::immutable::load(
+                    Some(compiler_llvm_context::EraVMCodeType::Runtime) => {
+                        compiler_llvm_context::eravm_evm_immutable::load(
                             context,
                             arguments[0].into_int_value(),
                         )
@@ -1076,15 +1088,15 @@ impl Instruction {
                             "Immutables are not available if the contract part is undefined"
                         );
                     }
-                    Some(compiler_llvm_context::CodeType::Deploy) => {
-                        compiler_llvm_context::calldata::copy(
+                    Some(compiler_llvm_context::EraVMCodeType::Deploy) => {
+                        compiler_llvm_context::eravm_evm_calldata::copy(
                             context,
                             arguments[0].into_int_value(),
                             arguments[1].into_int_value(),
                             arguments[2].into_int_value(),
                         )
                     }
-                    Some(compiler_llvm_context::CodeType::Runtime) => immutable::load_bytes(
+                    Some(compiler_llvm_context::EraVMCodeType::Runtime) => immutable::load_bytes(
                         context,
                         arguments[0].into_int_value(),
                         arguments[1].into_int_value(),
@@ -1098,19 +1110,22 @@ impl Instruction {
                     .code_type()
                     .ok_or_else(|| anyhow::anyhow!("The contract code part type is undefined"))?
                 {
-                    compiler_llvm_context::CodeType::Deploy => {
-                        compiler_llvm_context::calldata::size(context).map(Some)
+                    compiler_llvm_context::EraVMCodeType::Deploy => {
+                        compiler_llvm_context::eravm_evm_calldata::size(context).map(Some)
                     }
-                    compiler_llvm_context::CodeType::Runtime => {
+                    compiler_llvm_context::EraVMCodeType::Runtime => {
                         let code_source =
-                            compiler_llvm_context::zkevm_general::code_source(context)?;
-                        compiler_llvm_context::ext_code::size(context, code_source.into_int_value())
-                            .map(Some)
+                            compiler_llvm_context::eravm_general::code_source(context)?;
+                        compiler_llvm_context::eravm_evm_ext_code::size(
+                            context,
+                            code_source.into_int_value(),
+                        )
+                        .map(Some)
                     }
                 }
             }
             Self::CODECOPY(arguments) => {
-                if let compiler_llvm_context::CodeType::Runtime = context
+                if let compiler_llvm_context::EraVMCodeType::Runtime = context
                     .code_type()
                     .ok_or_else(|| anyhow::anyhow!("The contract code part type is undefined"))?
                 {
@@ -1120,7 +1135,7 @@ impl Instruction {
                 }
 
                 let arguments = Self::translate_arguments_llvm::<D, 3>(arguments, context)?;
-                compiler_llvm_context::calldata::copy(
+                compiler_llvm_context::eravm_evm_calldata::copy(
                     context,
                     arguments[0].into_int_value(),
                     arguments[1].into_int_value(),
@@ -1128,10 +1143,12 @@ impl Instruction {
                 )
                 .map(|_| None)
             }
-            Self::RETURNDATASIZE => compiler_llvm_context::return_data::size(context).map(Some),
+            Self::RETURNDATASIZE => {
+                compiler_llvm_context::eravm_evm_return_data::size(context).map(Some)
+            }
             Self::RETURNDATACOPY(arguments) => {
                 let arguments = Self::translate_arguments_llvm::<D, 3>(arguments, context)?;
-                compiler_llvm_context::return_data::copy(
+                compiler_llvm_context::eravm_evm_return_data::copy(
                     context,
                     arguments[0].into_int_value(),
                     arguments[1].into_int_value(),
@@ -1141,23 +1158,31 @@ impl Instruction {
             }
             Self::EXTCODESIZE(arguments) => {
                 let arguments = Self::translate_arguments_llvm::<D, 1>(arguments, context)?;
-                compiler_llvm_context::ext_code::size(context, arguments[0].into_int_value())
-                    .map(Some)
+                compiler_llvm_context::eravm_evm_ext_code::size(
+                    context,
+                    arguments[0].into_int_value(),
+                )
+                .map(Some)
             }
             Self::EXTCODEHASH(arguments) => {
                 let arguments = Self::translate_arguments_llvm::<D, 1>(arguments, context)?;
-                compiler_llvm_context::ext_code::hash(context, arguments[0].into_int_value())
-                    .map(Some)
+                compiler_llvm_context::eravm_evm_ext_code::hash(
+                    context,
+                    arguments[0].into_int_value(),
+                )
+                .map(Some)
             }
 
             Self::RETURN(inner) => inner.into_llvm_value(context).map(|_| None),
             Self::REVERT(inner) => inner.into_llvm_value(context).map(|_| None),
-            Self::STOP => compiler_llvm_context::r#return::stop(context).map(|_| None),
-            Self::INVALID => compiler_llvm_context::r#return::invalid(context).map(|_| None),
+            Self::STOP => compiler_llvm_context::eravm_evm_return::stop(context).map(|_| None),
+            Self::INVALID => {
+                compiler_llvm_context::eravm_evm_return::invalid(context).map(|_| None)
+            }
 
             Self::LOG0(arguments) => {
                 let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;
-                compiler_llvm_context::event::log(
+                compiler_llvm_context::eravm_evm_event::log(
                     context,
                     arguments[0].into_int_value(),
                     arguments[1].into_int_value(),
@@ -1167,7 +1192,7 @@ impl Instruction {
             }
             Self::LOG1(arguments) => {
                 let arguments = Self::translate_arguments_llvm::<D, 3>(arguments, context)?;
-                compiler_llvm_context::event::log(
+                compiler_llvm_context::eravm_evm_event::log(
                     context,
                     arguments[0].into_int_value(),
                     arguments[1].into_int_value(),
@@ -1180,7 +1205,7 @@ impl Instruction {
             }
             Self::LOG2(arguments) => {
                 let arguments = Self::translate_arguments_llvm::<D, 4>(arguments, context)?;
-                compiler_llvm_context::event::log(
+                compiler_llvm_context::eravm_evm_event::log(
                     context,
                     arguments[0].into_int_value(),
                     arguments[1].into_int_value(),
@@ -1193,7 +1218,7 @@ impl Instruction {
             }
             Self::LOG3(arguments) => {
                 let arguments = Self::translate_arguments_llvm::<D, 5>(arguments, context)?;
-                compiler_llvm_context::event::log(
+                compiler_llvm_context::eravm_evm_event::log(
                     context,
                     arguments[0].into_int_value(),
                     arguments[1].into_int_value(),
@@ -1206,7 +1231,7 @@ impl Instruction {
             }
             Self::LOG4(arguments) => {
                 let arguments = Self::translate_arguments_llvm::<D, 6>(arguments, context)?;
-                compiler_llvm_context::event::log(
+                compiler_llvm_context::eravm_evm_event::log(
                     context,
                     arguments[0].into_int_value(),
                     arguments[1].into_int_value(),
@@ -1229,7 +1254,7 @@ impl Instruction {
                 let output_offset = arguments[5].into_int_value();
                 let output_size = arguments[6].into_int_value();
 
-                compiler_llvm_context::call::default(
+                compiler_llvm_context::eravm_evm_call::default(
                     context,
                     context.llvm_runtime().far_call,
                     gas,
@@ -1253,7 +1278,7 @@ impl Instruction {
                 let output_offset = arguments[4].into_int_value();
                 let output_size = arguments[5].into_int_value();
 
-                compiler_llvm_context::call::default(
+                compiler_llvm_context::eravm_evm_call::default(
                     context,
                     context.llvm_runtime().static_call,
                     gas,
@@ -1277,7 +1302,7 @@ impl Instruction {
                 let output_offset = arguments[4].into_int_value();
                 let output_size = arguments[5].into_int_value();
 
-                compiler_llvm_context::call::default(
+                compiler_llvm_context::eravm_evm_call::default(
                     context,
                     context.llvm_runtime().delegate_call,
                     gas,
@@ -1318,13 +1343,13 @@ impl Instruction {
             Self::ADDRESS => Ok(context.build_call(context.intrinsics().address, &[], "address")),
             Self::CALLER => Ok(context.build_call(context.intrinsics().caller, &[], "caller")),
 
-            Self::CALLVALUE => compiler_llvm_context::ether_gas::value(context).map(Some),
-            Self::GAS => compiler_llvm_context::ether_gas::gas(context).map(Some),
+            Self::CALLVALUE => compiler_llvm_context::eravm_evm_ether_gas::value(context).map(Some),
+            Self::GAS => compiler_llvm_context::eravm_evm_ether_gas::gas(context).map(Some),
             Self::BALANCE(arguments) => {
                 let arguments = Self::translate_arguments_llvm::<D, 1>(arguments, context)?;
 
                 let address = arguments[0].into_int_value();
-                compiler_llvm_context::ether_gas::balance(context, address).map(Some)
+                compiler_llvm_context::eravm_evm_ether_gas::balance(context, address).map(Some)
             }
             Self::SELFBALANCE => {
                 let address = context
@@ -1332,31 +1357,47 @@ impl Instruction {
                     .expect("Always exists")
                     .into_int_value();
 
-                compiler_llvm_context::ether_gas::balance(context, address).map(Some)
+                compiler_llvm_context::eravm_evm_ether_gas::balance(context, address).map(Some)
             }
 
-            Self::GASLIMIT => compiler_llvm_context::contract_context::gas_limit(context).map(Some),
-            Self::GASPRICE => compiler_llvm_context::contract_context::gas_price(context).map(Some),
-            Self::ORIGIN => compiler_llvm_context::contract_context::origin(context).map(Some),
-            Self::CHAINID => compiler_llvm_context::contract_context::chain_id(context).map(Some),
+            Self::GASLIMIT => {
+                compiler_llvm_context::eravm_evm_contract_context::gas_limit(context).map(Some)
+            }
+            Self::GASPRICE => {
+                compiler_llvm_context::eravm_evm_contract_context::gas_price(context).map(Some)
+            }
+            Self::ORIGIN => {
+                compiler_llvm_context::eravm_evm_contract_context::origin(context).map(Some)
+            }
+            Self::CHAINID => {
+                compiler_llvm_context::eravm_evm_contract_context::chain_id(context).map(Some)
+            }
             Self::NUMBER => {
-                compiler_llvm_context::contract_context::block_number(context).map(Some)
+                compiler_llvm_context::eravm_evm_contract_context::block_number(context).map(Some)
             }
             Self::TIMESTAMP => {
-                compiler_llvm_context::contract_context::block_timestamp(context).map(Some)
+                compiler_llvm_context::eravm_evm_contract_context::block_timestamp(context)
+                    .map(Some)
             }
             Self::BLOCKHASH(arguments) => {
                 let arguments = Self::translate_arguments_llvm::<D, 1>(arguments, context)?;
                 let index = arguments[0].into_int_value();
 
-                compiler_llvm_context::contract_context::block_hash(context, index).map(Some)
+                compiler_llvm_context::eravm_evm_contract_context::block_hash(context, index)
+                    .map(Some)
             }
             Self::DIFFICULTY => {
-                compiler_llvm_context::contract_context::difficulty(context).map(Some)
+                compiler_llvm_context::eravm_evm_contract_context::difficulty(context).map(Some)
+            }
+            Self::COINBASE => {
+                compiler_llvm_context::eravm_evm_contract_context::coinbase(context).map(Some)
+            }
+            Self::BASEFEE => {
+                compiler_llvm_context::eravm_evm_contract_context::basefee(context).map(Some)
+            }
+            Self::MSIZE => {
+                compiler_llvm_context::eravm_evm_contract_context::msize(context).map(Some)
             }
-            Self::COINBASE => compiler_llvm_context::contract_context::coinbase(context).map(Some),
-            Self::BASEFEE => compiler_llvm_context::contract_context::basefee(context).map(Some),
-            Self::MSIZE => compiler_llvm_context::contract_context::msize(context).map(Some),
 
             Self::CALLCODE(arguments) => {
                 let _arguments = Self::translate_arguments_llvm::<D, 7>(arguments, context)?;
diff --git a/src/project/contract/vyper/expression/instruction/offset.rs b/src/project/contract/vyper/expression/instruction/offset.rs
index df12a87..b159038 100644
--- a/src/project/contract/vyper/expression/instruction/offset.rs
+++ b/src/project/contract/vyper/expression/instruction/offset.rs
@@ -8,11 +8,11 @@ use inkwell::values::BasicValue;
 /// Translates the Vyper LLL-specific `ceil32` instruction.
 ///
 pub fn ceil_32<'ctx, D>(
-    context: &mut compiler_llvm_context::Context<'ctx, D>,
+    context: &mut compiler_llvm_context::EraVMContext<'ctx, D>,
     value: inkwell::values::IntValue<'ctx>,
 ) -> anyhow::Result<inkwell::values::BasicValueEnum<'ctx>>
 where
-    D: compiler_llvm_context::Dependency + Clone,
+    D: compiler_llvm_context::EraVMDependency + Clone,
 {
     let remainder = context.builder().build_int_unsigned_rem(
         value,
diff --git a/src/project/contract/vyper/expression/instruction/repeat.rs b/src/project/contract/vyper/expression/instruction/repeat.rs
index 34b1844..2656055 100644
--- a/src/project/contract/vyper/expression/instruction/repeat.rs
+++ b/src/project/contract/vyper/expression/instruction/repeat.rs
@@ -33,10 +33,10 @@ impl Repeat {
     ///
     pub fn into_llvm_value<D>(
         mut self,
-        context: &mut compiler_llvm_context::Context<D>,
+        context: &mut compiler_llvm_context::EraVMContext<D>,
     ) -> anyhow::Result<()>
     where
-        D: compiler_llvm_context::Dependency + Clone,
+        D: compiler_llvm_context::EraVMDependency + Clone,
     {
         let index_identifier = self.0.remove(0).try_into_identifier()?;
         let start = self.0.remove(0);
diff --git a/src/project/contract/vyper/expression/instruction/return.rs b/src/project/contract/vyper/expression/instruction/return.rs
index 1379dff..08a07bb 100644
--- a/src/project/contract/vyper/expression/instruction/return.rs
+++ b/src/project/contract/vyper/expression/instruction/return.rs
@@ -28,13 +28,13 @@ impl Return {
     ///
     pub fn into_llvm_value<D>(
         self,
-        context: &mut compiler_llvm_context::Context<D>,
+        context: &mut compiler_llvm_context::EraVMContext<D>,
     ) -> anyhow::Result<()>
     where
-        D: compiler_llvm_context::Dependency + Clone,
+        D: compiler_llvm_context::EraVMDependency + Clone,
     {
         let arguments = Instruction::translate_arguments_llvm::<D, 2>(self.0, context)?;
-        compiler_llvm_context::r#return::r#return(
+        compiler_llvm_context::eravm_evm_return::r#return(
             context,
             arguments[0].into_int_value(),
             arguments[1].into_int_value(),
diff --git a/src/project/contract/vyper/expression/instruction/revert.rs b/src/project/contract/vyper/expression/instruction/revert.rs
index ff233ca..a7718b7 100644
--- a/src/project/contract/vyper/expression/instruction/revert.rs
+++ b/src/project/contract/vyper/expression/instruction/revert.rs
@@ -28,13 +28,13 @@ impl Revert {
     ///
     pub fn into_llvm_value<D>(
         self,
-        context: &mut compiler_llvm_context::Context<D>,
+        context: &mut compiler_llvm_context::EraVMContext<D>,
     ) -> anyhow::Result<()>
     where
-        D: compiler_llvm_context::Dependency + Clone,
+        D: compiler_llvm_context::EraVMDependency + Clone,
     {
         let arguments = Instruction::translate_arguments_llvm::<D, 2>(self.0, context)?;
-        compiler_llvm_context::r#return::revert(
+        compiler_llvm_context::eravm_evm_return::revert(
             context,
             arguments[0].into_int_value(),
             arguments[1].into_int_value(),
diff --git a/src/project/contract/vyper/expression/instruction/seq.rs b/src/project/contract/vyper/expression/instruction/seq.rs
index ddef40c..2aa1e43 100644
--- a/src/project/contract/vyper/expression/instruction/seq.rs
+++ b/src/project/contract/vyper/expression/instruction/seq.rs
@@ -147,10 +147,10 @@ impl Seq {
     ///
     pub fn into_llvm_value<'ctx, D>(
         mut self,
-        context: &mut compiler_llvm_context::Context<'ctx, D>,
+        context: &mut compiler_llvm_context::EraVMContext<'ctx, D>,
     ) -> anyhow::Result<Option<inkwell::values::BasicValueEnum<'ctx>>>
     where
-        D: compiler_llvm_context::Dependency + Clone,
+        D: compiler_llvm_context::EraVMDependency + Clone,
     {
         let (mut labels, expressions) = self.drain_and_split();
 
@@ -174,11 +174,14 @@ impl Seq {
     }
 }
 
-impl<D> compiler_llvm_context::WriteLLVM<D> for Seq
+impl<D> compiler_llvm_context::EraVMWriteLLVM<D> for Seq
 where
-    D: compiler_llvm_context::Dependency + Clone,
+    D: compiler_llvm_context::EraVMDependency + Clone,
 {
-    fn into_llvm(mut self, context: &mut compiler_llvm_context::Context<D>) -> anyhow::Result<()> {
+    fn into_llvm(
+        mut self,
+        context: &mut compiler_llvm_context::EraVMContext<D>,
+    ) -> anyhow::Result<()> {
         let current_block = context.basic_block();
 
         let (mut labels, expressions) = self.drain_and_split();
diff --git a/src/project/contract/vyper/expression/instruction/set.rs b/src/project/contract/vyper/expression/instruction/set.rs
index 84be3b3..5f890c0 100644
--- a/src/project/contract/vyper/expression/instruction/set.rs
+++ b/src/project/contract/vyper/expression/instruction/set.rs
@@ -19,10 +19,10 @@ impl Set {
     ///
     pub fn into_llvm_value<D>(
         self,
-        context: &mut compiler_llvm_context::Context<D>,
+        context: &mut compiler_llvm_context::EraVMContext<D>,
     ) -> anyhow::Result<()>
     where
-        D: compiler_llvm_context::Dependency + Clone,
+        D: compiler_llvm_context::EraVMDependency + Clone,
     {
         let [identifier, value] = self.0;
         let identifier = identifier.try_into_identifier()?;
diff --git a/src/project/contract/vyper/expression/instruction/with.rs b/src/project/contract/vyper/expression/instruction/with.rs
index f4ea9de..6e9bb0c 100644
--- a/src/project/contract/vyper/expression/instruction/with.rs
+++ b/src/project/contract/vyper/expression/instruction/with.rs
@@ -31,10 +31,10 @@ impl With {
     ///
     pub fn into_llvm_value<'ctx, D>(
         self,
-        context: &mut compiler_llvm_context::Context<'ctx, D>,
+        context: &mut compiler_llvm_context::EraVMContext<'ctx, D>,
     ) -> anyhow::Result<Option<inkwell::values::BasicValueEnum<'ctx>>>
     where
-        D: compiler_llvm_context::Dependency + Clone,
+        D: compiler_llvm_context::EraVMDependency + Clone,
     {
         let [identifier, value, block] = self.0;
         let identifier = identifier.try_into_identifier()?;
diff --git a/src/project/contract/vyper/expression/mod.rs b/src/project/contract/vyper/expression/mod.rs
index 0094800..82553f4 100644
--- a/src/project/contract/vyper/expression/mod.rs
+++ b/src/project/contract/vyper/expression/mod.rs
@@ -124,10 +124,10 @@ impl Expression {
     ///
     pub fn into_llvm_value<'ctx, D>(
         self,
-        context: &mut compiler_llvm_context::Context<'ctx, D>,
+        context: &mut compiler_llvm_context::EraVMContext<'ctx, D>,
     ) -> anyhow::Result<Option<inkwell::values::BasicValueEnum<'ctx>>>
     where
-        D: compiler_llvm_context::Dependency + Clone,
+        D: compiler_llvm_context::EraVMDependency + Clone,
     {
         match self {
             Self::Instruction(inner) => inner.into_llvm_value(context),
diff --git a/src/project/contract/vyper/function.rs b/src/project/contract/vyper/function.rs
index f9bcfe0..b2940cb 100644
--- a/src/project/contract/vyper/function.rs
+++ b/src/project/contract/vyper/function.rs
@@ -4,8 +4,8 @@
 
 use inkwell::types::BasicType;
 
-use compiler_llvm_context::Dependency;
-use compiler_llvm_context::WriteLLVM;
+use compiler_llvm_context::EraVMDependency;
+use compiler_llvm_context::EraVMWriteLLVM;
 
 use crate::metadata::function::Function as FunctionMetadata;
 use crate::project::contract::vyper::expression::Expression;
@@ -36,11 +36,14 @@ impl Function {
     }
 }
 
-impl<D> WriteLLVM<D> for Function
+impl<D> EraVMWriteLLVM<D> for Function
 where
-    D: Dependency + Clone,
+    D: EraVMDependency + Clone,
 {
-    fn declare(&mut self, context: &mut compiler_llvm_context::Context<D>) -> anyhow::Result<()> {
+    fn declare(
+        &mut self,
+        context: &mut compiler_llvm_context::EraVMContext<D>,
+    ) -> anyhow::Result<()> {
         let mut argument_types = vec![];
         if self
             .name
@@ -61,12 +64,12 @@ where
         )?;
         function
             .borrow_mut()
-            .set_vyper_data(compiler_llvm_context::FunctionVyperData::default());
+            .set_vyper_data(compiler_llvm_context::EraVMFunctionVyperData::default());
 
         Ok(())
     }
 
-    fn into_llvm(self, context: &mut compiler_llvm_context::Context<D>) -> anyhow::Result<()> {
+    fn into_llvm(self, context: &mut compiler_llvm_context::EraVMContext<D>) -> anyhow::Result<()> {
         context.set_current_function(self.name.as_str())?;
 
         let llvm_entry_block = context.current_function().borrow().entry_block();
diff --git a/src/project/contract/vyper/mod.rs b/src/project/contract/vyper/mod.rs
index 7c30dc5..efc0eb2 100644
--- a/src/project/contract/vyper/mod.rs
+++ b/src/project/contract/vyper/mod.rs
@@ -10,8 +10,8 @@ use std::collections::BTreeMap;
 use serde::Deserialize;
 use serde::Serialize;
 
-use compiler_llvm_context::Dependency;
-use compiler_llvm_context::WriteLLVM;
+use compiler_llvm_context::EraVMDependency;
+use compiler_llvm_context::EraVMWriteLLVM;
 
 use crate::build::contract::Contract as ContractBuild;
 use crate::metadata::Metadata as SourceMetadata;
@@ -120,7 +120,7 @@ impl Contract {
         });
 
         let dependency_data = DependencyData::default();
-        let mut context = compiler_llvm_context::Context::<DependencyData>::new(
+        let mut context = compiler_llvm_context::EraVMContext::<DependencyData>::new(
             &llvm,
             llvm.create_module(contract_path),
             optimizer,
@@ -158,31 +158,35 @@ impl Contract {
     }
 }
 
-impl<D> WriteLLVM<D> for Contract
+impl<D> EraVMWriteLLVM<D> for Contract
 where
-    D: Dependency + Clone,
+    D: EraVMDependency + Clone,
 {
-    fn declare(&mut self, context: &mut compiler_llvm_context::Context<D>) -> anyhow::Result<()> {
-        let mut entry = compiler_llvm_context::EntryFunction::default();
+    fn declare(
+        &mut self,
+        context: &mut compiler_llvm_context::EraVMContext<D>,
+    ) -> anyhow::Result<()> {
+        let mut entry = compiler_llvm_context::EraVMEntryFunction::default();
         entry.declare(context)?;
 
-        let mut runtime =
-            compiler_llvm_context::Runtime::new(compiler_llvm_context::AddressSpace::HeapAuxiliary);
+        let mut runtime = compiler_llvm_context::EraVMRuntime::new(
+            compiler_llvm_context::EraVMAddressSpace::HeapAuxiliary,
+        );
         runtime.declare(context)?;
 
-        compiler_llvm_context::DeployCodeFunction::new(
-            compiler_llvm_context::DummyLLVMWritable::default(),
+        compiler_llvm_context::EraVMDeployCodeFunction::new(
+            compiler_llvm_context::EraVMDummyLLVMWritable::default(),
         )
         .declare(context)?;
-        compiler_llvm_context::RuntimeCodeFunction::new(
-            compiler_llvm_context::DummyLLVMWritable::default(),
+        compiler_llvm_context::EraVMRuntimeCodeFunction::new(
+            compiler_llvm_context::EraVMDummyLLVMWritable::default(),
         )
         .declare(context)?;
 
         for name in [
-            compiler_llvm_context::Runtime::FUNCTION_DEPLOY_CODE,
-            compiler_llvm_context::Runtime::FUNCTION_RUNTIME_CODE,
-            compiler_llvm_context::Runtime::FUNCTION_ENTRY,
+            compiler_llvm_context::EraVMRuntime::FUNCTION_DEPLOY_CODE,
+            compiler_llvm_context::EraVMRuntime::FUNCTION_RUNTIME_CODE,
+            compiler_llvm_context::EraVMRuntime::FUNCTION_ENTRY,
         ]
         .into_iter()
         {
@@ -190,7 +194,7 @@ where
                 .get_function(name)
                 .expect("Always exists")
                 .borrow_mut()
-                .set_vyper_data(compiler_llvm_context::FunctionVyperData::default());
+                .set_vyper_data(compiler_llvm_context::EraVMFunctionVyperData::default());
         }
 
         entry.into_llvm(context)?;
@@ -200,7 +204,10 @@ where
         Ok(())
     }
 
-    fn into_llvm(mut self, context: &mut compiler_llvm_context::Context<D>) -> anyhow::Result<()> {
+    fn into_llvm(
+        mut self,
+        context: &mut compiler_llvm_context::EraVMContext<D>,
+    ) -> anyhow::Result<()> {
         let (mut runtime_code, immutables_size) =
             self.expression.extract_runtime_code()?.unwrap_or_default();
         let mut deploy_code = self.expression.try_into_deploy_code()?;
@@ -210,8 +217,10 @@ where
                 let immutables_size = number
                     .as_u64()
                     .ok_or_else(|| anyhow::anyhow!("Immutable size `{}` parsing error", number))?;
-                let vyper_data =
-                    compiler_llvm_context::ContextVyperData::new(immutables_size as usize, false);
+                let vyper_data = compiler_llvm_context::EraVMContextVyperData::new(
+                    immutables_size as usize,
+                    false,
+                );
                 context.set_vyper_data(vyper_data);
             }
             expression => anyhow::bail!("Invalid immutables size format: {:?}", expression),
@@ -220,25 +229,37 @@ where
         let mut function_expressions = deploy_code
             .extract_functions()?
             .into_iter()
-            .map(|(label, expression)| (label, expression, compiler_llvm_context::CodeType::Deploy))
-            .collect::<Vec<(String, Expression, compiler_llvm_context::CodeType)>>();
+            .map(|(label, expression)| {
+                (
+                    label,
+                    expression,
+                    compiler_llvm_context::EraVMCodeType::Deploy,
+                )
+            })
+            .collect::<Vec<(String, Expression, compiler_llvm_context::EraVMCodeType)>>();
         function_expressions.extend(
             runtime_code
                 .extract_functions()?
                 .into_iter()
                 .map(|(label, expression)| {
-                    (label, expression, compiler_llvm_context::CodeType::Runtime)
+                    (
+                        label,
+                        expression,
+                        compiler_llvm_context::EraVMCodeType::Runtime,
+                    )
                 })
-                .collect::<Vec<(String, Expression, compiler_llvm_context::CodeType)>>(),
+                .collect::<Vec<(String, Expression, compiler_llvm_context::EraVMCodeType)>>(),
         );
 
         let mut functions = Vec::with_capacity(function_expressions.capacity());
         for (label, expression, code_type) in function_expressions.into_iter() {
             let mut metadata_label = label
-                .strip_suffix(format!("_{}", compiler_llvm_context::CodeType::Deploy).as_str())
+                .strip_suffix(format!("_{}", compiler_llvm_context::EraVMCodeType::Deploy).as_str())
                 .unwrap_or(label.as_str());
             metadata_label = label
-                .strip_suffix(format!("_{}", compiler_llvm_context::CodeType::Runtime).as_str())
+                .strip_suffix(
+                    format!("_{}", compiler_llvm_context::EraVMCodeType::Runtime).as_str(),
+                )
                 .unwrap_or(metadata_label);
             metadata_label = label
                 .strip_suffix(format!("_{}", crate::r#const::LABEL_SUFFIX_COMMON).as_str())
@@ -273,14 +294,14 @@ where
             function.into_llvm(context)?;
         }
 
-        compiler_llvm_context::DeployCodeFunction::new(deploy_code).into_llvm(context)?;
-        compiler_llvm_context::RuntimeCodeFunction::new(runtime_code).into_llvm(context)?;
+        compiler_llvm_context::EraVMDeployCodeFunction::new(deploy_code).into_llvm(context)?;
+        compiler_llvm_context::EraVMRuntimeCodeFunction::new(runtime_code).into_llvm(context)?;
 
         Ok(())
     }
 }
 
-impl Dependency for DependencyData {
+impl EraVMDependency for DependencyData {
     fn compile(
         _contract: Self,
         _name: &str,
diff --git a/src/project/contract/zkasm.rs b/src/project/contract/zkasm.rs
index bb10a56..455adb4 100644
--- a/src/project/contract/zkasm.rs
+++ b/src/project/contract/zkasm.rs
@@ -50,7 +50,7 @@ impl Contract {
             .keccak256()
         });
 
-        let build = compiler_llvm_context::build_assembly_text(
+        let build = compiler_llvm_context::eravm_build_assembly_text(
             contract_path,
             self.source_code.as_str(),
             metadata_hash,
diff --git a/src/project/mod.rs b/src/project/mod.rs
index f6a2751..13e75be 100644
--- a/src/project/mod.rs
+++ b/src/project/mod.rs
@@ -62,11 +62,15 @@ impl Project {
         let mut project_contracts = BTreeMap::new();
         project_contracts.insert(
             path,
-            LLVMIRContract::new(compiler_llvm_context::LLVM_VERSION, source_code).into(),
+            LLVMIRContract::new(
+                compiler_llvm_context::eravm_const::LLVM_VERSION,
+                source_code,
+            )
+            .into(),
         );
 
         Ok(Self::new(
-            compiler_llvm_context::LLVM_VERSION,
+            compiler_llvm_context::eravm_const::LLVM_VERSION,
             source_code_hash,
             project_contracts,
         ))
@@ -86,11 +90,15 @@ impl Project {
         let mut project_contracts = BTreeMap::new();
         project_contracts.insert(
             path,
-            ZKASMContract::new(compiler_llvm_context::ZKEVM_VERSION, source_code).into(),
+            ZKASMContract::new(
+                compiler_llvm_context::eravm_const::ZKEVM_VERSION,
+                source_code,
+            )
+            .into(),
         );
 
         Ok(Self::new(
-            compiler_llvm_context::ZKEVM_VERSION,
+            compiler_llvm_context::eravm_const::ZKEVM_VERSION,
             source_code_hash,
             project_contracts,
         ))
@@ -141,7 +149,7 @@ impl Project {
                 .unwrap_or_default()
         });
         if is_forwarder_used {
-            let forwarder_build = compiler_llvm_context::Build::new(
+            let forwarder_build = compiler_llvm_context::EraVMBuild::new(
                 crate::r#const::FORWARDER_CONTRACT_ASSEMBLY.to_owned(),
                 None,
                 crate::r#const::FORWARDER_CONTRACT_BYTECODE.clone(),
diff --git a/src/tests/mod.rs b/src/tests/mod.rs
index 6fc7034..5f5e954 100644
--- a/src/tests/mod.rs
+++ b/src/tests/mod.rs
@@ -42,7 +42,7 @@ pub fn build_vyper(
     }
 
     inkwell::support::enable_llvm_pretty_stack_trace();
-    compiler_llvm_context::initialize_target();
+    compiler_llvm_context::initialize_target(compiler_llvm_context::Target::EraVM);
     let _ = crate::process::EXECUTABLE.set(PathBuf::from(crate::r#const::DEFAULT_EXECUTABLE_NAME));
     let optimizer_settings = compiler_llvm_context::OptimizerSettings::none();
 
diff --git a/src/vyper/mod.rs b/src/vyper/mod.rs
index c9846cf..8304b2e 100644
--- a/src/vyper/mod.rs
+++ b/src/vyper/mod.rs
@@ -41,8 +41,11 @@ impl Compiler {
     pub const DEFAULT_EXECUTABLE_NAME: &'static str = "vyper";
 
     /// The supported versions of `vyper`.
-    pub const SUPPORTED_VERSIONS: [semver::Version; 2] =
-        [semver::Version::new(0, 3, 3), semver::Version::new(0, 3, 9)];
+    pub const SUPPORTED_VERSIONS: [semver::Version; 2 /* 3 */] = [
+        semver::Version::new(0, 3, 3),
+        semver::Version::new(0, 3, 9),
+        // semver::Version::new(0, 3, 10),
+    ];
 
     ///
     /// A shortcut constructor.
@@ -66,6 +69,9 @@ impl Compiler {
         command.arg("-f");
         command.arg("combined_json");
         command.args(paths);
+        if self.version.default >= semver::Version::new(0, 3, 10) {
+            command.arg("--no-optimize");
+        }
         let output = command.output().map_err(|error| {
             anyhow::anyhow!("{} subprocess error: {:?}", self.executable, error)
         })?;
@@ -85,12 +91,18 @@ impl Compiler {
     ///
     /// The `vyper --standard-json` mirror.
     ///
-    pub fn standard_json(&self, input: StandardJsonInput) -> anyhow::Result<StandardJsonOutput> {
+    pub fn standard_json(
+        &self,
+        mut input: StandardJsonInput,
+    ) -> anyhow::Result<StandardJsonOutput> {
         let mut command = std::process::Command::new(self.executable.as_str());
         command.stdin(std::process::Stdio::piped());
         command.stdout(std::process::Stdio::piped());
         command.arg("--standard-json");
 
+        if self.version.default >= semver::Version::new(0, 3, 10) {
+            input.settings.optimize = false;
+        }
         let input_json = serde_json::to_vec(&input).expect("Always valid");
 
         let process = command.spawn().map_err(|error| {
@@ -169,7 +181,7 @@ impl Compiler {
         let mut command = std::process::Command::new(self.executable.as_str());
         command.arg("-f");
         command.arg("ir");
-        if !optimize {
+        if !optimize || self.version.default >= semver::Version::new(0, 3, 10) {
             command.arg("--no-optimize");
         }
         command.arg(path);
@@ -205,7 +217,7 @@ impl Compiler {
         let mut command = std::process::Command::new(self.executable.as_str());
         command.arg("-f");
         command.arg("ir_json,metadata,method_identifiers");
-        if !optimize {
+        if !optimize || self.version.default >= semver::Version::new(0, 3, 10) {
             command.arg("--no-optimize");
         }
         command.args(paths.as_slice());
diff --git a/src/zkvyper/arguments.rs b/src/zkvyper/arguments.rs
index c7e80ca..79ccbe8 100644
--- a/src/zkvyper/arguments.rs
+++ b/src/zkvyper/arguments.rs
@@ -47,19 +47,21 @@ pub struct Arguments {
     pub vyper: Option<String>,
 
     /// An extra output format string.
-    /// See `vyper --help` for available options.
+    /// See `vyper --help` for available options including combined JSON mode.
     #[structopt(short = "f")]
     pub format: Option<String>,
 
     /// Switch to LLVM IR mode.
     /// Only one input LLVM IR file is allowed.
-    /// Cannot be used with combined or standard JSON modes.
+    /// Cannot be used with combined JSON mode.
+    /// Use this mode at your own risk, as LLVM IR input validation is not implemented.
     #[structopt(long = "llvm-ir")]
     pub llvm_ir: bool,
 
     /// Switch to zkEVM assembly mode.
     /// Only one input zkEVM assembly file is allowed.
-    /// Cannot be used with combined or standard JSON modes.
+    /// Cannot be used with combined JSON modes.
+    /// Use this mode at your own risk, as EraVM assembly input validation is not implemented.
     #[structopt(long = "zkasm")]
     pub zkasm: bool,
 
diff --git a/src/zkvyper/main.rs b/src/zkvyper/main.rs
index 620c6f0..f473482 100644
--- a/src/zkvyper/main.rs
+++ b/src/zkvyper/main.rs
@@ -41,7 +41,7 @@ fn main_inner() -> anyhow::Result<()> {
         .build_global()
         .expect("Thread pool configuration failure");
     inkwell::support::enable_llvm_pretty_stack_trace();
-    compiler_llvm_context::initialize_target();
+    compiler_llvm_context::initialize_target(compiler_llvm_context::Target::EraVM); // TODO: pass from CLI
 
     if arguments.version {
         println!(
@@ -86,8 +86,9 @@ fn main_inner() -> anyhow::Result<()> {
 
     let include_metadata_hash = match arguments.metadata_hash {
         Some(metadata_hash) => {
-            let metadata = compiler_llvm_context::MetadataHash::from_str(metadata_hash.as_str())?;
-            metadata != compiler_llvm_context::MetadataHash::None
+            let metadata =
+                compiler_llvm_context::EraVMMetadataHash::from_str(metadata_hash.as_str())?;
+            metadata != compiler_llvm_context::EraVMMetadataHash::None
         }
         None => true,
     };
