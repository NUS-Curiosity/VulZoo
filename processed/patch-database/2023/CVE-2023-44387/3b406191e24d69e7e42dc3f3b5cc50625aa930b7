diff --git a/subprojects/core/src/main/java/org/gradle/execution/plan/FinalizerGroup.java b/subprojects/core/src/main/java/org/gradle/execution/plan/FinalizerGroup.java
index 69a7230802f6..c689d9ca66a4 100644
--- a/subprojects/core/src/main/java/org/gradle/execution/plan/FinalizerGroup.java
+++ b/subprojects/core/src/main/java/org/gradle/execution/plan/FinalizerGroup.java
@@ -22,6 +22,7 @@
 import com.google.common.collect.SetMultimap;
 
 import javax.annotation.Nullable;
+import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashSet;
@@ -43,6 +44,7 @@ public class FinalizerGroup extends HasFinalizers {
     @Nullable
     private ElementSuccessors successors;
     private boolean finalizedNodeHasStarted;
+    private boolean hasBeenScheduled;
 
     public FinalizerGroup(TaskNode node, NodeGroup delegate) {
         this.ordinal = delegate.asOrdinal();
@@ -159,6 +161,12 @@ public void onNodeStart(Node finalizer, Node node) {
     }
 
     public void scheduleMembers(SetMultimap<FinalizerGroup, FinalizerGroup> reachableGroups) {
+        if (hasBeenScheduled) {
+            return;
+        } else {
+            hasBeenScheduled = true;
+        }
+
         Set<Node> finalizedNodesToBlockOn = findFinalizedNodesThatDoNotIntroduceACycle(reachableGroups);
         WaitForNodesToComplete waitForFinalizers = new WaitForNodesToComplete(finalizedNodesToBlockOn);
 
@@ -176,6 +184,10 @@ public void scheduleMembers(SetMultimap<FinalizerGroup, FinalizerGroup> reachabl
         // There are some finalized nodes that are also members
         // For each member, determine which finalized nodes to wait for
         ImmutableMap.Builder<Node, MemberSuccessors> blockingNodesBuilder = ImmutableMap.builder();
+
+        // Calculate the set of dependencies of finalized nodes that are also members of this group
+        Set<Node> dependenciesThatAreMembers = getDependenciesThatAreMembers(blockedFinalizedMembers);
+
         for (Node member : members) {
             if (isFinalizerNode(member) || memberCanStartAtAnyTime(member)) {
                 // Short-circuit for these, they are handled separately
@@ -190,22 +202,15 @@ public void scheduleMembers(SetMultimap<FinalizerGroup, FinalizerGroup> reachabl
                     blockingNodesBuilder.put(member, new WaitForFinalizedNodesToBecomeActive(Collections.singleton(member)));
                 }
             } else {
-                // Determine whether this member is a dependency of a finalized node, in which case treat it as if it were a finalized member
-                boolean requiredByBlockedFinalizedMember = false;
-                for (Node finalizedMember : blockedFinalizedMembers) {
-                    if (dependsOn(finalizedMember, member)) {
-                        requiredByBlockedFinalizedMember = true;
-                        break;
-                    }
-                }
-                if (requiredByBlockedFinalizedMember) {
+                if (dependenciesThatAreMembers.contains(member)) {
+                    // This member is a dependency of a finalized member. Treat is as if it were a finalized member.
                     blockingNodesBuilder.put(member, waitForFinalizers);
-                    continue;
+                } else {
+                    // Wait for the finalized nodes that don't introduce a cycle
+                    Set<Node> blockOn = new LinkedHashSet<>(finalizedNodesToBlockOn);
+                    blockOn.addAll(blockedFinalizedMembers);
+                    blockingNodesBuilder.put(member, new WaitForNodesToComplete(blockOn));
                 }
-                // Wait for the finalized nodes that don't introduce a cycle
-                Set<Node> blockOn = new LinkedHashSet<>(finalizedNodesToBlockOn);
-                blockOn.addAll(blockedFinalizedMembers);
-                blockingNodesBuilder.put(member, new WaitForNodesToComplete(blockOn));
             }
         }
         ImmutableMap<Node, MemberSuccessors> blockingNodes = blockingNodesBuilder.build();
@@ -260,21 +265,26 @@ private MemberSuccessors getNodesThatBlock(Node node) {
         return successors.getNodesThatBlock(node);
     }
 
-    private boolean dependsOn(Node fromNode, Node toNode) {
-        Set<Node> seen = new HashSet<>();
-        List<Node> queue = new ArrayList<>();
-        Iterables.addAll(queue, fromNode.getHardSuccessors());
-        while (!queue.isEmpty()) {
-            Node node = queue.remove(0);
-            if (node == toNode) {
-                return true;
-            }
-            if (!seen.add(node)) {
-                continue;
+    private Set<Node> getDependenciesThatAreMembers(Set<Node> blockedFinalizedMembers) {
+        Set<Node> dependenciesThatAreMembers = new HashSet<>(members.size());
+        Set<Node> seen = new HashSet<>(1024);
+
+        ArrayDeque<Node> queue = new ArrayDeque<>(1024);
+        for (Node fromNode : blockedFinalizedMembers) {
+            queue.add(fromNode);
+            while (!queue.isEmpty()) {
+                Node toNode = queue.removeFirst();
+                if (members.contains(toNode) && !blockedFinalizedMembers.contains(toNode)) {
+                    dependenciesThatAreMembers.add(toNode);
+                }
+                toNode.visitHardSuccessors(node -> {
+                    if (seen.add(node)) {
+                        queue.add(node);
+                    }
+                });
             }
-            Iterables.addAll(queue, node.getHardSuccessors());
         }
-        return false;
+        return dependenciesThatAreMembers;
     }
 
     private boolean hasACycle(Node finalized, SetMultimap<FinalizerGroup, FinalizerGroup> reachableGroups) {
diff --git a/subprojects/core/src/main/java/org/gradle/execution/plan/Node.java b/subprojects/core/src/main/java/org/gradle/execution/plan/Node.java
index e0a927a6c286..e97dacfb9413 100644
--- a/subprojects/core/src/main/java/org/gradle/execution/plan/Node.java
+++ b/subprojects/core/src/main/java/org/gradle/execution/plan/Node.java
@@ -535,6 +535,16 @@ public Iterable<Node> getHardSuccessors() {
         return dependencyNodes.getDependencySuccessors();
     }
 
+    /**
+     * Iterates over the nodes which are hard successors applying a visitor, i.e. which have a non-removable relationship to the current node.
+     *
+     * This can be a more efficient way to iterate over the successors than {@link #getHardSuccessors()}.
+     */
+    @OverridingMethodsMustInvokeSuper
+    public void visitHardSuccessors(Consumer<? super Node> visitor) {
+        dependencyNodes.getDependencySuccessors().forEach(visitor);
+    }
+
     public SortedSet<Node> getFinalizers() {
         return dependentNodes.getFinalizers();
     }
diff --git a/subprojects/core/src/main/java/org/gradle/execution/plan/TaskNode.java b/subprojects/core/src/main/java/org/gradle/execution/plan/TaskNode.java
index 7d2c97f86e43..02f936d15263 100644
--- a/subprojects/core/src/main/java/org/gradle/execution/plan/TaskNode.java
+++ b/subprojects/core/src/main/java/org/gradle/execution/plan/TaskNode.java
@@ -22,6 +22,7 @@
 
 import java.util.NavigableSet;
 import java.util.Set;
+import java.util.function.Consumer;
 
 import static org.gradle.execution.plan.NodeSets.newSortedNodeSet;
 
@@ -92,6 +93,13 @@ public Iterable<Node> getHardSuccessors() {
         );
     }
 
+    @Override
+    public void visitHardSuccessors(Consumer<? super Node> visitor) {
+        finalizingSuccessors.forEach(visitor);
+        getMustSuccessors().forEach(visitor);
+        super.visitHardSuccessors(visitor);
+    }
+
     public abstract TaskInternal getTask();
 
     protected void deprecateLifecycleHookReferencingNonLocalTask(String hookName, Node taskNode) {
diff --git a/subprojects/core/src/test/groovy/org/gradle/execution/plan/DefaultExecutionPlanTest.groovy b/subprojects/core/src/test/groovy/org/gradle/execution/plan/DefaultExecutionPlanTest.groovy
index 07a06d68ef4c..4bd8dda303dc 100644
--- a/subprojects/core/src/test/groovy/org/gradle/execution/plan/DefaultExecutionPlanTest.groovy
+++ b/subprojects/core/src/test/groovy/org/gradle/execution/plan/DefaultExecutionPlanTest.groovy
@@ -457,7 +457,7 @@ class DefaultExecutionPlanTest extends AbstractExecutionPlanSpec {
         orderingRule << ['dependsOn', 'mustRunAfter', 'shouldRunAfter']
     }
 
-    def "finalizer groups that finalize each other form a cycle"() {
+    def "finalizer groups that finalize each other do not form a cycle"() {
         given:
         TaskInternal finalizerA = createTask("finalizerA")
         TaskInternal finalizerB = createTask("finalizerB")
diff --git a/subprojects/process-services/src/main/java/org/gradle/process/internal/health/memory/CGroupMemoryInfo.java b/subprojects/process-services/src/main/java/org/gradle/process/internal/health/memory/CGroupMemoryInfo.java
new file mode 100644
index 000000000000..fa61f5a82f52
--- /dev/null
+++ b/subprojects/process-services/src/main/java/org/gradle/process/internal/health/memory/CGroupMemoryInfo.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2022 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.gradle.process.internal.health.memory;
+
+import com.google.common.annotations.VisibleForTesting;
+import com.google.common.io.Files;
+
+import java.io.File;
+import java.io.IOException;
+import java.nio.charset.Charset;
+
+public class CGroupMemoryInfo implements OsMemoryInfo {
+    private static final String CGROUP_MEM_USAGE_FILE = "/sys/fs/cgroup/memory/memory.usage_in_bytes";
+    private static final String CGROUP_MEM_TOTAL_FILE = "/sys/fs/cgroup/memory/memory.limit_in_bytes";
+
+    @Override
+    public OsMemoryStatus getOsSnapshot() {
+        String memUsageString = readStringFromFile(new File(CGROUP_MEM_USAGE_FILE));
+        String memTotalString = readStringFromFile(new File(CGROUP_MEM_TOTAL_FILE));
+
+        return getOsSnapshotFromCgroup(memUsageString, memTotalString);
+    }
+
+    private String readStringFromFile(File file) {
+        try {
+            return Files.asCharSource(file, Charset.defaultCharset()).readFirstLine();
+        } catch (IOException e) {
+            throw new UnsupportedOperationException("Unable to read system memory from " + file.getAbsoluteFile(), e);
+        }
+    }
+
+    @VisibleForTesting
+    OsMemoryStatusSnapshot getOsSnapshotFromCgroup(String memUsageString, String memTotalString) {
+        long memUsage;
+        long memTotal;
+        long memAvailable;
+
+        try {
+            memUsage = Long.parseLong(memUsageString);
+            memTotal = Long.parseLong(memTotalString);
+            memAvailable = Math.max(0, memTotal - memUsage);
+        } catch (NumberFormatException e) {
+            throw new UnsupportedOperationException("Unable to read system memory", e);
+        }
+
+        return new OsMemoryStatusSnapshot(memTotal, memAvailable);
+    }
+}
diff --git a/subprojects/process-services/src/main/java/org/gradle/process/internal/health/memory/DefaultOsMemoryInfo.java b/subprojects/process-services/src/main/java/org/gradle/process/internal/health/memory/DefaultOsMemoryInfo.java
index 68fef054ee5c..b4ac77af500b 100644
--- a/subprojects/process-services/src/main/java/org/gradle/process/internal/health/memory/DefaultOsMemoryInfo.java
+++ b/subprojects/process-services/src/main/java/org/gradle/process/internal/health/memory/DefaultOsMemoryInfo.java
@@ -26,12 +26,37 @@ public DefaultOsMemoryInfo() {
         if (operatingSystem.isMacOsX()) {
             delegate = new NativeOsMemoryInfo();
         } else if (operatingSystem.isLinux()) {
-            delegate = new MemInfoOsMemoryInfo();
+            delegate = getLinuxDelegate();
         } else {
             delegate = new MBeanOsMemoryInfo();
         }
     }
 
+    private OsMemoryInfo getLinuxDelegate() {
+        OsMemoryInfo cGroupDelegate = new CGroupMemoryInfo();
+        OsMemoryInfo memInfoDelegate = new MemInfoOsMemoryInfo();
+
+        OsMemoryStatus cGroupSnapshot;
+        OsMemoryStatus memInfoSnapshot;
+
+        try {
+            cGroupSnapshot = cGroupDelegate.getOsSnapshot();
+        } catch (UnsupportedOperationException e) {
+            return memInfoDelegate;
+        }
+
+        try {
+            memInfoSnapshot = memInfoDelegate.getOsSnapshot();
+        } catch (UnsupportedOperationException e) {
+            return cGroupDelegate;
+        }
+
+        long cGroupFreeMemory = cGroupSnapshot.getFreePhysicalMemory();
+        long memInfoFreeMemory = memInfoSnapshot.getFreePhysicalMemory();
+
+        return cGroupFreeMemory > memInfoFreeMemory ? memInfoDelegate : cGroupDelegate;
+    }
+
     @Override
     public OsMemoryStatus getOsSnapshot() {
         return delegate.getOsSnapshot();
diff --git a/subprojects/process-services/src/main/java/org/gradle/process/internal/health/memory/MemInfoOsMemoryInfo.java b/subprojects/process-services/src/main/java/org/gradle/process/internal/health/memory/MemInfoOsMemoryInfo.java
index 849ad1e6566b..22a67b05c86a 100644
--- a/subprojects/process-services/src/main/java/org/gradle/process/internal/health/memory/MemInfoOsMemoryInfo.java
+++ b/subprojects/process-services/src/main/java/org/gradle/process/internal/health/memory/MemInfoOsMemoryInfo.java
@@ -47,11 +47,8 @@ public synchronized OsMemoryStatus getOsSnapshot() {
         } catch (IOException e) {
             throw new UnsupportedOperationException("Unable to read system memory from " + MEMINFO_FILE_PATH, e);
         }
-        OsMemoryStatusSnapshot memInfo = getOsSnapshotFromMemInfo(meminfoOutputLines);
-        if (memInfo.getFreePhysicalMemory() < 0 || memInfo.getTotalPhysicalMemory() < 0) {
-            throw new UnsupportedOperationException("Unable to read system memory from " + MEMINFO_FILE_PATH);
-        }
-        return memInfo;
+
+        return getOsSnapshotFromMemInfo(meminfoOutputLines);
     }
 
 
@@ -80,6 +77,10 @@ OsMemoryStatusSnapshot getOsSnapshotFromMemInfo(final List<String> meminfoLines)
             }
         }
 
+        if (meminfo.getAvailable() < 0 || meminfo.getTotal() < 0) {
+            throw new UnsupportedOperationException("Unable to read system memory from " + MEMINFO_FILE_PATH);
+        }
+
         return new OsMemoryStatusSnapshot(meminfo.getTotal(), meminfo.getAvailable());
     }
 
diff --git a/subprojects/process-services/src/test/groovy/org/gradle/process/internal/health/memory/CGroupMemoryInfoTest.groovy b/subprojects/process-services/src/test/groovy/org/gradle/process/internal/health/memory/CGroupMemoryInfoTest.groovy
new file mode 100644
index 000000000000..a7aeb8fa3ec5
--- /dev/null
+++ b/subprojects/process-services/src/test/groovy/org/gradle/process/internal/health/memory/CGroupMemoryInfoTest.groovy
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2023 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.gradle.process.internal.health.memory
+
+import spock.lang.Specification
+
+class CGroupMemoryInfoTest extends Specification {
+    private static final long MB_IN_BYTES = 1024 * 1024 * 1024
+
+    def "parses memory from cgroup values"() {
+        def snapshot = new CGroupMemoryInfo().getOsSnapshotFromCgroup(mbsToBytesAsString(800), mbsToBytesAsString(1024))
+
+        expect:
+        snapshot.totalPhysicalMemory == mbsToBytes(1024)
+        snapshot.freePhysicalMemory == mbsToBytes(224)
+    }
+
+    def "negative free memory returns zero"() {
+        def snapshot = new CGroupMemoryInfo().getOsSnapshotFromCgroup(mbsToBytesAsString(1024), mbsToBytesAsString(512))
+
+        expect:
+        snapshot.totalPhysicalMemory == mbsToBytes(512)
+        snapshot.freePhysicalMemory == 0
+    }
+
+    def "throws unsupported operation exception when non-numeric values are provided"() {
+        when:
+        new CGroupMemoryInfo().getOsSnapshotFromCgroup("foo", "bar")
+
+        then:
+        thrown(UnsupportedOperationException)
+    }
+
+    long mbsToBytes(int mbs) {
+        return mbs * MB_IN_BYTES
+    }
+
+    String mbsToBytesAsString(int mbs) {
+        return mbsToBytes(mbs) as String
+    }
+}
diff --git a/subprojects/process-services/src/test/groovy/org/gradle/process/internal/health/memory/MemInfoOsMemoryInfoTest.groovy b/subprojects/process-services/src/test/groovy/org/gradle/process/internal/health/memory/MemInfoOsMemoryInfoTest.groovy
index 810d5e49e9b5..a7442718c0ed 100644
--- a/subprojects/process-services/src/test/groovy/org/gradle/process/internal/health/memory/MemInfoOsMemoryInfoTest.groovy
+++ b/subprojects/process-services/src/test/groovy/org/gradle/process/internal/health/memory/MemInfoOsMemoryInfoTest.groovy
@@ -37,12 +37,15 @@ class MemInfoOsMemoryInfoTest extends Specification {
         snapshot.totalPhysicalMemory == 33_594_605_568L
     }
 
-    def "returns -1 given unparsable file"() {
-        given:
-        def snapshot = new MemInfoOsMemoryInfo().getOsSnapshotFromMemInfo(["bogustown"])
-        expect:
-        snapshot.freePhysicalMemory == -1L
-        snapshot.totalPhysicalMemory == -1L
+    def "throws unsupported operation exception when non-numeric values are provided"() {
+        when:
+        new MemInfoOsMemoryInfo().getOsSnapshotFromMemInfo(meminfo)
+
+        then:
+        thrown(UnsupportedOperationException)
+
+        where:
+        meminfo << [["bogustown"], bogusMeminfoLinux3(), bogusMeminfoLinux4()]
     }
 
     private static List<String> meminfoLinux3() {
@@ -138,6 +141,102 @@ Hugepagesize:       2048 kB
 DirectMap4k:      197056 kB
 DirectMap2M:     5953536 kB
 DirectMap1G:    28311552 kB
+""".split(/\n/)
+    }
+
+    private static List<String> bogusMeminfoLinux3() {
+        """MemTotal:       foo
+MemFree:        bar
+Buffers:          baz
+Cached:         14152476 kB
+SwapCached:            0 kB
+Active:         17791108 kB
+Inactive:       13818288 kB
+Active(anon):   17189920 kB
+Inactive(anon):      460 kB
+Active(file):     601188 kB
+Inactive(file): 13817828 kB
+Unevictable:           0 kB
+Mlocked:               0 kB
+SwapTotal:             0 kB
+SwapFree:              0 kB
+Dirty:                20 kB
+Writeback:             0 kB
+AnonPages:      17189100 kB
+Mapped:            24008 kB
+Shmem:              1312 kB
+Slab:            1291916 kB
+SReclaimable:    1236196 kB
+SUnreclaim:        55720 kB
+KernelStack:        2888 kB
+PageTables:        41200 kB
+NFS_Unstable:          0 kB
+Bounce:                0 kB
+WritebackTmp:          0 kB
+CommitLimit:    24731588 kB
+Committed_AS:   22081020 kB
+VmallocTotal:   34359738367 kB
+VmallocUsed:      173104 kB
+VmallocChunk:   34359438128 kB
+HardwareCorrupted:     0 kB
+AnonHugePages:  17104896 kB
+HugePages_Total:       0
+HugePages_Free:        0
+HugePages_Rsvd:        0
+HugePages_Surp:        0
+Hugepagesize:       2048 kB
+DirectMap4k:      107840 kB
+DirectMap2M:    50223104 kB
+""".split(/\n/)
+    }
+
+    private static List<String> bogusMeminfoLinux4() {
+        """MemTotal:       foo
+MemFree:          315332 kB
+MemAvailable:    bar
+Buffers:          452252 kB
+Cached:          1425068 kB
+SwapCached:        80148 kB
+Active:          1587152 kB
+Inactive:        1029860 kB
+Active(anon):     213704 kB
+Inactive(anon):   526268 kB
+Active(file):    1373448 kB
+Inactive(file):   503592 kB
+Unevictable:           0 kB
+Mlocked:               0 kB
+SwapTotal:      16777212 kB
+SwapFree:       16550088 kB
+Dirty:               104 kB
+Writeback:             0 kB
+AnonPages:        714372 kB
+Mapped:            26076 kB
+Shmem:               280 kB
+Slab:             209636 kB
+SReclaimable:     173608 kB
+SUnreclaim:        36028 kB
+KernelStack:        6960 kB
+PageTables:        23980 kB
+NFS_Unstable:          0 kB
+Bounce:                0 kB
+WritebackTmp:          0 kB
+CommitLimit:    18435228 kB
+Committed_AS:    2004416 kB
+VmallocTotal:   34359738367 kB
+VmallocUsed:      186088 kB
+VmallocChunk:   34359452624 kB
+HardwareCorrupted:     0 kB
+AnonHugePages:    194560 kB
+CmaTotal:              0 kB
+CmaFree:               0 kB
+HugePages_Total:   14400
+HugePages_Free:       60
+HugePages_Rsvd:        0
+HugePages_Surp:        0
+Hugepagesize:       2048 kB
+DirectMap4k:      197056 kB
+DirectMap2M:     5953536 kB
+DirectMap1G:    28311552 kB
 """.split(/\n/)
     }
 }
