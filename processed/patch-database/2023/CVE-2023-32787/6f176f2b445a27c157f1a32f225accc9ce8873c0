diff --git a/src/main/java/org/opcfoundation/ua/transport/tcp/nio/OpcTcpServer.java b/src/main/java/org/opcfoundation/ua/transport/tcp/nio/OpcTcpServer.java
index 1ddba1b..fab751a 100644
--- a/src/main/java/org/opcfoundation/ua/transport/tcp/nio/OpcTcpServer.java
+++ b/src/main/java/org/opcfoundation/ua/transport/tcp/nio/OpcTcpServer.java
@@ -191,9 +191,13 @@ public void onOpen() {
 	          if (tmp.size() > maxConnections) {
 	            logger.trace("We are at over limit, unable to purge enough old connections, closing this connection");
 	            conn.close();
-	          } else if (tmp.size() == maxConnections) {
-	            logger.trace("We are exactly at maximum connections (including this connection). "
-	                + "No older connections could be purged. Keeping this connection open.");
+	          } else {
+	        	  if (tmp.size() == maxConnections) {
+	        		logger.trace("We are exactly at maximum connections (including this connection). ")	;
+	        	  } else {
+	        		logger.trace("We are below maximum connection limit");
+	        	  }
+	              conn.init();	        	  
 	          }
 	    }};
 	ConnectionCollection connections = new ConnectionCollection(this);	
@@ -297,6 +301,8 @@ public void onClosed(ServiceResultException closeError) {
 					@Override
 					public void onOpen() {
 					}});
+		        // start listening to messages
+				conn.init();
 				//async, do last, others listen on socket state.
 				socketHandle.socket.connect(socketHandle.socketAddress);
 			}catch(IOException e) {
diff --git a/src/main/java/org/opcfoundation/ua/transport/tcp/nio/OpcTcpServerConnection.java b/src/main/java/org/opcfoundation/ua/transport/tcp/nio/OpcTcpServerConnection.java
index 9172a1d..a3ac061 100644
--- a/src/main/java/org/opcfoundation/ua/transport/tcp/nio/OpcTcpServerConnection.java
+++ b/src/main/java/org/opcfoundation/ua/transport/tcp/nio/OpcTcpServerConnection.java
@@ -311,15 +311,27 @@ public void onStateTransition(IStatefulObject<SocketState, ?> monitor, SocketSta
 
 				setState(CloseableObjectState.Opening);
 
+			}
+			
+			/**
+			 * Start listening for data from the connection, note that data might be processed already before
+			 * this method returns.
+			 */
+			public void init() {
 				s.getStateMonitor().addStateListener(socketListener);
-				s.getInputStream().createMonitor(8, inputListener);
 				
+			    // must set timeout timer here, because it might be canceled before the below monitor
+			    // is triggered
 				if(rh == null) {
 					timeoutTimer = TimerUtil.schedule(
 							timer, timeout,
 							StackUtils.getBlockingWorkExecutor(),
 							System.currentTimeMillis() + handshakeTimeout);
 				}
+
+			    // Start listening for the Hello (the inputListener will schedule itself again)
+				s.getInputStream().createMonitor(8, inputListener);
+
 				if(rh != null) {
 					s.getStateMonitor().addStateListener(new StateListener<SocketState>() {
 						@Override
@@ -335,8 +347,8 @@ public void onStateTransition(
 							}							
 						}
 					});
-				}
-			}
+				}	
+			  }			
 
 			/** {@inheritDoc} */
 			@Override
@@ -1234,7 +1246,8 @@ public void run() {
 							// number of supported SecureChannels. ")
 							if (msg.getMessage() instanceof ActivateSessionResponse) {
 								ActivateSessionResponse res = (ActivateSessionResponse) msg.getMessage();
-								if (res.getResponseHeader().getServiceResult().isGood()) {
+								if ((res.getResponseHeader() != null) && (res.getResponseHeader().getServiceResult() != null) && 
+										(res.getResponseHeader().getServiceResult().isGood())) {
 									hasBeenSuccessfullySessionActivated.set(true);
 								}
 							}
