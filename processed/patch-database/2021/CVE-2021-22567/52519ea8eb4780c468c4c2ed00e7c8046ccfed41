diff --git a/CHANGELOG.md b/CHANGELOG.md
index c611f3b2c6a0..68af8037b83e 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -2,14 +2,18 @@
 
 ### Language
 
-- **[Constructor tearoffs][]**: **BETA PREVIEW**
+The following features are new in the Dart 2.15 [language version][]. To use
+them, you must set the lower bound on the SDK constraint for your package to
+2.15 or greater (`sdk: '>=2.15.0 <3.0.0'`).
 
-  Previous Dart versions allowed a method on an instance to be passed as a
-  closure, and similarly for static methods. This is commonly referred to as
-  "closurizing" or "tearing off" a method. Constructors were not previously
-  eligible for closurization, forcing users to explicitly write wrapper
-  functions when using constructors as first class functions, as in the calls to
-  `List.map` in the following example:
+[language version]: https://dart.dev/guides/language/evolution
+
+- **[Constructor tear-offs][]**: Previous Dart versions allowed a method on an
+  instance to be passed as a closure, and similarly for static methods. This is
+  commonly referred to as "closurizing" or "tearing off" a method. Constructors
+  were not previously eligible for closurization, forcing users to explicitly
+  write wrapper functions when using constructors as first class functions, as
+  in the calls to `map()` in the following example:
 
   ```dart
   class A {
@@ -55,10 +59,10 @@
   ```
 
   Constructors for generic classes may be torn off as generic functions, or
-  instantiated at the tear off site. So in the following code, the tear off
+  instantiated at the tear-off site. So in the following code, the tear-off
   `G.new` used to initialize the variable `f` produces a generic function which
   may be used to produce an instance of `G<T>` for any type `T` provided when
-  `f` is called. The tear off `G<String>.new` used to initialize the variable
+  `f` is called. The tear-off `G<String>.new` used to initialize the variable
   `g` on the other hand produces a non-generic function which may only be used
   to produce instances of type `G<String>`.
 
@@ -76,27 +80,14 @@
   }
   ```
 
-  The new constructor tearoff feature is currently in **BETA PREVIEW**. The
-  feature is enabled in beta releases only, and is still subject to breaking
-  changes. It is not fully supported by all tools and there may be known issues
-  with the tool support. Feedback on the feature is welcome, but it is not
-  recommended that production code use the feature until it has been released in
-  a stable version.
-
-  The new constructor tearoff feature is only available as part of the 2.15
-  [language version](https://dart.dev/guides/language/evolution). To use this
-  feature, you must set the lower bound on the sdk constraint for your package
-  to 2.15 or greater (if using a beta preview release, an sdk constraint of
-  `>=2.15.0-0` must be used).
-
-- **[Generic type literals][Explicit instantiation]**: **BETA PREVIEW**
+[constructor tear-offs]: https://github.com/dart-lang/language/blob/master/accepted/future-releases/constructor-tearoffs/feature-specification.md
 
-  Previous Dart versions allowed class names to be used as type literals. So
-  for example,`int` may be used as an expression, producing a value of type
-  `Type`. Generic classes (e.g. `List`) could be referred to by name as an
-  expression, but no type arguments could be provided and so only the `dynamic`
-  instantiation could be produced directly as an expression without using
-  indirect methods:
+- **[Generic type literals][explicit instantiation]**: Previous Dart versions
+  allowed class names to be used as type literals. So for example,`int` may be
+  used as an expression, producing a value of type `Type`. Generic classes (e.g.
+  `List`) could be referred to by name as an expression, but no type arguments
+  could be provided and so only the `dynamic` instantiation could be produced
+  directly as an expression without using indirect methods:
 
   ```dart
   // Workaround to capture generic type literals.
@@ -121,23 +112,9 @@
   }
   ```
 
-  The new generic type literal feature is currently in **BETA PREVIEW**. The
-  feature is enabled in beta releases only, and is still subject to breaking
-  changes. It is not fully supported by all tools and there may be known issues
-  with the tool support. Feedback on the feature is welcome, but it is not
-  recommended that production code use the feature until it has been released in
-  a stable version.
-
-  Generic type literals are only available as part of the 2.15 [language
-  version](https://dart.dev/guides/language/evolution). To use this feature, you
-  must set the lower bound on the sdk constraint for your package to 2.15 or
-  greater (if using a beta preview release, an sdk constraint of
-  `>=2.15.0-0` must be used).
-
-- **[Explicit generic method instantiations][Explicit instantiation]**: **BETA PREVIEW**
-
-  Previous Dart versions allowed generic methods to be implicitly specialized
-  (or "instantiated") to non-generic versions when assigned to a location with a
+- **[Explicit generic method instantiations][explicit instantiation]**: Previous
+  Dart versions allowed generic methods to be implicitly specialized (or
+  "instantiated") to non-generic versions when assigned to a location with a
   compatible monomorphic type. Example:
 
   ```dart
@@ -177,30 +154,12 @@
   }
   ```
 
-  The new generic method instantation feature is currently in **BETA PREVIEW**.
-  The feature is enabled in beta releases only, and is still subject to breaking
-  changes. It is not fully supported by all tools and there may be known issues
-  with the tool support. Feedback on the feature is welcome, but it is not
-  recommended that production code use the feature until it has been released in
-  a stable version.
+[explicit instantiation]: https://github.com/dart-lang/language/blob/master/accepted/future-releases/constructor-tearoffs/feature-specification.md#explicitly-instantiated-classes-and-functions
 
-  Explicit generic method instantiations are only available as part of the 2.15
-  [language version](https://dart.dev/guides/language/evolution). To use this
-  feature, you must set the lower bound on the sdk constraint for your package
-  to 2.15 or greater (if using a beta preview release, an sdk constraint of
-  `>=2.15.0-0` must be used).
-
-  [Constructor tearoffs]:
-        https://github.com/dart-lang/language/blob/master/accepted/future-releases/constructor-tearoffs/feature-specification.md
-
-  [Explicit instantiation]:
-        https://github.com/dart-lang/language/blob/master/accepted/future-releases/constructor-tearoffs/feature-specification.md#explicitly-instantiated-classes-and-functions
-
-- **[Generic instantiation of function objects][Object instantiation]**: **BETA PREVIEW**
-
-  Generic function instantiation was previously restricted to function
-  declarations. For example, as soon as a function had already been torn
-  off, it could not be instantiated:
+- **[Generic instantiation of function objects][object instantiation]**: Generic
+  function instantiation was previously restricted to function declarations. For
+  example, as soon as a function had already been torn off, it could not be
+  instantiated:
 
   ```dart
   X id<X>(X x) => x;
@@ -240,19 +199,6 @@
   }
   ```
 
-  The new generic instantation of objects feature is currently in **BETA
-  PREVIEW**. The feature is enabled in beta releases only, and is still subject
-  to breaking changes. It is not fully supported by all tools and there may be
-  known issues with the tool support. Feedback on the feature is welcome, but it
-  is not recommended that production code use the feature until it has been
-  released in a stable version.
-
-  Generic instantiation of objects is only available as part of the 2.15
-  [language version](https://dart.dev/guides/language/evolution). To use this
-  feature, you must set the lower bound on the sdk constraint for your package
-  to 2.15 or greater (if using a beta preview release, an sdk constraint of
-  `>=2.15.0-0` must be used).
-
 [Object instantiation]: https://github.com/dart-lang/language/pull/1812
 
 - Annotations on type parameters of classes can no longer refer to class members
@@ -282,7 +228,7 @@
   f(int? i) {
     var iIsNull = i == null;
     if (!iIsNull) {
-      print(i + 1); // OK, because `i` is known to be non-null
+      print(i + 1); // OK, because `i` is known to be non-null.
     }
   }
   ```
@@ -293,7 +239,7 @@
   lacked an explicit type.
 
   To avoid causing problems for packages that are intended to work with older
-  versions of Dart, the fix only takes effect when the "constructor tearoffs"
+  versions of Dart, the fix only takes effect when the "constructor tear-offs"
   language feature is enabled.
 
 [#1785]: https://github.com/dart-lang/language/issues/1785
@@ -324,72 +270,17 @@
   instance variable, and it brings the implementation behavior in line with
   the specification in all other cases.
 
-- **Function object canonicalization and equality**
-
-  Several corner cases in the area of function object canonicalization and
-  function object equality have been updated, such that all tools behave in
-  the same way, and the behavior matches the specification.
+- **Function object canonicalization and equality**: Several corner cases in the
+  area of function object canonicalization and function object equality have
+  been updated, such that all tools behave in the same way, and the behavior
+  matches the specification.
 
   In particular, function objects are now equal when they are obtained by
   generic instantiation from the same function with the same actual type
   arguments, even when that type argument is not known at compile time.
   When the expressions are constant then said function objects are identical.
   Constant expressions are treated as such even when they do not occur in a
-  constant context (e.g., `var f = top;`). Here are the main cases where the
-  behavior has been adjusted:
-
-  ```dart
-  void top() {}
-  X? genericTop<X>() => null;
-
-  class A {
-    static void stat() {}
-    static X? genericStat<X>() => null;
-    void inst() {}
-    X? genericInst<X>() => null;
-  }
-
-  const int? Function() cIntTop1 = genericTop;
-  const int? Function() cIntStat1 = A.genericStat;
-
-  int? Function() vIntTop1 = genericTop;
-  int? Function() vIntStat1 = A.genericStat;
-  int? Function() vIntTop2 = genericTop;
-  int? Function() vIntStat2 = A.genericStat;
-
-  String? Function() vStringTop = genericTop;
-  String? Function() vStringStat = A.genericStat;
-
-  void main() {
-    var a = A();
-    int? Function() vIntInst1 = a.genericInst;
-    int? Function() vIntInst2 = a.genericInst;
-
-    // All true (used to be false).
-    identical(cIntTop1, vIntTop2);
-    identical(cIntStat1, vIntStat2);
-    identical(vIntTop1, vIntTop2);
-    identical(vIntStat1, vIntStat2);
-    vIntInst1 == vIntInst2;
-
-    <X>() {
-      X? Function() vXTop1 = genericTop;
-      X? Function() vXStat1 = A.genericStat;
-      X? Function() vXTop2 = genericTop;
-      X? Function() vXStat2 = A.genericStat;
-      X? Function() vXInst1 = a.genericInst;
-      X? Function() vXInst2 = a.genericInst;
-
-      // All true (used to be false).
-      vXTop1 == vXTop2;
-      vXStat1 == vXStat2;
-      vXInst1 == vXInst2;
-      vXTop1 == vIntTop1;
-      vXStat1 == vIntStat1;
-      vXInst1 == vIntInst2;
-    }<int>();
-  }
-  ```
+  constant context (e.g., `var f = top;`).
 
 ### Core libraries
 
diff --git a/pkg/_fe_analyzer_shared/lib/src/messages/codes_generated.dart b/pkg/_fe_analyzer_shared/lib/src/messages/codes_generated.dart
index 0b96e0802c60..5e5e65043f45 100644
--- a/pkg/_fe_analyzer_shared/lib/src/messages/codes_generated.dart
+++ b/pkg/_fe_analyzer_shared/lib/src/messages/codes_generated.dart
@@ -3271,48 +3271,6 @@ Message _withArgumentsExperimentNotEnabled(String string, String string2) {
       arguments: {'string': string, 'string2': string2});
 }
 
-// DO NOT EDIT. THIS FILE IS GENERATED. SEE TOP OF FILE.
-const Code<Null> codeExperimentNotEnabledNoFlag =
-    messageExperimentNotEnabledNoFlag;
-
-// DO NOT EDIT. THIS FILE IS GENERATED. SEE TOP OF FILE.
-const MessageCode messageExperimentNotEnabledNoFlag = const MessageCode(
-    "ExperimentNotEnabledNoFlag",
-    analyzerCodes: <String>["ParserErrorCode.EXPERIMENT_NOT_ENABLED"],
-    problemMessage:
-        r"""This requires the null safety language feature, which is experimental.""",
-    correctionMessage:
-        r"""You can enable the experiment using the '--enable-experiment=non-nullable' command line option.""");
-
-// DO NOT EDIT. THIS FILE IS GENERATED. SEE TOP OF FILE.
-const Template<Message Function(String string2)>
-    templateExperimentNotEnabledNoFlagInvalidLanguageVersion =
-    const Template<Message Function(String string2)>(
-        problemMessageTemplate:
-            r"""This requires the null safety language feature, which is experimental and requires language version of #string2 or higher.""",
-        correctionMessageTemplate:
-            r"""You can enable the experiment using the '--enable-experiment=non-nullable' command line option.""",
-        withArguments:
-            _withArgumentsExperimentNotEnabledNoFlagInvalidLanguageVersion);
-
-// DO NOT EDIT. THIS FILE IS GENERATED. SEE TOP OF FILE.
-const Code<Message Function(String string2)>
-    codeExperimentNotEnabledNoFlagInvalidLanguageVersion =
-    const Code<Message Function(String string2)>(
-        "ExperimentNotEnabledNoFlagInvalidLanguageVersion",
-        analyzerCodes: <String>["ParserErrorCode.EXPERIMENT_NOT_ENABLED"]);
-
-// DO NOT EDIT. THIS FILE IS GENERATED. SEE TOP OF FILE.
-Message _withArgumentsExperimentNotEnabledNoFlagInvalidLanguageVersion(
-    String string2) {
-  if (string2.isEmpty) throw 'No string provided';
-  return new Message(codeExperimentNotEnabledNoFlagInvalidLanguageVersion,
-      problemMessage:
-          """This requires the null safety language feature, which is experimental and requires language version of ${string2} or higher.""",
-      correctionMessage: """You can enable the experiment using the '--enable-experiment=non-nullable' command line option.""",
-      arguments: {'string2': string2});
-}
-
 // DO NOT EDIT. THIS FILE IS GENERATED. SEE TOP OF FILE.
 const Code<Null> codeExplicitExtensionArgumentMismatch =
     messageExplicitExtensionArgumentMismatch;
diff --git a/pkg/analyzer/lib/error/error.dart b/pkg/analyzer/lib/error/error.dart
index 1c98a3a60783..0bc425e94104 100644
--- a/pkg/analyzer/lib/error/error.dart
+++ b/pkg/analyzer/lib/error/error.dart
@@ -632,6 +632,8 @@ const List<ErrorCode> errorCodeValues = [
   HintCode.UNNECESSARY_QUESTION_MARK,
   HintCode.UNNECESSARY_TYPE_CHECK_FALSE,
   HintCode.UNNECESSARY_TYPE_CHECK_TRUE,
+  HintCode.TEXT_DIRECTION_CODE_POINT_IN_COMMENT,
+  HintCode.TEXT_DIRECTION_CODE_POINT_IN_LITERAL,
   HintCode.UNUSED_CATCH_CLAUSE,
   HintCode.UNUSED_CATCH_STACK,
   HintCode.UNUSED_ELEMENT,
diff --git a/pkg/analyzer/lib/src/dart/analysis/library_analyzer.dart b/pkg/analyzer/lib/src/dart/analysis/library_analyzer.dart
index 315b85647584..f6a39e86dcae 100644
--- a/pkg/analyzer/lib/src/dart/analysis/library_analyzer.dart
+++ b/pkg/analyzer/lib/src/dart/analysis/library_analyzer.dart
@@ -33,6 +33,7 @@ import 'package:analyzer/src/error/inheritance_override.dart';
 import 'package:analyzer/src/error/language_version_override_verifier.dart';
 import 'package:analyzer/src/error/override_verifier.dart';
 import 'package:analyzer/src/error/todo_finder.dart';
+import 'package:analyzer/src/error/unicode_text_verifier.dart';
 import 'package:analyzer/src/error/unused_local_elements_verifier.dart';
 import 'package:analyzer/src/generated/declaration_resolver.dart';
 import 'package:analyzer/src/generated/engine.dart';
@@ -259,6 +260,8 @@ class LibraryAnalyzer {
       );
     }
 
+    UnicodeTextVerifier(errorReporter).verify(unit, file.content);
+
     unit.accept(DeadCodeVerifier(errorReporter));
 
     unit.accept(
diff --git a/pkg/analyzer/lib/src/dart/error/hint_codes.g.dart b/pkg/analyzer/lib/src/dart/error/hint_codes.g.dart
index 8dc8f2a51f54..ecb67b1aa315 100644
--- a/pkg/analyzer/lib/src/dart/error/hint_codes.g.dart
+++ b/pkg/analyzer/lib/src/dart/error/hint_codes.g.dart
@@ -2913,6 +2913,92 @@ class HintCode extends AnalyzerErrorCode {
     hasPublishedDocs: true,
   );
 
+  /**
+   * Parameters:
+   * 0: the unicode sequence of the code point.
+   */
+  // #### Description
+  //
+  // The analyzer produces this diagnostic when it encounters source that
+  // contains text direction Unicode code points. These code points cause
+  // source code in either a string literal or a comment to be interpreted
+  // and compiled differently than how it appears in editors, leading to
+  // possible security vulnerabilities.
+  //
+  // #### Example
+  //
+  // The following code produces this diagnostic twice because there are
+  // hidden characters at the start and end of the label string:
+  //
+  // ```dart
+  // var label = '[!I!]nteractive text[!'!];
+  // ```
+  //
+  // #### Common fixes
+  //
+  // If the code points are intended to be included in the string literal,
+  // then escape them:
+  //
+  // ```dart
+  // var label = '\u202AInteractive text\u202C';
+  // ```
+  //
+  // If the code points aren't intended to be included in the string literal,
+  // then remove them:
+  //
+  // ```dart
+  // var label = 'Interactive text';
+  // ```
+  static const HintCode TEXT_DIRECTION_CODE_POINT_IN_COMMENT = HintCode(
+    'TEXT_DIRECTION_CODE_POINT_IN_COMMENT',
+    "The Unicode code point 'U+{0}' changes the appearance of text from how it's interpreted by the compiler.",
+    correctionMessage:
+        "Try removing the code point or using the Unicode escape sequence '\\u{0}'.",
+  );
+
+  /**
+   * Parameters:
+   * 0: the unicode sequence of the code point.
+   */
+  // #### Description
+  //
+  // The analyzer produces this diagnostic when it encounters source that
+  // contains text direction Unicode code points. These code points cause
+  // source code in either a string literal or a comment to be interpreted
+  // and compiled differently than how it appears in editors, leading to
+  // possible security vulnerabilities.
+  //
+  // #### Example
+  //
+  // The following code produces this diagnostic twice because there are
+  // hidden characters at the start and end of the label string:
+  //
+  // ```dart
+  // var label = '[!I!]nteractive text[!'!];
+  // ```
+  //
+  // #### Common fixes
+  //
+  // If the code points are intended to be included in the string literal,
+  // then escape them:
+  //
+  // ```dart
+  // var label = '\u202AInteractive text\u202C';
+  // ```
+  //
+  // If the code points aren't intended to be included in the string literal,
+  // then remove them:
+  //
+  // ```dart
+  // var label = 'Interactive text';
+  // ```
+  static const HintCode TEXT_DIRECTION_CODE_POINT_IN_LITERAL = HintCode(
+    'TEXT_DIRECTION_CODE_POINT_IN_LITERAL',
+    "The Unicode code point 'U+{0}' changes the appearance of text from how it's interpreted by the compiler.",
+    correctionMessage:
+        "Try removing the code point or using the Unicode escape sequence '\\u{0}'.",
+  );
+
   /**
    * No parameters.
    */
diff --git a/pkg/analyzer/lib/src/dart/micro/library_analyzer.dart b/pkg/analyzer/lib/src/dart/micro/library_analyzer.dart
index be5b2ba5ae1d..e904ee0110d8 100644
--- a/pkg/analyzer/lib/src/dart/micro/library_analyzer.dart
+++ b/pkg/analyzer/lib/src/dart/micro/library_analyzer.dart
@@ -31,6 +31,7 @@ import 'package:analyzer/src/error/imports_verifier.dart';
 import 'package:analyzer/src/error/inheritance_override.dart';
 import 'package:analyzer/src/error/override_verifier.dart';
 import 'package:analyzer/src/error/todo_finder.dart';
+import 'package:analyzer/src/error/unicode_text_verifier.dart';
 import 'package:analyzer/src/error/unused_local_elements_verifier.dart';
 import 'package:analyzer/src/generated/declaration_resolver.dart';
 import 'package:analyzer/src/generated/engine.dart';
@@ -270,6 +271,8 @@ class LibraryAnalyzer {
     unit.accept(DeadCodeVerifier(errorReporter));
 
     var content = getFileContent(file);
+    UnicodeTextVerifier(errorReporter).verify(unit, content);
+
     unit.accept(
       BestPracticesVerifier(
         errorReporter,
diff --git a/pkg/analyzer/lib/src/error/unicode_text_verifier.dart b/pkg/analyzer/lib/src/error/unicode_text_verifier.dart
new file mode 100644
index 000000000000..cdbe7ada7ee2
--- /dev/null
+++ b/pkg/analyzer/lib/src/error/unicode_text_verifier.dart
@@ -0,0 +1,37 @@
+// Copyright (c) 2021, the Dart project authors. Please see the AUTHORS file
+// for details. All rights reserved. Use of this source code is governed by a
+// BSD-style license that can be found in the LICENSE file.
+
+import 'package:analyzer/dart/ast/ast.dart';
+import 'package:analyzer/error/listener.dart';
+import 'package:analyzer/src/dart/ast/utilities.dart';
+import 'package:analyzer/src/error/codes.dart';
+
+/// A verifier that checks for unsafe Unicode text.
+/// todo(pq): update w/ a Dart CVE link once published
+class UnicodeTextVerifier {
+  final ErrorReporter errorReporter;
+  UnicodeTextVerifier(this.errorReporter);
+
+  void verify(CompilationUnit unit, String source) {
+    for (var offset = 0; offset < source.length; ++offset) {
+      var codeUnit = source.codeUnitAt(offset);
+      // U+202A, U+202B, U+202C, U+202D, U+202E, U+2066, U+2067, U+2068, U+2069.
+      if (0x202a <= codeUnit &&
+          codeUnit <= 0x2069 &&
+          (codeUnit <= 0x202e || 0x2066 <= codeUnit)) {
+        // This uses an AST visitor; consider a more direct approach.
+        var node = NodeLocator(offset).searchWithin(unit);
+        // If it's not in a string literal, we assume we're in a comment.
+        // This can potentially over-report on syntactically incorrect sources
+        // (where Unicode is outside a string or comment).
+        var errorCode =
+            node is SimpleStringLiteral || node is InterpolationString
+                ? HintCode.TEXT_DIRECTION_CODE_POINT_IN_LITERAL
+                : HintCode.TEXT_DIRECTION_CODE_POINT_IN_COMMENT;
+        var code = codeUnit.toRadixString(16).toUpperCase();
+        errorReporter.reportErrorForOffset(errorCode, offset, 1, [code]);
+      }
+    }
+  }
+}
diff --git a/pkg/analyzer/messages.yaml b/pkg/analyzer/messages.yaml
index 3637c8deb6d8..3aa6e61f23f8 100644
--- a/pkg/analyzer/messages.yaml
+++ b/pkg/analyzer/messages.yaml
@@ -16446,6 +16446,86 @@ HintCode:
       If the class needs to be a subtype of the sealed class, then either change
       the sealed class so that it's no longer sealed or move the subclass into
       the same package as the sealed class.
+  TEXT_DIRECTION_CODE_POINT_IN_COMMENT:
+    problemMessage: The Unicode code point 'U+{0}' changes the appearance of text from how it's interpreted by the compiler.
+    correctionMessage: Try removing the code point or using the Unicode escape sequence '\u{0}'.
+    hasPublishedDocs: false
+    comment: |-
+      Parameters:
+      0: the unicode sequence of the code point.
+    documentation: |-
+      #### Description
+
+      The analyzer produces this diagnostic when it encounters source that
+      contains text direction Unicode code points. These code points cause
+      source code in either a string literal or a comment to be interpreted
+      and compiled differently than how it appears in editors, leading to
+      possible security vulnerabilities.
+
+      #### Example
+
+      The following code produces this diagnostic twice because there are
+      hidden characters at the start and end of the label string:
+
+      ```dart
+      var label = '[!I!]nteractive text[!'!];
+      ```
+
+      #### Common fixes
+
+      If the code points are intended to be included in the string literal,
+      then escape them:
+
+      ```dart
+      var label = '\u202AInteractive text\u202C';
+      ```
+
+      If the code points aren't intended to be included in the string literal,
+      then remove them:
+
+      ```dart
+      var label = 'Interactive text';
+      ```
+  TEXT_DIRECTION_CODE_POINT_IN_LITERAL:
+    problemMessage: The Unicode code point 'U+{0}' changes the appearance of text from how it's interpreted by the compiler.
+    correctionMessage: Try removing the code point or using the Unicode escape sequence '\u{0}'.
+    hasPublishedDocs: false
+    comment: |-
+      Parameters:
+      0: the unicode sequence of the code point.
+    documentation: |-
+      #### Description
+
+      The analyzer produces this diagnostic when it encounters source that
+      contains text direction Unicode code points. These code points cause
+      source code in either a string literal or a comment to be interpreted
+      and compiled differently than how it appears in editors, leading to
+      possible security vulnerabilities.
+
+      #### Example
+
+      The following code produces this diagnostic twice because there are
+      hidden characters at the start and end of the label string:
+
+      ```dart
+      var label = '[!I!]nteractive text[!'!];
+      ```
+
+      #### Common fixes
+
+      If the code points are intended to be included in the string literal,
+      then escape them:
+
+      ```dart
+      var label = '\u202AInteractive text\u202C';
+      ```
+
+      If the code points aren't intended to be included in the string literal,
+      then remove them:
+
+      ```dart
+      var label = 'Interactive text';
+      ```
   TYPE_CHECK_IS_NOT_NULL:
     sharedName: TYPE_CHECK_WITH_NULL
     problemMessage: "Tests for non-null should be done with '!= null'."
diff --git a/pkg/analyzer/test/src/diagnostics/test_all.dart b/pkg/analyzer/test/src/diagnostics/test_all.dart
index 263958af8582..0331a23c6700 100644
--- a/pkg/analyzer/test/src/diagnostics/test_all.dart
+++ b/pkg/analyzer/test/src/diagnostics/test_all.dart
@@ -630,6 +630,7 @@ import 'switch_expression_not_assignable_test.dart'
     as switch_expression_not_assignable;
 import 'tearoff_of_generative_constructor_of_abstract_class_test.dart'
     as tearoff_of_generative_constructor_of_abstract_class;
+import 'text_direction_code_point_test.dart' as text_direction_code_point;
 import 'throw_of_invalid_type_test.dart' as throw_of_invalid_type;
 import 'todo_test.dart' as todo_test;
 import 'top_level_cycle_test.dart' as top_level_cycle;
@@ -1132,6 +1133,7 @@ main() {
     switch_case_completes_normally.main();
     switch_expression_not_assignable.main();
     tearoff_of_generative_constructor_of_abstract_class.main();
+    text_direction_code_point.main();
     throw_of_invalid_type.main();
     todo_test.main();
     top_level_cycle.main();
diff --git a/pkg/analyzer/test/src/diagnostics/text_direction_code_point_test.dart b/pkg/analyzer/test/src/diagnostics/text_direction_code_point_test.dart
new file mode 100644
index 000000000000..be19a86520a0
--- /dev/null
+++ b/pkg/analyzer/test/src/diagnostics/text_direction_code_point_test.dart
@@ -0,0 +1,92 @@
+// Copyright (c) 2021, the Dart project authors. Please see the AUTHORS file
+// for details. All rights reserved. Use of this source code is governed by a
+// BSD-style license that can be found in the LICENSE file.
+
+import 'package:analyzer/src/dart/error/hint_codes.dart';
+import 'package:test_reflective_loader/test_reflective_loader.dart';
+
+import '../dart/resolution/context_collection_resolution.dart';
+
+main() {
+  defineReflectiveSuite(() {
+    defineReflectiveTests(UnsafeTextDirectionCodepointTest);
+  });
+}
+
+@reflectiveTest
+class UnsafeTextDirectionCodepointTest extends PubPackageResolutionTest {
+  test_comments() async {
+    await assertErrorsInCode('''
+// \u2066
+/// \u2066
+void f() { // \u2066
+  // \u2066
+}
+''', [
+      error(HintCode.TEXT_DIRECTION_CODE_POINT_IN_COMMENT, 3, 1),
+      error(HintCode.TEXT_DIRECTION_CODE_POINT_IN_COMMENT, 9, 1),
+      error(HintCode.TEXT_DIRECTION_CODE_POINT_IN_COMMENT, 25, 1),
+      error(HintCode.TEXT_DIRECTION_CODE_POINT_IN_COMMENT, 32, 1),
+    ]);
+  }
+
+  /// https://github.com/flutter/flutter/pull/93029
+  test_file_ok() async {
+    // Raw strings preserve the escapes.
+    await assertNoErrorsInCode(r'''
+var u202a = '\u202AInteractive text\u202C';
+''');
+  }
+
+  test_message_escape() async {
+    await assertErrorsInCode('''
+var u202a = '\u202A';
+''', [
+      error(HintCode.TEXT_DIRECTION_CODE_POINT_IN_LITERAL, 13, 1,
+          messageContains: ['U+202A']),
+    ]);
+  }
+
+  test_multiLineString() async {
+    await assertErrorsInCode('''
+var s = """ \u202a
+        Multiline!
+""";
+''', [
+      error(HintCode.TEXT_DIRECTION_CODE_POINT_IN_LITERAL, 12, 1),
+    ]);
+  }
+
+  test_simpleStrings() async {
+    await assertErrorsInCode('''
+var u202a = '\u202A';
+var u202b = '\u202B';
+var u202c = '\u202C';
+var u202d = '\u202D';
+var u202e = '\u202E';
+var u2066 = '\u2066';
+var u2067 = '\u2067';
+var u2068 = '\u2068';
+var u2069 = '\u2069';
+''', [
+      error(HintCode.TEXT_DIRECTION_CODE_POINT_IN_LITERAL, 13, 1),
+      error(HintCode.TEXT_DIRECTION_CODE_POINT_IN_LITERAL, 30, 1),
+      error(HintCode.TEXT_DIRECTION_CODE_POINT_IN_LITERAL, 47, 1),
+      error(HintCode.TEXT_DIRECTION_CODE_POINT_IN_LITERAL, 64, 1),
+      error(HintCode.TEXT_DIRECTION_CODE_POINT_IN_LITERAL, 81, 1),
+      error(HintCode.TEXT_DIRECTION_CODE_POINT_IN_LITERAL, 98, 1),
+      error(HintCode.TEXT_DIRECTION_CODE_POINT_IN_LITERAL, 115, 1),
+      error(HintCode.TEXT_DIRECTION_CODE_POINT_IN_LITERAL, 132, 1),
+      error(HintCode.TEXT_DIRECTION_CODE_POINT_IN_LITERAL, 149, 1),
+    ]);
+  }
+
+  test_stringInterpolation() async {
+    await assertErrorsInCode('''
+var x = 'x';
+var u202a = '\u202A\$x';
+''', [
+      error(HintCode.TEXT_DIRECTION_CODE_POINT_IN_LITERAL, 26, 1),
+    ]);
+  }
+}
diff --git a/pkg/analyzer/test/verify_diagnostics_test.dart b/pkg/analyzer/test/verify_diagnostics_test.dart
index bb0643dd8f80..d5ee1bf808cc 100644
--- a/pkg/analyzer/test/verify_diagnostics_test.dart
+++ b/pkg/analyzer/test/verify_diagnostics_test.dart
@@ -82,6 +82,11 @@ class DocumentationValidator {
     'CompileTimeErrorCode.YIELD_EACH_IN_NON_GENERATOR',
     // The code has been replaced but is not yet removed.
     'HintCode.DEPRECATED_MEMBER_USE',
+    // Produces more than one error range by design.
+    // TODO: update verification to allow for multiple highlight ranges.
+    'HintCode.TEXT_DIRECTION_CODE_POINT_IN_COMMENT',
+    // Produces more than one error range by design.
+    'HintCode.TEXT_DIRECTION_CODE_POINT_IN_LITERAL',
     // Produces two diagnostics when it should only produce one (see
     // https://github.com/dart-lang/sdk/issues/43051)
     'HintCode.UNNECESSARY_NULL_COMPARISON_FALSE',
diff --git a/pkg/analyzer/tool/diagnostics/diagnostics.md b/pkg/analyzer/tool/diagnostics/diagnostics.md
index 3fdc9d918409..d00d0d51b498 100644
--- a/pkg/analyzer/tool/diagnostics/diagnostics.md
+++ b/pkg/analyzer/tool/diagnostics/diagnostics.md
@@ -13017,6 +13017,82 @@ void f() {
 
 Tear off the constructor of a concrete class.
 
+### text_direction_code_point_in_comment
+
+_The Unicode code point 'U+{0}' changes the appearance of text from how it's
+interpreted by the compiler._
+
+#### Description
+
+The analyzer produces this diagnostic when it encounters source that
+contains text direction Unicode code points. These code points cause
+source code in either a string literal or a comment to be interpreted
+and compiled differently than how it appears in editors, leading to
+possible security vulnerabilities.
+
+#### Example
+
+The following code produces this diagnostic twice because there are
+hidden characters at the start and end of the label string:
+
+{% prettify dart tag=pre+code %}
+var label = '[!I!]nteractive text[!'!];
+{% endprettify %}
+
+#### Common fixes
+
+If the code points are intended to be included in the string literal,
+then escape them:
+
+{% prettify dart tag=pre+code %}
+var label = '\u202AInteractive text\u202C';
+{% endprettify %}
+
+If the code points aren't intended to be included in the string literal,
+then remove them:
+
+{% prettify dart tag=pre+code %}
+var label = 'Interactive text';
+{% endprettify %}
+
+### text_direction_code_point_in_literal
+
+_The Unicode code point 'U+{0}' changes the appearance of text from how it's
+interpreted by the compiler._
+
+#### Description
+
+The analyzer produces this diagnostic when it encounters source that
+contains text direction Unicode code points. These code points cause
+source code in either a string literal or a comment to be interpreted
+and compiled differently than how it appears in editors, leading to
+possible security vulnerabilities.
+
+#### Example
+
+The following code produces this diagnostic twice because there are
+hidden characters at the start and end of the label string:
+
+{% prettify dart tag=pre+code %}
+var label = '[!I!]nteractive text[!'!];
+{% endprettify %}
+
+#### Common fixes
+
+If the code points are intended to be included in the string literal,
+then escape them:
+
+{% prettify dart tag=pre+code %}
+var label = '\u202AInteractive text\u202C';
+{% endprettify %}
+
+If the code points aren't intended to be included in the string literal,
+then remove them:
+
+{% prettify dart tag=pre+code %}
+var label = 'Interactive text';
+{% endprettify %}
+
 ### throw_of_invalid_type
 
 _The type '{0}' of the thrown expression must be assignable to 'Object'._
diff --git a/pkg/compiler/lib/src/js/rewrite_async.dart b/pkg/compiler/lib/src/js/rewrite_async.dart
index 69a999f8e4bd..8a48496c1056 100644
--- a/pkg/compiler/lib/src/js/rewrite_async.dart
+++ b/pkg/compiler/lib/src/js/rewrite_async.dart
@@ -1397,8 +1397,8 @@ abstract class AsyncRewriterBase extends js.NodeVisitor {
 
   @override
   void visitSwitch(js.Switch node) {
-    if (!node.cases.any(shouldTransform)) {
-      // If only the key has an await, translation can be simplified.
+    if (!shouldTransform(node)) {
+      // TODO(sra): If only the key has an await, translation can be simplified.
       bool oldInsideUntranslated = insideUntranslatedBreakable;
       insideUntranslatedBreakable = true;
       withExpression(node.key, (js.Expression key) {
@@ -2824,10 +2824,9 @@ class PreTranslationAnalysis extends js.BaseVisitor<bool> {
   @override
   bool visitSwitch(js.Switch node) {
     loopsAndSwitches.add(node);
-    // If the key has an `await` expression, do not transform the
-    // body of the switch.
-    visit(node.key);
-    bool result = false;
+    // TODO(sra): If just the key has an `await` expression, do not transform
+    // the body of the switch.
+    bool result = visit(node.key);
     for (js.SwitchClause clause in node.cases) {
       if (visit(clause)) result = true;
     }
diff --git a/pkg/compiler/test/async_await/async_await_js_transform_test.dart b/pkg/compiler/test/async_await/async_await_js_transform_test.dart
index 4ea675b229f3..589725953320 100644
--- a/pkg/compiler/test/async_await/async_await_js_transform_test.dart
+++ b/pkg/compiler/test/async_await/async_await_js_transform_test.dart
@@ -1085,20 +1085,116 @@ function(l) {
       switch (__goto) {
         case 0:
           // Function start
-          __goto = 2;
-          return awaitHelper(l, body);
         case 2:
+          // switch
+          __goto = 7;
+          return awaitHelper(l, body);
+        case 7:
           // returning from await.
           switch (__result) {
             case 1:
-              print(1);
+              // goto case
+              __goto = 4;
               break;
             case 2:
-              print(1);
+              // goto case
+              __goto = 5;
+              break;
+            default:
+              // goto default
+              __goto = 6;
+              break;
+          }
+          break;
+        case 4:
+          // case
+          print(1);
+          // goto after switch
+          __goto = 3;
+          break;
+        case 5:
+          // case
+          print(1);
+        case 6:
+          // default
+          print(2);
+          // goto after switch
+          __goto = 3;
+          break;
+        case 3:
+          // after switch
+          // implicit return
+          return returnHelper(null, __completer);
+      }
+  });
+  return startHelper(body, __completer);
+}""");
+
+  testAsyncTransform("""
+  // This example is like #47566
+  function(b, l) async {
+    print("start");
+    if (b) {
+      switch(await l) {
+        case 1:
+          print(1);
+          break;
+        default:
+          print(2);
+          break;
+      }
+    }
+    print("end");
+  }""", """
+function(b, l) {
+  var __goto = 0,
+    __completer = NewCompleter(CompleterType);
+  var body = _wrapJsFunctionForAsync(function(__errorCode, __result) {
+    if (__errorCode === 1)
+      return rethrowHelper(__result, __completer);
+    while (true)
+      switch (__goto) {
+        case 0:
+          // Function start
+          print("start");
+          __goto = b ? 2 : 3;
+          break;
+        case 2:
+          // then
+        case 4:
+          // switch
+          __goto = 8;
+          return awaitHelper(l, body);
+        case 8:
+          // returning from await.
+          switch (__result) {
+            case 1:
+              // goto case
+              __goto = 6;
+              break;
             default:
-              print(2);
+              // goto default
+              __goto = 7;
               break;
           }
+          break;
+        case 6:
+          // case
+          print(1);
+          // goto after switch
+          __goto = 5;
+          break;
+        case 7:
+          // default
+          print(2);
+          // goto after switch
+          __goto = 5;
+          break;
+        case 5:
+          // after switch
+        case 3:
+          // join
+          print("end");
           // implicit return
           return returnHelper(null, __completer);
       }
diff --git a/pkg/compiler/test/rti/rti_emission_test_helper.dart b/pkg/compiler/test/rti/rti_emission_test_helper.dart
index aa48230c0bdc..e48496179aa9 100644
--- a/pkg/compiler/test/rti/rti_emission_test_helper.dart
+++ b/pkg/compiler/test/rti/rti_emission_test_helper.dart
@@ -31,7 +31,6 @@ runTests(List<String> args, [int shardIndex]) {
         new Directory.fromUri(Platform.script.resolve('emission'));
     await checkTests(dataDir, const RtiEmissionDataComputer(),
         args: args,
-        options: ['--enable-experiment=constructor-tearoffs'],
         shardIndex: shardIndex ?? 0,
         shards: shardIndex != null ? 4 : 1);
   });
diff --git a/pkg/compiler/test/rti/rti_need_test_helper.dart b/pkg/compiler/test/rti/rti_need_test_helper.dart
index f72a9f469df5..02aaf4ee8d6d 100644
--- a/pkg/compiler/test/rti/rti_need_test_helper.dart
+++ b/pkg/compiler/test/rti/rti_need_test_helper.dart
@@ -34,7 +34,6 @@ runTests(List<String> args, [int shardIndex]) {
   asyncTest(() async {
     Directory dataDir = new Directory.fromUri(Platform.script.resolve('data'));
     await checkTests(dataDir, const RtiNeedDataComputer(),
-        options: ['--enable-experiment=constructor-tearoffs'],
         args: args,
         shardIndex: shardIndex ?? 0,
         shards: shardIndex != null ? 4 : 1);
diff --git a/pkg/compiler/test/sourcemaps/stacktrace_test.dart b/pkg/compiler/test/sourcemaps/stacktrace_test.dart
index 7468227562b4..00ea52f6a3b3 100644
--- a/pkg/compiler/test/sourcemaps/stacktrace_test.dart
+++ b/pkg/compiler/test/sourcemaps/stacktrace_test.dart
@@ -89,7 +89,6 @@ Future runTest(Test test, String config,
       '--libraries-spec=$sdkLibrariesSpecificationPath',
       '--packages=${Platform.packageConfig}',
       Flags.testMode,
-      '--enable-experiment=extension-methods',
       input,
     ]..addAll(options);
     print("Compiling dart2js ${arguments.join(' ')}");
diff --git a/pkg/dev_compiler/lib/src/kernel/compiler.dart b/pkg/dev_compiler/lib/src/kernel/compiler.dart
index ba81acf39348..131d3081ca57 100644
--- a/pkg/dev_compiler/lib/src/kernel/compiler.dart
+++ b/pkg/dev_compiler/lib/src/kernel/compiler.dart
@@ -1124,6 +1124,7 @@ class ProgramCompiler extends ComputeOnceConstantVisitor<js_ast.Expression>
     for (var i = 0; i < mixinApplications.length; i++) {
       var m = mixinApplications[i];
       var mixinClass = m.isAnonymousMixin ? m.mixedInClass : m;
+      _declareBeforeUse(mixinClass);
       var mixinType =
           _hierarchy.getClassAsInstanceOf(c, mixinClass).asInterfaceType;
       var mixinName =
diff --git a/pkg/front_end/lib/src/api_prototype/experimental_flags_generated.dart b/pkg/front_end/lib/src/api_prototype/experimental_flags_generated.dart
index 4102f5a11e0c..4f3c9121377e 100644
--- a/pkg/front_end/lib/src/api_prototype/experimental_flags_generated.dart
+++ b/pkg/front_end/lib/src/api_prototype/experimental_flags_generated.dart
@@ -125,17 +125,17 @@ const Map<ExperimentalFlag, bool> expiredExperimentalFlags = {
   ExperimentalFlag.constructorTearoffs: false,
   ExperimentalFlag.controlFlowCollections: true,
   ExperimentalFlag.enhancedEnums: false,
-  ExperimentalFlag.extensionMethods: false,
+  ExperimentalFlag.extensionMethods: true,
   ExperimentalFlag.extensionTypes: false,
-  ExperimentalFlag.genericMetadata: false,
+  ExperimentalFlag.genericMetadata: true,
   ExperimentalFlag.namedArgumentsAnywhere: false,
-  ExperimentalFlag.nonNullable: false,
-  ExperimentalFlag.nonfunctionTypeAliases: false,
+  ExperimentalFlag.nonNullable: true,
+  ExperimentalFlag.nonfunctionTypeAliases: true,
   ExperimentalFlag.setLiterals: true,
   ExperimentalFlag.spreadCollections: true,
   ExperimentalFlag.superParameters: false,
   ExperimentalFlag.testExperiment: false,
-  ExperimentalFlag.tripleShift: false,
+  ExperimentalFlag.tripleShift: true,
   ExperimentalFlag.valueClass: false,
   ExperimentalFlag.variance: false,
 };
diff --git a/pkg/front_end/lib/src/fasta/source/stack_listener_impl.dart b/pkg/front_end/lib/src/fasta/source/stack_listener_impl.dart
index fa89f685dd3e..3e8326c72c89 100644
--- a/pkg/front_end/lib/src/fasta/source/stack_listener_impl.dart
+++ b/pkg/front_end/lib/src/fasta/source/stack_listener_impl.dart
@@ -12,8 +12,6 @@ import 'package:_fe_analyzer_shared/src/scanner/scanner.dart' show Token;
 
 import 'package:kernel/ast.dart';
 
-import '../../api_prototype/experimental_flags.dart';
-
 import '../fasta_codes.dart';
 
 import '../problems.dart' as problems
@@ -97,8 +95,7 @@ abstract class StackListenerImpl extends StackListener {
             token.charOffset,
             token.charCount);
       }
-    } else if (libraryBuilder.loader.target
-        .isExperimentEnabledByDefault(ExperimentalFlag.nonNullable)) {
+    } else {
       if (libraryBuilder.languageVersion.version <
           libraryBuilder.enableNonNullableVersionInLibrary) {
         addProblem(
@@ -110,25 +107,6 @@ abstract class StackListenerImpl extends StackListener {
         addProblem(templateExperimentDisabled.withArguments('non-nullable'),
             token.offset, noLength);
       }
-    } else if (!libraryBuilder.loader.target
-        .isExperimentEnabledGlobally(ExperimentalFlag.nonNullable)) {
-      if (libraryBuilder.languageVersion.version <
-          libraryBuilder.enableNonNullableVersionInLibrary) {
-        addProblem(
-            templateExperimentNotEnabledNoFlagInvalidLanguageVersion
-                .withArguments(
-                    libraryBuilder.enableNonNullableVersionInLibrary.toText()),
-            token.offset,
-            noLength);
-      } else {
-        addProblem(messageExperimentNotEnabledNoFlag, token.offset, noLength);
-      }
-    } else {
-      addProblem(
-          templateExperimentNotEnabled.withArguments('non-nullable',
-              libraryBuilder.enableNonNullableVersionInLibrary.toText()),
-          token.offset,
-          noLength);
     }
   }
 
diff --git a/pkg/front_end/messages.yaml b/pkg/front_end/messages.yaml
index 0ef4650566fd..5eac795b821b 100644
--- a/pkg/front_end/messages.yaml
+++ b/pkg/front_end/messages.yaml
@@ -282,16 +282,6 @@ ExperimentNotEnabled:
   correctionMessage: "Try updating your pubspec.yaml to set the minimum SDK constraint to #string2 or higher, and running 'pub get'."
   analyzerCode: ParserErrorCode.EXPERIMENT_NOT_ENABLED
 
-ExperimentNotEnabledNoFlag:
-  problemMessage: "This requires the null safety language feature, which is experimental."
-  correctionMessage: "You can enable the experiment using the '--enable-experiment=non-nullable' command line option."
-  analyzerCode: ParserErrorCode.EXPERIMENT_NOT_ENABLED
-
-ExperimentNotEnabledNoFlagInvalidLanguageVersion:
-  problemMessage: "This requires the null safety language feature, which is experimental and requires language version of #string2 or higher."
-  correctionMessage: "You can enable the experiment using the '--enable-experiment=non-nullable' command line option."
-  analyzerCode: ParserErrorCode.EXPERIMENT_NOT_ENABLED
-
 ExperimentDisabled:
   problemMessage: "This requires the '#string' language feature to be enabled."
   correctionMessage: "The feature is on by default but is currently disabled, maybe because the '--enable-experiment=no-#string' command line option is passed."
diff --git a/pkg/front_end/testcases/constructor_tearoffs/folder.options b/pkg/front_end/testcases/constructor_tearoffs/folder.options
index 73976a7b8e0d..0318d1c6a423 100644
--- a/pkg/front_end/testcases/constructor_tearoffs/folder.options
+++ b/pkg/front_end/testcases/constructor_tearoffs/folder.options
@@ -1,2 +1 @@
---enable-experiment=constructor-tearoffs
 --force-constructor-tear-off-lowering=0
diff --git a/pkg/front_end/testcases/constructor_tearoffs/lowering/folder.options b/pkg/front_end/testcases/constructor_tearoffs/lowering/folder.options
index 8b3469f58f22..a5f888697154 100644
--- a/pkg/front_end/testcases/constructor_tearoffs/lowering/folder.options
+++ b/pkg/front_end/testcases/constructor_tearoffs/lowering/folder.options
@@ -1,2 +1 @@
---enable-experiment=constructor-tearoffs
---force-constructor-tear-off-lowering
\ No newline at end of file
+--force-constructor-tear-off-lowering
diff --git a/pkg/front_end/testcases/extensions/extension_methods.dart b/pkg/front_end/testcases/extensions/extension_methods.dart
index 3b790498e946..958a31349727 100644
--- a/pkg/front_end/testcases/extensions/extension_methods.dart
+++ b/pkg/front_end/testcases/extensions/extension_methods.dart
@@ -1,8 +1,8 @@
 // Copyright (c) 2019, the Dart project authors.  Please see the AUTHORS file
 // for details. All rights reserved. Use of this source code is governed by a
 // BSD-style license that can be found in the LICENSE file.
+
 // @dart=2.9
-// SharedOptions=--enable-experiment=extension-methods
 
 import 'package:expect/expect.dart';
 
diff --git a/pkg/front_end/testcases/extensions/use_this.dart b/pkg/front_end/testcases/extensions/use_this.dart
index 32ef9d91dd01..8a23cb9e6d8f 100644
--- a/pkg/front_end/testcases/extensions/use_this.dart
+++ b/pkg/front_end/testcases/extensions/use_this.dart
@@ -1,8 +1,8 @@
 // Copyright (c) 2019, the Dart project authors.  Please see the AUTHORS file
 // for details. All rights reserved. Use of this source code is governed by a
 // BSD-style license that can be found in the LICENSE file.
+
 // @dart=2.9
-// SharedOptions=--enable-experiment=extension-methods
 
 class A1 {}
 
@@ -30,4 +30,4 @@ extension B2<T> on B1<T> {
   }
 }
 
-main() {}
\ No newline at end of file
+main() {}
diff --git a/runtime/lib/isolate.cc b/runtime/lib/isolate.cc
index 3569eb90afd9..21b66a2b88d7 100644
--- a/runtime/lib/isolate.cc
+++ b/runtime/lib/isolate.cc
@@ -108,7 +108,7 @@ DEFINE_NATIVE_ENTRY(SendPortImpl_sendInternal_, 0, 2) {
 
   const Dart_Port destination_port_id = port.Id();
   const bool can_send_any_object = isolate->origin_id() == port.origin_id();
-  // We have to check whether the reciever has the same isolate group (e.g.
+  // We have to check whether the receiver has the same isolate group (e.g.
   // native message handlers such as an IOService handler does not but does
   // share the same origin port).
   const bool same_group =
@@ -719,7 +719,11 @@ class SpawnIsolateTask : public ThreadPool::Task {
     }
 
     state_->set_isolate(child);
-    child->set_origin_id(state_->origin_id());
+    if (state_->origin_id() != ILLEGAL_PORT) {
+      // origin_id is set to parent isolate main port id when spawning via
+      // spawnFunction.
+      child->set_origin_id(state_->origin_id());
+    }
 
     bool success = true;
     {
diff --git a/runtime/observatory/tests/service/constructor_tear_off_test.dart b/runtime/observatory/tests/service/constructor_tear_off_test.dart
index 672a1a15721c..ac105e2a9947 100644
--- a/runtime/observatory/tests/service/constructor_tear_off_test.dart
+++ b/runtime/observatory/tests/service/constructor_tear_off_test.dart
@@ -4,8 +4,6 @@
 
 // @dart=2.15
 
-// SharedOptions=--enable-experiment=constructor-tearoffs
-
 import 'package:observatory/service_common.dart';
 import 'package:test/test.dart';
 
diff --git a/runtime/tests/vm/dart/isolates/send_object_to_spawn_uri_isolate_test.dart b/runtime/tests/vm/dart/isolates/send_object_to_spawn_uri_isolate_test.dart
new file mode 100644
index 000000000000..37eb717e0040
--- /dev/null
+++ b/runtime/tests/vm/dart/isolates/send_object_to_spawn_uri_isolate_test.dart
@@ -0,0 +1,52 @@
+// Copyright (c) 2021, the Dart project authors.  Please see the AUTHORS file
+// for details. All rights reserved. Use of this source code is governed by a
+// BSD-style license that can be found in the LICENSE file.
+//
+// This test ensures that one can't send user dart objects to
+// an isolate spawned via spawnUri.
+
+import 'dart:async';
+import 'dart:io';
+import 'dart:isolate';
+
+import 'package:expect/expect.dart';
+import "package:test/test.dart";
+
+class Foo {
+  var bar = 123;
+}
+
+Future<void> main(args, message) async {
+  if (message == null) {
+    final receivePort = ReceivePort();
+    final isolate = await Isolate.spawnUri(
+        Platform.script, <String>[], <SendPort>[receivePort.sendPort],
+        errorsAreFatal: true);
+    final result = await receivePort.first;
+    Expect.equals("done", result);
+    return;
+  }
+
+  if (args.length > 0) {
+    Expect.equals("worker", args[0]);
+    final SendPort sendPort = message[0] as SendPort;
+    Expect.throws(() => sendPort.send(Foo()));
+    sendPort.send("done");
+  } else {
+    final SendPort sendPort = message[0] as SendPort;
+
+    final receivePort = ReceivePort();
+    try {
+      final isolate = await Isolate.spawnUri(
+          Platform.script, <String>["worker"], <SendPort>[receivePort.sendPort],
+          errorsAreFatal: true);
+      final result = await receivePort.first;
+      Expect.equals("done", result);
+      sendPort.send("done");
+    } catch (_) {
+      sendPort.send("fail");
+    }
+
+    sendPort.send("done");
+  }
+}
diff --git a/runtime/tests/vm/dart_2/isolates/send_object_to_spawn_uri_isolate_test.dart b/runtime/tests/vm/dart_2/isolates/send_object_to_spawn_uri_isolate_test.dart
new file mode 100644
index 000000000000..8793ace16a50
--- /dev/null
+++ b/runtime/tests/vm/dart_2/isolates/send_object_to_spawn_uri_isolate_test.dart
@@ -0,0 +1,54 @@
+// Copyright (c) 2021, the Dart project authors.  Please see the AUTHORS file
+// for details. All rights reserved. Use of this source code is governed by a
+// BSD-style license that can be found in the LICENSE file.
+//
+// @dart = 2.9
+//
+// This test ensures that one can't send user dart objects to
+// an isolate spawned via spawnUri.
+
+import 'dart:async';
+import 'dart:io';
+import 'dart:isolate';
+
+import 'package:expect/expect.dart';
+import "package:test/test.dart";
+
+class Foo {
+  var bar = 123;
+}
+
+Future<void> main(args, message) async {
+  if (message == null) {
+    final receivePort = ReceivePort();
+    final isolate = await Isolate.spawnUri(
+        Platform.script, <String>[], <SendPort>[receivePort.sendPort],
+        errorsAreFatal: true);
+    final result = await receivePort.first;
+    Expect.equals("done", result);
+    return;
+  }
+
+  if (args.length > 0) {
+    Expect.equals("worker", args[0]);
+    final SendPort sendPort = message[0] as SendPort;
+    Expect.throws(() => sendPort.send(Foo()));
+    sendPort.send("done");
+  } else {
+    final SendPort sendPort = message[0] as SendPort;
+
+    final receivePort = ReceivePort();
+    try {
+      final isolate = await Isolate.spawnUri(
+          Platform.script, <String>["worker"], <SendPort>[receivePort.sendPort],
+          errorsAreFatal: true);
+      final result = await receivePort.first;
+      Expect.equals("done", result);
+      sendPort.send("done");
+    } catch (_) {
+      sendPort.send("fail");
+    }
+
+    sendPort.send("done");
+  }
+}
diff --git a/runtime/tests/vm/vm.status b/runtime/tests/vm/vm.status
index 8de67b8d03eb..9f7c51c173bb 100644
--- a/runtime/tests/vm/vm.status
+++ b/runtime/tests/vm/vm.status
@@ -421,8 +421,10 @@ dart_2/*: SkipByDesign # Legacy tests are not supposed to run on NNBD bots.
 # These Isolate tests that use spawnURI are hence skipped on purpose.
 [ $runtime == dart_precompiled || $runtime == vm && ($arch == simarm || $arch == simarm64 || $arch == simarm64c) ]
 dart/data_uri_spawn_test: SkipByDesign # Isolate.spawnUri
+dart/isolates/send_object_to_spawn_uri_isolate_test: SkipByDesign # uses spawnUri
 dart/issue32950_test: SkipByDesign # uses spawnUri.
 dart_2/data_uri_spawn_test: SkipByDesign # Isolate.spawnUri
+dart_2/isolates/send_object_to_spawn_uri_isolate_test: SkipByDesign # uses spawnUri
 dart_2/issue32950_test: SkipByDesign # uses spawnUri.
 
 [ $runtime != dart_precompiled || $system == android ]
diff --git a/runtime/vm/compiler/frontend/kernel_binary_flowgraph.cc b/runtime/vm/compiler/frontend/kernel_binary_flowgraph.cc
index 798174df4d7f..6bf2d87a0baa 100644
--- a/runtime/vm/compiler/frontend/kernel_binary_flowgraph.cc
+++ b/runtime/vm/compiler/frontend/kernel_binary_flowgraph.cc
@@ -4869,17 +4869,28 @@ Fragment StreamingFlowGraphBuilder::BuildReturnStatement() {
 
   if (instructions.is_open()) {
     if (inside_try_finally) {
-      ASSERT(scopes()->finally_return_variable != NULL);
+      LocalVariable* const finally_return_variable =
+          scopes()->finally_return_variable;
+      ASSERT(finally_return_variable != nullptr);
       const Function& function = parsed_function()->function();
       if (NeedsDebugStepCheck(function, position)) {
         instructions += DebugStepCheck(position);
       }
-      instructions += StoreLocal(position, scopes()->finally_return_variable);
+      instructions += StoreLocal(position, finally_return_variable);
       instructions += Drop();
-      instructions += TranslateFinallyFinalizers(NULL, -1);
+      const intptr_t target_context_depth =
+          finally_return_variable->is_captured()
+              ? finally_return_variable->owner()->context_level()
+              : -1;
+      instructions += TranslateFinallyFinalizers(nullptr, target_context_depth);
       if (instructions.is_open()) {
-        instructions += LoadLocal(scopes()->finally_return_variable);
+        const intptr_t saved_context_depth = B->context_depth_;
+        if (finally_return_variable->is_captured()) {
+          B->context_depth_ = target_context_depth;
+        }
+        instructions += LoadLocal(finally_return_variable);
         instructions += Return(TokenPosition::kNoSource);
+        B->context_depth_ = saved_context_depth;
       }
     } else {
       instructions += Return(position);
diff --git a/runtime/vm/experimental_features.cc b/runtime/vm/experimental_features.cc
index 5ebf334f6c67..c907f0c503b2 100644
--- a/runtime/vm/experimental_features.cc
+++ b/runtime/vm/experimental_features.cc
@@ -18,7 +18,16 @@ namespace dart {
 
 bool GetExperimentalFeatureDefault(ExperimentalFeature feature) {
   constexpr bool kFeatureValues[] = {
-      true, true, true, true, true, true, true, true, true, true,
+    true,
+    true,
+    true,
+    true,
+    true,
+    true,
+    true,
+    true,
+    true,
+    true,
   };
   ASSERT(static_cast<size_t>(feature) < ARRAY_SIZE(kFeatureValues));
   return kFeatureValues[static_cast<int>(feature)];
@@ -26,16 +35,16 @@ bool GetExperimentalFeatureDefault(ExperimentalFeature feature) {
 
 const char* GetExperimentalFeatureName(ExperimentalFeature feature) {
   constexpr const char* kFeatureNames[] = {
-      "nonfunction-type-aliases",
-      "non-nullable",
-      "extension-methods",
-      "constant-update-2018",
-      "control-flow-collections",
-      "generic-metadata",
-      "set-literals",
-      "spread-collections",
-      "triple-shift",
-      "constructor-tearoffs",
+    "nonfunction-type-aliases",
+    "non-nullable",
+    "extension-methods",
+    "constant-update-2018",
+    "control-flow-collections",
+    "generic-metadata",
+    "set-literals",
+    "spread-collections",
+    "triple-shift",
+    "constructor-tearoffs",
   };
   ASSERT(static_cast<size_t>(feature) < ARRAY_SIZE(kFeatureNames));
   return kFeatureNames[static_cast<int>(feature)];
diff --git a/runtime/vm/isolate.cc b/runtime/vm/isolate.cc
index c1e6cbe6132a..9103b357b0e7 100644
--- a/runtime/vm/isolate.cc
+++ b/runtime/vm/isolate.cc
@@ -2418,7 +2418,18 @@ void Isolate::ProcessFreeSampleBlocks(Thread* thread) {
 
 // static
 void Isolate::NotifyLowMemory() {
-  Isolate::KillAllIsolates(Isolate::kLowMemoryMsg);
+  IsolateGroup::ForEach([](IsolateGroup* group) { group->NotifyLowMemory(); });
+}
+
+void IsolateGroup::NotifyLowMemory() {
+  SafepointReadRwLocker ml(Thread::Current(), isolates_lock_.get());
+  MonitorLocker ml2(Isolate::isolate_creation_monitor_);
+  for (Isolate* isolate : isolates_) {
+    if (isolate->AcceptsMessagesLocked()) {
+      isolate->KillLocked(Isolate::kLowMemoryMsg);
+      return;  // Only wake up one member of the group.
+    }
+  }
 }
 
 void Isolate::LowLevelShutdown() {
diff --git a/runtime/vm/isolate.h b/runtime/vm/isolate.h
index b1e493933ba9..5d2f636155d5 100644
--- a/runtime/vm/isolate.h
+++ b/runtime/vm/isolate.h
@@ -592,6 +592,8 @@ class IsolateGroup : public IntrusiveDListEntry<IsolateGroup> {
     return deferred_marking_stack_;
   }
 
+  void NotifyLowMemory();
+
   // Runs the given [function] on every isolate in the isolate group.
   //
   // During the duration of this function, no new isolates can be added or
diff --git a/tests/language/async_star/regression_47610_test.dart b/tests/language/async_star/regression_47610_test.dart
new file mode 100644
index 000000000000..9bb4ce235871
--- /dev/null
+++ b/tests/language/async_star/regression_47610_test.dart
@@ -0,0 +1,32 @@
+// Copyright (c) 2021, the Dart project authors.  Please see the AUTHORS file
+// for details. All rights reserved. Use of this source code is governed by a
+// BSD-style license that can be found in the LICENSE file.
+
+// Regression test for https://github.com/dart-lang/sdk/issues/47610.
+// Tests returning value from a deep context depth along with
+// breaking from 'await for'.
+
+import "dart:async";
+import "package:expect/expect.dart";
+import "package:async_helper/async_helper.dart";
+
+Stream<int> foo() async* {
+  for (int i = 0; i < 2; ++i) {
+    for (int j = 0; j < 2; ++j) {
+      for (int k = 0; k < 2; ++k) {
+        yield i + j + k;
+      }
+    }
+  }
+}
+
+void test() async {
+  await for (var x in foo()) {
+    Expect.equals(0, x);
+    break;
+  }
+}
+
+void main() {
+  asyncTest(test);
+}
diff --git a/tests/language/const/constant_type_variable_error_test.dart b/tests/language/const/constant_type_variable_error_test.dart
index 6e2438b57e95..369d1ee88239 100644
--- a/tests/language/const/constant_type_variable_error_test.dart
+++ b/tests/language/const/constant_type_variable_error_test.dart
@@ -2,8 +2,6 @@
 // for details. All rights reserved. Use of this source code is governed by a
 // BSD-style license that can be found in the LICENSE file.
 
-// SharedOptions=--enable-experiment=constructor-tearoffs
-
 // Test the support for errors about type parameters as potentially
 // constant expressions or potentially constant type expressions.
 
diff --git a/tests/language/const/constant_type_variable_test.dart b/tests/language/const/constant_type_variable_test.dart
index b8436a56c980..ef347d797848 100644
--- a/tests/language/const/constant_type_variable_test.dart
+++ b/tests/language/const/constant_type_variable_test.dart
@@ -2,8 +2,6 @@
 // for details. All rights reserved. Use of this source code is governed by a
 // BSD-style license that can be found in the LICENSE file.
 
-// SharedOptions=--enable-experiment=constructor-tearoffs
-
 // Test the support for type parameters as potentially constant expressions
 // and potentially constant type expressions. The cast to dynamic is included
 // in order to avoid a diagnostic message about an unnecessary cast.
diff --git a/tests/language/const/instantiated_function_constant_error_test.dart b/tests/language/const/instantiated_function_constant_error_test.dart
index 91b5ec41512d..f1dd485bb15b 100644
--- a/tests/language/const/instantiated_function_constant_error_test.dart
+++ b/tests/language/const/instantiated_function_constant_error_test.dart
@@ -2,8 +2,6 @@
 // for details. All rights reserved. Use of this source code is governed by a
 // BSD-style license that can be found in the LICENSE file.
 
-// SharedOptions=--enable-experiment=constructor-tearoffs
-
 // Test the support for error detection with generic function instantiation
 // expressions that are constant or potentially constant. Include both some
 // explicit generic function instantiations, and some implicit ones (for the
diff --git a/tests/language/const/instantiated_function_constant_test.dart b/tests/language/const/instantiated_function_constant_test.dart
index b86f99dec468..3d5619c4d187 100644
--- a/tests/language/const/instantiated_function_constant_test.dart
+++ b/tests/language/const/instantiated_function_constant_test.dart
@@ -2,8 +2,6 @@
 // for details. All rights reserved. Use of this source code is governed by a
 // BSD-style license that can be found in the LICENSE file.
 
-// SharedOptions=--enable-experiment=constructor-tearoffs
-
 // Test the support for generic function instantiation with constant and
 // potentially constant expressions. Include both some explicit generic
 // function instantiations, and some implicit ones (for the latter, the type
diff --git a/tests/language/constructor/explicit_instantiation_syntax_test.dart b/tests/language/constructor/explicit_instantiation_syntax_test.dart
index 387da72a7c39..345b4721c9d5 100644
--- a/tests/language/constructor/explicit_instantiation_syntax_test.dart
+++ b/tests/language/constructor/explicit_instantiation_syntax_test.dart
@@ -2,7 +2,7 @@
 // for details. All rights reserved. Use of this source code is governed by a
 // BSD-style license that can be found in the LICENSE file.
 
-// SharedOptions=--enable-experiment=constructor-tearoffs
+
 
 import 'dart:core' hide dynamic;
 import 'dart:core' as core show dynamic;
diff --git a/tests/language/constructor/tear_off_test.dart b/tests/language/constructor/tear_off_test.dart
index f70127dfdd67..ce7144dd01e0 100644
--- a/tests/language/constructor/tear_off_test.dart
+++ b/tests/language/constructor/tear_off_test.dart
@@ -2,8 +2,6 @@
 // for details. All rights reserved. Use of this source code is governed by a
 // BSD-style license that can be found in the LICENSE file.
 
-// SharedOptions=--enable-experiment=constructor-tearoffs
-
 import "package:expect/expect.dart";
 
 import "../static_type_helper.dart";
@@ -91,23 +89,23 @@ void main() {
 
   GGen<int>.new.expectStaticType<Exactly<GGen<int> Function(int)>>();
   GGen<int>.named.expectStaticType<Exactly<GGen<int> Function(int)>>();
-  GGenRedir<int>.new
-      .expectStaticType<Exactly<GGenRedir<int> Function(int)>>();
-  GGenRedir<int>.named
+  GGenRedir<int>.new.expectStaticType<Exactly<GGenRedir<int> Function(int)>>();
+  GGenRedir<int>
+      .named
       .expectStaticType<Exactly<GGenRedir<int> Function(int)>>();
   GFac<int>.new.expectStaticType<Exactly<GFac<int> Function(int)>>();
   GFac<int>.named.expectStaticType<Exactly<GFac<int> Function(int)>>();
-  GFacRedir<int>.new
-      .expectStaticType<Exactly<GFacRedir<int> Function(int)>>();
-  GFacRedir<int>.named
+  GFacRedir<int>.new.expectStaticType<Exactly<GFacRedir<int> Function(int)>>();
+  GFacRedir<int>
+      .named
       .expectStaticType<Exactly<GFacRedir<int> Function(int)>>();
 
   context<GGen<int> Function(int)>(
       GGen.new..expectStaticType<Exactly<GGen<int> Function(int)>>());
   context<GGen<int> Function(int)>(
       GGen.named..expectStaticType<Exactly<GGen<int> Function(int)>>());
-  context<GGenRedir<int> Function(int)>(GGenRedir.new
-    ..expectStaticType<Exactly<GGenRedir<int> Function(int)>>());
+  context<GGenRedir<int> Function(int)>(
+      GGenRedir.new..expectStaticType<Exactly<GGenRedir<int> Function(int)>>());
   context<GGenRedir<int> Function(int)>(GGenRedir.named
     ..expectStaticType<Exactly<GGenRedir<int> Function(int)>>());
   context<GFac<int> Function(int)>(
@@ -156,15 +154,13 @@ void main() {
 
   // Generic class constructors torn off with explicit instantiation
   // to constant type.
-  test<GGen<int> Function(int)>(
-      GGen<int>.new, GGen<int>.new, GGen<int>.named);
+  test<GGen<int> Function(int)>(GGen<int>.new, GGen<int>.new, GGen<int>.named);
   test<GGen<int> Function(int)>(GGen<int>.named, GGen<int>.named);
   test<GGenRedir<int> Function(int)>(
       GGenRedir<int>.new, GGenRedir<int>.new, GGenRedir<int>.named);
   test<GGenRedir<int> Function(int)>(
       GGenRedir<int>.named, GGenRedir<int>.named);
-  test<GFac<int> Function(int)>(
-      GFac<int>.new, GFac<int>.new, GFac<int>.named);
+  test<GFac<int> Function(int)>(GFac<int>.new, GFac<int>.new, GFac<int>.named);
   test<GFac<int> Function(int)>(GFac<int>.named, GFac<int>.named);
   test<GFacRedir<int> Function(int)>(
       GFacRedir<int>.new, GFacRedir<int>.new, GFacRedir<int>.named);
diff --git a/tests/language/constructor/unnamed_new_error_test.dart b/tests/language/constructor/unnamed_new_error_test.dart
index 0fec8bf86481..c44904bb818e 100644
--- a/tests/language/constructor/unnamed_new_error_test.dart
+++ b/tests/language/constructor/unnamed_new_error_test.dart
@@ -2,7 +2,7 @@
 // for details. All rights reserved. Use of this source code is governed by a
 // BSD-style license that can be found in the LICENSE file.
 
-// SharedOptions=--enable-experiment=constructor-tearoffs
+
 
 import "package:expect/expect.dart";
 
diff --git a/tests/language/constructor/unnamed_new_test.dart b/tests/language/constructor/unnamed_new_test.dart
index a0ced5a60add..e6ca31d1ca71 100644
--- a/tests/language/constructor/unnamed_new_test.dart
+++ b/tests/language/constructor/unnamed_new_test.dart
@@ -2,8 +2,6 @@
 // for details. All rights reserved. Use of this source code is governed by a
 // BSD-style license that can be found in the LICENSE file.
 
-// SharedOptions=--enable-experiment=constructor-tearoffs
-
 import "package:expect/expect.dart";
 
 import "unnamed_new_test.dart" as prefix;
diff --git a/tests/language/explicit_type_instantiation_parsing_test.dart b/tests/language/explicit_type_instantiation_parsing_test.dart
index a7c748c7590a..47b58d14cb96 100644
--- a/tests/language/explicit_type_instantiation_parsing_test.dart
+++ b/tests/language/explicit_type_instantiation_parsing_test.dart
@@ -2,7 +2,7 @@
 // for details. All rights reserved. Use of this source code is governed by a
 // BSD-style license that can be found in the LICENSE file.
 
-// SharedOptions=--enable-experiment=constructor-tearoffs
+
 
 // Test parsing around ambiguities in grammar for explicit type instantiation.
 //
diff --git a/tests/language/generic_methods/explicit_instantiated_tearoff_test.dart b/tests/language/generic_methods/explicit_instantiated_tearoff_test.dart
index 8028216dce8f..5cfd18193380 100644
--- a/tests/language/generic_methods/explicit_instantiated_tearoff_test.dart
+++ b/tests/language/generic_methods/explicit_instantiated_tearoff_test.dart
@@ -2,8 +2,6 @@
 // for details. All rights reserved. Use of this source code is governed by a
 // BSD-style license that can be found in the LICENSE file.
 
-// SharedOptions=--enable-experiment=constructor-tearoffs
-
 import "package:expect/expect.dart";
 
 import "../static_type_helper.dart";
@@ -19,11 +17,11 @@ class C {
   void tearOffsOnThis() {
     const staticTearOff = staticMethod<int, String>;
     staticMethod<int, String>
-      .expectStaticType<Exactly<int Function(String, [String?])>>();
+        .expectStaticType<Exactly<int Function(String, [String?])>>();
     instanceMethod<int, String>
-      .expectStaticType<Exactly<int Function(String, [String?])>>();
+        .expectStaticType<Exactly<int Function(String, [String?])>>();
     this.instanceMethod<int, String>
-      .expectStaticType<Exactly<int Function(String, [String?])>>();
+        .expectStaticType<Exactly<int Function(String, [String?])>>();
 
     Expect.identical(staticMethod<int, String>, staticTearOff);
 
@@ -39,16 +37,15 @@ mixin M on C {
   void mixinTearOffsOnThis() {
     const staticTearOff = staticMethod<int, String>;
     staticMethod<int, String>
-      .expectStaticType<Exactly<int Function(String, [String?])>>();
+        .expectStaticType<Exactly<int Function(String, [String?])>>();
     mixinInstanceMethod<int, String>
-      .expectStaticType<Exactly<int Function(String, [String?])>>();
+        .expectStaticType<Exactly<int Function(String, [String?])>>();
     this.mixinInstanceMethod<int, String>
-      .expectStaticType<Exactly<int Function(String, [String?])>>();
+        .expectStaticType<Exactly<int Function(String, [String?])>>();
 
     Expect.identical(staticMethod<int, String>, staticTearOff);
 
-    Expect.equals(
-        mixinInstanceMethod<int, String>,
+    Expect.equals(mixinInstanceMethod<int, String>,
         this.mixinInstanceMethod<int, String>);
   }
 }
@@ -60,11 +57,11 @@ extension E on C {
   void extensionTearOffsOnThis() {
     const staticTearOff = staticMethod<int, String>;
     staticMethod<int, String>
-      .expectStaticType<Exactly<int Function(String, [String?])>>();
+        .expectStaticType<Exactly<int Function(String, [String?])>>();
     extInstanceMethod<int, String>
-      .expectStaticType<Exactly<int Function(String, [String?])>>();
+        .expectStaticType<Exactly<int Function(String, [String?])>>();
     this.extInstanceMethod<int, String>
-      .expectStaticType<Exactly<int Function(String, [String?])>>();
+        .expectStaticType<Exactly<int Function(String, [String?])>>();
     Expect.identical(staticMethod<int, String>, staticTearOff);
     // Extension instance methods do not specify equality.
   }
@@ -73,7 +70,7 @@ extension E on C {
 class D extends C with M {
   void tearOffsOnSuper() {
     super.instanceMethod<int, String>
-      .expectStaticType<Exactly<int Function(String, [String?])>>();
+        .expectStaticType<Exactly<int Function(String, [String?])>>();
     Expect.equals(
         super.instanceMethod<int, String>, super.instanceMethod<int, String>);
   }
@@ -93,23 +90,17 @@ void main() {
 
   toplevel<int, String>
       .expectStaticType<Exactly<int Function(String, [String?])>>();
-  C
-      .staticMethod<int, String>
+  C.staticMethod<int, String>
       .expectStaticType<Exactly<int Function(String, [String?])>>();
-  M
-      .staticMethod<int, String>
+  M.staticMethod<int, String>
       .expectStaticType<Exactly<int Function(String, [String?])>>();
-  E
-      .staticMethod<int, String>
+  E.staticMethod<int, String>
       .expectStaticType<Exactly<int Function(String, [String?])>>();
-  o
-      .instanceMethod<int, String>
+  o.instanceMethod<int, String>
       .expectStaticType<Exactly<int Function(String, [String?])>>();
-  o
-      .mixinInstanceMethod<int, String>
+  o.mixinInstanceMethod<int, String>
       .expectStaticType<Exactly<int Function(String, [String?])>>();
-  o
-      .extInstanceMethod<int, String>
+  o.extInstanceMethod<int, String>
       .expectStaticType<Exactly<int Function(String, [String?])>>();
   local<int, String>
       .expectStaticType<Exactly<int Function(String, [String?])>>();
@@ -125,8 +116,7 @@ void main() {
 
   // But not for instance method tear-off.
   // Specification requires equality.
-  Expect.equals(
-      o.instanceMethod<int, String>, o.instanceMethod<int, String>);
+  Expect.equals(o.instanceMethod<int, String>, o.instanceMethod<int, String>);
   Expect.equals(
       o.mixinInstanceMethod<int, String>, o.mixinInstanceMethod<int, String>);
 
@@ -134,8 +124,7 @@ void main() {
 
   // And not canonicalized where they shouldn't (different types).
   Expect.notEquals(toplevel<int, String>, toplevel<num, String>);
-  Expect.notEquals(
-      C.staticMethod<int, String>, C.staticMethod<num, String>);
+  Expect.notEquals(C.staticMethod<int, String>, C.staticMethod<num, String>);
   Expect.notEquals(local<int, String>, local<num, String>);
   Expect.notEquals(
       o.instanceMethod<int, String>, o.instanceMethod<num, String>);
diff --git a/tests/language/mixin/regress_47645_test.dart b/tests/language/mixin/regress_47645_test.dart
new file mode 100644
index 000000000000..4482a73b033f
--- /dev/null
+++ b/tests/language/mixin/regress_47645_test.dart
@@ -0,0 +1,19 @@
+// Copyright (c) 2021, the Dart project authors.  Please see the AUTHORS file
+// for details. All rights reserved. Use of this source code is governed by a
+// BSD-style license that can be found in the LICENSE file.
+
+import "package:expect/expect.dart";
+
+// Regression test for https://github.com/dart-lang/sdk/issues/47645.
+// To reproduce the issue the class declaration must appear before the mixin
+// declaration.
+class C<T> with M<C<T>> {}
+
+mixin M<T> {
+  bool fn() => true;
+}
+
+void main() {
+  var c = C<int>();
+  Expect.isTrue(c.fn());
+}
diff --git a/tests/language/nnbd/flow_analysis/local_boolean_implicitly_typed_new_test.dart b/tests/language/nnbd/flow_analysis/local_boolean_implicitly_typed_new_test.dart
index 5fd472137ad7..343064a9c8a4 100644
--- a/tests/language/nnbd/flow_analysis/local_boolean_implicitly_typed_new_test.dart
+++ b/tests/language/nnbd/flow_analysis/local_boolean_implicitly_typed_new_test.dart
@@ -2,8 +2,6 @@
 // for details. All rights reserved. Use of this source code is governed by a
 // BSD-style license that can be found in the LICENSE file.
 
-// SharedOptions=--enable-experiment=constructor-tearoffs
-
 import '../../static_type_helper.dart';
 
 // This test checks whether a local boolean variable can be used to perform type
diff --git a/tests/language/nonfunction_type_aliases/basic_syntax_test.dart b/tests/language/nonfunction_type_aliases/basic_syntax_test.dart
index eb61a95ac31d..e83763cc18ce 100644
--- a/tests/language/nonfunction_type_aliases/basic_syntax_test.dart
+++ b/tests/language/nonfunction_type_aliases/basic_syntax_test.dart
@@ -2,8 +2,6 @@
 // for details. All rights reserved. Use of this source code is governed by a
 // BSD-style license that can be found in the LICENSE file.
 
-// SharedOptions=--enable-experiment=non-nullable
-
 typedef T0 = void;
 typedef T1 = Function;
 typedef T2<X> = List<X>;
diff --git a/tests/language/nonfunction_type_aliases/nnbd_syntax_test.dart b/tests/language/nonfunction_type_aliases/nnbd_syntax_test.dart
index d14de11521e6..4463ca95303b 100644
--- a/tests/language/nonfunction_type_aliases/nnbd_syntax_test.dart
+++ b/tests/language/nonfunction_type_aliases/nnbd_syntax_test.dart
@@ -2,15 +2,13 @@
 // for details. All rights reserved. Use of this source code is governed by a
 // BSD-style license that can be found in the LICENSE file.
 
-// SharedOptions=--enable-experiment=non-nullable
-
 typedef T0 = Function?;
 typedef T1<X> = List<X?>?;
 typedef T2<X, Y> = Map<X?, Y?>?;
 typedef T3 = Never? Function(void)?;
 typedef T4<X> = X? Function(X?, {required X? name})?;
-typedef T5<X extends String, Y extends List<X?>> =
-    X? Function(Y?, [Map<Y, Y?>]);
+typedef T5<X extends String, Y extends List<X?>> = X? Function(Y?,
+    [Map<Y, Y?>]);
 
 void main() {
   // ignore:unused_local_variable
diff --git a/tests/language/regress/regress47566_test.dart b/tests/language/regress/regress47566_test.dart
new file mode 100644
index 000000000000..4ba35ae3f09d
--- /dev/null
+++ b/tests/language/regress/regress47566_test.dart
@@ -0,0 +1,42 @@
+// Copyright (c) 2021, the Dart project authors.  Please see the AUTHORS file
+// for details. All rights reserved. Use of this source code is governed by a
+// BSD-style license that can be found in the LICENSE file.
+
+// Regression test for https://github.com/dart-lang/sdk/issues/47566
+
+import 'package:expect/expect.dart';
+
+final List trace = [];
+void log(String s) {
+  trace.add(s);
+}
+
+Future<void> test(bool value) async {
+  log('f1');
+
+  if (value) {
+    final result = await bar();
+    switch (result) {
+      case 1:
+        log('sb');
+        break;
+      case 0:
+        return;
+    }
+    log('sc');
+  }
+
+  log('f2');
+}
+
+Future<int> bar() async => 1;
+
+Future<void> main() async {
+  trace.clear();
+  await test(true);
+  Expect.equals('f1,sb,sc,f2', trace.join(','));
+
+  trace.clear();
+  await test(false);
+  Expect.equals('f1,f2', trace.join(','));
+}
diff --git a/tests/language/type_object/explicit_instantiated_type_literal_error_test.dart b/tests/language/type_object/explicit_instantiated_type_literal_error_test.dart
index af49363cb08f..804a29127586 100644
--- a/tests/language/type_object/explicit_instantiated_type_literal_error_test.dart
+++ b/tests/language/type_object/explicit_instantiated_type_literal_error_test.dart
@@ -2,7 +2,7 @@
 // for details. All rights reserved. Use of this source code is governed by a
 // BSD-style license that can be found in the LICENSE file.
 
-// SharedOptions=--enable-experiment=constructor-tearoffs
+
 
 // Tests that explicitly instantiated type objects only work
 // when instantiated correctly.
diff --git a/tests/language/type_object/explicit_instantiated_type_literal_test.dart b/tests/language/type_object/explicit_instantiated_type_literal_test.dart
index 5d036e6a116c..ff9e7d384ff5 100644
--- a/tests/language/type_object/explicit_instantiated_type_literal_test.dart
+++ b/tests/language/type_object/explicit_instantiated_type_literal_test.dart
@@ -2,8 +2,6 @@
 // for details. All rights reserved. Use of this source code is governed by a
 // BSD-style license that can be found in the LICENSE file.
 
-// SharedOptions=--enable-experiment=constructor-tearoffs
-
 import "package:expect/expect.dart";
 
 import "../static_type_helper.dart";
diff --git a/tests/language/typedef/aliased_constructor_tear_off_test.dart b/tests/language/typedef/aliased_constructor_tear_off_test.dart
index 9adb357e3309..f4feb9f73070 100644
--- a/tests/language/typedef/aliased_constructor_tear_off_test.dart
+++ b/tests/language/typedef/aliased_constructor_tear_off_test.dart
@@ -2,8 +2,6 @@
 // for details. All rights reserved. Use of this source code is governed by a
 // BSD-style license that can be found in the LICENSE file.
 
-// SharedOptions=--enable-experiment=constructor-tearoffs
-
 // Tests that constructor tear-offs from type aliases work and
 // are canonicalized correctly
 
@@ -115,15 +113,15 @@ void main() {
   context<C<int> Function(int)>(
       Bounded.named..expectStaticType<Exactly<C<int> Function(int)>>());
 
-  context<C<C<int>> Function(C<int>)>(Wrapping.new
-    ..expectStaticType<Exactly<C<C<int>> Function(C<int>)>>());
-  context<C<C<int>> Function(C<int>)>(Wrapping.named
-    ..expectStaticType<Exactly<C<C<int>> Function(C<int>)>>());
+  context<C<C<int>> Function(C<int>)>(
+      Wrapping.new..expectStaticType<Exactly<C<C<int>> Function(C<int>)>>());
+  context<C<C<int>> Function(C<int>)>(
+      Wrapping.named..expectStaticType<Exactly<C<C<int>> Function(C<int>)>>());
 
-  context<C<int> Function(int)>(Extra.new
-    ..expectStaticType<Exactly<C<int> Function(int)>>());
-  context<C<int> Function(int)>(Extra.named
-    ..expectStaticType<Exactly<C<int> Function(int)>>());
+  context<C<int> Function(int)>(
+      Extra.new..expectStaticType<Exactly<C<int> Function(int)>>());
+  context<C<int> Function(int)>(
+      Extra.named..expectStaticType<Exactly<C<int> Function(int)>>());
 
   // Uninstantiated tear-offs always canonicalize.
   Expect.identical(Direct.new, Direct.new);
diff --git a/tests/language/typedef/aliased_type_literal_instantiation_test.dart b/tests/language/typedef/aliased_type_literal_instantiation_test.dart
index d30640f64a1d..74b0fa92f6df 100644
--- a/tests/language/typedef/aliased_type_literal_instantiation_test.dart
+++ b/tests/language/typedef/aliased_type_literal_instantiation_test.dart
@@ -2,8 +2,6 @@
 // for details. All rights reserved. Use of this source code is governed by a
 // BSD-style license that can be found in the LICENSE file.
 
-// SharedOptions=--enable-experiment=constructor-tearoffs
-
 // Tests that type literals made from type aliases work and
 // are canonicalized correctly
 
diff --git a/tests/language/vm/regress_flutter_42845_test.dart b/tests/language/vm/regress_flutter_42845_test.dart
index ac05e97211cb..0b16f1461e8a 100644
--- a/tests/language/vm/regress_flutter_42845_test.dart
+++ b/tests/language/vm/regress_flutter_42845_test.dart
@@ -2,8 +2,6 @@
 // for details. All rights reserved. Use of this source code is governed by a
 // BSD-style license that can be found in the LICENSE file.
 
-// SharedOptions=--enable-experiment=extension-methods
-
 // Tests exported extensions.
 
 import "regress_flutter_42845_lib.dart";
diff --git a/tests/language_2/async_star/regression_47610_test.dart b/tests/language_2/async_star/regression_47610_test.dart
new file mode 100644
index 000000000000..4fd78150f904
--- /dev/null
+++ b/tests/language_2/async_star/regression_47610_test.dart
@@ -0,0 +1,34 @@
+// Copyright (c) 2021, the Dart project authors.  Please see the AUTHORS file
+// for details. All rights reserved. Use of this source code is governed by a
+// BSD-style license that can be found in the LICENSE file.
+
+// @dart = 2.9
+
+// Regression test for https://github.com/dart-lang/sdk/issues/47610.
+// Tests returning value from a deep context depth along with
+// breaking from 'await for'.
+
+import "dart:async";
+import "package:expect/expect.dart";
+import "package:async_helper/async_helper.dart";
+
+Stream<int> foo() async* {
+  for (int i = 0; i < 2; ++i) {
+    for (int j = 0; j < 2; ++j) {
+      for (int k = 0; k < 2; ++k) {
+        yield i + j + k;
+      }
+    }
+  }
+}
+
+void test() async {
+  await for (var x in foo()) {
+    Expect.equals(0, x);
+    break;
+  }
+}
+
+void main() {
+  asyncTest(test);
+}
diff --git a/tests/language_2/mixin/regress_47645_test.dart b/tests/language_2/mixin/regress_47645_test.dart
new file mode 100644
index 000000000000..27885e9262a9
--- /dev/null
+++ b/tests/language_2/mixin/regress_47645_test.dart
@@ -0,0 +1,21 @@
+// Copyright (c) 2021, the Dart project authors.  Please see the AUTHORS file
+// for details. All rights reserved. Use of this source code is governed by a
+// BSD-style license that can be found in the LICENSE file.
+
+// @dart = 2.9
+
+import "package:expect/expect.dart";
+
+// Regression test for https://github.com/dart-lang/sdk/issues/47645.
+// To reproduce the issue the class declaration must appear before the mixin
+// declaration.
+class C<T> with M<C<T>> {}
+
+mixin M<T> {
+  bool fn() => true;
+}
+
+void main() {
+  var c = C<int>();
+  Expect.isTrue(c.fn());
+}
diff --git a/tests/lib/mirrors/method_mirror_extension_test.dart b/tests/lib/mirrors/method_mirror_extension_test.dart
index 2d68474512c2..79e39bb4fc4b 100644
--- a/tests/lib/mirrors/method_mirror_extension_test.dart
+++ b/tests/lib/mirrors/method_mirror_extension_test.dart
@@ -2,8 +2,6 @@
 // for details. All rights reserved. Use of this source code is governed by a
 // BSD-style license that can be found in the LICENSE file.
 
-// SharedOptions=--enable-experiment=extension-methods
-
 library lib;
 
 import "dart:mirrors";
diff --git a/tools/VERSION b/tools/VERSION
index 53fe3f8cc9af..e37b1dd14531 100644
--- a/tools/VERSION
+++ b/tools/VERSION
@@ -28,4 +28,4 @@ MAJOR 2
 MINOR 15
 PATCH 0
 PRERELEASE 268
-PRERELEASE_PATCH 8
\ No newline at end of file
+PRERELEASE_PATCH 18
\ No newline at end of file
diff --git a/tools/experimental_features.yaml b/tools/experimental_features.yaml
index 3c3b0a7b6d1d..971d42286e86 100644
--- a/tools/experimental_features.yaml
+++ b/tools/experimental_features.yaml
@@ -151,6 +151,7 @@ features:
         S s = 'feature enabled';
         print(s);
       }
+    expired: true
 
   non-nullable:
     help: "Non Nullable by default"
@@ -161,10 +162,12 @@ features:
         int? a = null;
         print('feature enabled');
       }
+    expired: true
 
   extension-methods:
     help: "Extension Methods"
     enabledIn: '2.6.0'
+    expired: true
 
   constant-update-2018:
     help: "Enhanced constant expressions"
@@ -181,6 +184,7 @@ features:
       Allow annotations to accept type arguments;
       also allow generic function types as type arguments.
     enabledIn: '2.14.0'
+    expired: true
 
   set-literals:
     help: "Set Literals"
@@ -202,6 +206,7 @@ features:
       void main() {
         if ((A() >>> 1) == 42) print('feature enabled');
       }
+    expired: true
 
   constructor-tearoffs:
     help: "Allow constructor tear-offs and explicit generic instantiations."
