diff --git a/lib/appSession.js b/lib/appSession.js
index 9be1fce1..3c34d673 100644
--- a/lib/appSession.js
+++ b/lib/appSession.js
@@ -15,6 +15,9 @@ const debug = require('./debug')('appSession');
 const epoch = () => (Date.now() / 1000) | 0;
 const MAX_COOKIE_SIZE = 4096;
 
+const REASSIGN = Symbol('reassign');
+const REGENERATED_SESSION_ID = Symbol('regenerated_session_id');
+
 function attachSessionObject(req, sessionName, value) {
   Object.defineProperty(req, sessionName, {
     enumerable: true,
@@ -22,7 +25,7 @@ function attachSessionObject(req, sessionName, value) {
       return value;
     },
     set(arg) {
-      if (arg === null || arg === undefined) {
+      if (arg === null || arg === undefined || arg[REASSIGN]) {
         value = arg;
       } else {
         throw new TypeError('session object cannot be reassigned');
@@ -32,6 +35,17 @@ function attachSessionObject(req, sessionName, value) {
   });
 }
 
+function regenerateSessionStoreId(req, config) {
+  if (config.session.store) {
+    req[REGENERATED_SESSION_ID] = config.session.genid(req);
+  }
+}
+
+function replaceSession(req, session, config) {
+  session[REASSIGN] = true;
+  req[config.session.name] = session;
+}
+
 module.exports = (config) => {
   let current;
 
@@ -175,7 +189,7 @@ module.exports = (config) => {
       };
     }
 
-    setCookie(id, req, res, iat) {
+    setCookie(req, res, iat) {
       setCookie(req, res, iat);
     }
   }
@@ -197,12 +211,14 @@ module.exports = (config) => {
       res,
       { uat = epoch(), iat = uat, exp = calculateExp(iat, uat) }
     ) {
-      if (!req[sessionName] || !Object.keys(req[sessionName]).length) {
-        if (req[COOKIES][sessionName]) {
-          await this._destroy(id);
-        }
-      } else {
-        await this._set(id, {
+      const hasPrevSession = !!req[COOKIES][sessionName];
+      const replacingPrevSession = !!req[REGENERATED_SESSION_ID];
+      const hasCurrentSession = req[sessionName] && Object.keys(req[sessionName]).length;
+      if (hasPrevSession && (replacingPrevSession || !hasCurrentSession)) {
+        await this._destroy(id);
+      }
+      if (hasCurrentSession) {
+        await this._set(req[REGENERATED_SESSION_ID] || id, {
           header: { iat, uat, exp },
           data: req[sessionName],
         });
@@ -233,7 +249,8 @@ module.exports = (config) => {
     }
   }
 
-  const store = config.session.store
+  const isCustomStore = !!config.session.store;
+  const store = isCustomStore
     ? new CustomStore(config.session.store)
     : new CookieStore();
 
@@ -330,11 +347,13 @@ module.exports = (config) => {
       attachSessionObject(req, sessionName, {});
     }
 
-    const id = existingSessionValue || generateId(req);
+    if (isCustomStore) {
+      const id = existingSessionValue || generateId(req);
 
-    onHeaders(res, () => store.setCookie(id, req, res, { iat }));
+      onHeaders(res, () =>
+        store.setCookie(req[REGENERATED_SESSION_ID] || id, req, res, { iat })
+      );
 
-    if (store.set) {
       const { end: origEnd } = res;
       res.end = async function resEnd(...args) {
         try {
@@ -349,8 +368,15 @@ module.exports = (config) => {
           process.nextTick(() => next(e));
         }
       };
+    } else {
+      onHeaders(res, () =>
+        store.setCookie(req, res, { iat })
+      );
     }
 
     return next();
   };
 };
+
+module.exports.regenerateSessionStoreId = regenerateSessionStoreId;
+module.exports.replaceSession = replaceSession;
diff --git a/middleware/auth.js b/middleware/auth.js
index c13a949f..68cae12b 100644
--- a/middleware/auth.js
+++ b/middleware/auth.js
@@ -10,6 +10,7 @@ const attemptSilentLogin = require('./attemptSilentLogin');
 const TransientCookieHandler = require('../lib/transientHandler');
 const { RequestContext, ResponseContext } = require('../lib/context');
 const appSession = require('../lib/appSession');
+const { regenerateSessionStoreId, replaceSession } = appSession;
 const { decodeState } = require('../lib/hooks/getLoginState');
 
 const enforceLeadingSlash = (path) => {
@@ -83,7 +84,7 @@ const auth = function (params) {
         try {
           const redirectUri = res.oidc.getRedirectUri();
 
-          let session;
+          let tokenSet;
 
           try {
             const callbackParams = client.callbackParams(req);
@@ -110,7 +111,7 @@ const auth = function (params) {
               extras = { exchangeBody: config.tokenEndpointParams };
             }
 
-            session = await client.callback(
+            tokenSet = await client.callback(
               redirectUri,
               callbackParams,
               checks,
@@ -120,16 +121,35 @@ const auth = function (params) {
             throw createError.BadRequest(err.message);
           }
 
+          let session = Object.assign({}, tokenSet); // Remove non-enumerable methods from the TokenSet
+
           if (config.afterCallback) {
             session = await config.afterCallback(
               req,
               res,
-              Object.assign({}, session), // Remove non-enumerable methods from the TokenSet
+              session,
               req.openidState
             );
           }
 
-          Object.assign(req[config.session.name], session);
+          if (req.oidc.isAuthenticated()) {
+            if (req.oidc.user.sub === tokenSet.claims().sub) {
+              // If it's the same user logging in again, just update the existing session.
+              Object.assign(req[config.session.name], session);
+            } else {
+              // If it's a different user, replace the session to remove any custom user
+              // properties on the session
+              replaceSession(req, session, config);
+              // And regenerate the session id so the previous user wont know the new user's session id
+              regenerateSessionStoreId(req, config);
+            }
+          } else {
+            // If a new user is replacing an anonymous session, update the existing session to keep
+            // any anonymous session state (eg. checkout basket)
+            Object.assign(req[config.session.name], session);
+            // But update the session store id so a previous anonymous user wont know the new user's session id
+            regenerateSessionStoreId(req, config);
+          }
           attemptSilentLogin.resumeSilentLogin(req, res);
 
           next();
diff --git a/test/appSession.customStore.tests.js b/test/appSession.customStore.tests.js
index 4d7ede6f..d323ec62 100644
--- a/test/appSession.customStore.tests.js
+++ b/test/appSession.customStore.tests.js
@@ -57,6 +57,7 @@ describe('appSession custom store', () => {
     const store = new RedisStore({ client: redisClient, prefix: '' });
     redisClient.asyncSet = promisify(redisClient.set).bind(redisClient);
     redisClient.asyncGet = promisify(redisClient.get).bind(redisClient);
+    redisClient.asyncDbsize = promisify(redisClient.dbsize).bind(redisClient);
 
     const conf = getConfig({
       ...defaultConfig,
@@ -72,6 +73,7 @@ describe('appSession custom store', () => {
       await new Promise((resolve) => server.close(resolve));
     }
     if (redisClient) {
+      await new Promise((resolve) => redisClient.flushall(resolve));
       await new Promise((resolve) => redisClient.quit(resolve));
     }
   });
@@ -116,6 +118,15 @@ describe('appSession custom store', () => {
     });
   });
 
+  it('should not populate the store when there is no session', async () => {
+    await setup();
+    await request.get('/session', {
+      baseUrl,
+      json: true,
+    });
+    assert.equal(await redisClient.asyncDbsize(), 0);
+  });
+
   it('should get a new session', async () => {
     await setup();
     const jar = await login({ sub: '__foo_user__' });
@@ -126,6 +137,7 @@ describe('appSession custom store', () => {
     });
     assert.equal(res.statusCode, 200);
     assert.deepEqual(res.body, { sub: '__foo_user__' });
+    assert.equal(await redisClient.asyncDbsize(), 1);
   });
 
   it('should destroy an existing session', async () => {
@@ -153,6 +165,7 @@ describe('appSession custom store', () => {
     });
     assert.isEmpty(loggedOutRes.body);
     assert.isEmpty(jar.getCookies(baseUrl));
+    assert.equal(await redisClient.asyncDbsize(), 0);
   });
 
   it('uses custom session id generator when provided', async () => {
@@ -178,6 +191,7 @@ describe('appSession custom store', () => {
       role: 'test',
       userid: immId,
     });
+    assert.equal(await redisClient.asyncDbsize(), 1);
   });
 
   it('should handle storage errors', async () => {
diff --git a/test/callback.tests.js b/test/callback.tests.js
index 7fefa24f..f08c8c11 100644
--- a/test/callback.tests.js
+++ b/test/callback.tests.js
@@ -14,6 +14,7 @@ const { makeIdToken } = require('./fixture/cert');
 const clientID = '__test_client_id__';
 const expectedDefaultState = encodeState({ returnTo: 'https://example.org' });
 const nock = require('nock');
+const MemoryStore = require('memorystore')(auth);
 
 const baseUrl = 'http://localhost:3000';
 const defaultConfig = {
@@ -77,6 +78,17 @@ const setup = async (params) => {
       };
     });
 
+  let existingSessionCookie;
+  if (params.existingSession) {
+    await request.post('/session', {
+      baseUrl,
+      jar,
+      json: params.existingSession,
+    });
+    const cookies = jar.getCookies(baseUrl);
+    existingSessionCookie = cookies.find(({ key }) => key === 'appSession');
+  }
+
   const response = await request.post('/callback', {
     baseUrl,
     jar,
@@ -85,6 +97,9 @@ const setup = async (params) => {
   const currentUser = await request
     .get('/user', { baseUrl, jar, json: true })
     .then((r) => r.body);
+  const currentSession = await request
+    .get('/session', { baseUrl, jar, json: true })
+    .then((r) => r.body);
   const tokens = await request
     .get('/tokens', { baseUrl, jar, json: true })
     .then((r) => r.body);
@@ -96,9 +111,11 @@ const setup = async (params) => {
     jar,
     response,
     currentUser,
+    currentSession,
     tokenReqHeader,
     tokenReqBody,
     tokens,
+    existingSessionCookie,
   };
 };
 
@@ -887,4 +904,153 @@ describe('callback response_mode: form_post', () => {
       assert.equal(statusCode, 999);
     });
   });
+
+  it('should replace the cookie session when a new user is logging in over an existing different user', async () => {
+    const { currentSession, currentUser } = await setup({
+      cookies: generateCookies({
+        state: expectedDefaultState,
+        nonce: '__test_nonce__',
+      }),
+      body: {
+        state: expectedDefaultState,
+        id_token: makeIdToken({ sub: 'bar' }),
+      },
+      existingSession: {
+        shoppingCartId: 'bar',
+        id_token: makeIdToken({ sub: 'foo' }),
+      },
+    });
+
+    assert.equal(currentUser.sub, 'bar');
+    assert.isUndefined(currentSession.shoppingCartId);
+  });
+
+  it('should preserve the cookie session when a new user is logging in over an anonymous session', async () => {
+    const { currentSession, currentUser } = await setup({
+      cookies: generateCookies({
+        state: expectedDefaultState,
+        nonce: '__test_nonce__',
+      }),
+      body: {
+        state: expectedDefaultState,
+        id_token: makeIdToken({ sub: 'foo' }),
+      },
+      existingSession: {
+        shoppingCartId: 'bar',
+      },
+    });
+
+    assert.equal(currentUser.sub, 'foo');
+    assert.equal(currentSession.shoppingCartId, 'bar');
+  });
+
+  it('should preserve session but regenerate session id when a new user is logging in over an anonymous session', async () => {
+    const store = new MemoryStore({
+      checkPeriod: 24 * 60 * 1000,
+    });
+    const { currentSession, currentUser, existingSessionCookie, jar } = await setup({
+      cookies: generateCookies({
+        state: expectedDefaultState,
+        nonce: '__test_nonce__',
+      }),
+      body: {
+        state: expectedDefaultState,
+        id_token: makeIdToken({ sub: 'foo' }),
+      },
+      existingSession: {
+        shoppingCartId: 'bar',
+      },
+      authOpts: {
+        session: {
+          store,
+        },
+      },
+    });
+
+    const cookies = jar.getCookies(baseUrl);
+    const newSessionCookie = cookies.find(({ key }) => key === 'appSession');
+    
+    assert.equal(currentUser.sub, 'foo');
+    assert.equal(currentSession.shoppingCartId, 'bar');
+    assert.equal(
+      store.store.length,
+      1,
+      'There should only be one session in the store'
+    );
+    assert.notEqual(existingSessionCookie.value, newSessionCookie.value);
+  });
+
+  it('should preserve session when the same user is logging in over their existing session', async () => {
+    const store = new MemoryStore({
+      checkPeriod: 24 * 60 * 1000,
+    });
+    const { currentSession, currentUser, existingSessionCookie, jar } = await setup({
+      cookies: generateCookies({
+        state: expectedDefaultState,
+        nonce: '__test_nonce__',
+      }),
+      body: {
+        state: expectedDefaultState,
+        id_token: makeIdToken({ sub: 'foo' }),
+      },
+      existingSession: {
+        shoppingCartId: 'bar',
+        id_token: makeIdToken({ sub: 'foo' }),
+      },
+      authOpts: {
+        session: {
+          store,
+        },
+      },
+    });
+
+    const cookies = jar.getCookies(baseUrl);
+    const newSessionCookie = cookies.find(({ key }) => key === 'appSession');
+    
+    assert.equal(currentUser.sub, 'foo');
+    assert.equal(currentSession.shoppingCartId, 'bar');
+    assert.equal(
+      store.store.length,
+      1,
+      'There should only be one session in the store'
+    );
+    assert.equal(existingSessionCookie.value, newSessionCookie.value);
+  });
+
+  it('should regenerate the session when a new user is logging in over an existing different user', async () => {
+    const store = new MemoryStore({
+      checkPeriod: 24 * 60 * 1000,
+    });
+    const { currentSession, currentUser, existingSessionCookie, jar } = await setup({
+      cookies: generateCookies({
+        state: expectedDefaultState,
+        nonce: '__test_nonce__',
+      }),
+      body: {
+        state: expectedDefaultState,
+        id_token: makeIdToken({ sub: 'bar' }),
+      },
+      existingSession: {
+        shoppingCartId: 'bar',
+        id_token: makeIdToken({ sub: 'foo' }),
+      },
+      authOpts: {
+        session: {
+          store,
+        },
+      },
+    });
+
+    const cookies = jar.getCookies(baseUrl);
+    const newSessionCookie = cookies.find(({ key }) => key === 'appSession');
+    
+    assert.equal(currentUser.sub, 'bar');
+    assert.isUndefined(currentSession.shoppingCartId);
+    assert.equal(
+      store.store.length,
+      1,
+      'There should only be one session in the store'
+    );
+    assert.notEqual(existingSessionCookie.value, newSessionCookie.value);
+  });
 });
