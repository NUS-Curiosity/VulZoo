diff --git a/blaze-server/src/main/scala/org/http4s/server/blaze/BlazeServerBuilder.scala b/blaze-server/src/main/scala/org/http4s/server/blaze/BlazeServerBuilder.scala
index 43c3f0b4b3a..38ad1422b20 100644
--- a/blaze-server/src/main/scala/org/http4s/server/blaze/BlazeServerBuilder.scala
+++ b/blaze-server/src/main/scala/org/http4s/server/blaze/BlazeServerBuilder.scala
@@ -38,7 +38,6 @@ import org.http4s.blaze.channel.{
   SocketConnection
 }
 import org.http4s.blaze.channel.nio1.NIO1SocketServerGroup
-import org.http4s.blaze.channel.nio2.NIO2SocketServerGroup
 import org.http4s.blaze.http.http2.server.ALPNServerSelector
 import org.http4s.blaze.pipeline.LeafBuilder
 import org.http4s.blaze.pipeline.stages.SSLStage
@@ -86,13 +85,13 @@ import scodec.bits.ByteVector
   *    this is necessary to recover totality from the error condition.
   * @param banner: Pretty log to display on server start. An empty sequence
   *    such as Nil disables this
+  * @param maxConnections: The maximum number of client connections that may be active at any time.
   */
-class BlazeServerBuilder[F[_]](
+class BlazeServerBuilder[F[_]] private (
     socketAddress: InetSocketAddress,
     executionContext: ExecutionContext,
     responseHeaderTimeout: Duration,
     idleTimeout: Duration,
-    isNio2: Boolean,
     connectorPoolSize: Int,
     bufferSize: Int,
     selectorThreadFactory: ThreadFactory,
@@ -105,6 +104,7 @@ class BlazeServerBuilder[F[_]](
     httpApp: HttpApp[F],
     serviceErrorHandler: ServiceErrorHandler[F],
     banner: immutable.Seq[String],
+    maxConnections: Int,
     val channelOptions: ChannelOptions
 )(implicit protected val F: Async[F])
     extends ServerBuilder[F]
@@ -118,7 +118,6 @@ class BlazeServerBuilder[F[_]](
       executionContext: ExecutionContext = executionContext,
       idleTimeout: Duration = idleTimeout,
       responseHeaderTimeout: Duration = responseHeaderTimeout,
-      isNio2: Boolean = isNio2,
       connectorPoolSize: Int = connectorPoolSize,
       bufferSize: Int = bufferSize,
       selectorThreadFactory: ThreadFactory = selectorThreadFactory,
@@ -131,6 +130,7 @@ class BlazeServerBuilder[F[_]](
       httpApp: HttpApp[F] = httpApp,
       serviceErrorHandler: ServiceErrorHandler[F] = serviceErrorHandler,
       banner: immutable.Seq[String] = banner,
+      maxConnections: Int = maxConnections,
       channelOptions: ChannelOptions = channelOptions
   ): Self =
     new BlazeServerBuilder(
@@ -138,7 +138,6 @@ class BlazeServerBuilder[F[_]](
       executionContext,
       responseHeaderTimeout,
       idleTimeout,
-      isNio2,
       connectorPoolSize,
       bufferSize,
       selectorThreadFactory,
@@ -151,6 +150,7 @@ class BlazeServerBuilder[F[_]](
       httpApp,
       serviceErrorHandler,
       banner,
+      maxConnections,
       channelOptions
     )
 
@@ -219,8 +219,6 @@ class BlazeServerBuilder[F[_]](
   def withSelectorThreadFactory(selectorThreadFactory: ThreadFactory): Self =
     copy(selectorThreadFactory = selectorThreadFactory)
 
-  def withNio2(isNio2: Boolean): Self = copy(isNio2 = isNio2)
-
   def withWebSockets(enableWebsockets: Boolean): Self =
     copy(enableWebSockets = enableWebsockets)
 
@@ -247,6 +245,9 @@ class BlazeServerBuilder[F[_]](
   def withChunkBufferMaxSize(chunkBufferMaxSize: Int): BlazeServerBuilder[F] =
     copy(chunkBufferMaxSize = chunkBufferMaxSize)
 
+  def withMaxConnections(maxConnections: Int): BlazeServerBuilder[F] =
+    copy(maxConnections = maxConnections)
+
   private def pipelineFactory(
       scheduler: TickWheelExecutor,
       engineConfig: Option[(SSLContext, SSLEngine => Unit)],
@@ -343,12 +344,8 @@ class BlazeServerBuilder[F[_]](
       else address
 
     val mkFactory: Resource[F, ServerChannelGroup] = Resource.make(F.delay {
-      if (isNio2)
-        NIO2SocketServerGroup
-          .fixedGroup(connectorPoolSize, bufferSize, channelOptions, selectorThreadFactory)
-      else
-        NIO1SocketServerGroup
-          .fixedGroup(connectorPoolSize, bufferSize, channelOptions, selectorThreadFactory)
+      NIO1SocketServerGroup
+        .fixed(connectorPoolSize, bufferSize, channelOptions, selectorThreadFactory, maxConnections)
     })(factory => F.delay(factory.closeGroup()))
 
     def mkServerChannel(
@@ -415,7 +412,6 @@ object BlazeServerBuilder {
       executionContext = executionContext,
       responseHeaderTimeout = defaults.ResponseTimeout,
       idleTimeout = defaults.IdleTimeout,
-      isNio2 = false,
       connectorPoolSize = DefaultPoolSize,
       bufferSize = 64 * 1024,
       selectorThreadFactory = defaultThreadSelectorFactory,
@@ -428,6 +424,7 @@ object BlazeServerBuilder {
       httpApp = defaultApp[F],
       serviceErrorHandler = DefaultServiceErrorHandler[F],
       banner = defaults.Banner,
+      maxConnections = defaults.MaxConnections,
       channelOptions = ChannelOptions(Vector.empty)
     )
 
diff --git a/build.sbt b/build.sbt
index b892bee9a85..1478c28c984 100644
--- a/build.sbt
+++ b/build.sbt
@@ -83,7 +83,6 @@ lazy val core = libraryProject("core")
   .enablePlugins(
     BuildInfoPlugin,
     MimeLoaderPlugin,
-    NowarnCompatPlugin,
   )
   .settings(
     description := "Core http4s library for servers and clients",
@@ -113,7 +112,6 @@ lazy val core = libraryProject("core")
       )
     },
     unusedCompileDependenciesFilter -= moduleFilter("org.scala-lang", "scala-reflect"),
-    Compile / packageBin / mappings ~= { _.filterNot(_._2.startsWith("scala/")) },
   )
 
 lazy val laws = libraryProject("laws")
@@ -175,7 +173,6 @@ lazy val tests = libraryProject("tests")
   .dependsOn(core, specs2 % "test->test")
 
 lazy val server = libraryProject("server")
-  .enablePlugins(NowarnCompatPlugin)
   .settings(
     description := "Base library for building http4s servers",
     startYear := Some(2014),
@@ -209,7 +206,6 @@ lazy val prometheusMetrics = libraryProject("prometheus-metrics")
   )
 
 lazy val client = libraryProject("client")
-  .enablePlugins(NowarnCompatPlugin)
   .settings(
     description := "Base library for building http4s clients",
     startYear := Some(2014),
@@ -286,6 +282,10 @@ lazy val blazeServer = libraryProject("blaze-server")
   .settings(
     description := "blaze implementation for http4s servers",
     startYear := Some(2014),
+    mimaBinaryIssueFilters ++= Seq(
+      // privat constructor with new parameter
+      ProblemFilters.exclude[DirectMissingMethodProblem]("org.http4s.server.blaze.BlazeServerBuilder.this")
+    )
   )
   .dependsOn(blazeCore % "compile;test->test", server % "compile;test->test")
 
diff --git a/client/src/test/scala/org/http4s/client/middleware/FollowRedirectSuite.scala b/client/src/test/scala/org/http4s/client/middleware/FollowRedirectSuite.scala
index 55d7d5d774e..76ee0a4567f 100644
--- a/client/src/test/scala/org/http4s/client/middleware/FollowRedirectSuite.scala
+++ b/client/src/test/scala/org/http4s/client/middleware/FollowRedirectSuite.scala
@@ -73,7 +73,7 @@ class FollowRedirectSuite extends Http4sSuite with Http4sClientDsl[IO] {
     val req = Request[IO](PUT, uri"http://localhost/303").withEntity("foo")
     client
       .run(req)
-      .use { case Ok(resp) =>
+      .use { case resp =>
         resp.headers.get(CIString("X-Original-Content-Length")).map(_.value).pure[IO]
       }
       .map(_.get)
@@ -128,7 +128,7 @@ class FollowRedirectSuite extends Http4sSuite with Http4sClientDsl[IO] {
       Header("Authorization", "Bearer s3cr3t"))
     client
       .run(req)
-      .use { case Ok(resp) =>
+      .use { case resp =>
         resp.headers.get(CIString("X-Original-Authorization")).map(_.value).pure[IO]
       }
       .assertEquals(Some(""))
@@ -141,7 +141,7 @@ class FollowRedirectSuite extends Http4sSuite with Http4sClientDsl[IO] {
       Header("Authorization", "Bearer s3cr3t"))
     client
       .run(req)
-      .use { case Ok(resp) =>
+      .use { case resp =>
         resp.headers.get(CIString("X-Original-Authorization")).map(_.value).pure[IO]
       }
       .assertEquals(Some("Bearer s3cr3t"))
@@ -150,7 +150,7 @@ class FollowRedirectSuite extends Http4sSuite with Http4sClientDsl[IO] {
   test("FollowRedirect should Record the intermediate URIs") {
     client
       .run(Request[IO](uri = uri"http://localhost/loop/0"))
-      .use { case Ok(resp) =>
+      .use { resp =>
         IO.pure(FollowRedirect.getRedirectUris(resp))
       }
       .assertEquals(
@@ -164,7 +164,7 @@ class FollowRedirectSuite extends Http4sSuite with Http4sClientDsl[IO] {
   test("FollowRedirect should Not add any URIs when there are no redirects") {
     client
       .run(Request[IO](uri = uri"http://localhost/loop/100"))
-      .use { case Ok(resp) =>
+      .use { case resp =>
         IO.pure(FollowRedirect.getRedirectUris(resp))
       }
       .assertEquals(List.empty[Uri])
diff --git a/core/src/main/scala-2.12/scala/annotation/nowarn.scala b/core/src/main/scala-2.12/scala/annotation/nowarn.scala
deleted file mode 100644
index eb5bfbd79f1..00000000000
--- a/core/src/main/scala-2.12/scala/annotation/nowarn.scala
+++ /dev/null
@@ -1,22 +0,0 @@
-/*
- * Copyright 2013 http4s.org
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package scala.annotation
-
-/** Shims Scala 2.13.2's `@nowarn` so it compiles on Scala 2.12.
-  * Silencer has rudimentary support.
-  */
-class nowarn(val value: String = "") extends StaticAnnotation
diff --git a/core/src/main/scala/org/http4s/Uri.scala b/core/src/main/scala/org/http4s/Uri.scala
index 8438f1b2b77..416211c850b 100644
--- a/core/src/main/scala/org/http4s/Uri.scala
+++ b/core/src/main/scala/org/http4s/Uri.scala
@@ -170,7 +170,7 @@ object Uri extends UriPlatform {
 
   /** Decodes the String to a [[Uri]] using the RFC 3986 uri decoding specification */
   def fromString(s: String): ParseResult[Uri] =
-    ParseResult.fromParser(uriReferenceUtf8, "Invalid URI")(s)
+    ParseResult.fromParser(Parser.uriReferenceUtf8, "Invalid URI")(s)
 
   /** Parses a String to a [[Uri]] according to RFC 3986.  If decoding
     *  fails, throws a [[ParseFailure]].
@@ -181,118 +181,9 @@ object Uri extends UriPlatform {
   def unsafeFromString(s: String): Uri =
     fromString(s).valueOr(throw _)
 
-  /* hier-part   = "//" authority path-abempty
-   *             / path-absolute
-   *             / path-rootless
-   *             / path-empty
-   */
-  def hierPart(cs: JCharset): Parser0[(Option[Authority], Path)] = {
-    import P.string
-    import Authority.{parser => authority}
-    import Path.{pathAbempty, pathAbsolute, pathEmpty, pathRootless}
-    val rel: P[(Option[Authority], Path)] = (string("//") *> authority(cs) ~ pathAbempty).map {
-      case (a, p) => (Some(a), p)
-    }
-    P.oneOf0(
-      rel :: pathAbsolute.map((None, _)) :: pathRootless.map((None, _)) :: pathEmpty.map(
-        (None, _)) :: Nil)
-  }
-
-  /* absolute-URI  = scheme ":" hier-part [ "?" query ] */
-  private[http4s] def absoluteUri(cs: JCharset): P[Uri] = {
-    import cats.parse.Parser.char
-    import Uri.Scheme.{parser => scheme}
-    import Query.{parser => query}
-
-    (scheme ~ (char(':') *> hierPart(cs)) ~ (char('?') *> query).?).map { case ((s, (a, p)), q) =>
-      Uri(scheme = Some(s), authority = a, path = p, query = q.getOrElse(Query.empty))
-    }
-  }
-
-  private[http4s] def parser(cs: JCharset): P[Uri] = {
-    import cats.parse.Parser.char
-    import Uri.Scheme.{parser => scheme}
-    import Query.{parser => query}
-    import Fragment.{parser => fragment}
-
-    (scheme ~ (char(':') *> hierPart(cs)) ~ (char('?') *> query).? ~ (char('#') *> fragment).?)
-      .map { case (((s, (a, p)), q), f) =>
-        Uri(
-          scheme = Some(s),
-          authority = a,
-          path = p,
-          query = q.getOrElse(Query.empty),
-          fragment = f)
-      }
-  }
-
-  /* relative-part = "//" authority path-abempty
-                   / path-absolute
-                   / path-noscheme
-                   / path-empty
-   */
-  private[http4s] def relativePart(cs: JCharset): Parser0[(Option[Authority], Path)] = {
-    import cats.parse.Parser.string
-    import Authority.{parser => authority}
-    import Path.{pathAbempty, pathAbsolute, pathEmpty, pathNoscheme}
-
-    P.oneOf0(
-      ((string("//") *> authority(cs) ~ pathAbempty).map { case (a, p) =>
-        (Some(a), p)
-      }) :: (pathAbsolute.map((None, _))) :: (pathNoscheme.map((None, _))) :: (pathEmpty.map(
-        (None, _))) :: Nil)
-  }
-
-  /* relative-ref  = relative-part [ "?" query ] [ "#" fragment ] */
-  private[http4s] def relativeRef(cs: JCharset): Parser0[Uri] = {
-    import cats.parse.Parser.char
-    import Query.{parser => query}
-    import Fragment.{parser => fragment}
-
-    (relativePart(cs) ~ (char('?') *> query).? ~ (char('#') *> fragment).?).map {
-      case (((a, p), q), f) =>
-        Uri(scheme = None, authority = a, path = p, query = q.getOrElse(Query.empty), fragment = f)
-    }
-  }
-
-  private[http4s] lazy val uriReferenceUtf8: Parser0[Uri] = uriReference(StandardCharsets.UTF_8)
-  private[http4s] def uriReference(cs: JCharset): Parser0[Uri] =
-    parser(cs).backtrack.orElse(relativeRef(cs))
-
   /** Decodes the String to a [[Uri]] using the RFC 7230 section 5.3 uri decoding specification */
   def requestTarget(s: String): ParseResult[Uri] =
-    ParseResult.fromParser(requestTargetParser, "Invalid request target")(s)
-
-  /* request-target = origin-form
-                    / absolute-form
-                    / authority-form
-                    / asterisk-form
-   */
-  private lazy val requestTargetParser: Parser0[Uri] = {
-    import cats.parse.Parser.{char, oneOf0}
-    import Authority.{parser => authority}
-    import Path.absolutePath
-    import Query.{parser => query}
-
-    /* origin-form    = absolute-path [ "?" query ] */
-    val originForm: P[Uri] =
-      (absolutePath ~ (char('?') *> query).?).map { case (p, q) =>
-        Uri(scheme = None, authority = None, path = p, query = q.getOrElse(Query.empty))
-      }
-
-    /* absolute-form = absolute-URI */
-    def absoluteForm: P[Uri] = absoluteUri(StandardCharsets.UTF_8)
-
-    /* authority-form = authority */
-    val authorityForm: Parser0[Uri] =
-      authority(StandardCharsets.UTF_8).map(a => Uri(authority = Some(a)))
-
-    /* asterisk-form = "*" */
-    val asteriskForm: P[Uri] =
-      char('*').as(Uri(path = Path.Asterisk))
-
-    oneOf0(originForm :: absoluteForm :: authorityForm :: asteriskForm :: Nil)
-  }
+    ParseResult.fromParser(Parser.requestTargetParser, "Invalid request target")(s)
 
   /** A [[org.http4s.Uri]] may begin with a scheme name that refers to a
     * specification for assigning identifiers within that scheme.
@@ -302,7 +193,7 @@ object Uri extends UriPlatform {
     *
     * @see [[https://tools.ietf.org/html/rfc3986#section-3.1 RFC 3986, Section 3.1, Scheme]]
     */
-  final class Scheme private (val value: String) extends Ordered[Scheme] {
+  final class Scheme private[http4s] (val value: String) extends Ordered[Scheme] {
     override def equals(o: Any) =
       o match {
         case that: Scheme => this.value.equalsIgnoreCase(that.value)
@@ -330,27 +221,12 @@ object Uri extends UriPlatform {
     def parse(s: String): ParseResult[Scheme] = fromString(s)
 
     def fromString(s: String): ParseResult[Scheme] =
-      ParseResult.fromParser(parser, "Invalid scheme")(s)
+      ParseResult.fromParser(Parser.scheme, "Invalid scheme")(s)
 
     /** Like `fromString`, but throws on invalid input */
     def unsafeFromString(s: String): Scheme =
       fromString(s).fold(throw _, identity)
 
-    /* scheme      = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." ) */
-    private[http4s] val parser: P[Scheme] = {
-      import cats.parse.Parser.{charIn, not, string}
-      import Rfc3986.{alpha, digit}
-
-      val unary = alpha.orElse(digit).orElse(charIn("+-."))
-
-      (string("https") <* not(unary))
-        .as(https)
-        .backtrack
-        .orElse((string("http") <* not(unary)).as(http))
-        .backtrack
-        .orElse((alpha *> unary.rep0).string.map(new Scheme(_)))
-    }
-
     implicit val http4sOrderForScheme: Order[Scheme] =
       Order.fromComparable
     implicit val http4sShowForScheme: Show[Scheme] =
@@ -367,18 +243,6 @@ object Uri extends UriPlatform {
 
   type Fragment = String
 
-  object Fragment {
-    import cats.parse.Parser.charIn
-    import Rfc3986.pchar
-
-    /* fragment    = *( pchar / "/" / "?" )
-     *
-     * Not URL decoded.
-     */
-    private[http4s] val parser: Parser0[Fragment] =
-      pchar.orElse(charIn("/?")).rep0.string
-  }
-
   final case class Authority(
       userInfo: Option[UserInfo] = None,
       host: Host = RegName("localhost"),
@@ -395,16 +259,6 @@ object Uri extends UriPlatform {
   }
 
   object Authority {
-    import cats.parse.Parser.{char}
-    import UserInfo.{parser => userinfo}
-    import Host.{parser => host}
-    import Port.{parser => port}
-
-    /* authority   = [ userinfo "@" ] host [ ":" port ] */
-    def parser(cs: JCharset): Parser0[Authority] =
-      ((userinfo(cs) <* char('@')).backtrack.? ~ host ~ (char(':') *> port).?).map {
-        case ((ui, h), p) => Authority(userInfo = ui, host = h, port = p.flatten)
-      }
 
     implicit val catsInstancesForHttp4sAuthority
         : Hash[Authority] with Order[Authority] with Show[Authority] =
@@ -544,28 +398,6 @@ object Uri extends UriPlatform {
 
       val empty: Segment = Segment("")
 
-      import cats.parse.Parser.char
-      import Rfc3986.{pchar, pctEncoded, subDelims, unreserved}
-
-      /* segment       = *pchar */
-      lazy val segment: Parser0[Segment] =
-        pchar.rep0.string.map(new Segment(_))
-
-      /* segment-nz    = 1*pchar */
-      lazy val segmentNz: P[Segment] =
-        pchar.rep.string.map(new Segment(_))
-
-      /* segment-nz-nc = 1*( unreserved / pct-encoded / sub-delims / "@" )
-                     ; non-zero-length segment without any colon ":" */
-      lazy val segmentNzNc: P[Segment] =
-        unreserved
-          .orElse(pctEncoded)
-          .orElse(subDelims)
-          .orElse(char('@'))
-          .rep
-          .string
-          .map(new Segment(_))
-
       implicit val http4sInstancesForSegment: Order[Segment] =
         new Order[Segment] {
           def compare(x: Segment, y: Segment): Int =
@@ -621,70 +453,6 @@ object Uri extends UriPlatform {
         def combine(x: Path, y: Path): Path = x.concat(y)
       }
 
-    import cats.parse.Parser.{char, pure}
-    import Segment.{segment, segmentNz, segmentNzNc}
-
-    /* path-abempty  = *( "/" segment ) */
-    lazy val pathAbempty: cats.parse.Parser0[Path] =
-      (char('/') *> segment).rep0.map {
-        case Nil => Path.empty
-        case List(Segment.empty) => Path.Root
-        case segments =>
-          val segmentsV = segments.toVector
-          if (segmentsV.last.isEmpty)
-            Path(segmentsV.dropRight(1), absolute = true, endsWithSlash = true)
-          else
-            Path(segmentsV, absolute = true, endsWithSlash = false)
-      }
-
-    /* path-absolute = "/" [ segment-nz *( "/" segment ) ] */
-    lazy val pathAbsolute: P[Path] =
-      (char('/') *> (segmentNz ~ (char('/') *> segment).rep0).?).map {
-        case Some((head, tail)) =>
-          val segmentsV = head +: tail.toVector
-          if (segmentsV.last.isEmpty)
-            Path(segmentsV.dropRight(1), absolute = true, endsWithSlash = true)
-          else
-            Path(segmentsV, absolute = true, endsWithSlash = false)
-        case None =>
-          Path.Root
-      }
-
-    /* path-rootless = segment-nz *( "/" segment ) */
-    lazy val pathRootless: P[Path] =
-      (segmentNz ~ (char('/') *> segment).rep0).map { case (head, tail) =>
-        val segmentsV = head +: tail.toVector
-        if (segmentsV.last.isEmpty)
-          Path(segmentsV.dropRight(1), absolute = false, endsWithSlash = true)
-        else
-          Path(segmentsV, absolute = false, endsWithSlash = false)
-      }
-
-    /* path-empty    = 0<pchar> */
-    lazy val pathEmpty: Parser0[Path] =
-      pure(Path.empty)
-
-    /* path-noscheme = segment-nz-nc *( "/" segment ) */
-    lazy val pathNoscheme: P[Path] =
-      (segmentNzNc ~ (char('/') *> segment).rep0).map { case (head, tail) =>
-        val segmentsV = head +: tail.toVector
-        if (segmentsV.last.isEmpty)
-          Path(segmentsV.dropRight(1), absolute = false, endsWithSlash = true)
-        else
-          Path(segmentsV, absolute = false, endsWithSlash = false)
-      }
-
-    /* absolute-path = 1*( "/" segment ) */
-    lazy val absolutePath: P[Path] =
-      (char('/') *> segment).rep.map {
-        case NonEmptyList(Segment.empty, Nil) => Path.Root
-        case segments =>
-          val segmentsV = segments.toList.toVector
-          if (segmentsV.last.isEmpty)
-            Path(segmentsV.dropRight(1), absolute = true, endsWithSlash = true)
-          else
-            Path(segmentsV, absolute = true, endsWithSlash = false)
-      }
   }
 
   /** The userinfo subcomponent may consist of a user name and,
@@ -718,19 +486,7 @@ object Uri extends UriPlatform {
 
     /** Parses a userInfo from a string percent-encoded in a specific charset. */
     def fromStringWithCharset(s: String, cs: JCharset): ParseResult[UserInfo] =
-      ParseResult.fromParser(parser(cs), "Invalid userinfo")(s)
-
-    /* userinfo    = *( unreserved / pct-encoded / sub-delims / ":" ) */
-    private[http4s] def parser(cs: JCharset): cats.parse.Parser0[UserInfo] = {
-      import cats.parse.Parser.{char, charIn, oneOf}
-      import Rfc3986.{pctEncoded, subDelims, unreserved}
-
-      val username = oneOf(unreserved :: pctEncoded :: subDelims :: Nil).rep0.string
-      val password = oneOf(unreserved :: pctEncoded :: subDelims :: charIn(':') :: Nil).rep0.string
-      (username ~ (char(':') *> password).?).map { case (u, p) =>
-        UserInfo(decode(u, cs), p.map(decode(_, cs)))
-      }
-    }
+      ParseResult.fromParser(Parser.userinfo(cs), "Invalid userinfo")(s)
 
     implicit val http4sInstancesForUserInfo
         : HttpCodec[UserInfo] with Order[UserInfo] with Hash[UserInfo] with Show[UserInfo] =
@@ -776,22 +532,6 @@ object Uri extends UriPlatform {
   }
 
   object Host {
-    /* host          = IP-literal / IPv4address / reg-name */
-    val parser: Parser0[Host] = {
-      import cats.parse.Parser.char
-      import Ipv4Address.{parser => ipv4Address}
-      import Ipv6Address.{parser => ipv6Address}
-      import RegName.{parser => regName}
-
-      // TODO This isn't in the 0.21 model.
-      /* IPvFuture     = "v" 1*HEXDIG "." 1*( unreserved / sub-delims / ":" ) */
-      val ipVFuture: P[Nothing] = P.fail
-
-      /* IP-literal    = "[" ( IPv6address / IPvFuture  ) "]" */
-      val ipLiteral = char('[') *> ipv6Address.orElse(ipVFuture) <* char(']')
-
-      ipLiteral.orElse(ipv4Address.backtrack).orElse(regName)
-    }
 
     implicit val catsInstancesForHttp4sUriHost: Hash[Host] with Order[Host] with Show[Host] =
       new Hash[Host] with Order[Host] with Show[Host] {
@@ -877,7 +617,7 @@ object Uri extends UriPlatform {
 
   object Ipv4Address {
     def fromString(s: String): ParseResult[Ipv4Address] =
-      ParseResult.fromParser(parser, "Invalid IPv4 Address")(s)
+      ParseResult.fromParser(Parser.ipv4Address, "Invalid IPv4 Address")(s)
 
     /** Like `fromString`, but throws on invalid input */
     def unsafeFromString(s: String): Ipv4Address =
@@ -899,9 +639,6 @@ object Uri extends UriPlatform {
           throw bug(s"Inet4Address.getAddress not exactly four bytes: ${array}")
       }
 
-    private[http4s] val parser: P[Ipv4Address] =
-      Rfc3986.ipv4Bytes.map { case (a, b, c, d) => Ipv4Address(a, b, c, d) }
-
     implicit val http4sInstancesForIpv4Address: HttpCodec[Ipv4Address]
       with Order[Ipv4Address]
       with Hash[Ipv4Address]
@@ -1016,7 +753,7 @@ object Uri extends UriPlatform {
 
   object Ipv6Address {
     def fromString(s: String): ParseResult[Ipv6Address] =
-      ParseResult.fromParser(parser, "Invalid IPv6 address")(s)
+      ParseResult.fromParser(Parser.ipv6Address, "Invalid IPv6 address")(s)
 
     /** Like `fromString`, but throws on invalid input */
     def unsafeFromString(s: String): Ipv6Address =
@@ -1058,60 +795,6 @@ object Uri extends UriPlatform {
       }
     }
 
-    private[http4s] val parser: P[Ipv6Address] = {
-      import cats.parse.Parser.{char, string}
-      import cats.parse.Parser
-      import Rfc3986.{hexdig, ipv4Bytes}
-
-      def toIpv6(lefts: collection.Seq[Short], rights: collection.Seq[Short]): Ipv6Address =
-        lefts ++ collection.Seq.fill(8 - lefts.size - rights.size)(0.toShort) ++ rights match {
-          case collection.Seq(a, b, c, d, e, f, g, h) =>
-            Ipv6Address(a, b, c, d, e, f, g, h)
-        }
-
-      val h16: P[Short] =
-        (hexdig ~ hexdig.? ~ hexdig.? ~ hexdig.?).string.map { (s: String) =>
-          java.lang.Integer.parseInt(s, 16).toShort
-        }
-
-      val colon = char(':')
-      val doubleColon = string("::").void
-      val h16Colon = h16 <* colon
-
-      val parsedIpv4Bytes = ipv4Bytes.map { case (a: Byte, b: Byte, c: Byte, d: Byte) =>
-        List(((a << 8) | b).toShort, ((c << 8) | d).toShort)
-      }
-
-      def rightsWithIpv4(n: Int) = (1 to n)
-        .map { i =>
-          (h16Colon.repExactlyAs[List[Short]](i) ~ parsedIpv4Bytes).backtrack.map { case (l, r) =>
-            l ++ r
-          }
-        }
-        .foldLeft(parsedIpv4Bytes.backtrack)(_ | _)
-
-      val ls32: P[List[Short]] = {
-        val option1 = ((h16 <* colon.void) ~ h16).map(t => List(t._1, t._2))
-        option1.backtrack.orElse(parsedIpv4Bytes)
-      }
-
-      val fullIpv6WihtOptionalIpv4 = (h16Colon.repExactlyAs[List[Short]](6) ~ ls32)
-        .map { case (ls: List[Short], rs) => toIpv6(ls.toList, rs) }
-
-      val shortIpv6WithIpv4 = for {
-        lefts <- h16.repSep0(0, 5, colon).with1 <* doubleColon
-        rights <- rightsWithIpv4(4 - lefts.size)
-      } yield toIpv6(lefts, rights)
-
-      val shortIpv6 = for {
-        lefts <- h16.repSep0(0, 7, colon).with1 <* doubleColon
-        rights <-
-          if (6 - lefts.size > 0)(h16.repSep0(0, 6 - lefts.size, colon)) else Parser.pure(Nil)
-      } yield toIpv6(lefts, rights)
-
-      fullIpv6WihtOptionalIpv4.backtrack.orElse(shortIpv6WithIpv4.backtrack).orElse(shortIpv6)
-    }
-
     implicit val http4sInstancesForIpv6Address: HttpCodec[Ipv6Address]
       with Order[Ipv6Address]
       with Hash[Ipv6Address]
@@ -1140,18 +823,6 @@ object Uri extends UriPlatform {
   object RegName {
     def apply(name: String): RegName = new RegName(CIString(name))
 
-    /* reg-name    = *( unreserved / pct-encoded / sub-delims) */
-    val parser: Parser0[RegName] = {
-      import Rfc3986.{pctEncoded, subDelims, unreserved}
-
-      unreserved
-        .orElse(pctEncoded)
-        .orElse(subDelims)
-        .rep0
-        .string
-        .map(s => RegName(CIString(decode(s))))
-    }
-
     implicit val catsInstancesForHttp4sUriRegName
         : Hash[RegName] with Order[RegName] with Show[RegName] =
       new Hash[RegName] with Order[RegName] with Show[RegName] {
@@ -1166,23 +837,6 @@ object Uri extends UriPlatform {
       }
   }
 
-  object Port {
-    /* port        = *DIGIT
-     *
-     * Limitation: we only parse up to Int. The spec allows bigint!
-     */
-    private[http4s] val parser: Parser0[Option[Int]] = {
-      import Rfc3986.digit
-
-      digit.rep0.string.mapFilter {
-        case "" => Some(None)
-        case s =>
-          try Some(Some(s.toInt))
-          catch { case _: NumberFormatException => None }
-      }
-    }
-  }
-
   /** Resolve a relative Uri reference, per RFC 3986 sec 5.2
     */
   def resolve(base: Uri, reference: Uri): Uri = {
@@ -1398,4 +1052,331 @@ object Uri extends UriPlatform {
       override def show(t: Uri): String =
         t.renderString
     }
+
+  private[http4s] object Parser {
+    /* port        = *DIGIT
+     *
+     * Limitation: we only parse up to Int. The spec allows bigint!
+     */
+    private[http4s] val port: Parser0[Option[Int]] = {
+      import Rfc3986.digit
+
+      digit.rep0.string.mapFilter {
+        case "" => Some(None)
+        case s =>
+          try Some(Some(s.toInt))
+          catch { case _: NumberFormatException => None }
+      }
+    }
+
+    /* reg-name    = *( unreserved / pct-encoded / sub-delims) */
+    private[http4s] val regName: Parser0[Uri.RegName] = {
+      import Rfc3986.{pctEncoded, subDelims, unreserved}
+
+      unreserved
+        .orElse(pctEncoded)
+        .orElse(subDelims)
+        .rep0
+        .string
+        .map(s => Uri.RegName(CIString(Uri.decode(s))))
+    }
+
+    private[http4s] val ipv6Address: P[Uri.Ipv6Address] = {
+      import cats.parse.Parser.{char, string}
+      import Rfc3986.{hexdig, ipv4Bytes}
+
+      def toIpv6(lefts: collection.Seq[Short], rights: collection.Seq[Short]): Uri.Ipv6Address =
+        lefts ++ collection.Seq.fill(8 - lefts.size - rights.size)(0.toShort) ++ rights match {
+          case collection.Seq(a, b, c, d, e, f, g, h) =>
+            Uri.Ipv6Address(a, b, c, d, e, f, g, h)
+        }
+
+      val h16: P[Short] =
+        (hexdig ~ hexdig.? ~ hexdig.? ~ hexdig.?).string.map { (s: String) =>
+          java.lang.Integer.parseInt(s, 16).toShort
+        }
+
+      val colon = char(':')
+      val doubleColon = string("::").void
+      val h16Colon = h16 <* colon
+
+      val parsedIpv4Bytes = ipv4Bytes.map { case (a: Byte, b: Byte, c: Byte, d: Byte) =>
+        List(((a << 8) | b).toShort, ((c << 8) | d).toShort)
+      }
+
+      def rightsWithIpv4(n: Int) = (1 to n)
+        .map { i =>
+          (h16Colon.repExactlyAs[List[Short]](i) ~ parsedIpv4Bytes).backtrack.map { case (l, r) =>
+            l ++ r
+          }
+        }
+        .foldLeft(parsedIpv4Bytes.backtrack)(_ | _)
+
+      val ls32: P[List[Short]] = {
+        val option1 = ((h16 <* colon.void) ~ h16).map(t => List(t._1, t._2))
+        option1.backtrack.orElse(parsedIpv4Bytes)
+      }
+
+      val fullIpv6WihtOptionalIpv4 = (h16Colon.repExactlyAs[List[Short]](6) ~ ls32)
+        .map { case (ls: List[Short], rs) => toIpv6(ls.toList, rs) }
+
+      val shortIpv6WithIpv4 = for {
+        lefts <- h16.repSep0(0, 5, colon).with1 <* doubleColon
+        rights <- rightsWithIpv4(4 - lefts.size)
+      } yield toIpv6(lefts, rights)
+
+      val shortIpv6 = for {
+        lefts <- h16.repSep0(0, 7, colon).with1 <* doubleColon
+        rights <-
+          if (6 - lefts.size > 0)(h16.repSep0(0, 6 - lefts.size, colon)) else P.pure(Nil)
+      } yield toIpv6(lefts, rights)
+
+      fullIpv6WihtOptionalIpv4.backtrack.orElse(shortIpv6WithIpv4.backtrack).orElse(shortIpv6)
+    }
+
+    private[http4s] val ipv4Address: P[Uri.Ipv4Address] =
+      Rfc3986.ipv4Bytes.map { case (a, b, c, d) => Uri.Ipv4Address(a, b, c, d) }
+
+    /* host          = IP-literal / IPv4address / reg-name */
+    private[http4s] val host: Parser0[Uri.Host] = {
+      import cats.parse.Parser.char
+
+      // TODO This isn't in the 0.21 model.
+      /* IPvFuture     = "v" 1*HEXDIG "." 1*( unreserved / sub-delims / ":" ) */
+      val ipVFuture: P[Nothing] = P.fail
+
+      /* IP-literal    = "[" ( IPv6address / IPvFuture  ) "]" */
+      val ipLiteral = char('[') *> ipv6Address.orElse(ipVFuture) <* char(']')
+
+      ipLiteral.orElse(ipv4Address.backtrack).orElse(regName)
+    }
+
+    /* userinfo    = *( unreserved / pct-encoded / sub-delims / ":" ) */
+    private[http4s] def userinfo(cs: JCharset): Parser0[Uri.UserInfo] = {
+      import cats.parse.Parser.{char, charIn, oneOf}
+      import Rfc3986.{pctEncoded, subDelims, unreserved}
+
+      val username = oneOf(unreserved :: pctEncoded :: subDelims :: Nil).rep0.string
+      val password = oneOf(unreserved :: pctEncoded :: subDelims :: charIn(':') :: Nil).rep0.string
+      (username ~ (char(':') *> password).?).map { case (u, p) =>
+        Uri.UserInfo(Uri.decode(u, cs), p.map(Uri.decode(_, cs)))
+      }
+    }
+
+    /* segment       = *pchar */
+    private[http4s] val segment: Parser0[Uri.Path.Segment] =
+      Rfc3986.pchar.rep0.string.map(Uri.Path.Segment.encoded)
+
+    /* segment-nz    = 1*pchar */
+    private[http4s] val segmentNz: P[Uri.Path.Segment] =
+      Rfc3986.pchar.rep.string.map(Uri.Path.Segment.encoded)
+
+    /* segment-nz-nc = 1*( unreserved / pct-encoded / sub-delims / "@" )
+                   ; non-zero-length segment without any colon ":" */
+    private[http4s] val segmentNzNc: P[Uri.Path.Segment] =
+      Rfc3986.unreserved
+        .orElse(Rfc3986.pctEncoded)
+        .orElse(Rfc3986.subDelims)
+        .orElse(P.char('@'))
+        .rep
+        .string
+        .map(Uri.Path.Segment.encoded(_))
+
+    import cats.parse.Parser.{char, pure}
+
+    /* path-abempty  = *( "/" segment ) */
+    private[http4s] val pathAbempty: Parser0[Uri.Path] =
+      (char('/') *> segment).rep0.map {
+        case Nil => Uri.Path.empty
+        case List(Uri.Path.Segment.empty) => Uri.Path.Root
+        case segments =>
+          val segmentsV = segments.toVector
+          if (segmentsV.last.isEmpty)
+            Uri.Path(segmentsV.dropRight(1), absolute = true, endsWithSlash = true)
+          else
+            Uri.Path(segmentsV, absolute = true, endsWithSlash = false)
+      }
+
+    /* path-absolute = "/" [ segment-nz *( "/" segment ) ] */
+    private[http4s] val pathAbsolute: P[Uri.Path] =
+      (char('/') *> (segmentNz ~ (char('/') *> segment).rep0).?).map {
+        case Some((head, tail)) =>
+          val segmentsV = head +: tail.toVector
+          if (segmentsV.last.isEmpty)
+            Uri.Path(segmentsV.dropRight(1), absolute = true, endsWithSlash = true)
+          else
+            Uri.Path(segmentsV, absolute = true, endsWithSlash = false)
+        case None =>
+          Uri.Path.Root
+      }
+
+    /* path-rootless = segment-nz *( "/" segment ) */
+    private[http4s] val pathRootless: P[Uri.Path] =
+      (segmentNz ~ (char('/') *> segment).rep0).map { case (head, tail) =>
+        val segmentsV = head +: tail.toVector
+        if (segmentsV.last.isEmpty)
+          Uri.Path(segmentsV.dropRight(1), absolute = false, endsWithSlash = true)
+        else
+          Uri.Path(segmentsV, absolute = false, endsWithSlash = false)
+      }
+
+    /* path-empty    = 0<pchar> */
+    private[http4s] val pathEmpty: Parser0[Uri.Path] =
+      pure(Uri.Path.empty)
+
+    /* path-noscheme = segment-nz-nc *( "/" segment ) */
+    private[http4s] val pathNoscheme: P[Uri.Path] =
+      (segmentNzNc ~ (char('/') *> segment).rep0).map { case (head, tail) =>
+        val segmentsV = head +: tail.toVector
+        if (segmentsV.last.isEmpty)
+          Uri.Path(segmentsV.dropRight(1), absolute = false, endsWithSlash = true)
+        else
+          Uri.Path(segmentsV, absolute = false, endsWithSlash = false)
+      }
+
+    /* absolute-path = 1*( "/" segment ) */
+    private[http4s] val absolutePath: P[Uri.Path] =
+      (char('/') *> segment).rep.map {
+        case NonEmptyList(Uri.Path.Segment.empty, Nil) => Uri.Path.Root
+        case segments =>
+          val segmentsV = segments.toList.toVector
+          if (segmentsV.last.isEmpty)
+            Uri.Path(segmentsV.dropRight(1), absolute = true, endsWithSlash = true)
+          else
+            Uri.Path(segmentsV, absolute = true, endsWithSlash = false)
+      }
+
+    /* authority   = [ userinfo "@" ] host [ ":" port ] */
+    private[http4s] def authority(cs: JCharset): Parser0[Uri.Authority] =
+      ((userinfo(cs) <* char('@')).backtrack.? ~ host ~ (char(':') *> port).?).map {
+        case ((ui, h), p) => Uri.Authority(userInfo = ui, host = h, port = p.flatten)
+      }
+
+    /* fragment    = *( pchar / "/" / "?" )
+     *
+     * Not URL decoded.
+     */
+    private[http4s] val fragment: Parser0[Uri.Fragment] =
+      Rfc3986.pchar.orElse(P.charIn("/?")).rep0.string
+
+    /* scheme      = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." ) */
+    private[http4s] val scheme: P[Uri.Scheme] = {
+      import cats.parse.Parser.{charIn, not, string}
+      import Rfc3986.{alpha, digit}
+
+      val unary = alpha.orElse(digit).orElse(charIn("+-."))
+
+      (string("https") <* not(unary))
+        .as(Uri.Scheme.https)
+        .backtrack
+        .orElse((string("http") <* not(unary)).as(Uri.Scheme.http))
+        .backtrack
+        .orElse((alpha *> unary.rep0).string.map(new Uri.Scheme(_)))
+    }
+
+    /* request-target = origin-form
+                      / absolute-form
+                      / authority-form
+                      / asterisk-form
+     */
+    private[http4s] val requestTargetParser: Parser0[Uri] = {
+      import cats.parse.Parser.{char, oneOf0}
+      import Query.{parser => query}
+
+      /* origin-form    = absolute-path [ "?" query ] */
+      val originForm: P[Uri] =
+        (absolutePath ~ (char('?') *> query).?).map { case (p, q) =>
+          Uri(scheme = None, authority = None, path = p, query = q.getOrElse(Query.empty))
+        }
+
+      /* absolute-form = absolute-URI */
+      def absoluteForm: P[Uri] = absoluteUri(StandardCharsets.UTF_8)
+
+      /* authority-form = authority */
+      val authorityForm: Parser0[Uri] =
+        authority(StandardCharsets.UTF_8).map(a => Uri(authority = Some(a)))
+
+      /* asterisk-form = "*" */
+      val asteriskForm: P[Uri] =
+        char('*').as(Uri(path = Uri.Path.Asterisk))
+
+      oneOf0(originForm :: absoluteForm :: authorityForm :: asteriskForm :: Nil)
+    }
+
+    /* hier-part   = "//" authority path-abempty
+     *             / path-absolute
+     *             / path-rootless
+     *             / path-empty
+     */
+    def hierPart(cs: JCharset): Parser0[(Option[Uri.Authority], Uri.Path)] = {
+      import P.string
+      val rel: P[(Option[Uri.Authority], Uri.Path)] =
+        (string("//") *> authority(cs) ~ pathAbempty).map { case (a, p) =>
+          (Some(a), p)
+        }
+      P.oneOf0(
+        rel :: pathAbsolute.map((None, _)) :: pathRootless.map((None, _)) :: pathEmpty.map(
+          (None, _)) :: Nil)
+    }
+
+    /* absolute-URI  = scheme ":" hier-part [ "?" query ] */
+    private[http4s] def absoluteUri(cs: JCharset): P[Uri] = {
+      import cats.parse.Parser.char
+      import Query.{parser => query}
+
+      (scheme ~ (char(':') *> hierPart(cs)) ~ (char('?') *> query).?).map { case ((s, (a, p)), q) =>
+        Uri(scheme = Some(s), authority = a, path = p, query = q.getOrElse(Query.empty))
+      }
+    }
+
+    private[http4s] def uri(cs: JCharset): P[Uri] = {
+      import cats.parse.Parser.char
+      import Query.{parser => query}
+
+      (scheme ~ (char(':') *> hierPart(cs)) ~ (char('?') *> query).? ~ (char('#') *> fragment).?)
+        .map { case (((s, (a, p)), q), f) =>
+          Uri(
+            scheme = Some(s),
+            authority = a,
+            path = p,
+            query = q.getOrElse(Query.empty),
+            fragment = f)
+        }
+    }
+
+    /* relative-part = "//" authority path-abempty
+                     / path-absolute
+                     / path-noscheme
+                     / path-empty
+     */
+    private[http4s] def relativePart(cs: JCharset): Parser0[(Option[Uri.Authority], Uri.Path)] = {
+      import cats.parse.Parser.string
+
+      P.oneOf0(
+        ((string("//") *> authority(cs) ~ pathAbempty).map { case (a, p) =>
+          (Some(a), p)
+        }) :: (pathAbsolute.map((None, _))) :: (pathNoscheme.map((None, _))) :: (pathEmpty.map(
+          (None, _))) :: Nil)
+    }
+
+    /* relative-ref  = relative-part [ "?" query ] [ "#" fragment ] */
+    private[http4s] def relativeRef(cs: JCharset): Parser0[Uri] = {
+      import cats.parse.Parser.char
+      import Query.{parser => query}
+
+      (relativePart(cs) ~ (char('?') *> query).? ~ (char('#') *> fragment).?).map {
+        case (((a, p), q), f) =>
+          Uri(
+            scheme = None,
+            authority = a,
+            path = p,
+            query = q.getOrElse(Query.empty),
+            fragment = f)
+      }
+    }
+
+    private[http4s] val uriReferenceUtf8: Parser0[Uri] = uriReference(StandardCharsets.UTF_8)
+    private[http4s] def uriReference(cs: JCharset): Parser0[Uri] =
+      uri(cs).backtrack.orElse(relativeRef(cs))
+  }
 }
diff --git a/core/src/main/scala/org/http4s/headers/Content-Location.scala b/core/src/main/scala/org/http4s/headers/Content-Location.scala
index 06f6ed4517a..55cf5421068 100644
--- a/core/src/main/scala/org/http4s/headers/Content-Location.scala
+++ b/core/src/main/scala/org/http4s/headers/Content-Location.scala
@@ -23,9 +23,9 @@ import java.nio.charset.StandardCharsets
 object `Content-Location` extends HeaderKey.Internal[`Content-Location`] with HeaderKey.Singleton {
   override def parse(s: String): ParseResult[`Content-Location`] =
     ParseResult.fromParser(parser, "Invalid Content-Location")(s)
-  private[http4s] val parser = Uri
+  private[http4s] val parser = Uri.Parser
     .absoluteUri(StandardCharsets.ISO_8859_1)
-    .orElse(Uri.relativeRef(StandardCharsets.ISO_8859_1))
+    .orElse(Uri.Parser.relativeRef(StandardCharsets.ISO_8859_1))
     .map(`Content-Location`(_))
 }
 
diff --git a/core/src/main/scala/org/http4s/headers/Forwarded.scala b/core/src/main/scala/org/http4s/headers/Forwarded.scala
index c56fed85d67..cdafabf75ca 100644
--- a/core/src/main/scala/org/http4s/headers/Forwarded.scala
+++ b/core/src/main/scala/org/http4s/headers/Forwarded.scala
@@ -22,7 +22,6 @@ import cats.syntax.either._
 import org.http4s._
 import org.http4s.util.{Renderable, Writer}
 import cats.parse.{Numbers, Parser0, Rfc5234, Parser => P}
-import org.http4s.Uri.{Ipv4Address, Ipv6Address}
 import org.http4s.internal.parsing.Rfc7230
 
 import java.util.Locale
@@ -122,8 +121,8 @@ object Forwarded
       val nodeName: P[Node.Name] =
         P.oneOf[Node.Name](
           List(
-            Ipv4Address.parser.map(Node.Name.Ipv4),
-            Ipv6Address.parser
+            Uri.Parser.ipv4Address.map(Node.Name.Ipv4),
+            Uri.Parser.ipv6Address
               .between(P.char('['), P.char(']'))
               .map(Node.Name.Ipv6),
             P.string("unknown").as(Node.Name.Unknown),
@@ -193,7 +192,7 @@ object Forwarded
 
       // ** RFC3986 **
       // port = *DIGIT
-      (Uri.Host.parser ~ (P.char(':') *> port).?)
+      (Uri.Parser.host ~ (P.char(':') *> port).?)
         .map { case (h, p) => apply(h, p.flatten) }
     }
   }
@@ -308,7 +307,7 @@ object Forwarded
     // [RFC3986]
 
     val host = Host.parser
-    val proto = Uri.Scheme.parser
+    val proto = Uri.Parser.scheme
     val node = Node.parser
 
     val forwardedPair = P.oneOf(
diff --git a/core/src/main/scala/org/http4s/headers/Host.scala b/core/src/main/scala/org/http4s/headers/Host.scala
index 1ae30edfab5..b8771c0095b 100644
--- a/core/src/main/scala/org/http4s/headers/Host.scala
+++ b/core/src/main/scala/org/http4s/headers/Host.scala
@@ -29,12 +29,11 @@ object Host extends HeaderKey.Internal[Host] with HeaderKey.Singleton {
     ParseResult.fromParser(parser, "Invalid Host")(s)
 
   private[http4s] val parser = {
-    import Uri.Host.{parser => host}
     val port = Parser.string(":") *> Rfc3986.digit.rep.string.mapFilter { s =>
       Try(s.toInt).toOption
     }
 
-    (host ~ port.?).map { case (host, port) =>
+    (Uri.Parser.host ~ port.?).map { case (host, port) =>
       Host(host.value, port)
     }
   }
diff --git a/core/src/main/scala/org/http4s/headers/Link.scala b/core/src/main/scala/org/http4s/headers/Link.scala
index 654494b123e..9b36fa94be2 100644
--- a/core/src/main/scala/org/http4s/headers/Link.scala
+++ b/core/src/main/scala/org/http4s/headers/Link.scala
@@ -38,12 +38,10 @@ object Link extends HeaderKey.Internal[Link] with HeaderKey.Recurring {
     final case class Type(value: MediaRange) extends LinkParam
 
     // https://tools.ietf.org/html/rfc3986#section-4.1
-    val linkValue: Parser0[LinkValue] = {
-      import Uri._
-      uriReference(StandardCharsets.UTF_8).map { uri =>
+    val linkValue: Parser0[LinkValue] =
+      Uri.Parser.uriReference(StandardCharsets.UTF_8).map { uri =>
         headers.LinkValue(uri)
       }
-    }
 
     val linkParam: Parser0[LinkParam] = {
       val relParser = (string("rel=") *> token.orElse(quotedString))
diff --git a/core/src/main/scala/org/http4s/headers/Location.scala b/core/src/main/scala/org/http4s/headers/Location.scala
index 11401ed79bd..f7a1234ceea 100644
--- a/core/src/main/scala/org/http4s/headers/Location.scala
+++ b/core/src/main/scala/org/http4s/headers/Location.scala
@@ -23,9 +23,9 @@ import java.nio.charset.StandardCharsets
 object Location extends HeaderKey.Internal[Location] with HeaderKey.Singleton {
   override def parse(s: String): ParseResult[Location] =
     ParseResult.fromParser(parser, "Invalid Location")(s)
-  private[http4s] val parser = Uri
+  private[http4s] val parser = Uri.Parser
     .absoluteUri(StandardCharsets.ISO_8859_1)
-    .orElse(Uri.relativeRef(StandardCharsets.ISO_8859_1))
+    .orElse(Uri.Parser.relativeRef(StandardCharsets.ISO_8859_1))
     .map(Location(_))
 }
 
diff --git a/core/src/main/scala/org/http4s/headers/Origin.scala b/core/src/main/scala/org/http4s/headers/Origin.scala
index 312e9486162..05108b9efdb 100644
--- a/core/src/main/scala/org/http4s/headers/Origin.scala
+++ b/core/src/main/scala/org/http4s/headers/Origin.scala
@@ -75,8 +75,8 @@ object Origin extends HeaderKey.Internal[Origin] with HeaderKey.Singleton {
       .string
       .map(Uri.Scheme.unsafeFromString)
     val stringHost = until(char(':').orElse(`end`)).map(RegName.apply)
-    val bracketedIpv6 = char('[') *> Uri.Ipv6Address.parser <* char(']')
-    val host = List(bracketedIpv6, Uri.Ipv4Address.parser, stringHost).reduceLeft(_ orElse _)
+    val bracketedIpv6 = char('[') *> Uri.Parser.ipv6Address <* char(']')
+    val host = List(bracketedIpv6, Uri.Parser.ipv4Address, stringHost).reduceLeft(_ orElse _)
     val port = char(':') *> digit.rep.string.map(_.toInt)
     val nullHost = (string("null") *> `end`).orElse(`end`).as(Origin.Null)
 
diff --git a/core/src/main/scala/org/http4s/headers/Referer.scala b/core/src/main/scala/org/http4s/headers/Referer.scala
index 3090fe45368..3fb2e636de6 100644
--- a/core/src/main/scala/org/http4s/headers/Referer.scala
+++ b/core/src/main/scala/org/http4s/headers/Referer.scala
@@ -23,9 +23,9 @@ import java.nio.charset.StandardCharsets
 object Referer extends HeaderKey.Internal[Referer] with HeaderKey.Singleton {
   override def parse(s: String): ParseResult[Referer] =
     ParseResult.fromParser(parser, "Invalid Referer")(s)
-  private[http4s] val parser = Uri
+  private[http4s] val parser = Uri.Parser
     .absoluteUri(StandardCharsets.ISO_8859_1)
-    .orElse(Uri.relativeRef(StandardCharsets.ISO_8859_1))
+    .orElse(Uri.Parser.relativeRef(StandardCharsets.ISO_8859_1))
     .map(Referer(_))
 }
 
diff --git a/core/src/main/scala/org/http4s/headers/X-Forwarded-For.scala b/core/src/main/scala/org/http4s/headers/X-Forwarded-For.scala
index a2719bdc176..8e3b0ae38db 100644
--- a/core/src/main/scala/org/http4s/headers/X-Forwarded-For.scala
+++ b/core/src/main/scala/org/http4s/headers/X-Forwarded-For.scala
@@ -29,7 +29,7 @@ object `X-Forwarded-For` extends HeaderKey.Internal[`X-Forwarded-For`] with Head
   private[http4s] val parser: Parser[`X-Forwarded-For`] =
     Rfc7230
       .headerRep1(
-        (Uri.Ipv4Address.parser.map(_.toInet4Address).backtrack | Uri.Ipv6Address.parser.map(
+        (Uri.Parser.ipv4Address.map(_.toInet4Address).backtrack | Uri.Parser.ipv6Address.map(
           _.toInet6Address)).map(s => Some(s)) | (Parser.string("unknown").as(None)))
       .map(`X-Forwarded-For`.apply)
 }
diff --git a/ember-client/src/main/scala/org/http4s/ember/client/EmberClientBuilder.scala b/ember-client/src/main/scala/org/http4s/ember/client/EmberClientBuilder.scala
index c601a8ad3e8..bef0aa2d86e 100644
--- a/ember-client/src/main/scala/org/http4s/ember/client/EmberClientBuilder.scala
+++ b/ember-client/src/main/scala/org/http4s/ember/client/EmberClientBuilder.scala
@@ -22,7 +22,6 @@ import cats.effect._
 import scala.concurrent.duration._
 import org.http4s.ProductId
 import org.http4s.client._
-import org.http4s.headers.{Connection, `User-Agent`}
 import org.typelevel.keypool._
 import org.typelevel.log4cats.Logger
 import org.typelevel.log4cats.slf4j.Slf4jLogger
@@ -30,6 +29,8 @@ import fs2.io.tcp.SocketGroup
 import fs2.io.tcp.SocketOptionMapping
 import fs2.io.tls._
 import scala.concurrent.duration.Duration
+import org.http4s.headers.{Connection, `User-Agent`}
+import org.http4s.ember.client.internal.ClientHelpers
 
 final class EmberClientBuilder[F[_]: Async] private (
     private val tlsContextOpt: Option[TLSContext],
@@ -40,6 +41,7 @@ final class EmberClientBuilder[F[_]: Async] private (
     private val logger: Logger[F],
     val chunkSize: Int,
     val maxResponseHeaderSize: Int,
+    private val idleConnectionTime: Duration,
     val timeout: Duration,
     val additionalSocketOptions: List[SocketOptionMapping[_]],
     val userAgent: Option[`User-Agent`]
@@ -54,6 +56,7 @@ final class EmberClientBuilder[F[_]: Async] private (
       logger: Logger[F] = self.logger,
       chunkSize: Int = self.chunkSize,
       maxResponseHeaderSize: Int = self.maxResponseHeaderSize,
+      idleConnectionTime: Duration = self.idleConnectionTime,
       timeout: Duration = self.timeout,
       additionalSocketOptions: List[SocketOptionMapping[_]] = self.additionalSocketOptions,
       userAgent: Option[`User-Agent`] = self.userAgent
@@ -67,6 +70,7 @@ final class EmberClientBuilder[F[_]: Async] private (
       logger = logger,
       chunkSize = chunkSize,
       maxResponseHeaderSize = maxResponseHeaderSize,
+      idleConnectionTime = idleConnectionTime,
       timeout = timeout,
       additionalSocketOptions = additionalSocketOptions,
       userAgent = userAgent
@@ -81,11 +85,14 @@ final class EmberClientBuilder[F[_]: Async] private (
   def withMaxTotal(maxTotal: Int) = copy(maxTotal = maxTotal)
   def withMaxPerKey(maxPerKey: RequestKey => Int) = copy(maxPerKey = maxPerKey)
   def withIdleTimeInPool(idleTimeInPool: Duration) = copy(idleTimeInPool = idleTimeInPool)
+  def withIdleConnectionTime(idleConnectionTime: Duration) =
+    copy(idleConnectionTime = idleConnectionTime)
 
   def withLogger(logger: Logger[F]) = copy(logger = logger)
   def withChunkSize(chunkSize: Int) = copy(chunkSize = chunkSize)
   def withMaxResponseHeaderSize(maxResponseHeaderSize: Int) =
     copy(maxResponseHeaderSize = maxResponseHeaderSize)
+
   def withTimeout(timeout: Duration) = copy(timeout = timeout)
   def withAdditionalSocketOptions(additionalSocketOptions: List[SocketOptionMapping[_]]) =
     copy(additionalSocketOptions = additionalSocketOptions)
@@ -122,7 +129,7 @@ final class EmberClientBuilder[F[_]: Async] private (
                 socket.endOfInput.attempt.void >>
                 socket.endOfOutput.attempt.void >>
                 socket.close.attempt.void >>
-                shutdown
+                shutdown.attempt.void
             }
           )
           .withDefaultReuseState(Reusable.DontReuse)
@@ -132,9 +139,9 @@ final class EmberClientBuilder[F[_]: Async] private (
           .withOnReaperException(_ => Applicative[F].unit)
       pool <- builder.build
     } yield {
-      val client = Client[F](request =>
+      val client = Client[F] { request =>
         for {
-          managed <- pool.take(RequestKey.fromRequest(request))
+          managed <- ClientHelpers.getValidManaged(pool, request)
           _ <- Resource.eval(
             pool.state.flatMap { poolState =>
               logger.trace(
@@ -143,31 +150,34 @@ final class EmberClientBuilder[F[_]: Async] private (
             }
           )
           responseResource <-
-            org.http4s.ember.client.internal.ClientHelpers
-              .request[F](
-                request,
-                managed.value._1,
-                managed.canBeReused,
-                chunkSize,
-                maxResponseHeaderSize,
-                timeout,
-                userAgent
-              )
-              .map(response =>
-                // TODO If Response Body has a take(1).compile.drain - would leave rest of bytes in root stream for next caller
-                response.copy(body = response.body.onFinalizeCaseWeak {
-                  case Resource.ExitCase.Succeeded =>
-                    val requestClose = request.headers.get(Connection).exists(_.hasClose)
-                    val responseClose = response.isChunked || response.headers
-                      .get(Connection)
-                      .exists(_.hasClose)
-
-                    if (requestClose || responseClose) Sync[F].unit
-                    else managed.canBeReused.set(Reusable.Reuse)
-                  case Resource.ExitCase.Canceled => Sync[F].unit
-                  case Resource.ExitCase.Errored(_) => Sync[F].unit
-                }))
-        } yield responseResource)
+            Resource.eval(
+              ClientHelpers
+                .request[F](
+                  request,
+                  managed.value._1,
+                  managed.canBeReused,
+                  chunkSize,
+                  maxResponseHeaderSize,
+                  idleConnectionTime,
+                  timeout,
+                  userAgent
+                )
+                .map(response =>
+                  // TODO If Response Body has a take(1).compile.drain - would leave rest of bytes in root stream for next caller
+                  response.copy(body = response.body.onFinalizeCaseWeak {
+                    case Resource.ExitCase.Succeeded =>
+                      val requestClose = request.headers.get(Connection).exists(_.hasClose)
+                      val responseClose = response.isChunked || response.headers
+                        .get(Connection)
+                        .exists(_.hasClose)
+
+                      if (requestClose || responseClose) Sync[F].unit
+                      else managed.canBeReused.set(Reusable.Reuse)
+                    case Resource.ExitCase.Canceled => Sync[F].unit
+                    case Resource.ExitCase.Errored(_) => Sync[F].unit
+                  })))
+        } yield responseResource
+      }
       new EmberClient[F](client, pool)
     }
 }
@@ -184,6 +194,7 @@ object EmberClientBuilder {
       logger = Slf4jLogger.getLogger[F],
       chunkSize = Defaults.chunkSize,
       maxResponseHeaderSize = Defaults.maxResponseHeaderSize,
+      idleConnectionTime = Defaults.idleConnectionTime,
       timeout = Defaults.timeout,
       additionalSocketOptions = Defaults.additionalSocketOptions,
       userAgent = Defaults.userAgent
@@ -193,7 +204,8 @@ object EmberClientBuilder {
     val acgFixedThreadPoolSize: Int = 100
     val chunkSize: Int = 32 * 1024
     val maxResponseHeaderSize: Int = 4096
-    val timeout: Duration = 60.seconds
+    val idleConnectionTime = org.http4s.client.defaults.RequestTimeout
+    val timeout: Duration = org.http4s.client.defaults.RequestTimeout
 
     // Pool Settings
     val maxPerKey = { (_: RequestKey) =>
diff --git a/ember-client/src/main/scala/org/http4s/ember/client/internal/ClientHelpers.scala b/ember-client/src/main/scala/org/http4s/ember/client/internal/ClientHelpers.scala
index a49b45d5c38..e2e097c12dc 100644
--- a/ember-client/src/main/scala/org/http4s/ember/client/internal/ClientHelpers.scala
+++ b/ember-client/src/main/scala/org/http4s/ember/client/internal/ClientHelpers.scala
@@ -17,7 +17,6 @@
 package org.http4s.ember.client.internal
 
 import org.http4s.ember.client._
-import fs2.concurrent._
 import fs2.io.tcp._
 import fs2.io.Network
 import cats._
@@ -31,12 +30,12 @@ import org.http4s._
 import org.http4s.client.RequestKey
 import org.typelevel.ci.CIString
 import _root_.org.http4s.ember.core.{Encoder, Parser}
-import _root_.org.http4s.ember.core.Util.readWithTimeout
 import _root_.fs2.io.tcp.SocketGroup
 import _root_.fs2.io.tls._
-import org.typelevel.keypool.Reusable
+import org.typelevel.keypool._
 import javax.net.ssl.SNIHostName
 import org.http4s.headers.{Connection, Date, `User-Agent`}
+import _root_.org.http4s.ember.core.Util.durationToFinite
 
 private[client] object ClientHelpers {
   def requestToSocketWithKey[F[_]: Sync: Network](
@@ -86,55 +85,34 @@ private[client] object ClientHelpers {
       reuseable: Ref[F, Reusable],
       chunkSize: Int,
       maxResponseHeaderSize: Int,
+      idleTimeout: Duration,
       timeout: Duration,
       userAgent: Option[`User-Agent`]
-  ): Resource[F, Response[F]] = {
-    def realtime: Resource[F, FiniteDuration] = Resource.liftK[F](Sync[F].realTime)
+  ): F[Response[F]] = {
 
     def writeRequestToSocket(
         req: Request[F],
         socket: Socket[F],
-        timeout: Option[FiniteDuration]): Resource[F, Unit] =
+        timeout: Option[FiniteDuration]): F[Unit] =
       Encoder
         .reqToBytes(req)
         .through(socket.writes(timeout))
         .compile
-        .resource
         .drain
 
-    def onNoTimeout(req: Request[F], socket: Socket[F]): Resource[F, Response[F]] =
-      writeRequestToSocket(req, socket, None) >>
-        Parser.Response.parser(maxResponseHeaderSize)(
-          socket.reads(chunkSize, None)
-        )
-
-    def onTimeout(
-        req: Request[F],
-        socket: Socket[F],
-        fin: FiniteDuration): Resource[F, Response[F]] =
-      for {
-        start <- realtime
-        _ <- writeRequestToSocket(req, socket, Option(fin))
-        timeoutSignal <- Resource.eval(SignallingRef[F, Boolean](true))
-        sent <- realtime
-        remains = fin - (sent - start)
-        resp <- Parser.Response.parser[F](maxResponseHeaderSize)(
-          readWithTimeout(socket, start.toMillis, remains, timeoutSignal.get, chunkSize)
-        )
-        _ <- Resource.eval(timeoutSignal.set(false).void)
-      } yield resp
-
-    def writeRead(req: Request[F]) =
-      timeout match {
-        case t: FiniteDuration => onTimeout(req, requestKeySocket.socket, t)
-        case _ => onNoTimeout(req, requestKeySocket.socket)
+    def writeRead(req: Request[F]): F[Response[F]] =
+      writeRequestToSocket(req, requestKeySocket.socket, durationToFinite(idleTimeout)) >> {
+        Parser.Response
+          .parser(maxResponseHeaderSize, durationToFinite(timeout))(
+            requestKeySocket.socket.reads(chunkSize, durationToFinite(idleTimeout))
+          )
+          .map(_._1)
       }
 
     for {
-      processedReq <- Resource.eval(preprocessRequest(request, userAgent))
+      processedReq <- preprocessRequest(request, userAgent)
       resp <- writeRead(processedReq)
-      processedResp <- postProcessResponse(processedReq, resp, reuseable)
-    } yield processedResp
+    } yield postProcessResponse(processedReq, resp, reuseable)
   }
 
   private[internal] def preprocessRequest[F[_]: Monad: Clock](
@@ -154,7 +132,7 @@ private[client] object ClientHelpers {
   private[internal] def postProcessResponse[F[_]: Concurrent](
       req: Request[F],
       resp: Response[F],
-      canBeReused: Ref[F, Reusable]): Resource[F, Response[F]] = {
+      canBeReused: Ref[F, Reusable]): Response[F] = {
     val out = resp.copy(
       body = resp.body.onFinalizeCaseWeak {
         case Resource.ExitCase.Succeeded =>
@@ -167,7 +145,7 @@ private[client] object ClientHelpers {
         case Resource.ExitCase.Errored(_) => Applicative[F].unit
       }
     )
-    Resource.pure[F, Response[F]](out)
+    out
   }
 
   // https://github.com/http4s/http4s/blob/main/blaze-client/src/main/scala/org/http4s/client/blaze/Http1Support.scala#L86
@@ -178,4 +156,25 @@ private[client] object ClientHelpers {
         val host = auth.host.value
         Sync[F].delay(new InetSocketAddress(host, port))
     }
+
+  // Assumes that the request doesn't have fancy finalizers besides shutting down the pool
+  private[client] def getValidManaged[F[_]: Sync](
+      pool: KeyPool[F, RequestKey, (RequestKeySocket[F], F[Unit])],
+      request: Request[F]): Resource[F, Managed[F, (RequestKeySocket[F], F[Unit])]] =
+    pool.take(RequestKey.fromRequest(request)).flatMap { managed =>
+      Resource
+        .eval(managed.value._1.socket.isOpen)
+        .ifM(
+          managed.pure[Resource[F, *]],
+          // Already Closed,
+          // The Resource Scopes Aren't doing us anything
+          // if we have max removed from pool we will need to revisit
+          if (managed.isReused) {
+            Resource.eval(managed.canBeReused.set(Reusable.DontReuse)) >>
+              getValidManaged(pool, request)
+          } else
+            Resource.eval(Sync[F].raiseError(
+              new java.net.SocketException("Fresh connection from pool was not open")))
+        )
+    }
 }
diff --git a/ember-client/src/test/scala/org/http4s/ember/client/internal/ClientHelpersSpec.scala b/ember-client/src/test/scala/org/http4s/ember/client/internal/ClientHelpersSpec.scala
index 34bbfe93e5f..aed1d97ec91 100644
--- a/ember-client/src/test/scala/org/http4s/ember/client/internal/ClientHelpersSpec.scala
+++ b/ember-client/src/test/scala/org/http4s/ember/client/internal/ClientHelpersSpec.scala
@@ -101,18 +101,17 @@ class ClientHelpersSpec extends Http4sSpec with CatsEffect {
       for {
         reuse <- Ref[IO].of(Reusable.DontReuse: Reusable)
 
-        testResult <-
+        resp =
           ClientHelpers
             .postProcessResponse(
               Request[IO](),
               Response[IO](),
               reuse
             )
-            .use { resp =>
-              resp.body.compile.drain >>
-                reuse.get.map { case r =>
-                  r must beEqualTo(Reusable.Reuse)
-                }
+        testResult <-
+          resp.body.compile.drain >>
+            reuse.get.map { case r =>
+              r must beEqualTo(Reusable.Reuse)
             }
       } yield testResult
     }
@@ -121,18 +120,18 @@ class ClientHelpersSpec extends Http4sSpec with CatsEffect {
       for {
         reuse <- Ref[IO].of(Reusable.DontReuse: Reusable)
 
-        testResult <-
+        _ =
           ClientHelpers
             .postProcessResponse(
               Request[IO](),
               Response[IO](),
               reuse
             )
-            .use { _ =>
-              reuse.get.map { case r =>
-                r must beEqualTo(Reusable.DontReuse)
-              }
-            }
+
+        testResult <-
+          reuse.get.map { case r =>
+            r must beEqualTo(Reusable.DontReuse)
+          }
       } yield testResult
     }
 
@@ -140,18 +139,17 @@ class ClientHelpersSpec extends Http4sSpec with CatsEffect {
       for {
         reuse <- Ref[IO].of(Reusable.DontReuse: Reusable)
 
-        testResult <-
+        resp =
           ClientHelpers
             .postProcessResponse(
               Request[IO](),
               Response[IO](body = fs2.Stream.raiseError[IO](new Throwable("Boo!"))),
               reuse
             )
-            .use { resp =>
-              resp.body.compile.drain.attempt >>
-                reuse.get.map { case r =>
-                  r must beEqualTo(Reusable.DontReuse)
-                }
+        testResult <-
+          resp.body.compile.drain.attempt >>
+            reuse.get.map { case r =>
+              r must beEqualTo(Reusable.DontReuse)
             }
       } yield testResult
     }
@@ -186,18 +184,17 @@ class ClientHelpersSpec extends Http4sSpec with CatsEffect {
       for {
         reuse <- Ref[IO].of(Reusable.DontReuse: Reusable)
 
-        testResult <-
+        resp =
           ClientHelpers
             .postProcessResponse(
               Request[IO](headers = Headers.of(Connection(NonEmptyList.of(CIString("close"))))),
               Response[IO](),
               reuse
             )
-            .use { resp =>
-              resp.body.compile.drain >>
-                reuse.get.map { case r =>
-                  r must beEqualTo(Reusable.DontReuse)
-                }
+        testResult <-
+          resp.body.compile.drain >>
+            reuse.get.map { case r =>
+              r must beEqualTo(Reusable.DontReuse)
             }
       } yield testResult
     }
@@ -206,18 +203,17 @@ class ClientHelpersSpec extends Http4sSpec with CatsEffect {
       for {
         reuse <- Ref[IO].of(Reusable.DontReuse: Reusable)
 
-        testResult <-
+        resp =
           ClientHelpers
             .postProcessResponse(
               Request[IO](),
               Response[IO](headers = Headers.of(Connection(NonEmptyList.of(CIString("close"))))),
               reuse
             )
-            .use { resp =>
-              resp.body.compile.drain >>
-                reuse.get.map { case r =>
-                  r must beEqualTo(Reusable.DontReuse)
-                }
+        testResult <-
+          resp.body.compile.drain >>
+            reuse.get.map { case r =>
+              r must beEqualTo(Reusable.DontReuse)
             }
       } yield testResult
     }
diff --git a/ember-core/src/main/scala/org/http4s/ember/core/Encoder.scala b/ember-core/src/main/scala/org/http4s/ember/core/Encoder.scala
index 1838c39b7c1..41a1930dfbb 100644
--- a/ember-core/src/main/scala/org/http4s/ember/core/Encoder.scala
+++ b/ember-core/src/main/scala/org/http4s/ember/core/Encoder.scala
@@ -29,6 +29,7 @@ private[ember] object Encoder {
 
   def respToBytes[F[_]](resp: Response[F], writeBufferSize: Int = 32 * 1024): Stream[F, Byte] = {
     var chunked = resp.isChunked
+    // resp.status.isEntityAllowed TODO
     val initSection = {
       var appliedContentLength = false
       val stringBuilder = new StringBuilder()
@@ -68,6 +69,9 @@ private[ember] object Encoder {
         .flatMap(Stream.chunk)
   }
 
+  private val NoPayloadMethods: Set[Method] =
+    Set(Method.GET, Method.DELETE, Method.CONNECT, Method.TRACE)
+
   def reqToBytes[F[_]](req: Request[F], writeBufferSize: Int = 32 * 1024): Stream[F, Byte] = {
     var chunked = req.isChunked
     val initSection = {
@@ -103,7 +107,7 @@ private[ember] object Encoder {
         ()
       }
 
-      if (!chunked && !appliedContentLength) {
+      if (!chunked && !appliedContentLength && !NoPayloadMethods.contains(req.method)) {
         stringBuilder.append(chunkedTansferEncodingHeaderRaw).append(CRLF)
         chunked = true
         ()
diff --git a/ember-core/src/main/scala/org/http4s/ember/core/Parser.scala b/ember-core/src/main/scala/org/http4s/ember/core/Parser.scala
index 874a8a9a193..f3930d1c710 100644
--- a/ember-core/src/main/scala/org/http4s/ember/core/Parser.scala
+++ b/ember-core/src/main/scala/org/http4s/ember/core/Parser.scala
@@ -24,6 +24,7 @@ import fs2._
 import org.http4s._
 import scala.annotation.switch
 import scala.collection.mutable
+import scala.concurrent.duration.FiniteDuration
 
 private[ember] object Parser {
 
@@ -192,6 +193,8 @@ private[ember] object Parser {
 
     object ReqPrelude {
 
+      val emptyStreamError = ParsePreludeError("Cannot Parse Empty Stream", None, None, None, None)
+
       def parsePrelude[F[_]: MonadThrow](
           s: Stream[F, Byte],
           maxHeaderLength: Int,
@@ -205,26 +208,34 @@ private[ember] object Parser {
             }
             ReqPrelude.preludeInSection(next) match {
               case ParsePreludeComplete(m, u, h, rest) =>
-                Pull.pure((m, u, h, Stream.chunk(Chunk.array(rest)) ++ tl))
-              case t @ ParsePreludeError(_, _, _, _) => Pull.raiseError[F](t)
+                val out = if (rest.isEmpty) tl else Stream.chunk(Chunk.array(rest)) ++ tl
+                Pull.pure((m, u, h, out))
+              case t @ ParsePreludeError(_, _, _, _, _) => Pull.raiseError[F](t)
               case p @ ParsePreludeIncomlete(_, _, method, uri, httpVersion) =>
                 if (next.size <= maxHeaderLength)
                   parsePrelude(tl, maxHeaderLength, p.some)
                 else
                   Pull.raiseError[F](
                     ParsePreludeError(
-                      new Throwable("Reached Max Header Length Looking for Request Prelude"),
+                      "Reached Max Header Length Looking for Request Prelude",
+                      None,
                       method,
                       uri,
                       httpVersion))
             }
           case None =>
-            Pull.raiseError[F](
-              ParsePreludeError(
-                new Throwable("Reached Ended of Stream Looking for Request Prelude"),
-                acc.flatMap(_.method),
-                acc.flatMap(_.uri),
-                acc.flatMap(_.httpVersion)))
+            acc match {
+              case None => Pull.raiseError(emptyStreamError)
+              case Some(incomplete) if incomplete.bv.isEmpty => Pull.raiseError(emptyStreamError)
+              case Some(incomplete) =>
+                Pull.raiseError(
+                  ParsePreludeError(
+                    s"Unexpected EOF - $incomplete",
+                    None,
+                    incomplete.method,
+                    incomplete.uri,
+                    incomplete.httpVersion))
+            }
         }
 
       // sealed trait ParsePreludeState
@@ -236,14 +247,16 @@ private[ember] object Parser {
       private val lf: Byte = '\n'.toByte
 
       sealed trait ParsePreludeResult
-      final case class ParsePreludeError(
-          throwable: Throwable,
+      case class ParsePreludeError(
+          message: String,
+          caused: Option[Throwable],
           method: Option[Method],
           uri: Option[Uri],
           httpVersion: Option[HttpVersion]
-      ) extends Throwable(
-            s"Parse Prelude Error Encountered - Partially Decoded: $method $uri $httpVersion",
-            throwable)
+      ) extends Exception(
+            s"Parse Prelude Error Encountered - Message: $message - Partially Decoded: $method $uri $httpVersion",
+            caused.orNull
+          )
           with ParsePreludeResult
       final case class ParsePreludeIncomlete(
           idx: Int,
@@ -322,7 +335,8 @@ private[ember] object Parser {
 
         if (throwable != null)
           ParsePreludeError(
-            throwable,
+            throwable.getMessage(),
+            Option(throwable),
             Option(method),
             Option(uri),
             Option(httpVersion)
@@ -334,9 +348,10 @@ private[ember] object Parser {
       }
     }
 
-    def parser[F[_]: Concurrent](maxHeaderLength: Int)(s: Stream[F, Byte]): F[Request[F]] =
+    def parser[F[_]: Concurrent: Temporal](maxHeaderLength: Int, timeout: Option[FiniteDuration])(
+        s: Stream[F, Byte]): F[(Request[F], Stream[F, Byte])] =
       Deferred[F, Headers].flatMap { trailers =>
-        ReqPrelude
+        val baseStream = ReqPrelude
           .parsePrelude[F](s, maxHeaderLength, None)
           .flatMap { case (method, uri, httpVersion, rest) =>
             HeaderP.parseHeaders(rest, maxHeaderLength, None).flatMap {
@@ -356,22 +371,25 @@ private[ember] object Parser {
                   else
                     baseReq.withBodyStream(rest.take(contentLength.getOrElse(0L)))
 
-                Pull.output1(req)
+                Pull.output1((req, rest))
             }
           }
           .stream
           .take(1)
-          .compile
-          .lastOrError
-      }
 
+        val action = baseStream.compile.lastOrError
+        timeout match {
+          case None => action
+          case Some(timeout) => Temporal[F].timeout(action, timeout)
+        }
+      }
   }
 
   object Response {
-    def parser[F[_]: Concurrent](maxHeaderLength: Int)(
-        s: Stream[F, Byte]): Resource[F, Response[F]] =
-      Resource.eval(Deferred[F, Headers]).flatMap { trailers =>
-        RespPrelude
+    def parser[F[_]: Concurrent: Temporal](maxHeaderLength: Int, timeout: Option[FiniteDuration])(
+        s: Stream[F, Byte]): F[(Response[F], Stream[F, Byte])] =
+      Deferred[F, Headers].flatMap { trailers =>
+        val base = RespPrelude
           .parsePrelude(s, maxHeaderLength, None)
           .flatMap { case (httpVersion, status, s) =>
             HeaderP.parseHeaders(s, maxHeaderLength, None).flatMap {
@@ -389,18 +407,20 @@ private[ember] object Parser {
                         rest.through(ChunkedEncoding.decode(maxHeaderLength, trailers)))
                   else
                     baseResp.withBodyStream(rest.take(contentLength.getOrElse(0L)))
-                Pull.output1(resp)
+                Pull.output1((resp, rest))
             }
           }
           .stream
           .take(1)
-          .compile
-          .resource
-          .lastOrError
+
+        val action = base.compile.lastOrError
+        timeout.fold(action)(duration => Temporal[F].timeout(action, duration))
       }
 
     object RespPrelude {
 
+      val emptyStreamError = RespPreludeError("Cannot Parse Empty Stream", None)
+
       def parsePrelude[F[_]: MonadThrow](
           s: Stream[F, Byte],
           maxHeaderLength: Int,
@@ -415,19 +435,28 @@ private[ember] object Parser {
             preludeInSection(next) match {
               case RespPreludeComplete(httpVersion, status, rest) =>
                 Pull.pure((httpVersion, status, Stream.chunk(Chunk.array(rest)) ++ tl))
-              case t @ RespPreludeError(_) => Pull.raiseError[F](t)
+              case t @ RespPreludeError(_, _) => Pull.raiseError[F](t)
               case RespPreludeIncomplete =>
                 if (next.size <= maxHeaderLength)
                   parsePrelude(tl, maxHeaderLength, next.some)
                 else
                   Pull.raiseError[F](
                     RespPreludeError(
-                      new Throwable("Reached Max Header Length Looking for Response Prelude")))
+                      "Reached Max Header Length Looking for Response Prelude",
+                      None))
             }
           case None =>
-            Pull.raiseError[F](
-              RespPreludeError(
-                new Throwable("Reached Ended of Stream Looking for Response Prelude")))
+            acc match {
+              case None => Pull.raiseError(emptyStreamError)
+              case Some(incomplete) if incomplete.isEmpty => Pull.raiseError(emptyStreamError)
+              case Some(_) =>
+                Pull.raiseError[F](
+                  RespPreludeError(
+                    "Unexpectedly Reached Ended of Stream Looking for Response Prelude",
+                    None)
+                )
+            }
+
         }
 
       private val space = ' '.toByte
@@ -438,8 +467,10 @@ private[ember] object Parser {
       case class RespPreludeComplete(httpVersion: HttpVersion, status: Status, rest: Array[Byte])
           extends RespPreludeResult
       case object RespPreludeIncomplete extends RespPreludeResult
-      case class RespPreludeError(cause: Throwable)
-          extends Throwable(s"Received Error while parsing prelude - ${cause.getMessage}", cause)
+      case class RespPreludeError(message: String, cause: Option[Throwable])
+          extends Throwable(
+            s"Received Error while parsing prelude - Message: $message - ${cause.map(_.getMessage)}",
+            cause.orNull)
           with RespPreludeResult
 
       // HTTP/1.1 200 OK
@@ -501,7 +532,7 @@ private[ember] object Parser {
           idx += 1
         }
 
-        if (throwable != null) RespPreludeError(throwable)
+        if (throwable != null) RespPreludeError("Encounterd Error parsing", Option(throwable))
         if (httpVersion != null && status != null)
           RespPreludeComplete(httpVersion, status, bv.drop(idx))
         else RespPreludeIncomplete
diff --git a/ember-core/src/main/scala/org/http4s/ember/core/Util.scala b/ember-core/src/main/scala/org/http4s/ember/core/Util.scala
index 2fde4659fc8..879727082d3 100644
--- a/ember-core/src/main/scala/org/http4s/ember/core/Util.scala
+++ b/ember-core/src/main/scala/org/http4s/ember/core/Util.scala
@@ -79,4 +79,10 @@ private[ember] object Util {
         )
     go(timeout)
   }
+
+  def durationToFinite(duration: Duration): Option[FiniteDuration] = duration match {
+    case f: FiniteDuration => Some(f)
+    case _ => None
+  }
+
 }
diff --git a/ember-core/src/test/scala/org/http4s/ember/core/EncoderSuite.scala b/ember-core/src/test/scala/org/http4s/ember/core/EncoderSuite.scala
index 74f0fc899db..3ee946c71cf 100644
--- a/ember-core/src/test/scala/org/http4s/ember/core/EncoderSuite.scala
+++ b/ember-core/src/test/scala/org/http4s/ember/core/EncoderSuite.scala
@@ -19,6 +19,7 @@ package ember.core
 
 import cats.syntax.all._
 import cats.effect.{IO, Sync}
+import org.http4s.headers.`Content-Length`
 
 class EncoderSuite extends Http4sSuite {
   private object Helpers {
@@ -48,9 +49,6 @@ class EncoderSuite extends Http4sSuite {
     val expected =
       """GET / HTTP/1.1
       |Host: www.google.com
-      |Transfer-Encoding: chunked
-      |
-      |0
       |
       |""".stripMargin
 
@@ -81,9 +79,6 @@ class EncoderSuite extends Http4sSuite {
       """GET / HTTP/1.1
         |Host: www.google.com
         |foo: bar
-        |Transfer-Encoding: chunked
-        |
-        |0
         |
         |""".stripMargin
     Helpers.encodeRequestRig(req).assertEquals(expected)
@@ -97,9 +92,6 @@ class EncoderSuite extends Http4sSuite {
     val expected =
       """GET /path?query HTTP/1.1
         |Host: www.example.com
-        |Transfer-Encoding: chunked
-        |
-        |0
         |
         |""".stripMargin
     Helpers.encodeRequestRig(req).assertEquals(expected)
@@ -114,22 +106,17 @@ class EncoderSuite extends Http4sSuite {
     val expected =
       """GET / HTTP/1.1
         |Host: example.org:8080
-        |Transfer-Encoding: chunked
-        |
-        |0
         |
         |""".stripMargin
     Helpers.encodeRequestRig(req).assertEquals(expected)
   }
 
   test("respToBytes should encode a no body response correctly") {
-    val resp = Response[IO](Status.Ok)
+    val resp = Response[IO](Status.Ok).putHeaders(`Content-Length`.zero)
 
     val expected =
       """HTTP/1.1 200 OK
-      |Transfer-Encoding: chunked
-      |
-      |0
+      |Content-Length: 0
       |
       |""".stripMargin
 
diff --git a/ember-core/src/test/scala/org/http4s/ember/core/ParsingSpec.scala b/ember-core/src/test/scala/org/http4s/ember/core/ParsingSpec.scala
index e2d1a54ac4a..fe81d976b71 100644
--- a/ember-core/src/test/scala/org/http4s/ember/core/ParsingSpec.scala
+++ b/ember-core/src/test/scala/org/http4s/ember/core/ParsingSpec.scala
@@ -35,24 +35,25 @@ class ParsingSpec extends Specification {
     def httpifyString(s: String): String = s.replace("\n", "\r\n")
 
     // Only for Use with Text Requests
-    def parseRequestRig[F[_]: Concurrent](s: String): F[Request[F]] = {
+    def parseRequestRig[F[_]: Concurrent: Temporal](s: String): F[Request[F]] = {
       val byteStream: Stream[F, Byte] = Stream
         .emit(s)
         .covary[F]
         .map(httpifyString)
         .through(fs2.text.utf8Encode[F])
 
-      Parser.Request.parser[F](Int.MaxValue)(byteStream)
+      Parser.Request.parser[F](Int.MaxValue, None)(byteStream).map(_._1)
     }
 
-    def parseResponseRig[F[_]: Concurrent](s: String): Resource[F, Response[F]] = {
+    def parseResponseRig[F[_]: Concurrent: Temporal](s: String): Resource[F, Response[F]] = {
       val byteStream: Stream[F, Byte] = Stream
         .emit(s)
         .covary[F]
         .map(httpifyString)
         .through(fs2.text.utf8Encode[F])
 
-      Parser.Response.parser[F](Int.MaxValue)(byteStream)
+      val action = Parser.Response.parser[F](Int.MaxValue, None)(byteStream).map(_._1) //(logger)
+      Resource.liftF(action)
     }
 
     def forceScopedParsing[F[_]: Concurrent](s: String): Stream[F, Byte] = {
@@ -153,19 +154,29 @@ class ParsingSpec extends Specification {
 
     "handle a response that requires multiple chunks to be read" in {
       val defaultMaxHeaderLength = 4096
-      val raw =
+      val raw1 =
         """HTTP/1.1 200 OK
           |Content-type: application/json
           |Content-Length: 2
           |
-          |{}
+          |{""".stripMargin
+
+      val raw2 = """}
           |""".stripMargin
+      val http1 = Helpers.httpifyString(raw1)
+
+      val http2 = Helpers.httpifyString(raw2)
+      val encoded = (Stream(http1) ++ Stream(http2)).through(fs2.text.utf8Encode)
 
       (for {
         parsed <-
           Parser.Response
-            .parser[IO](defaultMaxHeaderLength)(Helpers.forceScopedParsing[IO](raw))
-            .use { resp =>
+            .parser[IO](defaultMaxHeaderLength, None)(
+              encoded
+              //Helpers.forceScopedParsing[IO](raw) // Cuts off `}` in current test. Why?
+              // I don't follow what the rig is testing vs this.
+            ) //(logger)
+            .flatMap { case (resp, _) =>
               resp.body.through(text.utf8Decode).compile.string
             }
       } yield parsed must_== "{}").unsafeRunSync()
@@ -181,8 +192,8 @@ class ParsingSpec extends Specification {
       val baseBv = ByteVector.fromBase64(base).get
 
       Parser.Response
-        .parser[IO](defaultMaxHeaderLength)(Stream.chunk(Chunk.byteVector(baseBv)))
-        .use { resp =>
+        .parser[IO](defaultMaxHeaderLength, None)(Stream.chunk(Chunk.byteVector(baseBv)))
+        .flatMap { case (resp, _) =>
           resp.body.through(text.utf8Decode).compile.string
 
         }
@@ -216,8 +227,8 @@ class ParsingSpec extends Specification {
           Stream.chunk(Chunk.array(s.getBytes(java.nio.charset.StandardCharsets.ISO_8859_1))))
 
       Parser.Response
-        .parser[IO](defaultMaxHeaderLength)(byteStream)
-        .use { resp =>
+        .parser[IO](defaultMaxHeaderLength, None)(byteStream)
+        .flatMap { case (resp, _) =>
           resp.body.through(text.utf8Decode).compile.string.map { body =>
             body must beEqualTo("MozillaDeveloperNetwork")
           }
@@ -248,8 +259,8 @@ class ParsingSpec extends Specification {
           Stream.chunk(Chunk.array(s.getBytes(java.nio.charset.StandardCharsets.US_ASCII))))
 
       Parser.Response
-        .parser[IO](defaultMaxHeaderLength)(byteStream)
-        .use { resp =>
+        .parser[IO](defaultMaxHeaderLength, None)(byteStream)
+        .flatMap { case (resp, _) =>
           for {
             body <- resp.body.through(text.utf8Decode).compile.string
             trailers <- resp.trailerHeaders
diff --git a/ember-server/src/main/scala/org/http4s/ember/server/EmberServerBuilder.scala b/ember-server/src/main/scala/org/http4s/ember/server/EmberServerBuilder.scala
index 0a8e9307b89..0104e334400 100644
--- a/ember-server/src/main/scala/org/http4s/ember/server/EmberServerBuilder.scala
+++ b/ember-server/src/main/scala/org/http4s/ember/server/EmberServerBuilder.scala
@@ -148,6 +148,7 @@ final class EmberServerBuilder[F[_]: Async] private (
       )
       _ <- Resource.make(Applicative[F].unit)(_ => shutdown.await)
       _ <- Resource.eval(ready.get.rethrow)
+      _ <- Resource.eval(logger.info(s"Ember-Server service bound to address: $bindAddress"))
     } yield new Server {
       def address: InetSocketAddress = bindAddress
       def isSecure: Boolean = tlsInfoOpt.isDefined
@@ -197,7 +198,7 @@ object EmberServerBuilder {
         : (Option[Request[F]], Response[F], Throwable) => F[Unit] = {
       case _: (Option[Request[F]], Response[F], Throwable) => Applicative[F].unit
     }
-    val maxConcurrency: Int = Int.MaxValue
+    val maxConcurrency: Int = server.defaults.MaxConnections
     val receiveBufferSize: Int = 256 * 1024
     val maxHeaderSize: Int = server.defaults.MaxHeadersSize
     val requestHeaderReceiveTimeout: Duration = 5.seconds
diff --git a/ember-server/src/main/scala/org/http4s/ember/server/internal/ServerHelpers.scala b/ember-server/src/main/scala/org/http4s/ember/server/internal/ServerHelpers.scala
index 88818d765a6..9d21371c6fe 100644
--- a/ember-server/src/main/scala/org/http4s/ember/server/internal/ServerHelpers.scala
+++ b/ember-server/src/main/scala/org/http4s/ember/server/internal/ServerHelpers.scala
@@ -16,8 +16,8 @@
 
 package org.http4s.ember.server.internal
 
+import cats._
 import fs2._
-import fs2.concurrent._
 import fs2.io.tcp._
 import fs2.io.tls._
 import fs2.io.Network
@@ -29,10 +29,9 @@ import org.http4s._
 import org.http4s.headers.{Connection, Date}
 import org.typelevel.ci.CIString
 import _root_.org.http4s.ember.core.{Encoder, Parser}
-import _root_.org.http4s.ember.core.Util.readWithTimeout
 import _root_.org.typelevel.log4cats.Logger
 import cats.data.NonEmptyList
-
+import _root_.org.http4s.ember.core.Util.durationToFinite
 private[server] object ServerHelpers {
 
   private val closeCi = CIString("close")
@@ -54,116 +53,14 @@ private[server] object ServerHelpers {
       // Defaults
       errorHandler: Throwable => F[Response[F]],
       onWriteFailure: (Option[Request[F]], Response[F], Throwable) => F[Unit],
-      maxConcurrency: Int = Int.MaxValue,
-      receiveBufferSize: Int = 256 * 1024,
-      maxHeaderSize: Int = 10 * 1024,
-      requestHeaderReceiveTimeout: Duration = 5.seconds,
-      idleTimeout: Duration = 60.seconds,
+      maxConcurrency: Int,
+      receiveBufferSize: Int,
+      maxHeaderSize: Int,
+      requestHeaderReceiveTimeout: Duration,
+      idleTimeout: Duration,
       additionalSocketOptions: List[SocketOptionMapping[_]] = List.empty,
       logger: Logger[F]
   )(implicit F: Temporal[F], N: Network[F]): Stream[F, Nothing] = {
-    def socketReadRequest(
-        socket: Socket[F],
-        requestHeaderReceiveTimeout: Duration,
-        receiveBufferSize: Int,
-        isReused: Boolean
-    ): F[Request[F]] = {
-      val (initial, readDuration) = (requestHeaderReceiveTimeout, idleTimeout, isReused) match {
-        case (fin: FiniteDuration, idle: FiniteDuration, true) => (true, idle + fin)
-        case (fin: FiniteDuration, _, false) => (true, fin)
-        case _ => (false, Duration.Zero)
-      }
-
-      SignallingRef[F, Boolean](initial).flatMap { timeoutSignal =>
-        F.realTime
-          .flatMap(now =>
-            Parser.Request
-              .parser(maxHeaderSize)(
-                readWithTimeout[F](
-                  socket,
-                  now.toMillis,
-                  readDuration,
-                  timeoutSignal.get,
-                  receiveBufferSize)
-              )
-              .flatMap { req =>
-                timeoutSignal.set(false).as(req)
-              })
-      }
-    }
-
-    def upgradeSocket(
-        socketInit: Socket[F],
-        tlsInfoOpt: Option[(TLSContext, TLSParameters)]): Resource[F, Socket[F]] =
-      tlsInfoOpt.fold(socketInit.pure[Resource[F, *]]) { case (context, params) =>
-        context
-          .server(socketInit, params, { (s: String) => logger.trace(s) }.some)
-          .widen[Socket[F]]
-      }
-
-    def runApp(socket: Socket[F], isReused: Boolean): F[(Request[F], Response[F])] =
-      for {
-        req <- socketReadRequest(socket, requestHeaderReceiveTimeout, receiveBufferSize, isReused)
-        resp <- httpApp
-          .run(req)
-          .handleErrorWith(errorHandler)
-          .handleError(_ => serverFailure.covary[F])
-      } yield (req, resp)
-
-    def send(socket: Socket[F])(request: Option[Request[F]], resp: Response[F]): F[Unit] =
-      Encoder
-        .respToBytes[F](resp)
-        .through(socket.writes())
-        .compile
-        .drain
-        .attempt
-        .flatMap {
-          case Left(err) => onWriteFailure(request, resp, err)
-          case Right(()) => F.unit
-        }
-
-    def postProcessResponse(req: Request[F], resp: Response[F]): F[Response[F]] = {
-      val reqHasClose = req.headers.exists {
-        // We know this is raw because we have not parsed any headers in the underlying alg.
-        // If Headers are being parsed into processed for in ParseHeaders this is incorrect.
-        case Header.Raw(name, values) => name == connectionCi && values.contains(closeCi.toString)
-        case _ => false
-      }
-      val connection: Connection =
-        if (reqHasClose) close
-        else keepAlive
-      for {
-        date <- HttpDate.current[F].map(Date(_))
-      } yield resp.withHeaders(Headers.of(date, connection) ++ resp.headers)
-    }
-
-    def withUpgradedSocket(socket: Socket[F]): Stream[F, Nothing] =
-      (Stream(false) ++ Stream(true).repeat)
-        .flatMap { isReused =>
-          Stream
-            .eval(runApp(socket, isReused).attempt)
-            .evalMap {
-              case Right((req, resp)) =>
-                postProcessResponse(req, resp).map(resp => (req, resp).asRight[Throwable])
-              case other => other.pure[F]
-            }
-            .evalTap {
-              case Right((request, response)) => send(socket)(Some(request), response)
-              case Left(err) =>
-                errorHandler(err)
-                  .handleError(_ => serverFailure.covary[F])
-                  .flatMap(send(socket)(None, _))
-            }
-        }
-        .takeWhile {
-          case Left(_) => false
-          case Right((req, resp)) =>
-            !(
-              req.headers.get(Connection).exists(_.hasClose) ||
-                resp.headers.get(Connection).exists(_.hasClose)
-            )
-        }
-        .drain
 
     val server: Stream[F, Resource[F, Socket[F]]] =
       Stream
@@ -179,10 +76,139 @@ private[server] object ServerHelpers {
       .map { connect =>
         shutdown.trackConnection >>
           Stream
-            .resource(connect.flatMap(upgradeSocket(_, tlsInfoOpt)))
-            .flatMap(withUpgradedSocket(_))
+            .resource(connect.flatMap(upgradeSocket(_, tlsInfoOpt, logger)))
+            .flatMap(
+              runConnection(
+                _,
+                logger,
+                idleTimeout,
+                receiveBufferSize,
+                maxHeaderSize,
+                requestHeaderReceiveTimeout,
+                httpApp,
+                errorHandler,
+                onWriteFailure))
       }
 
     StreamForking.forking(streams, maxConcurrency)
   }
+
+  // private[internal] def reachedEndError[F[_]: Sync](
+  //     socket: Socket[F],
+  //     idleTimeout: Duration,
+  //     receiveBufferSize: Int): Stream[F, Byte] =
+  //   Stream.repeatEval(socket.read(receiveBufferSize, durationToFinite(idleTimeout))).flatMap {
+  //     case None =>
+  //       Stream.raiseError(new EOFException("Unexpected EOF - socket.read returned None") with NoStackTrace)
+  //     case Some(value) => Stream.chunk(value)
+  //   }
+
+  private[internal] def upgradeSocket[F[_]: Concurrent: Network](
+      socketInit: Socket[F],
+      tlsInfoOpt: Option[(TLSContext, TLSParameters)],
+      logger: Logger[F]
+  ): Resource[F, Socket[F]] =
+    tlsInfoOpt.fold(socketInit.pure[Resource[F, *]]) { case (context, params) =>
+      context
+        .server(socketInit, params, { (s: String) => logger.trace(s) }.some)
+        .widen[Socket[F]]
+    }
+
+  private[internal] def runApp[F[_]: Concurrent: Temporal](
+      incoming: Stream[F, Byte],
+      maxHeaderSize: Int,
+      requestHeaderReceiveTimeout: Duration,
+      httpApp: HttpApp[F],
+      errorHandler: Throwable => F[Response[F]]): F[(Request[F], Response[F], Stream[F, Byte])] =
+    for {
+      tup <- Parser.Request.parser(maxHeaderSize, durationToFinite(requestHeaderReceiveTimeout))(
+        incoming)
+      (req, rest) = tup
+      resp <- httpApp
+        .run(req)
+        .handleErrorWith(errorHandler)
+        .handleError(_ => serverFailure.covary[F])
+    } yield (req, resp, rest)
+
+  private[internal] def send[F[_]: Concurrent](socket: Socket[F])(
+      request: Option[Request[F]],
+      resp: Response[F],
+      idleTimeout: Duration,
+      onWriteFailure: (Option[Request[F]], Response[F], Throwable) => F[Unit]): F[Unit] =
+    Encoder
+      .respToBytes[F](resp)
+      .through(socket.writes(durationToFinite(idleTimeout)))
+      .compile
+      .drain
+      .attempt
+      .flatMap {
+        case Left(err) => onWriteFailure(request, resp, err)
+        case Right(()) => Applicative[F].unit
+      }
+
+  private[internal] def postProcessResponse[F[_]: Temporal: Monad](
+      req: Request[F],
+      resp: Response[F]): F[Response[F]] = {
+    val reqHasClose = req.headers.exists {
+      // We know this is raw because we have not parsed any headers in the underlying alg.
+      // If Headers are being parsed into processed for in ParseHeaders this is incorrect.
+      case Header.Raw(name, values) => name == connectionCi && values.contains(closeCi.toString)
+      case _ => false
+    }
+    val connection: Connection =
+      if (reqHasClose) close
+      else keepAlive
+    for {
+      date <- HttpDate.current[F].map(Date(_))
+    } yield resp.withHeaders(Headers.of(date, connection) ++ resp.headers)
+  }
+
+  private[internal] def runConnection[F[_]: Concurrent: Temporal](
+      socket: Socket[F],
+      logger: Logger[F],
+      idleTimeout: Duration,
+      receiveBufferSize: Int,
+      maxHeaderSize: Int,
+      requestHeaderReceiveTimeout: Duration,
+      httpApp: HttpApp[F],
+      errorHandler: Throwable => F[org.http4s.Response[F]],
+      onWriteFailure: (Option[Request[F]], Response[F], Throwable) => F[Unit]
+  ): Stream[F, Nothing] = {
+    val _ = logger
+    Stream
+      .unfoldLoopEval(socket.reads(receiveBufferSize, durationToFinite(idleTimeout)))(s =>
+        runApp(s, maxHeaderSize, requestHeaderReceiveTimeout, httpApp, errorHandler).attempt.map {
+          case Right((req, resp, rest)) => (Right((req, resp)), Some(rest))
+          case Left(e) => (Left(e), None)
+        })
+      .evalMap {
+        case Right((req, resp)) =>
+          postProcessResponse(req, resp).map(resp => (req, resp).asRight[Throwable])
+        case other => other.pure[F]
+      }
+      .evalTap {
+        case Right((request, response)) =>
+          send(socket)(Some(request), response, idleTimeout, onWriteFailure)
+        case Left(err) =>
+          err match {
+            case req: Parser.Request.ReqPrelude.ParsePreludeError
+                if req == Parser.Request.ReqPrelude.emptyStreamError =>
+              Applicative[F].unit
+            case err =>
+              errorHandler(err)
+                .handleError(_ => serverFailure.covary[F])
+                .flatMap(send(socket)(None, _, idleTimeout, onWriteFailure))
+          }
+      }
+      .takeWhile {
+        case Left(_) => false
+        case Right((req, resp)) =>
+          !(
+            req.headers.get(Connection).exists(_.hasClose) ||
+              resp.headers.get(Connection).exists(_.hasClose)
+          )
+      }
+      .drain ++ Stream.eval(socket.close).drain
+  }
+
 }
diff --git a/project/Http4sPlugin.scala b/project/Http4sPlugin.scala
index 57be9a8a30a..425968c59d9 100644
--- a/project/Http4sPlugin.scala
+++ b/project/Http4sPlugin.scala
@@ -23,8 +23,8 @@ object Http4sPlugin extends AutoPlugin {
 
   override def requires = Http4sOrgPlugin
 
-  val scala_213 = "2.13.3"
-  val scala_212 = "2.12.12"
+  val scala_213 = "2.13.4"
+  val scala_212 = "2.12.13"
 
   override lazy val globalSettings = Seq(
     isCi := sys.env.get("CI").isDefined
@@ -78,8 +78,6 @@ object Http4sPlugin extends AutoPlugin {
     // Incompatible with latest circe: https://github.com/circe/circe/pull/1591
     dependencyUpdatesFilter -= moduleFilter(name = "jawn*", revision = "1.0.2"),
     dependencyUpdatesFilter -= moduleFilter(name = "jawn*", revision = "1.0.3"),
-    // https://github.com/scalacenter/scalafix/issues/1299
-    dependencyUpdatesFilter -= moduleFilter(name = "scalafix-core", revision = "0.9.24"),
 
     excludeFilter.in(headerSources) := HiddenFileFilter ||
       new FileFilter {
@@ -286,7 +284,7 @@ object Http4sPlugin extends AutoPlugin {
     // error-prone merge conflicts in the dependencies below.
     val argonaut = "6.3.3"
     val asyncHttpClient = "2.12.2"
-    val blaze = "0.14.14"
+    val blaze = "0.14.15"
     val boopickle = "1.3.3"
     val caseInsensitive = "1.0.0-RC2"
     val cats = "2.3.1"
@@ -315,7 +313,7 @@ object Http4sPlugin extends AutoPlugin {
     val netty = "4.1.58.Final"
     val okio = "2.10.0"
     val okhttp = "4.9.1"
-    val playJson = "2.9.2"
+    val playJson = "2.10.0-RC1"
     val prometheusClient = "0.10.0"
     val reactiveStreams = "1.0.3"
     val quasiquotes = "2.1.0"
diff --git a/project/plugins.sbt b/project/plugins.sbt
index 8bac3b123e7..d17bea0e7f1 100644
--- a/project/plugins.sbt
+++ b/project/plugins.sbt
@@ -3,13 +3,12 @@ libraryDependencies += "ch.qos.logback" % "logback-classic" % "1.2.3"
 // https://github.com/coursier/coursier/issues/450
 classpathTypes += "maven-plugin"
 
-addSbtPlugin("ch.epfl.lamp"               %  "sbt-dotty"                 % "0.5.1")
-addSbtPlugin("ch.epfl.scala"              %  "sbt-scalafix"              % "0.9.23")
+addSbtPlugin("ch.epfl.scala"              %  "sbt-scalafix"              % "0.9.25")
 addSbtPlugin("com.earldouglas"            %  "xsbt-web-plugin"           % "4.2.1")
 addSbtPlugin("com.eed3si9n"               %  "sbt-buildinfo"             % "0.10.0")
 addSbtPlugin("com.eed3si9n"               %  "sbt-unidoc"                % "0.4.3")
 addSbtPlugin("com.github.tkawachi"        %  "sbt-doctest"               % "0.9.9")
-addSbtPlugin("org.http4s"                 %  "sbt-http4s-org"            % "0.7.1")
+addSbtPlugin("org.http4s"                 %  "sbt-http4s-org"            % "0.7.2")
 addSbtPlugin("com.timushev.sbt"           %  "sbt-updates"               % "0.5.1")
 addSbtPlugin("com.typesafe.sbt"           %  "sbt-ghpages"               % "0.6.3")
 addSbtPlugin("com.typesafe.sbt"           %  "sbt-site"                  % "1.4.1")
diff --git a/server/src/main/scala/org/http4s/server/package.scala b/server/src/main/scala/org/http4s/server/package.scala
index 72a63df9db7..2d4b7a37547 100644
--- a/server/src/main/scala/org/http4s/server/package.scala
+++ b/server/src/main/scala/org/http4s/server/package.scala
@@ -51,6 +51,9 @@ package object server {
 
     /** Default max size of all headers. */
     val MaxHeadersSize: Int = 40 * 1024
+
+    /** Default max connections */
+    val MaxConnections: Int = 1024
   }
 
   object ServerRequestKeys {
diff --git a/tests/src/test/scala/org/http4s/parser/UriParserSpec.scala b/tests/src/test/scala/org/http4s/parser/UriParserSpec.scala
index 03b7a570f3c..4f53650cf12 100644
--- a/tests/src/test/scala/org/http4s/parser/UriParserSpec.scala
+++ b/tests/src/test/scala/org/http4s/parser/UriParserSpec.scala
@@ -43,7 +43,7 @@ class UriParserSpec extends Http4sSpec {
       } yield f + "::" + b)
 
       foreach(v) { s =>
-        Ipv6Address.parser.string.parseAll(s) must beRight(s)
+        Uri.Parser.ipv6Address.string.parseAll(s) must beRight(s)
       }
     }
 
diff --git a/website/src/hugo/content/changelog.md b/website/src/hugo/content/changelog.md
index 20aa2c4c237..34d4964be6e 100644
--- a/website/src/hugo/content/changelog.md
+++ b/website/src/hugo/content/changelog.md
@@ -20,7 +20,13 @@ it.
 
 * [#4306](https://github.com/http4s/http4s/pull/4306): Update the copyright notice to 2021.
 
-# v0.22.0-M2
+# v0.22.0-M2 (2021-02-02)
+
+This release fixes a [High Severity vulnerability](https://github.com/http4s/http4s/security/advisories/GHSA-xhv5-w9c5-2r2w) in blaze-server.
+
+## http4s-blaze-server
+
+* [GHSA-xhv5-w9c5-2r2w](https://github.com/http4s/http4s/security/advisories/GHSA-xhv5-w9c5-2r2w): Additionally to the fix in v0.21.17, drops support for NIO2.
 
 ## http4s-core
 
@@ -31,6 +37,7 @@ it.
 ### Breaking changes
 
 * [#4259](https://github.com/http4s/http4s/pull/4259): Regenerate `MimeDb` from the IANA database. This shifts around some constants in a binary incompatible way, but almost nobody will notice.
+* [#4327](https://github.com/http4s/http4s/pull/4237): Shifted the parsers around in `Uri` to prevent deadlocks that appeared since M1.  This should not be visible, but is binary breaking.
 
 ## http4s-prometheus
 
@@ -42,9 +49,26 @@ it.
 
 * jawn-fs2-1.0.1
 * keypool-0.3.0-RC1 (moved to `org.typelevel`)
+* play-json-2.10.0-RC1
 * simpleclient-0.10.0 (Prometheus)
 
-# v0.21.17
+# v0.21.17 (2021-02-02)
+
+This release fixes a [High Severity vulnerability](https://github.com/http4s/http4s/security/advisories/GHSA-xhv5-w9c5-2r2w) in blaze-server.
+
+## http4s-blaze-server
+
+### Security patches
+
+* [GHSA-xhv5-w9c5-2r2w](https://github.com/http4s/http4s/security/advisories/GHSA-xhv5-w9c5-2r2w): blaze-core, a library underlying http4s-blaze-server, accepts connections without bound.  Each connection claims a file handle, a scarce resource, leading to a denial of service vector.
+
+  `BlazeServerBuilder` now has a `maxConnections` property, limiting the number of concurrent connections.  The cap is not applied to the NIO2 socket server, which is now deprecated. 
+
+## http4s-ember-core
+
+### Enhancements
+
+* [#4331](https://github.com/http4s/http4s/pull/4331): Don't render an empty chunked payload if a request has neither a `Content-Length` or `Transfer-Encoding` and the method is one of `GET`, `DELETE`, `CONNECT`, or `TRACE`. It is undefined behavior for those methods to send payloads.
 
 ## http4s-ember-server
 
@@ -57,6 +81,12 @@ it.
 * [#4244](https://github.com/http4s/http4s/pull/4244): Internal refactoring of how the stream of server connections is parallelized and terminated.
 * [#4287](https://github.com/http4s/http4s/pull/4287): Replace `onError: Throwable => Response[F]` with `withErrorHandler: PartialFunction[Thrwable, F[Response[F]]`.  Error handling is invoked earlier, allowing custom responses to parsing and timeout failures.
 
+## http4s-ember-client
+
+### Enhancements
+
+* [#4301](https://github.com/http4s/http4s/pull/4301): Add an `idleConnectionTime` to `EmberClientBuilder`. Discard stale connections from the pool and try to acquire a new one.
+
 ## http4s-servlet
 
 ### Bugfixes
@@ -69,6 +99,7 @@ it.
 
 ## Dependency upgrades
 
+* blaze-0.14.15
 * okhttp-4.9.1
 
 # v1.0.0-M13 (2021-01-25)
