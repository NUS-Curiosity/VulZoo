diff --git a/.gitattributes b/.gitattributes
new file mode 100644
index 00000000..3cbfe7d8
--- /dev/null
+++ b/.gitattributes
@@ -0,0 +1 @@
+dependencies linguist-language=yaml
diff --git a/.github/dependabot.yml b/.github/dependabot.yml
new file mode 100644
index 00000000..a83a73d4
--- /dev/null
+++ b/.github/dependabot.yml
@@ -0,0 +1,10 @@
+version: 2
+updates:
+  - package-ecosystem: "github-actions"
+    directory: "/"
+    schedule:
+      interval: "daily"
+  - package-ecosystem: "composer"
+    directory: "/"
+    schedule:
+      interval: "daily"
diff --git a/.github/workflows/dependencies b/.github/workflows/dependencies
new file mode 100644
index 00000000..333045ab
--- /dev/null
+++ b/.github/workflows/dependencies
@@ -0,0 +1,3 @@
+Variables:
+  branch: auto
+  repo: auto
diff --git a/.github/workflows/mediawiki-tests.yml b/.github/workflows/mediawiki-tests.yml
new file mode 100644
index 00000000..b5278cfb
--- /dev/null
+++ b/.github/workflows/mediawiki-tests.yml
@@ -0,0 +1,433 @@
+name: Quibble and Phan
+
+on:
+  push:
+    branches: [ master ]
+  pull_request:
+    branches: [ master ]
+
+jobs:
+  test:
+    name: "${{ matrix.mw }} | PHP ${{ matrix.php }} (${{ matrix.stage }})"
+
+    strategy:
+      matrix:
+        include:
+          # Latest stable MediaWiki - PHP 7.3 (phan)
+          - mw: 'REL1_36'
+            php: 7.3
+            php-docker: 73
+            experimental: false
+            stage: phan
+
+          # Latest stable MediaWiki - PHP 7.4 (phan)
+          - mw: 'REL1_36'
+            php: 7.4
+            php-docker: 74
+            experimental: false
+            stage: phan
+
+          # Latest MediaWiki release branch - PHP 7.3 (phan)
+          - mw: 'REL1_37'
+            php: 7.3
+            php-docker: 73
+            experimental: true
+            stage: phan
+
+          # Latest MediaWiki release branch - PHP 7.4 (phan)
+          - mw: 'REL1_37'
+            php: 7.4
+            php-docker: 74
+            experimental: true
+            stage: phan
+
+          # Latest MediaWiki master - PHP 7.3 (phan)
+          - mw: 'master'
+            php: 7.3
+            php-docker: 73
+            experimental: true
+            stage: phan
+
+          # Latest MediaWiki master - PHP 7.4 (phan)
+          - mw: 'master'
+            php: 7.4
+            php-docker: 74
+            experimental: true
+            stage: phan
+
+          # Latest stable MediaWiki - PHP 7.3 (coverage)
+          - mw: 'REL1_36'
+            php: 7.3
+            php-docker: 73
+            experimental: false
+            stage: coverage
+
+          # Latest MediaWiki release branch - PHP 7.3 (coverage)
+          - mw: 'REL1_37'
+            php: 7.3
+            php-docker: 73
+            experimental: false
+            stage: coverage
+
+          # Latest MediaWiki master - PHP 7.3 (coverage)
+          - mw: 'master'
+            php: 7.3
+            php-docker: 73
+            experimental: false
+            stage: coverage
+
+          # Latest stable MediaWiki - PHP 7.3 (phpunit-unit)
+          - mw: 'REL1_36'
+            php: 7.3
+            php-docker: 73
+            experimental: false
+            stage: phpunit-unit
+
+          # Latest stable MediaWiki - PHP 7.4 (phpunit-unit)
+          - mw: 'REL1_36'
+            php: 7.4
+            php-docker: 74
+            experimental: false
+            stage: phpunit-unit
+
+          # Latest MediaWiki release branch - PHP 7.3 (phpunit-unit)
+          - mw: 'REL1_37'
+            php: 7.3
+            php-docker: 73
+            experimental: false
+            stage: phpunit-unit
+
+          # Latest MediaWiki release branch - PHP 7.4 (phpunit-unit)
+          - mw: 'REL1_37'
+            php: 7.4
+            php-docker: 74
+            experimental: false
+            stage: phpunit-unit
+
+          # Latest MediaWiki master - PHP 7.3 (phpunit-unit)
+          - mw: 'master'
+            php: 7.3
+            php-docker: 73
+            experimental: false
+            stage: phpunit-unit
+
+          # Latest MediaWiki master - PHP 7.4 (phpunit-unit)
+          - mw: 'master'
+            php: 7.4
+            php-docker: 74
+            experimental: false
+            stage: phpunit-unit
+
+          # Latest stable MediaWiki - PHP 7.3 (phpunit)
+          - mw: 'REL1_36'
+            php: 7.3
+            php-docker: 73
+            experimental: false
+            stage: phpunit
+
+          # Latest stable MediaWiki - PHP 7.4 (phpunit)
+          - mw: 'REL1_36'
+            php: 7.4
+            php-docker: 74
+            experimental: false
+            stage: phpunit
+
+          # Latest MediaWiki release branch - PHP 7.3 (phpunit)
+          - mw: 'REL1_37'
+            php: 7.3
+            php-docker: 73
+            experimental: false
+            stage: phpunit
+
+          # Latest MediaWiki release branch - PHP 7.4 (phpunit)
+          - mw: 'REL1_37'
+            php: 7.4
+            php-docker: 74
+            experimental: false
+            stage: phpunit
+
+          # Latest MediaWiki master - PHP 7.3 (phpunit)
+          - mw: 'master'
+            php: 7.3
+            php-docker: 73
+            experimental: false
+            stage: phpunit
+
+          # Latest MediaWiki master - PHP 7.4 (phpunit)
+          - mw: 'master'
+            php: 7.4
+            php-docker: 74
+            experimental: false
+            stage: phpunit
+
+          # Latest stable MediaWiki - PHP 7.3 (selenium)
+          - mw: 'REL1_36'
+            php: 7.3
+            php-docker: 73
+            experimental: false
+            stage: selenium
+
+          # Latest MediaWiki release branch - PHP 7.3 (selenium)
+          - mw: 'REL1_37'
+            php: 7.3
+            php-docker: 73
+            experimental: false
+            stage: selenium
+
+          # Latest MediaWiki master - PHP 7.3 (selenium)
+          - mw: 'master'
+            php: 7.3
+            php-docker: 73
+            experimental: false
+            stage: selenium
+
+          # Latest stable MediaWiki - PHP 7.3 (qunit)
+          - mw: 'REL1_36'
+            php: 7.3
+            php-docker: 73
+            experimental: false
+            stage: qunit
+
+          # Latest MediaWiki release branch - PHP 7.3 (qunit)
+          - mw: 'REL1_37'
+            php: 7.3
+            php-docker: 73
+            experimental: false
+            stage: qunit
+
+          # Latest MediaWiki master - PHP 7.3 (qunit)
+          - mw: 'master'
+            php: 7.3
+            php-docker: 73
+            experimental: false
+            stage: qunit
+
+          # Latest stable MediaWiki - PHP 7.3 (composer-test)
+          - mw: 'REL1_36'
+            php: 7.3
+            php-docker: 73
+            experimental: false
+            stage: composer-test
+
+    runs-on: ubuntu-latest
+
+    env:
+      DOCKER_REGISTRY: docker-registry.wikimedia.org
+      DOCKER_ORG: releng
+      QUIBBLE_DOCKER_IMAGE: quibble-buster-php${{ matrix.php-docker }}
+      COVERAGE_DOCKER_IMAGE: quibble-buster-php${{ matrix.php-docker }}-coverage
+      PHAN_DOCKER_IMAGE: mediawiki-phan-php${{ matrix.php-docker }}
+
+    steps:
+      - name: Cancel Previous Runs
+        uses: styfle/cancel-workflow-action@0.9.1
+        with:
+          access_token: ${{ github.token }}
+
+      - uses: actions/checkout@v2
+
+      # /home/runner/cache/                               Cache
+      # /home/runner/src/                                 Mediawiki installation
+      # /home/runner/src/extensions/EXTENSION_NAME/       Clone of the extension repository
+      # /home/runner/docker-images/                       Docker images which exported with docker-save command
+      # $GITHUB_WORKSPACE/.github/workflows/dependencies  Necessary dependencies - YAML syntax
+      # $GITHUB_WORKSPACE/.github/workflows/globals.php   Add global configuration options for MediaWiki
+      - name: Set up
+        run: |
+          echo MEDIAWIKI_VERSION="${{ matrix.mw }}" >> $GITHUB_ENV
+
+          if [ "${{ matrix.stage }}" == 'phan' ]; then
+            export DOCKER_IMAGE="${PHAN_DOCKER_IMAGE}"
+          elif [ "${{ matrix.stage }}" == coverage ]; then
+            export DOCKER_IMAGE="${COVERAGE_DOCKER_IMAGE}"
+          else
+            export DOCKER_IMAGE="${QUIBBLE_DOCKER_IMAGE}"
+          fi
+          echo "DOCKER_IMAGE=${DOCKER_IMAGE}" >> $GITHUB_ENV
+
+          # Get the latest docker tag (Ref: https://github.com/thcipriani/dockerregistry)
+          DOCKER_LATEST_TAG="$(curl -sL "https://${DOCKER_REGISTRY}/v2/${DOCKER_ORG}/${DOCKER_IMAGE}/tags/list" |
+            python3 -c 'import json;print("\n".join(json.loads(input())["tags"]))' |
+            grep -v latest | sort -Vr | head -1)"
+          echo "DOCKER_LATEST_TAG=${DOCKER_LATEST_TAG}" >> $GITHUB_ENV
+          if [ "${{ matrix.stage }}" == 'phan' ] || [ "${{ matrix.stage }}" == 'coverage' ]; then
+            echo "QUIBBLE_DOCKER_LATEST_TAG=$(curl -sL "https://${DOCKER_REGISTRY}/v2/${DOCKER_ORG}/${QUIBBLE_DOCKER_IMAGE}/tags/list" |
+              python3 -c 'import json;print("\n".join(json.loads(input())["tags"]))' |
+              grep -v latest | sort -Vr | head -1)" >> $GITHUB_ENV
+          fi
+
+          # Resolve dependencies
+          if [ -e .github/workflows/dependencies ] && [ "${{ matrix.stage }}" == 'phan' ]; then
+            cd .github/workflows
+            curl -sL https://raw.githubusercontent.com/wikimedia/integration-config/master/zuul/parameter_functions.py -o pf.py
+            curl -sL https://raw.githubusercontent.com/Universal-Omega/scripts/master/mediawiki/resolve_dependencies.py -o rd.py
+            echo "DEPENDENCIES=$(python3 rd.py)" >> $GITHUB_ENV
+          fi
+
+      - name: Cache docker image
+        uses: actions/cache@v2
+        with:
+          path: /home/runner/docker-images/${{ env.DOCKER_IMAGE }}
+          key: ${{ env.DOCKER_IMAGE }}:${{ env.DOCKER_LATEST_TAG }}
+
+      - name: Load or pull docker image
+        run: |
+          docker load -i /home/runner/docker-images/"${DOCKER_IMAGE}" || \
+            docker pull "${DOCKER_REGISTRY}/${DOCKER_ORG}/${DOCKER_IMAGE}:${DOCKER_LATEST_TAG}"
+
+      - name: Cache quibble docker image
+        if: ${{ matrix.stage == 'coverage' || matrix.stage == 'phan' }}
+        uses: actions/cache@v2
+        with:
+          path: /home/runner/docker-images/${{ env.QUIBBLE_DOCKER_IMAGE }}
+          key: ${{ env.QUIBBLE_DOCKER_IMAGE }}:${{ env.QUIBBLE_DOCKER_LATEST_TAG }}
+      - name: Load or pull quibble docker image
+        if: ${{ matrix.stage == 'coverage' || matrix.stage == 'phan' }}
+        run: |
+          docker load -i /home/runner/docker-images/"${QUIBBLE_DOCKER_IMAGE}" || \
+            docker pull "${DOCKER_REGISTRY}/${DOCKER_ORG}/${QUIBBLE_DOCKER_IMAGE}:${QUIBBLE_DOCKER_LATEST_TAG}"
+
+      - name: Download MediaWiki and extensions
+        run: |
+          cd /home/runner
+          if [ ! -d src ]; then
+            git clone -b "${MEDIAWIKI_VERSION}" --depth 1 https://gerrit.wikimedia.org/r/mediawiki/core src
+            git clone --recurse-submodules -b "${MEDIAWIKI_VERSION}" --depth 1 https://gerrit.wikimedia.org/r/mediawiki/skins/Vector src/skins/Vector
+            for dep in $DEPENDENCIES; do
+              dependency=$(echo $dep | cut -d'|' -f1)
+              repository=$(echo $dep | cut -sd'|' -f2)
+              branch=$(echo $dep | rev | cut -sd'|' -f1 | rev)
+
+              if [ $repository == $branch ]; then
+                repository=""
+              fi
+
+              git clone --recurse-submodules -b "${branch:-${MEDIAWIKI_VERSION}}" --depth 1 "${repository:-https://gerrit.wikimedia.org/r/${dependency}}" src/"$(echo $dependency | cut -d'/' -f2,3)"
+            done
+          fi
+
+          # REPLACE SETUP.PHP FOR CREATEWIKI DEPENDANT EXTENSIONS ON REL1_36.
+          # FIXES A BUG PRESENT ON REL1_36, WHEN DOING DATABASE STUFF BEFORE THIS WAS DONE, REQUEST INFO WAS ALREADY SET FOR DBLoadBalancerFactory,
+          # RESULTING IN "LogicException: ChronologyProtector already initialized". THIS HACK REMOVES
+          # MediaWikiServices::getInstance()->getDBLoadBalancerFactory()->setRequestInfo(). THIS IS ALREADY FIXED FOR REL1_37 AND LATER.
+          # WITH https://github.com/wikimedia/mediawiki/commit/29827d
+
+          if [ -d src/extensions/CreateWiki ] || [ "${{ github.event.repository.name }}" == 'CreateWiki' ] && [ "${MEDIAWIKI_VERSION}" == 'REL1_36' ]; then
+            curl -sL https://raw.githubusercontent.com/Universal-Omega/scripts/master/mediawiki/hacks/Setup-REL1_36.php > src/includes/Setup.php
+          fi
+
+          if [ -e "$GITHUB_WORKSPACE"/.github/workflows/globals.php ]; then
+            echo 'require_once __DIR__ . "/../extensions/${{ github.event.repository.name }}/.github/workflows/globals.php";' >> src/includes/DevelopmentSettings.php
+          fi
+
+          git -C src/ log -n 1 --format="%H"
+
+      - name: Cache dependencies (composer and npm)
+        uses: actions/cache@v2
+        with:
+          path: /home/runner/cache
+          key: ${{ runner.os }}-${{ env.MEDIAWIKI_VERSION }}-${{ hashFiles('**/*.lock') }}
+
+      - name: Setup PHP Action
+        if: ${{ matrix.stage == 'phan' }}
+        uses: shivammathur/setup-php@v2
+        with:
+          php-version: ${{ matrix.php }}
+          tools: composer:v2
+
+      - name: Composer install
+        if: ${{ matrix.stage == 'phan' }}
+        run: |
+          if [ -e composer.json ]; then
+            composer install --prefer-dist --no-progress --no-interaction
+          fi
+
+      - name: Fix PHPCS violations
+        continue-on-error: true
+        if: ${{ github.event_name == 'pull_request' && matrix.stage == 'composer-test' }}
+        env:
+          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
+        run: |
+          if [ -e composer.json ]; then
+            composer install --prefer-dist --no-progress --no-interaction
+            composer fix
+
+            rm composer.lock
+
+            git config --global user.name "github-actions"
+            git config --global user.email "github-actions@users.noreply.github.com"
+            git remote set-url origin "https://x-access-token:${GITHUB_TOKEN}@github.com/${GITHUB_REPOSITORY}.git"
+            git checkout -b ${GITHUB_HEAD_REF}
+            git add .
+            git commit -am "CI: lint code to MediaWiki standards" -m "Check commit and GitHub actions for more details" || echo "No changes to commit"
+            git pull origin ${GITHUB_HEAD_REF} --rebase
+            git push --set-upstream origin ${GITHUB_HEAD_REF}
+          fi
+
+      - name: Main Test
+        continue-on-error: ${{ matrix.experimental }}
+        run: |
+          cd /home/runner
+          # Move our extension
+          sudo cp -r "${GITHUB_WORKSPACE}" src/extensions/
+          mkdir -p cache cover
+          chmod 777 src cache cover
+          sudo chown -R nobody:nogroup src cache
+          sudo chown $(id -u):$(id -g) src cache
+          # Composer install
+          if [ "${{ matrix.stage }}" == 'phan' ] || [ "${{ matrix.stage }}" == 'coverage' ]; then
+            docker run \
+              -e ZUUL_PROJECT=mediawiki/extensions/"${{ github.event.repository.name }}" \
+              -v "$(pwd)"/cache:/cache \
+              -v "$(pwd)"/src:/workspace/src \
+              "${DOCKER_REGISTRY}/${DOCKER_ORG}/${QUIBBLE_DOCKER_IMAGE}:${QUIBBLE_DOCKER_LATEST_TAG}" \
+              --skip-zuul \
+              --packages-source composer \
+              --skip-install \
+              --skip all \
+              $DEPENDENCIES
+          fi
+
+          if [ "${{ matrix.stage }}" == 'phan' ]; then
+            docker run \
+              -e THING_SUBNAME=extensions/"${{ github.event.repository.name }}" \
+              -v "$(pwd)"/src:/mediawiki \
+              "${DOCKER_REGISTRY}/${DOCKER_ORG}/${DOCKER_IMAGE}:${DOCKER_LATEST_TAG}" \
+              --color
+          elif [ "${{ matrix.stage }}" == 'coverage' ] && [ -d src/extensions/"${{ github.event.repository.name }}"/tests/phpunit ]; then
+            docker run \
+              -e ZUUL_PROJECT=mediawiki/extensions/"${{ github.event.repository.name }}" \
+              -v "$(pwd)"/cache:/cache \
+              -v "$(pwd)"/src:/workspace/src \
+              -v "$(pwd)"/cover:/workspace/cover \
+              "${DOCKER_REGISTRY}/${DOCKER_ORG}/${DOCKER_IMAGE}:${DOCKER_LATEST_TAG}" \
+              --skip-zuul \
+              --skip-deps \
+              -c mwext-phpunit-coverage
+          elif [ "${{ matrix.stage }}" != 'coverage' ]; then
+            docker run \
+              -e ZUUL_PROJECT=mediawiki/extensions/"${{ github.event.repository.name }}" \
+              -v "$(pwd)"/cache:/cache \
+              -v "$(pwd)"/src:/workspace/src \
+              "${DOCKER_REGISTRY}/${DOCKER_ORG}/${DOCKER_IMAGE}:${DOCKER_LATEST_TAG}" \
+              --skip-zuul \
+              --packages-source composer \
+              --run "${{ matrix.stage }}" \
+              $DEPENDENCIES
+            fi
+
+      - name: Upload coverage to Codecov
+        if: ${{ matrix.stage == 'coverage' }}
+        uses: codecov/codecov-action@v2
+        with:
+          directory: /home/runner/cover
+
+      - name: Tear down
+        run: |
+          cd /home/runner
+          sudo rm -rf src/extensions/"${{ github.event.repository.name }}"
+          # See https://doc.wikimedia.org/quibble/index.html#remove-localsettings-php-between-runs
+          rm "$(pwd)"/src/LocalSettings.php || true
+          mkdir -p docker-images
+          docker save -o "$(pwd)/docker-images/${DOCKER_IMAGE}" \
+            "${DOCKER_REGISTRY}/${DOCKER_ORG}/${DOCKER_IMAGE}:${DOCKER_LATEST_TAG}"
diff --git a/.gitignore b/.gitignore
index 6016e6ed..e794f92b 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,10 +1,3 @@
-/node_modules
-/vendor
 /composer.lock
-/.eslintcache
-*.kate-swp
-*~
-.*.swp
-.DS_Store
-.svn
-.idea
+/vendor
+.github/*
diff --git a/.phan/config.php b/.phan/config.php
index ff50366c..2e2aa11d 100644
--- a/.phan/config.php
+++ b/.phan/config.php
@@ -2,39 +2,22 @@
 
 $cfg = require __DIR__ . '/../vendor/mediawiki/mediawiki-phan-config/src/config.php';
 
-$cfg['suppress_issue_types'] = array_merge( $cfg['suppress_issue_types'], [
-	'PhanUndeclaredInterface',
-	'PhanUndeclaredTypeParameter',
-	'PhanUndeclaredClassMethod',
-	'PhanUndeclaredFunction',
-	'PhanUndeclaredConstant',
-	'PhanUndeclaredTypeReturnType',
-	'PhanPossiblyUndeclaredVariable',
-	'PhanTypePossiblyInvalidDimOffset',
-	'PhanTypeInvalidDimOffset',
-	'PhanUndeclaredConstantOfClass',
-	'PhanUndeclaredExtendedClass',
-	'PhanTypeMismatchReturnNullable',
-	'PhanUndeclaredExtendedClass',
-	'PhanUndeclaredMethod',
-	'PhanUndeclaredProperty',
-	'PhanPluginDuplicateAdjacentStatement',
-	'PhanImpossibleCondition',
-	'PhanUndeclaredClassInstanceof',
-	'PhanTypeArraySuspiciousNullable',
-	'PhanParamTooMany',
-	'PhanPluginDuplicateConditionalNullCoalescing',
-	'PhanRedundantCondition',
-	'PhanPluginDuplicateConditionalTernaryDuplication',
-	'PhanTypeMismatchReturnProbablyReal',
-	'PhanUndeclaredVariableDim',
-	'PhanUndeclaredClass',
-	'PhanUnextractableAnnotation',
-	'PhanTypeSuspiciousStringExpression',
-	'PhanImpossibleTypeComparison',
-	'PhanTypeMismatchArgument'
-] );
+$cfg['directory_list'] = array_merge(
+	$cfg['directory_list'], [
+		'../../extensions/Variables',
+	]
+);
 
-$cfg['scalar_implicit_cast'] = true;
+$cfg['exclude_analysis_directory_list'] = array_merge(
+	$cfg['exclude_analysis_directory_list'], [
+		'../../extensions/Variables',
+	]
+);
+
+$cfg['suppress_issue_types'] = [
+	'SecurityCheck-ReDoS',
+	'SecurityCheck-LikelyFalsePositive',
+	'PhanAccessMethodInternal',
+];
 
 return $cfg;
diff --git a/.phpcs.xml b/.phpcs.xml
index f844bc5a..8e445048 100644
--- a/.phpcs.xml
+++ b/.phpcs.xml
@@ -1,16 +1,17 @@
 <?xml version="1.0"?>
 <ruleset>
-    <rule ref="./vendor/mediawiki/mediawiki-codesniffer/MediaWiki">
-		<exclude name="Generic.Files.LineLength" />
+	<file>.</file>
+	<rule ref="./vendor/mediawiki/mediawiki-codesniffer/MediaWiki">
+		<exclude name="Generic.Files.LineLength.TooLong" />
 		<exclude name="MediaWiki.Commenting.FunctionComment" />
-		<exclude name="MediaWiki.NamingConventions.LowerCamelFunctionsName" />
-		<exclude name="MediaWiki.WhiteSpace.SpaceBeforeSingleLineComment" />
+		<exclude name="MediaWiki.Commenting.MissingCovers.MissingCovers" />
+		<exclude name="MediaWiki.NamingConventions.LowerCamelFunctionsName.FunctionName" />
+		<exclude name="MediaWiki.WhiteSpace.SpaceBeforeSingleLineComment.NewLineComment" />
 		<exclude name="PSR2.Methods.MethodDeclaration.Underscore" />
+		<exclude name="MediaWiki.ControlStructures.AssignmentInControlStructures.AssignmentInControlStructures" />
+		<exclude name="PEAR.Functions.ValidDefaultValue.NotAtEnd" />
 	</rule>
-	<rule ref="Generic.NamingConventions.ConstructorName">
-		<severity>3</severity>
-	</rule>
-    <file>.</file>
-    <arg name="extensions" value="php,php5,inc"/>
-    <arg name="encoding" value="UTF-8"/>
+	<arg name="bootstrap" value="./vendor/mediawiki/mediawiki-codesniffer/utils/bootstrap-ci.php"/>
+	<arg name="extensions" value="php"/>
+	<arg name="encoding" value="UTF-8"/>
 </ruleset>
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 0ae24b3c..a22555f0 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -702,3 +702,9 @@ Many thanks to GreenReaper on GitHub for reporting and finding issues with core
 # Version 3.3.5
 * Fix syntax error in extension.json
 * 1.36.0 support
+
+# Version 3.3.6
+* Major code cleanup
+* Numerous bug fixes
+* Now requires MediaWiki 1.36.0 or later
+* 1.37.0 support
diff --git a/COPYING b/COPYING
index d159169d..94a9ed02 100644
--- a/COPYING
+++ b/COPYING
@@ -1,281 +1,622 @@
                     GNU GENERAL PUBLIC LICENSE
-                       Version 2, June 1991
+                       Version 3, 29 June 2007
 
- Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
- 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
  Everyone is permitted to copy and distribute verbatim copies
  of this license document, but changing it is not allowed.
 
                             Preamble
 
-  The licenses for most software are designed to take away your
-freedom to share and change it.  By contrast, the GNU General Public
-License is intended to guarantee your freedom to share and change free
-software--to make sure the software is free for all its users.  This
-General Public License applies to most of the Free Software
-Foundation's software and to any other program whose authors commit to
-using it.  (Some other Free Software Foundation software is covered by
-the GNU Lesser General Public License instead.)  You can apply it to
+  The GNU General Public License is a free, copyleft license for
+software and other kinds of works.
+
+  The licenses for most software and other practical works are designed
+to take away your freedom to share and change the works.  By contrast,
+the GNU General Public License is intended to guarantee your freedom to
+share and change all versions of a program--to make sure it remains free
+software for all its users.  We, the Free Software Foundation, use the
+GNU General Public License for most of our software; it applies also to
+any other work released this way by its authors.  You can apply it to
 your programs, too.
 
   When we speak of free software, we are referring to freedom, not
 price.  Our General Public Licenses are designed to make sure that you
 have the freedom to distribute copies of free software (and charge for
-this service if you wish), that you receive source code or can get it
-if you want it, that you can change the software or use pieces of it
-in new free programs; and that you know you can do these things.
+them if you wish), that you receive source code or can get it if you
+want it, that you can change the software or use pieces of it in new
+free programs, and that you know you can do these things.
 
-  To protect your rights, we need to make restrictions that forbid
-anyone to deny you these rights or to ask you to surrender the rights.
-These restrictions translate to certain responsibilities for you if you
-distribute copies of the software, or if you modify it.
+  To protect your rights, we need to prevent others from denying you
+these rights or asking you to surrender the rights.  Therefore, you have
+certain responsibilities if you distribute copies of the software, or if
+you modify it: responsibilities to respect the freedom of others.
 
   For example, if you distribute copies of such a program, whether
-gratis or for a fee, you must give the recipients all the rights that
-you have.  You must make sure that they, too, receive or can get the
-source code.  And you must show them these terms so they know their
-rights.
-
-  We protect your rights with two steps: (1) copyright the software, and
-(2) offer you this license which gives you legal permission to copy,
-distribute and/or modify the software.
-
-  Also, for each author's protection and ours, we want to make certain
-that everyone understands that there is no warranty for this free
-software.  If the software is modified by someone else and passed on, we
-want its recipients to know that what they have is not the original, so
-that any problems introduced by others will not reflect on the original
-authors' reputations.
-
-  Finally, any free program is threatened constantly by software
-patents.  We wish to avoid the danger that redistributors of a free
-program will individually obtain patent licenses, in effect making the
-program proprietary.  To prevent this, we have made it clear that any
-patent must be licensed for everyone's free use or not licensed at all.
+gratis or for a fee, you must pass on to the recipients the same
+freedoms that you received.  You must make sure that they, too, receive
+or can get the source code.  And you must show them these terms so they
+know their rights.
+
+  Developers that use the GNU GPL protect your rights with two steps:
+(1) assert copyright on the software, and (2) offer you this License
+giving you legal permission to copy, distribute and/or modify it.
+
+  For the developers' and authors' protection, the GPL clearly explains
+that there is no warranty for this free software.  For both users' and
+authors' sake, the GPL requires that modified versions be marked as
+changed, so that their problems will not be attributed erroneously to
+authors of previous versions.
+
+  Some devices are designed to deny users access to install or run
+modified versions of the software inside them, although the manufacturer
+can do so.  This is fundamentally incompatible with the aim of
+protecting users' freedom to change the software.  The systematic
+pattern of such abuse occurs in the area of products for individuals to
+use, which is precisely where it is most unacceptable.  Therefore, we
+have designed this version of the GPL to prohibit the practice for those
+products.  If such problems arise substantially in other domains, we
+stand ready to extend this provision to those domains in future versions
+of the GPL, as needed to protect the freedom of users.
+
+  Finally, every program is threatened constantly by software patents.
+States should not allow patents to restrict development and use of
+software on general-purpose computers, but in those that do, we wish to
+avoid the special danger that patents applied to a free program could
+make it effectively proprietary.  To prevent this, the GPL assures that
+patents cannot be used to render the program non-free.
 
   The precise terms and conditions for copying, distribution and
 modification follow.
 
-                    GNU GENERAL PUBLIC LICENSE
-   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
-
-  0. This License applies to any program or other work which contains
-a notice placed by the copyright holder saying it may be distributed
-under the terms of this General Public License.  The "Program", below,
-refers to any such program or work, and a "work based on the Program"
-means either the Program or any derivative work under copyright law:
-that is to say, a work containing the Program or a portion of it,
-either verbatim or with modifications and/or translated into another
-language.  (Hereinafter, translation is included without limitation in
-the term "modification".)  Each licensee is addressed as "you".
-
-Activities other than copying, distribution and modification are not
-covered by this License; they are outside its scope.  The act of
-running the Program is not restricted, and the output from the Program
-is covered only if its contents constitute a work based on the
-Program (independent of having been made by running the Program).
-Whether that is true depends on what the Program does.
-
-  1. You may copy and distribute verbatim copies of the Program's
-source code as you receive it, in any medium, provided that you
-conspicuously and appropriately publish on each copy an appropriate
-copyright notice and disclaimer of warranty; keep intact all the
-notices that refer to this License and to the absence of any warranty;
-and give any other recipients of the Program a copy of this License
-along with the Program.
-
-You may charge a fee for the physical act of transferring a copy, and
-you may at your option offer warranty protection in exchange for a fee.
-
-  2. You may modify your copy or copies of the Program or any portion
-of it, thus forming a work based on the Program, and copy and
-distribute such modifications or work under the terms of Section 1
-above, provided that you also meet all of these conditions:
-
-    a) You must cause the modified files to carry prominent notices
-    stating that you changed the files and the date of any change.
-
-    b) You must cause any work that you distribute or publish, that in
-    whole or in part contains or is derived from the Program or any
-    part thereof, to be licensed as a whole at no charge to all third
-    parties under the terms of this License.
-
-    c) If the modified program normally reads commands interactively
-    when run, you must cause it, when started running for such
-    interactive use in the most ordinary way, to print or display an
-    announcement including an appropriate copyright notice and a
-    notice that there is no warranty (or else, saying that you provide
-    a warranty) and that users may redistribute the program under
-    these conditions, and telling the user how to view a copy of this
-    License.  (Exception: if the Program itself is interactive but
-    does not normally print such an announcement, your work based on
-    the Program is not required to print an announcement.)
-
-These requirements apply to the modified work as a whole.  If
-identifiable sections of that work are not derived from the Program,
-and can be reasonably considered independent and separate works in
-themselves, then this License, and its terms, do not apply to those
-sections when you distribute them as separate works.  But when you
-distribute the same sections as part of a whole which is a work based
-on the Program, the distribution of the whole must be on the terms of
-this License, whose permissions for other licensees extend to the
-entire whole, and thus to each and every part regardless of who wrote it.
-
-Thus, it is not the intent of this section to claim rights or contest
-your rights to work written entirely by you; rather, the intent is to
-exercise the right to control the distribution of derivative or
-collective works based on the Program.
-
-In addition, mere aggregation of another work not based on the Program
-with the Program (or with a work based on the Program) on a volume of
-a storage or distribution medium does not bring the other work under
-the scope of this License.
-
-  3. You may copy and distribute the Program (or a work based on it,
-under Section 2) in object code or executable form under the terms of
-Sections 1 and 2 above provided that you also do one of the following:
-
-    a) Accompany it with the complete corresponding machine-readable
-    source code, which must be distributed under the terms of Sections
-    1 and 2 above on a medium customarily used for software interchange; or,
-
-    b) Accompany it with a written offer, valid for at least three
-    years, to give any third party, for a charge no more than your
-    cost of physically performing source distribution, a complete
-    machine-readable copy of the corresponding source code, to be
-    distributed under the terms of Sections 1 and 2 above on a medium
-    customarily used for software interchange; or,
-
-    c) Accompany it with the information you received as to the offer
-    to distribute corresponding source code.  (This alternative is
-    allowed only for noncommercial distribution and only if you
-    received the program in object code or executable form with such
-    an offer, in accord with Subsection b above.)
-
-The source code for a work means the preferred form of the work for
-making modifications to it.  For an executable work, complete source
-code means all the source code for all modules it contains, plus any
-associated interface definition files, plus the scripts used to
-control compilation and installation of the executable.  However, as a
-special exception, the source code distributed need not include
-anything that is normally distributed (in either source or binary
-form) with the major components (compiler, kernel, and so on) of the
-operating system on which the executable runs, unless that component
-itself accompanies the executable.
-
-If distribution of executable or object code is made by offering
-access to copy from a designated place, then offering equivalent
-access to copy the source code from the same place counts as
-distribution of the source code, even though third parties are not
-compelled to copy the source along with the object code.
-
-  4. You may not copy, modify, sublicense, or distribute the Program
-except as expressly provided under this License.  Any attempt
-otherwise to copy, modify, sublicense or distribute the Program is
-void, and will automatically terminate your rights under this License.
-However, parties who have received copies, or rights, from you under
-this License will not have their licenses terminated so long as such
-parties remain in full compliance.
-
-  5. You are not required to accept this License, since you have not
-signed it.  However, nothing else grants you permission to modify or
-distribute the Program or its derivative works.  These actions are
-prohibited by law if you do not accept this License.  Therefore, by
-modifying or distributing the Program (or any work based on the
-Program), you indicate your acceptance of this License to do so, and
-all its terms and conditions for copying, distributing or modifying
-the Program or works based on it.
-
-  6. Each time you redistribute the Program (or any work based on the
-Program), the recipient automatically receives a license from the
-original licensor to copy, distribute or modify the Program subject to
-these terms and conditions.  You may not impose any further
-restrictions on the recipients' exercise of the rights granted herein.
-You are not responsible for enforcing compliance by third parties to
+                       TERMS AND CONDITIONS
+
+  0. Definitions.
+
+  "This License" refers to version 3 of the GNU General Public License.
+
+  "Copyright" also means copyright-like laws that apply to other kinds of
+works, such as semiconductor masks.
+
+  "The Program" refers to any copyrightable work licensed under this
+License.  Each licensee is addressed as "you".  "Licensees" and
+"recipients" may be individuals or organizations.
+
+  To "modify" a work means to copy from or adapt all or part of the work
+in a fashion requiring copyright permission, other than the making of an
+exact copy.  The resulting work is called a "modified version" of the
+earlier work or a work "based on" the earlier work.
+
+  A "covered work" means either the unmodified Program or a work based
+on the Program.
+
+  To "propagate" a work means to do anything with it that, without
+permission, would make you directly or secondarily liable for
+infringement under applicable copyright law, except executing it on a
+computer or modifying a private copy.  Propagation includes copying,
+distribution (with or without modification), making available to the
+public, and in some countries other activities as well.
+
+  To "convey" a work means any kind of propagation that enables other
+parties to make or receive copies.  Mere interaction with a user through
+a computer network, with no transfer of a copy, is not conveying.
+
+  An interactive user interface displays "Appropriate Legal Notices"
+to the extent that it includes a convenient and prominently visible
+feature that (1) displays an appropriate copyright notice, and (2)
+tells the user that there is no warranty for the work (except to the
+extent that warranties are provided), that licensees may convey the
+work under this License, and how to view a copy of this License.  If
+the interface presents a list of user commands or options, such as a
+menu, a prominent item in the list meets this criterion.
+
+  1. Source Code.
+
+  The "source code" for a work means the preferred form of the work
+for making modifications to it.  "Object code" means any non-source
+form of a work.
+
+  A "Standard Interface" means an interface that either is an official
+standard defined by a recognized standards body, or, in the case of
+interfaces specified for a particular programming language, one that
+is widely used among developers working in that language.
+
+  The "System Libraries" of an executable work include anything, other
+than the work as a whole, that (a) is included in the normal form of
+packaging a Major Component, but which is not part of that Major
+Component, and (b) serves only to enable use of the work with that
+Major Component, or to implement a Standard Interface for which an
+implementation is available to the public in source code form.  A
+"Major Component", in this context, means a major essential component
+(kernel, window system, and so on) of the specific operating system
+(if any) on which the executable work runs, or a compiler used to
+produce the work, or an object code interpreter used to run it.
+
+  The "Corresponding Source" for a work in object code form means all
+the source code needed to generate, install, and (for an executable
+work) run the object code and to modify the work, including scripts to
+control those activities.  However, it does not include the work's
+System Libraries, or general-purpose tools or generally available free
+programs which are used unmodified in performing those activities but
+which are not part of the work.  For example, Corresponding Source
+includes interface definition files associated with source files for
+the work, and the source code for shared libraries and dynamically
+linked subprograms that the work is specifically designed to require,
+such as by intimate data communication or control flow between those
+subprograms and other parts of the work.
+
+  The Corresponding Source need not include anything that users
+can regenerate automatically from other parts of the Corresponding
+Source.
+
+  The Corresponding Source for a work in source code form is that
+same work.
+
+  2. Basic Permissions.
+
+  All rights granted under this License are granted for the term of
+copyright on the Program, and are irrevocable provided the stated
+conditions are met.  This License explicitly affirms your unlimited
+permission to run the unmodified Program.  The output from running a
+covered work is covered by this License only if the output, given its
+content, constitutes a covered work.  This License acknowledges your
+rights of fair use or other equivalent, as provided by copyright law.
+
+  You may make, run and propagate covered works that you do not
+convey, without conditions so long as your license otherwise remains
+in force.  You may convey covered works to others for the sole purpose
+of having them make modifications exclusively for you, or provide you
+with facilities for running those works, provided that you comply with
+the terms of this License in conveying all material for which you do
+not control copyright.  Those thus making or running the covered works
+for you must do so exclusively on your behalf, under your direction
+and control, on terms that prohibit them from making any copies of
+your copyrighted material outside their relationship with you.
+
+  Conveying under any other circumstances is permitted solely under
+the conditions stated below.  Sublicensing is not allowed; section 10
+makes it unnecessary.
+
+  3. Protecting Users' Legal Rights From Anti-Circumvention Law.
+
+  No covered work shall be deemed part of an effective technological
+measure under any applicable law fulfilling obligations under article
+11 of the WIPO copyright treaty adopted on 20 December 1996, or
+similar laws prohibiting or restricting circumvention of such
+measures.
+
+  When you convey a covered work, you waive any legal power to forbid
+circumvention of technological measures to the extent such circumvention
+is effected by exercising rights under this License with respect to
+the covered work, and you disclaim any intention to limit operation or
+modification of the work as a means of enforcing, against the work's
+users, your or third parties' legal rights to forbid circumvention of
+technological measures.
+
+  4. Conveying Verbatim Copies.
+
+  You may convey verbatim copies of the Program's source code as you
+receive it, in any medium, provided that you conspicuously and
+appropriately publish on each copy an appropriate copyright notice;
+keep intact all notices stating that this License and any
+non-permissive terms added in accord with section 7 apply to the code;
+keep intact all notices of the absence of any warranty; and give all
+recipients a copy of this License along with the Program.
+
+  You may charge any price or no price for each copy that you convey,
+and you may offer support or warranty protection for a fee.
+
+  5. Conveying Modified Source Versions.
+
+  You may convey a work based on the Program, or the modifications to
+produce it from the Program, in the form of source code under the
+terms of section 4, provided that you also meet all of these conditions:
+
+    a) The work must carry prominent notices stating that you modified
+    it, and giving a relevant date.
+
+    b) The work must carry prominent notices stating that it is
+    released under this License and any conditions added under section
+    7.  This requirement modifies the requirement in section 4 to
+    "keep intact all notices".
+
+    c) You must license the entire work, as a whole, under this
+    License to anyone who comes into possession of a copy.  This
+    License will therefore apply, along with any applicable section 7
+    additional terms, to the whole of the work, and all its parts,
+    regardless of how they are packaged.  This License gives no
+    permission to license the work in any other way, but it does not
+    invalidate such permission if you have separately received it.
+
+    d) If the work has interactive user interfaces, each must display
+    Appropriate Legal Notices; however, if the Program has interactive
+    interfaces that do not display Appropriate Legal Notices, your
+    work need not make them do so.
+
+  A compilation of a covered work with other separate and independent
+works, which are not by their nature extensions of the covered work,
+and which are not combined with it such as to form a larger program,
+in or on a volume of a storage or distribution medium, is called an
+"aggregate" if the compilation and its resulting copyright are not
+used to limit the access or legal rights of the compilation's users
+beyond what the individual works permit.  Inclusion of a covered work
+in an aggregate does not cause this License to apply to the other
+parts of the aggregate.
+
+  6. Conveying Non-Source Forms.
+
+  You may convey a covered work in object code form under the terms
+of sections 4 and 5, provided that you also convey the
+machine-readable Corresponding Source under the terms of this License,
+in one of these ways:
+
+    a) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by the
+    Corresponding Source fixed on a durable physical medium
+    customarily used for software interchange.
+
+    b) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by a
+    written offer, valid for at least three years and valid for as
+    long as you offer spare parts or customer support for that product
+    model, to give anyone who possesses the object code either (1) a
+    copy of the Corresponding Source for all the software in the
+    product that is covered by this License, on a durable physical
+    medium customarily used for software interchange, for a price no
+    more than your reasonable cost of physically performing this
+    conveying of source, or (2) access to copy the
+    Corresponding Source from a network server at no charge.
+
+    c) Convey individual copies of the object code with a copy of the
+    written offer to provide the Corresponding Source.  This
+    alternative is allowed only occasionally and noncommercially, and
+    only if you received the object code with such an offer, in accord
+    with subsection 6b.
+
+    d) Convey the object code by offering access from a designated
+    place (gratis or for a charge), and offer equivalent access to the
+    Corresponding Source in the same way through the same place at no
+    further charge.  You need not require recipients to copy the
+    Corresponding Source along with the object code.  If the place to
+    copy the object code is a network server, the Corresponding Source
+    may be on a different server (operated by you or a third party)
+    that supports equivalent copying facilities, provided you maintain
+    clear directions next to the object code saying where to find the
+    Corresponding Source.  Regardless of what server hosts the
+    Corresponding Source, you remain obligated to ensure that it is
+    available for as long as needed to satisfy these requirements.
+
+    e) Convey the object code using peer-to-peer transmission, provided
+    you inform other peers where the object code and Corresponding
+    Source of the work are being offered to the general public at no
+    charge under subsection 6d.
+
+  A separable portion of the object code, whose source code is excluded
+from the Corresponding Source as a System Library, need not be
+included in conveying the object code work.
+
+  A "User Product" is either (1) a "consumer product", which means any
+tangible personal property which is normally used for personal, family,
+or household purposes, or (2) anything designed or sold for incorporation
+into a dwelling.  In determining whether a product is a consumer product,
+doubtful cases shall be resolved in favor of coverage.  For a particular
+product received by a particular user, "normally used" refers to a
+typical or common use of that class of product, regardless of the status
+of the particular user or of the way in which the particular user
+actually uses, or expects or is expected to use, the product.  A product
+is a consumer product regardless of whether the product has substantial
+commercial, industrial or non-consumer uses, unless such uses represent
+the only significant mode of use of the product.
+
+  "Installation Information" for a User Product means any methods,
+procedures, authorization keys, or other information required to install
+and execute modified versions of a covered work in that User Product from
+a modified version of its Corresponding Source.  The information must
+suffice to ensure that the continued functioning of the modified object
+code is in no case prevented or interfered with solely because
+modification has been made.
+
+  If you convey an object code work under this section in, or with, or
+specifically for use in, a User Product, and the conveying occurs as
+part of a transaction in which the right of possession and use of the
+User Product is transferred to the recipient in perpetuity or for a
+fixed term (regardless of how the transaction is characterized), the
+Corresponding Source conveyed under this section must be accompanied
+by the Installation Information.  But this requirement does not apply
+if neither you nor any third party retains the ability to install
+modified object code on the User Product (for example, the work has
+been installed in ROM).
+
+  The requirement to provide Installation Information does not include a
+requirement to continue to provide support service, warranty, or updates
+for a work that has been modified or installed by the recipient, or for
+the User Product in which it has been modified or installed.  Access to a
+network may be denied when the modification itself materially and
+adversely affects the operation of the network or violates the rules and
+protocols for communication across the network.
+
+  Corresponding Source conveyed, and Installation Information provided,
+in accord with this section must be in a format that is publicly
+documented (and with an implementation available to the public in
+source code form), and must require no special password or key for
+unpacking, reading or copying.
+
+  7. Additional Terms.
+
+  "Additional permissions" are terms that supplement the terms of this
+License by making exceptions from one or more of its conditions.
+Additional permissions that are applicable to the entire Program shall
+be treated as though they were included in this License, to the extent
+that they are valid under applicable law.  If additional permissions
+apply only to part of the Program, that part may be used separately
+under those permissions, but the entire Program remains governed by
+this License without regard to the additional permissions.
+
+  When you convey a copy of a covered work, you may at your option
+remove any additional permissions from that copy, or from any part of
+it.  (Additional permissions may be written to require their own
+removal in certain cases when you modify the work.)  You may place
+additional permissions on material, added by you to a covered work,
+for which you have or can give appropriate copyright permission.
+
+  Notwithstanding any other provision of this License, for material you
+add to a covered work, you may (if authorized by the copyright holders of
+that material) supplement the terms of this License with terms:
+
+    a) Disclaiming warranty or limiting liability differently from the
+    terms of sections 15 and 16 of this License; or
+
+    b) Requiring preservation of specified reasonable legal notices or
+    author attributions in that material or in the Appropriate Legal
+    Notices displayed by works containing it; or
+
+    c) Prohibiting misrepresentation of the origin of that material, or
+    requiring that modified versions of such material be marked in
+    reasonable ways as different from the original version; or
+
+    d) Limiting the use for publicity purposes of names of licensors or
+    authors of the material; or
+
+    e) Declining to grant rights under trademark law for use of some
+    trade names, trademarks, or service marks; or
+
+    f) Requiring indemnification of licensors and authors of that
+    material by anyone who conveys the material (or modified versions of
+    it) with contractual assumptions of liability to the recipient, for
+    any liability that these contractual assumptions directly impose on
+    those licensors and authors.
+
+  All other non-permissive additional terms are considered "further
+restrictions" within the meaning of section 10.  If the Program as you
+received it, or any part of it, contains a notice stating that it is
+governed by this License along with a term that is a further
+restriction, you may remove that term.  If a license document contains
+a further restriction but permits relicensing or conveying under this
+License, you may add to a covered work material governed by the terms
+of that license document, provided that the further restriction does
+not survive such relicensing or conveying.
+
+  If you add terms to a covered work in accord with this section, you
+must place, in the relevant source files, a statement of the
+additional terms that apply to those files, or a notice indicating
+where to find the applicable terms.
+
+  Additional terms, permissive or non-permissive, may be stated in the
+form of a separately written license, or stated as exceptions;
+the above requirements apply either way.
+
+  8. Termination.
+
+  You may not propagate or modify a covered work except as expressly
+provided under this License.  Any attempt otherwise to propagate or
+modify it is void, and will automatically terminate your rights under
+this License (including any patent licenses granted under the third
+paragraph of section 11).
+
+  However, if you cease all violation of this License, then your
+license from a particular copyright holder is reinstated (a)
+provisionally, unless and until the copyright holder explicitly and
+finally terminates your license, and (b) permanently, if the copyright
+holder fails to notify you of the violation by some reasonable means
+prior to 60 days after the cessation.
+
+  Moreover, your license from a particular copyright holder is
+reinstated permanently if the copyright holder notifies you of the
+violation by some reasonable means, this is the first time you have
+received notice of violation of this License (for any work) from that
+copyright holder, and you cure the violation prior to 30 days after
+your receipt of the notice.
+
+  Termination of your rights under this section does not terminate the
+licenses of parties who have received copies or rights from you under
+this License.  If your rights have been terminated and not permanently
+reinstated, you do not qualify to receive new licenses for the same
+material under section 10.
+
+  9. Acceptance Not Required for Having Copies.
+
+  You are not required to accept this License in order to receive or
+run a copy of the Program.  Ancillary propagation of a covered work
+occurring solely as a consequence of using peer-to-peer transmission
+to receive a copy likewise does not require acceptance.  However,
+nothing other than this License grants you permission to propagate or
+modify any covered work.  These actions infringe copyright if you do
+not accept this License.  Therefore, by modifying or propagating a
+covered work, you indicate your acceptance of this License to do so.
+
+  10. Automatic Licensing of Downstream Recipients.
+
+  Each time you convey a covered work, the recipient automatically
+receives a license from the original licensors, to run, modify and
+propagate that work, subject to this License.  You are not responsible
+for enforcing compliance by third parties with this License.
+
+  An "entity transaction" is a transaction transferring control of an
+organization, or substantially all assets of one, or subdividing an
+organization, or merging organizations.  If propagation of a covered
+work results from an entity transaction, each party to that
+transaction who receives a copy of the work also receives whatever
+licenses to the work the party's predecessor in interest had or could
+give under the previous paragraph, plus a right to possession of the
+Corresponding Source of the work from the predecessor in interest, if
+the predecessor has it or can get it with reasonable efforts.
+
+  You may not impose any further restrictions on the exercise of the
+rights granted or affirmed under this License.  For example, you may
+not impose a license fee, royalty, or other charge for exercise of
+rights granted under this License, and you may not initiate litigation
+(including a cross-claim or counterclaim in a lawsuit) alleging that
+any patent claim is infringed by making, using, selling, offering for
+sale, or importing the Program or any portion of it.
+
+  11. Patents.
+
+  A "contributor" is a copyright holder who authorizes use under this
+License of the Program or a work on which the Program is based.  The
+work thus licensed is called the contributor's "contributor version".
+
+  A contributor's "essential patent claims" are all patent claims
+owned or controlled by the contributor, whether already acquired or
+hereafter acquired, that would be infringed by some manner, permitted
+by this License, of making, using, or selling its contributor version,
+but do not include claims that would be infringed only as a
+consequence of further modification of the contributor version.  For
+purposes of this definition, "control" includes the right to grant
+patent sublicenses in a manner consistent with the requirements of
 this License.
 
-  7. If, as a consequence of a court judgment or allegation of patent
-infringement or for any other reason (not limited to patent issues),
-conditions are imposed on you (whether by court order, agreement or
+  Each contributor grants you a non-exclusive, worldwide, royalty-free
+patent license under the contributor's essential patent claims, to
+make, use, sell, offer for sale, import and otherwise run, modify and
+propagate the contents of its contributor version.
+
+  In the following three paragraphs, a "patent license" is any express
+agreement or commitment, however denominated, not to enforce a patent
+(such as an express permission to practice a patent or covenant not to
+sue for patent infringement).  To "grant" such a patent license to a
+party means to make such an agreement or commitment not to enforce a
+patent against the party.
+
+  If you convey a covered work, knowingly relying on a patent license,
+and the Corresponding Source of the work is not available for anyone
+to copy, free of charge and under the terms of this License, through a
+publicly available network server or other readily accessible means,
+then you must either (1) cause the Corresponding Source to be so
+available, or (2) arrange to deprive yourself of the benefit of the
+patent license for this particular work, or (3) arrange, in a manner
+consistent with the requirements of this License, to extend the patent
+license to downstream recipients.  "Knowingly relying" means you have
+actual knowledge that, but for the patent license, your conveying the
+covered work in a country, or your recipient's use of the covered work
+in a country, would infringe one or more identifiable patents in that
+country that you have reason to believe are valid.
+
+  If, pursuant to or in connection with a single transaction or
+arrangement, you convey, or propagate by procuring conveyance of, a
+covered work, and grant a patent license to some of the parties
+receiving the covered work authorizing them to use, propagate, modify
+or convey a specific copy of the covered work, then the patent license
+you grant is automatically extended to all recipients of the covered
+work and works based on it.
+
+  A patent license is "discriminatory" if it does not include within
+the scope of its coverage, prohibits the exercise of, or is
+conditioned on the non-exercise of one or more of the rights that are
+specifically granted under this License.  You may not convey a covered
+work if you are a party to an arrangement with a third party that is
+in the business of distributing software, under which you make payment
+to the third party based on the extent of your activity of conveying
+the work, and under which the third party grants, to any of the
+parties who would receive the covered work from you, a discriminatory
+patent license (a) in connection with copies of the covered work
+conveyed by you (or copies made from those copies), or (b) primarily
+for and in connection with specific products or compilations that
+contain the covered work, unless you entered into that arrangement,
+or that patent license was granted, prior to 28 March 2007.
+
+  Nothing in this License shall be construed as excluding or limiting
+any implied license or other defenses to infringement that may
+otherwise be available to you under applicable patent law.
+
+  12. No Surrender of Others' Freedom.
+
+  If conditions are imposed on you (whether by court order, agreement or
 otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot
-distribute so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you
-may not distribute the Program at all.  For example, if a patent
-license would not permit royalty-free redistribution of the Program by
-all those who receive copies directly or indirectly through you, then
-the only way you could satisfy both it and this License would be to
-refrain entirely from distribution of the Program.
-
-If any portion of this section is held invalid or unenforceable under
-any particular circumstance, the balance of the section is intended to
-apply and the section as a whole is intended to apply in other
-circumstances.
-
-It is not the purpose of this section to induce you to infringe any
-patents or other property right claims or to contest validity of any
-such claims; this section has the sole purpose of protecting the
-integrity of the free software distribution system, which is
-implemented by public license practices.  Many people have made
-generous contributions to the wide range of software distributed
-through that system in reliance on consistent application of that
-system; it is up to the author/donor to decide if he or she is willing
-to distribute software through any other system and a licensee cannot
-impose that choice.
-
-This section is intended to make thoroughly clear what is believed to
-be a consequence of the rest of this License.
-
-  8. If the distribution and/or use of the Program is restricted in
-certain countries either by patents or by copyrighted interfaces, the
-original copyright holder who places the Program under this License
-may add an explicit geographical distribution limitation excluding
-those countries, so that distribution is permitted only in or among
-countries not thus excluded.  In such case, this License incorporates
-the limitation as if written in the body of this License.
-
-  9. The Free Software Foundation may publish revised and/or new versions
-of the General Public License from time to time.  Such new versions will
+excuse you from the conditions of this License.  If you cannot convey a
+covered work so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you may
+not convey it at all.  For example, if you agree to terms that obligate you
+to collect a royalty for further conveying from those to whom you convey
+the Program, the only way you could satisfy both those terms and this
+License would be to refrain entirely from conveying the Program.
+
+  13. Use with the GNU Affero General Public License.
+
+  Notwithstanding any other provision of this License, you have
+permission to link or combine any covered work with a work licensed
+under version 3 of the GNU Affero General Public License into a single
+combined work, and to convey the resulting work.  The terms of this
+License will continue to apply to the part which is the covered work,
+but the special requirements of the GNU Affero General Public License,
+section 13, concerning interaction through a network will apply to the
+combination as such.
+
+  14. Revised Versions of this License.
+
+  The Free Software Foundation may publish revised and/or new versions of
+the GNU General Public License from time to time.  Such new versions will
 be similar in spirit to the present version, but may differ in detail to
 address new problems or concerns.
 
-Each version is given a distinguishing version number.  If the Program
-specifies a version number of this License which applies to it and "any
-later version", you have the option of following the terms and conditions
-either of that version or of any later version published by the Free
-Software Foundation.  If the Program does not specify a version number of
-this License, you may choose any version ever published by the Free Software
-Foundation.
-
-  10. If you wish to incorporate parts of the Program into other free
-programs whose distribution conditions are different, write to the author
-to ask for permission.  For software which is copyrighted by the Free
-Software Foundation, write to the Free Software Foundation; we sometimes
-make exceptions for this.  Our decision will be guided by the two goals
-of preserving the free status of all derivatives of our free software and
-of promoting the sharing and reuse of software generally.
-
-                            NO WARRANTY
-
-  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
-FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
-OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
-PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
-OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
-TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
-PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
-REPAIR OR CORRECTION.
-
-  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
-WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
-REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
-INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
-OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
-TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
-YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
-PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGES.
+  Each version is given a distinguishing version number.  If the
+Program specifies that a certain numbered version of the GNU General
+Public License "or any later version" applies to it, you have the
+option of following the terms and conditions either of that numbered
+version or of any later version published by the Free Software
+Foundation.  If the Program does not specify a version number of the
+GNU General Public License, you may choose any version ever published
+by the Free Software Foundation.
+
+  If the Program specifies that a proxy can decide which future
+versions of the GNU General Public License can be used, that proxy's
+public statement of acceptance of a version permanently authorizes you
+to choose that version for the Program.
+
+  Later license versions may give you additional or different
+permissions.  However, no additional obligations are imposed on any
+author or copyright holder as a result of your choosing to follow a
+later version.
+
+  15. Disclaimer of Warranty.
+
+  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
+APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
+HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
+OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
+IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
+ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. Limitation of Liability.
+
+  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
+THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
+GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
+USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
+DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
+PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
+EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
+SUCH DAMAGES.
+
+  17. Interpretation of Sections 15 and 16.
+
+  If the disclaimer of warranty and limitation of liability provided
+above cannot be given local legal effect according to their terms,
+reviewing courts shall apply local law that most closely approximates
+an absolute waiver of all civil liability in connection with the
+Program, unless a warranty or assumption of liability accompanies a
+copy of the Program in return for a fee.
 
                      END OF TERMS AND CONDITIONS
 
@@ -287,15 +628,15 @@ free software which everyone can redistribute and change under these terms.
 
   To do so, attach the following notices to the program.  It is safest
 to attach them to the start of each source file to most effectively
-convey the exclusion of warranty; and each file should have at least
+state the exclusion of warranty; and each file should have at least
 the "copyright" line and a pointer to where the full notice is found.
 
     <one line to give the program's name and a brief idea of what it does.>
     Copyright (C) <year>  <name of author>
 
-    This program is free software; you can redistribute it and/or modify
+    This program is free software: you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
+    the Free Software Foundation, either version 3 of the License, or
     (at your option) any later version.
 
     This program is distributed in the hope that it will be useful,
@@ -303,37 +644,31 @@ the "copyright" line and a pointer to where the full notice is found.
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License along
-    with this program; if not, write to the Free Software Foundation, Inc.,
-    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 Also add information on how to contact you by electronic and paper mail.
 
-If the program is interactive, make it output a short notice like this
-when it starts in an interactive mode:
+  If the program does terminal interaction, make it output a short
+notice like this when it starts in an interactive mode:
 
-    Gnomovision version 69, Copyright (C) year name of author
-    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    <program>  Copyright (C) <year>  <name of author>
+    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
     This is free software, and you are welcome to redistribute it
     under certain conditions; type `show c' for details.
 
 The hypothetical commands `show w' and `show c' should show the appropriate
-parts of the General Public License.  Of course, the commands you use may
-be called something other than `show w' and `show c'; they could even be
-mouse-clicks or menu items--whatever suits your program.
-
-You should also get your employer (if you work as a programmer) or your
-school, if any, to sign a "copyright disclaimer" for the program, if
-necessary.  Here is a sample; alter the names:
-
-  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
-  `Gnomovision' (which makes passes at compilers) written by James Hacker.
-
-  <signature of Ty Coon>, 1 April 1989
-  Ty Coon, President of Vice
-
-This General Public License does not permit incorporating your program into
-proprietary programs.  If your program is a subroutine library, you may
-consider it more useful to permit linking proprietary applications with the
-library.  If this is what you want to do, use the GNU Lesser General
-Public License instead of this License.
+parts of the General Public License.  Of course, your program's commands
+might be different; for a GUI interface, you would use an "about box".
+
+  You should also get your employer (if you work as a programmer) or school,
+if any, to sign a "copyright disclaimer" for the program, if necessary.
+For more information on this, and how to apply and follow the GNU GPL, see
+<http://www.gnu.org/licenses/>.
+
+  The GNU General Public License does not permit incorporating your program
+into proprietary programs.  If your program is a subroutine library, you
+may consider it more useful to permit linking proprietary applications with
+the library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.  But first, please read
+<http://www.gnu.org/philosophy/why-not-lgpl.html>.
diff --git a/README.md b/README.md
index 7fdb82cd..02c185f5 100644
--- a/README.md
+++ b/README.md
@@ -11,7 +11,7 @@ Complex look ups can result in computationally expensive database queries.  Howe
 * Manual and Complete Documentation: [Documentation at Gamepedia Help Wiki](https://help.gamepedia.com/Extension:DPL3/Manual)
 * Source Code: [Source code at Gitlab](https://gitlab.com/hydrawiki/extensions/DynamicPageList)
 * Bugs and Feature Requests: [Issues at Gitlab](https://gitlab.com/hydrawiki/extensions/DynamicPageList/issues)
-* Licensing: DynamicPageList3 is released under [GNU General Public License, version 2](https://opensource.org/licenses/GPL-2.0).
+* Licensing: DynamicPageList3 is released under [GNU General Public License, version 3](https://opensource.org/licenses/GPL-3.0).
 
 
 ## Installation
diff --git a/composer.json b/composer.json
index fae1037b..ed71f5e1 100644
--- a/composer.json
+++ b/composer.json
@@ -3,7 +3,7 @@
 	"type": "mediawiki-extension",
 	"description": "The DynamicPageList3 extension allows creating lists of other articles based on their category, namespace, title, references or template usage and include contents or arguments of template calls of those articles into your page.",
 	"homepage": "https://www.mediawiki.org/wiki/Extension:DynamicPageList3",
-	"license": "GPL-2.0-or-later",
+	"license": "GPL-3.0-or-later",
 	"require": {
 		"composer/installers": ">=1.0.1"
 	},
@@ -12,22 +12,23 @@
 		"optimize-autoloader": true
 	},
 	"require-dev": {
-		"mediawiki/mediawiki-codesniffer": "35.0.0",
-		"mediawiki/mediawiki-phan-config": "0.10.6",
+		"mediawiki/mediawiki-codesniffer": "37.0.0",
+		"mediawiki/mediawiki-phan-config": "0.11.0",
 		"mediawiki/minus-x": "1.1.1",
 		"php-parallel-lint/php-console-highlighter": "0.5.0",
-		"php-parallel-lint/php-parallel-lint": "1.2.0"
+		"php-parallel-lint/php-parallel-lint": "1.3.1"
 	},
 	"scripts": {
-		"test": [
-			"parallel-lint . --exclude vendor --exclude node_modules",
-			"minus-x check .",
-			"phpcs -p -s"
-		],
 		"fix": [
 			"minus-x fix .",
-			"phpcbf"
+			"phpcbf; if [ $? -eq 1 ]; then exit 0; fi"
+		],
+		"test": [
+			"parallel-lint . --exclude node_modules --exclude vendor",
+			"minus-x check .",
+			"@phpcs"
 		],
-		"phan": "phan -d . --long-progress-bar"
+		"phan": "phan -d . --long-progress-bar",
+		"phpcs": "phpcs -sp --cache"
 	}
 }
diff --git a/extension.json b/extension.json
index 8a2f6dad..1a569254 100644
--- a/extension.json
+++ b/extension.json
@@ -1,6 +1,6 @@
 {
 	"name": "DynamicPageList3",
-	"version": "3.3.5",
+	"version": "3.3.6",
 	"author": [
 		"Alexia E. Smith",
 		"[https://meta.miraheze.org/wiki/User:Universal_Omega Universal Omega]",
@@ -8,10 +8,10 @@
 	],
 	"url": "https://www.mediawiki.org/wiki/Extension:DynamicPageList3",
 	"descriptionmsg": "dpl-desc",
-	"license-name": "GPL-2.0-or-later",
+	"license-name": "GPL-3.0-or-later",
 	"type": "parserhook",
 	"requires": {
-		"MediaWiki": ">= 1.35.0"
+		"MediaWiki": ">= 1.36.0"
 	},
 	"GroupPermissions": {
 		"sysop": {
@@ -29,7 +29,7 @@
 		]
 	},
 	"ExtensionMessagesFiles": {
-		"DynamicPageListMagic": "DynamicPageList.i18n.magic.php"
+		"DynamicPageListMagic": "includes/DynamicPageListMagic.php"
 	},
 	"AutoloadClasses": {
 		"DPL\\Article": "includes/Article.php",
@@ -57,14 +57,17 @@
 		"DPL\\Query": "includes/Query.php",
 		"DPL\\UpdateArticle": "includes/UpdateArticle.php",
 		"DPL\\Variables": "includes/Variables.php",
-		"DynamicPageListHooks": "DynamicPageListHooks.php"
+		"DPL\\RevisionJoinBuilder": "includes/RevisionJoinBuilder.php",
+		"DPL\\UserQueryBuilder": "includes/UserQueryBuilder.php",
+		"DPL\\DynamicPageListHooks": "includes/DynamicPageListHooks.php",
+		"DPL\\DPLIntegrationTestCase": "tests/phpunit/DPLIntegrationTestCase.php"
 	},
 	"Hooks": {
 		"ParserFirstCallInit": [
-			"DynamicPageListHooks::onParserFirstCallInit"
+			"DPL\\DynamicPageListHooks::onParserFirstCallInit"
 		],
 		"LoadExtensionSchemaUpdates": [
-			"DynamicPageListHooks::onLoadExtensionSchemaUpdates"
+			"DPL\\DynamicPageListHooks::onLoadExtensionSchemaUpdates"
 		]
 	},
 	"config": {
@@ -95,6 +98,5 @@
 		"dplchapter-parserfunc-tracking-category",
 		"dplmatrix-parserfunc-tracking-category"
 	],
-	"callback": "DynamicPageListHooks::onRegistration",
 	"manifest_version": 1
 }
diff --git a/i18n/af.json b/i18n/af.json
deleted file mode 100644
index ebdf6d31..00000000
--- a/i18n/af.json
+++ /dev/null
@@ -1,10 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Naudefj"
-        ]
-    },
-    "intersection_toomanycats": "Fout: Te veel kategorieë!",
-    "intersection_toofewcats": "Fout: Te min kategorieë!",
-    "intersection_noresults": "Fout: Geen resultate!"
-}
\ No newline at end of file
diff --git a/i18n/an.json b/i18n/an.json
deleted file mode 100644
index 7fe2fe06..00000000
--- a/i18n/an.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Juanpabl"
-        ]
-    },
-    "intersection-desc": "Preduz una lista d'os elementos más rezients que bi ha en una categoría u a unión de barios categorías",
-    "intersection_toomanycats": "Error: Masiadas categorías!",
-    "intersection_toofewcats": "Error: numero insufizient de categorías!",
-    "intersection_noresults": "Error: No bi ha garra resultau!",
-    "intersection_noincludecats": "Error: Ha d'encluyir á lo menos una categoría u endicar un espazio de nombres!"
-}
\ No newline at end of file
diff --git a/i18n/ar.json b/i18n/ar.json
deleted file mode 100644
index 3f4b0815..00000000
--- a/i18n/ar.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Meno25"
-        ]
-    },
-    "intersection-desc": "يخرج قائمة معلمة بأحدث المدخلات الساكنة في تصنيف، أو اتحاد عدة تصنيفات",
-    "intersection_toomanycats": "خطأ: تصنيفات كثيرة جدا!",
-    "intersection_toofewcats": "خطأ: تصنيفات قليلة جدا!",
-    "intersection_noresults": "خطأ: لا نتائج!",
-    "intersection_noincludecats": "خطأ: ينبغي أن تضمن تصنيفا واحدا على الأقل، أو تحدد نطاقا!"
-}
\ No newline at end of file
diff --git a/i18n/arz.json b/i18n/arz.json
deleted file mode 100644
index c8edb502..00000000
--- a/i18n/arz.json
+++ /dev/null
@@ -1,13 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Meno25",
-            "Ramsis II"
-        ]
-    },
-    "intersection-desc": "بيطلع لستة مترقمة لاحدث الحاجات الموجودة فى تصنيف,او اتحاد اكتر من تصنيف",
-    "intersection_toomanycats": "غلط:تصانيف كتيرة خالص!",
-    "intersection_toofewcats": "غلط:تصانيف قليلة خالص!",
-    "intersection_noresults": "غلط:مافيش نتايج!",
-    "intersection_noincludecats": "غلط: لازم تحط تصنيف واحد على الأقل، أو تحدد نطاق!"
-}
\ No newline at end of file
diff --git a/i18n/ast.json b/i18n/ast.json
deleted file mode 100644
index d8fb3a39..00000000
--- a/i18n/ast.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Esbardu"
-        ]
-    },
-    "intersection-desc": "Amuesa una llista de los elementos más recién que tenga una categoría o una xuntanza de varies categoríes",
-    "intersection_toomanycats": "Error: ¡Demasiaes categoríes!",
-    "intersection_toofewcats": "Error: ¡Demasiaes poques categoríes!",
-    "intersection_noresults": "Error: ¡Nun hai resultaos!",
-    "intersection_noincludecats": "Error: ¡Necesites amiestar a lo menos una categoría, o especificar un espaciu de nomes!"
-}
\ No newline at end of file
diff --git a/i18n/bcc.json b/i18n/bcc.json
deleted file mode 100644
index b649694f..00000000
--- a/i18n/bcc.json
+++ /dev/null
@@ -1,11 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Mostafadaneshvar"
-        ]
-    },
-    "intersection_toomanycats": "DynamicPageList: بازگین دسته جات!",
-    "intersection_toofewcats": "DynamicPageList: باز کمین دسته جات!",
-    "intersection_noresults": "DynamicPageList: هچ نتیجه ای",
-    "intersection_noincludecats": "لیست صفحات دینامیکی: شما لازمنت حداقل یک دسته هور کنیت یا یک نام فضایی مشخص کنیت!"
-}
\ No newline at end of file
diff --git a/i18n/be-tarask.json b/i18n/be-tarask.json
deleted file mode 100644
index 03a089df..00000000
--- a/i18n/be-tarask.json
+++ /dev/null
@@ -1,13 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "EugeneZelenko",
-            "Jim-by"
-        ]
-    },
-    "intersection-desc": "Выводзіць у маркіраваны сьпіс апошнія дабаўленьні да катэгорыі альбо аб'ядноўвае некалькі катэгорыяў",
-    "intersection_toomanycats": "Памылка: Зашмат катэгорыяў!",
-    "intersection_toofewcats": "Памылка: Занадта мала катэгорыяў!",
-    "intersection_noresults": "Памылка: Няма вынікаў!",
-    "intersection_noincludecats": "Памылка: Вам неабходна ўключыць хаця б адну катэгорыю альбо ўказаць прастору назваў!"
-}
\ No newline at end of file
diff --git a/i18n/bg.json b/i18n/bg.json
deleted file mode 100644
index 41f1898c..00000000
--- a/i18n/bg.json
+++ /dev/null
@@ -1,13 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "DCLXVI",
-            "Spiritia"
-        ]
-    },
-    "intersection-desc": "Извежда списък на най-скорошните записи в дадена категория или сечение на няколко категории",
-    "intersection_toomanycats": "Error: Твърде много категории!",
-    "intersection_toofewcats": "Error: Твърде малко категории!",
-    "intersection_noresults": "Error: Няма резултати!",
-    "intersection_noincludecats": "Error: Необходимо е да се включи поне една категория или да се посочи именно пространство!"
-}
\ No newline at end of file
diff --git a/i18n/bn.json b/i18n/bn.json
deleted file mode 100644
index c09714c3..00000000
--- a/i18n/bn.json
+++ /dev/null
@@ -1,11 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Bellayet"
-        ]
-    },
-    "intersection_toomanycats": "Error: অনেক বেশি বিষয়শ্রেণী!",
-    "intersection_toofewcats": "Error: অনেক কম বিষয়শ্রেণী!",
-    "intersection_noresults": "Error: ফলাফল নাই!",
-    "intersection_noincludecats": "ত্রুটি:আপনার অন্তত একটি বিষয়শ্রেণী যুক্ত করতে, অথবা একটি নেমস্পেস দিতে হবে!"
-}
\ No newline at end of file
diff --git a/i18n/br.json b/i18n/br.json
deleted file mode 100644
index 77c8e4d3..00000000
--- a/i18n/br.json
+++ /dev/null
@@ -1,10 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Fulup"
-        ]
-    },
-    "intersection_toomanycats": "Error: Re a rummadoù !",
-    "intersection_toofewcats": "Error: Re nebeut a rummadoù !",
-    "intersection_noresults": "Error: Disoc'h ebet !"
-}
\ No newline at end of file
diff --git a/i18n/bs.json b/i18n/bs.json
deleted file mode 100644
index f0f2a2bb..00000000
--- a/i18n/bs.json
+++ /dev/null
@@ -1,13 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "CERminator",
-            "Seha"
-        ]
-    },
-    "intersection-desc": "Izbacuje listu najčešćih tačaka koje se nalaze u kategoriji ili u sekciji nekoliko kategorija.",
-    "intersection_toomanycats": "Greška: Previše kategorija!",
-    "intersection_toofewcats": "Greška: Premalo kategorija!",
-    "intersection_noresults": "Greška: Nema rezultata!",
-    "intersection_noincludecats": "Greška: Potrebno je da uključite najmanje jednu kategoriju ili odredite imenski prostor!"
-}
\ No newline at end of file
diff --git a/i18n/ca.json b/i18n/ca.json
deleted file mode 100644
index 256e6bb5..00000000
--- a/i18n/ca.json
+++ /dev/null
@@ -1,13 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Paucabot",
-            "SMP"
-        ]
-    },
-    "intersection-desc": "Genera una llista d'elements recents en una categoria o en la intersecció de diverses.",
-    "intersection_toomanycats": "Error: Massa categories!",
-    "intersection_toofewcats": "Error: Massa poques categories!",
-    "intersection_noresults": "Error: Cap resultat!",
-    "intersection_noincludecats": "Error: Heu d'incloure almenys una categoria o especificar un espai de noms!"
-}
\ No newline at end of file
diff --git a/i18n/cs.json b/i18n/cs.json
deleted file mode 100644
index 97aa5ee3..00000000
--- a/i18n/cs.json
+++ /dev/null
@@ -1,13 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Li-sung",
-            "Matěj Grabovský"
-        ]
-    },
-    "intersection-desc": "Vypíše seznam nejnovějších položek v kategorii nebo sjednotí několik kategorií",
-    "intersection_toomanycats": "Error: Příliš mnoho kategorií!",
-    "intersection_toofewcats": "Error: Málo kategorií!",
-    "intersection_noresults": "Error: Žádné výsledky!",
-    "intersection_noincludecats": "Error: Musíte zahrnout alespoň jednu kategorii nebo určit jmenný prostor!"
-}
\ No newline at end of file
diff --git a/i18n/de.json b/i18n/de.json
deleted file mode 100644
index 89514d29..00000000
--- a/i18n/de.json
+++ /dev/null
@@ -1,49 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Gero Scholz",
-            "MarkusRost"
-        ]
-    },
-    "intersection-desc": "Ausgabe einer Liste der aktuellsten Einträge in einer Kategorie, oder der Schnittmenge mehrerer Kategorien",
-    "intersection_toomanycats": "Fehler: Zu viele Kategorien!",
-    "intersection_toofewcats": "Fehler: Zu wenige Kategorien!",
-    "intersection_noresults": "Fehler: Kein Ergebnis!",
-    "intersection_noincludecats": "Fehler: Es muss mindestens eine Kategorie eingebunden werden oder ein Namensraum angegeben sein!",
-    "dpl_log_1": "Fehler: bei „$1“ Parameter: „$2“! Hilfe:  <code>$1= <i>(leer)</i> (Hauptnamensraum)$3</code>.",
-    "dpl_log_2": "Fehler: bei „$1“ Parameter: „$2“! Hilfe:  <code>$1= <i>vollständiger Seitenname</i></code>.",
-    "dpl_log_3": "Fehler: Zu viele Kategorien! Maximum: $1.",
-    "dpl_log_4": "Fehler: Zu wenige Kategorien! Minimum: $1.",
-    "dpl_log_5": "Fehler: Keine Auswahlkriterien angegeben! Mindestens einer der folgenden Parameter ist erforderlich: category, namespace, titlematch, linksto, uses, createdby, modifiedby, lastmodifiedby oder die „not“-Varianten davon.",
-    "dpl_log_6": "Fehler: Sie müssen mindestens eine Kategorie angeben, wenn Sie „addfirstcategorydate=true“ oder „ordermethod=categoryadd“ benutzen.",
-    "dpl_log_7": "Fehler: Wenn Sie mehr als eine Kategorie angeben, können Sie „addfirstcategorydate=true“ oder „ordermethod=categoryadd“ nicht benutzen.",
-    "dpl_log_8": "Fehler: Es ist nur eine einzige Art der Datumsangabe gleichzeitig möglich.",
-    "dpl_log_9": "Fehler: Der Parameter „$1“ muss in Verbindung mit „ordermethod=[ $2 ]“ benutzt werden.",
-    "dpl_log_10": "Fehler: Die Indexangabe bei „dominantsection“ muss zwischen 1 und  der Anzahl der Argumente von „includepage“ liegen ($0 in diesem Fall).",
-    "dpl_log_11": "Fehler: Kann keine logischen Operationen an nicht kategorisierten Seiten ausführen (z.&nbsp;B. mit dem „category“ Parameter) weil die „$0“-Ansicht nicht in der Datenbank vorhanden ist!",
-    "dpl_log_12": "Fehler: Die Angabe von „openreferences“ ist nicht vereinbar mit anderen angegegeben Optionen. Entferne die anderen Optionen oder „openreferences“. Details dazu stehen im DPL-Manual.",
-    "dpl_log_13": "Warnung: Der unbekannte Parameter „$1“ wurde ignoriert. Hilfe: Verfügbare Parameter: <code>$2</code>.",
-    "dpl_log_14": "Warnung: Überspringe die ungültige Option „$2“ für den Parameter „$1“.",
-    "dpl_log_15": "Warnung: Falscher „$1“-Parameter: „$2“! Standardwert wird verwendet: „$3“ (unbegrenzt). Hilfe: <code>$1= <i>(leer)</i> (unbegrenzt) | n</code>, wobei <code>n</code> eine positive Ganzzahl sein muss.",
-    "dpl_log_16": "Warnung: Keine Ergebnisse.",
-    "dpl_log_17": "Warnung: Add* Parameter („adduser“, „addeditdate“, usw.) und „includepage“ haben keinen Effekt in Verbindung mit „mode=category“. Es kann nur der Seitentitel und Namensraum angezeigt werden.",
-    "dpl_log_18": "Warnung: „headingmode=$1“ hat keinen Effekt, wenn „ordermethod“ sich auf eine einzelne Komponente bezieht. Es wird „$2“ verwendet. Hilfe: Sie können not-$1 „headingmode“ Werte in Verbindung mit „ordermethod“ für mehrfache Komponenten verwenden. Die erste Konponente wird für Gruppen verwendet. Z.&nbsp;B. „ordermethod=category,<i>comp</i>“ (<i>comp</i> ist eine andere Komponente) für Kategorie-Gruppen.",
-    "dpl_log_19": "Warnung: „debug=$1“ steht nicht an erster Stelle in der DPL-Anweisung. Die Einstellung wird erst wirksam, nachdem die vorausgehenden Parameter geprüft und verarbeitet sind.",
-    "dpl_log_20": "Warnung: Endlosschleife beim Einbinden von Inhalten der Seite „$0“.",
-    "dpl_log_21": "Datenbank-Abfrage: <code>$0</code>",
-    "dpl_log_22": "Warnung: Keine Parameter-Option angegeben für „$1“. („=“ fehlt)",
-    "dpl_articlecount": "Diese Gruppe enthält {{PLURAL:$1|einen|$1}} Artikel.",
-    "action-dpl_param_update_rules": "um den Parameter „updaterules“ zu nutzen",
-    "action-dpl_param_delete_rules": "um den Parameter „deleterules“ zu nutzen",
-    "dpl_query_error": "Die DPL-Erweiterung (Version $1) produzierte ein SQL-Statement, was zu einem Datenbank-Fehler führte.<br/>Der Grund könnte ein interner Fehler von DPL sein oder ein Fehler deinerseits; besonders beim Nutzen von Parametern wie „categoryregexp“ oder „titleregexp“.  Die Verwendung von non-greedy *? matching patterns werden nicht unterstützt.<br/>Fehlermeldung:<br/><code>$2</code>",
-    "dpl-tag-tracking-category": "Seiten, die DynamicPageList parser tag nutzen",
-    "dpl-intersection-tracking-category": "Seiten, die DynamicPageList Intersection parser tag nutzen",
-    "dpl-parserfunc-tracking-category": "Seiten, die DynamicPageList parser function nutzen",
-    "dplnum-parserfunc-tracking-category": "Seiten, die DynamicPageList dplnum parser function nutzen",
-    "dplvar-parserfunc-tracking-category": "Seiten, die DynamicPageList dplvar parser function nutzen",
-    "dplreplace-parserfunc-tracking-category": "Seiten, die DynamicPageList dplreplace parser function nutzen",
-    "dplchapter-parserfunc-tracking-category": "Seiten, die DynamicPageList dplchapter parser function nutzen",
-    "dplmatrix-parserfunc-tracking-category": "Seiten, die DynamicPageList dplmatrix parser function nutzen",
-    "right-dpl_param_delete_rules": "Massenlöschungen von Seiten, die DPL nutzen",
-    "right-dpl_param_update_rules": "Massenänderungen von Seiten, die DPL nutzen"
-}
\ No newline at end of file
diff --git a/i18n/dsb.json b/i18n/dsb.json
deleted file mode 100644
index 13cd527f..00000000
--- a/i18n/dsb.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Michawiki"
-        ]
-    },
-    "intersection-desc": "Wudawa lisćina nejaktualnjejšych zapiskow w kategoriji abo zgromadneje młogosći někotarych kategorijow",
-    "intersection_toomanycats": "Zmólka: Pśewjele kategorijow!",
-    "intersection_toofewcats": "Zmólka: Pśemało kategorijow!",
-    "intersection_noresults": "Zmólka: Žedne wuslědki!",
-    "intersection_noincludecats": "Zmólka: Musyš nanejmjenjej jadnu kategoriju zapśěgnuś abo mjenjowy rum pódaś!"
-}
\ No newline at end of file
diff --git a/i18n/el.json b/i18n/el.json
deleted file mode 100644
index 9aca7805..00000000
--- a/i18n/el.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Dead3y3"
-        ]
-    },
-    "intersection-desc": "Έχει ως έξοδο μια μη αριθμημένη λίστα των πιο πρόσφατων στοιχείων σε μια κατηγορία, ή μια τομή μερικών κατηγοριών",
-    "intersection_toomanycats": "Σφάλμα: Πάρα πολλές κατηγορίες!",
-    "intersection_toofewcats": "Σφάλμα: Πολύ λίγες κατηγορίες!",
-    "intersection_noresults": "Σφάλμα: Δεν υπάρχουν αποτελέσματα!",
-    "intersection_noincludecats": "Σφάλμα: Πρέπει να περιλάβετε τουλάχιστον μία κατηγορία, ή να ορίσετε μια περιοχή ονομάτων!"
-}
\ No newline at end of file
diff --git a/i18n/en.json b/i18n/en.json
index 31c03ccf..26a94fb0 100644
--- a/i18n/en.json
+++ b/i18n/en.json
@@ -1,50 +1,51 @@
 {
-    "@metadata": {
-        "authors": [
-            "m:User:Dangerman <cyril.dangerville@gmail.com>"
-        ]
-    },
-    "intersection-desc": "Outputs a bulleted list of the most recent items residing in a category, or an intersection of several categories",
-    "intersection_toomanycats": "Error: Too many categories!",
-    "intersection_toofewcats": "Error: Too few categories!",
-    "intersection_noresults": "Error: No results!",
-    "intersection_noincludecats": "Error: You need to include at least one category, or specify a namespace!",
-    "dpl-desc": "A highly flexible report generator for MediaWikis",
-    "dpl_log_1": "Error: Wrong '$1' parameter: '$2'! Help:  <code>$1= <i>empty string</i> (Main)$3</code>.",
-    "dpl_log_2": "Error: Wrong '$1' parameter: '$2'! Help:  <code>$1= <i>full pagename</i></code>.",
-    "dpl_log_3": "Error: Too many categories! Maximum: $1. Help: increase <code>$wgDplSettings['maxCategoryCount']</code> to specify more categories or set <code>$wgDplSettings['allowUnlimitedCategories'] = true;</code> for no limitation. (Set the variable in the wiki's <code>LocalSettings.php</code> configuration file.)",
-    "dpl_log_4": "Error: Too few categories! Minimum: $1. Help: decrease <code>$wgDplSettings['minCategoryCount']</code> to specify fewer categories. (Set the variable in the wiki's <code>LocalSettings.php</code> configuration file.)",
-    "dpl_log_5": "Error: No selection criteria found! You must use at least one of the following parameters: category, namespace, titlematch, linksto, uses, createdby, modifiedby, lastmodifiedby, or their 'not' variants",
-    "dpl_log_6": "Error: At least one category must be chosen if to use 'addfirstcategorydate=true' or 'ordermethod=categoryadd'.",
-    "dpl_log_7": "Error: If you include more than one category, you cannot use 'addfirstcategorydate=true' or 'ordermethod=categoryadd'.",
-    "dpl_log_8": "Error: Only one date type can be added at a time.",
-    "dpl_log_9": "Error: The paramater '$1' must be used with 'ordermethod=[ $2 ]'",
-    "dpl_log_10": "Error: the index for the dominant section must be between 1 and the number of arguments of includepage ($0 in this case)",
-    "dpl_log_11": "Error: Cannot perform logical operations on the Uncategorized pages (f.e. with the 'category' parameter) because the $0 view does not exist on the database! Help: have the database administrator execute this query: <code>$1</code>.",
-    "dpl_log_12": "Error: specifying \"openreferences\" is incompatible with another option specified.  Please remove that other option or \"openreferences\".  See the manual for details.",
-    "dpl_log_13": "Warning: Unknown parameter '$1' was ignored. Help: available parameters: <code>$2</code>.",
-    "dpl_log_14": "Warning: Skipping bad option '$2' for parameter '$1'.",
-    "dpl_log_15": "Warning: Wrong '$1' parameter: '$2'! Using default: '$3' (no limit). Help: <code>$1= <i>empty string</i> (no limit) | n</code>, with <code>n</code> a positive integer.",
-    "dpl_log_16": "Warning: No results.",
-    "dpl_log_17": "Warning: Add* parameters ('adduser', 'addeditdate', etc.)' and 'includepage' have no effect with 'mode=category'. Only the page namespace/title can be viewed in this mode.",
-    "dpl_log_18": "Warning: 'headingmode=$1' has no effect with 'ordermethod' on a single component. Using: '$2'. Help: you can use not-$2 'headingmode' values with 'ordermethod' on multiple components. The first component is used for headings. E.g. 'ordermethod=category,<i>comp</i>' (<i>comp</i> is another component) for category headings.",
-    "dpl_log_19": "Warning: 'debug=$1' is not in first position in the DPL element. The new debug settings are not applied before all previous parameters have been parsed and checked.",
-    "dpl_log_20": "Warning: An infinite transclusion loop is created by page '$0'.",
-    "dpl_log_21": "Query: <code>$0</code>",
-    "dpl_log_22": "Warning: No parameter option supplied for '$1'. (Missing '=')",
-    "dpl_articlecount": "There {{PLURAL:$1|is one article|are $1 articles}} in this heading.",
-    "dpl_description": "A flexible report generator for MediaWiki. See [http://semeb.com/dpldemo] for the manual and examples",
-    "action-dpl_param_update_rules": "to use the parameter 'updaterules'",
-    "action-dpl_param_delete_rules": "to use the parameter 'deleterules'",
-    "dpl_query_error": "The DPL extension (version $1) produced a SQL statement which led to a Database error.<br/>The reason may be an internal error of DPL or an error which you made; especially when using parameters like 'categoryregexp' or 'titleregexp'.  Usage of non-greedy *? matching patterns are not supported.<br/>Error message was:<br/><tt>$2</tt>",
-    "dpl-tag-tracking-category": "Pages using DynamicPageList parser tag",
-    "dpl-intersection-tracking-category": "Pages using DynamicPageList Intersection parser tag",
-    "dpl-parserfunc-tracking-category": "Pages using DynamicPageList parser function",
-    "dplnum-parserfunc-tracking-category": "Pages using DynamicPageList dplnum parser function",
-    "dplvar-parserfunc-tracking-category": "Pages using DynamicPageList dplvar parser function",
-    "dplreplace-parserfunc-tracking-category": "Pages using DynamicPageList dplreplace parser function",
-    "dplchapter-parserfunc-tracking-category": "Pages using DynamicPageList dplchapter parser function",
-    "dplmatrix-parserfunc-tracking-category": "Pages using DynamicPageList dplmatrix parser function",
-    "right-dpl_param_delete_rules": "Mass deletion of pages using DPL",
-    "right-dpl_param_update_rules": "Mass update of pages using DPL"
-}
\ No newline at end of file
+	"@metadata": {
+		"authors": [
+			"Dangerman",
+			"Universal Omega"
+		]
+	},
+	"intersection-desc": "Outputs a bulleted list of the most recent items residing in a category, or an intersection of several categories",
+	"intersection_toomanycats": "Error: Too many categories!",
+	"intersection_toofewcats": "Error: Too few categories!",
+	"intersection_noresults": "Error: No results!",
+	"intersection_noincludecats": "Error: You need to include at least one category, or specify a namespace!",
+	"dpl-desc": "A highly flexible report generator for MediaWikis",
+	"dpl_log_1": "Error: Wrong '$1' parameter: '$2'! Help: <code>$1= <i>empty string</i> (Main)$3</code>.",
+	"dpl_log_2": "Error: Wrong '$1' parameter: '$2'! Help: <code>$1= <i>full pagename</i></code>.",
+	"dpl_log_3": "Error: Too many categories! Maximum: $1. Help: increase <code>$wgDplSettings['maxCategoryCount']</code> to specify more categories or set <code>$wgDplSettings['allowUnlimitedCategories'] = true;</code> for no limitation. (Set the variable in the wiki's <code>LocalSettings.php</code> configuration file.)",
+	"dpl_log_4": "Error: Too few categories! Minimum: $1. Help: decrease <code>$wgDplSettings['minCategoryCount']</code> to specify fewer categories. (Set the variable in the wiki's <code>LocalSettings.php</code> configuration file.)",
+	"dpl_log_5": "Error: No selection criteria found! You must use at least one of the following parameters: category, namespace, titlematch, linksto, uses, createdby, modifiedby, lastmodifiedby, or their 'not' variants",
+	"dpl_log_6": "Error: At least one category must be chosen if to use 'addfirstcategorydate=true' or 'ordermethod=categoryadd'.",
+	"dpl_log_7": "Error: If you include more than one category, you cannot use 'addfirstcategorydate=true' or 'ordermethod=categoryadd'.",
+	"dpl_log_8": "Error: Only one date type can be added at a time.",
+	"dpl_log_9": "Error: The paramater '$1' must be used with 'ordermethod=[ $2 ]'",
+	"dpl_log_10": "Error: the index for the dominant section must be between 1 and the number of arguments of includepage ($0 in this case)",
+	"dpl_log_11": "Error: Cannot perform logical operations on the Uncategorized pages (f.e. with the 'category' parameter) because the $0 view does not exist on the database! Help: have the database administrator execute this query: <code>$1</code>.",
+	"dpl_log_12": "Error: specifying \"openreferences\" is incompatible with another option specified. Please remove that other option or \"openreferences\". See the manual for details.",
+	"dpl_log_13": "Warning: Unknown parameter '$1' was ignored. Help: available parameters: <code>$2</code>.",
+	"dpl_log_14": "Warning: Skipping bad option '$2' for parameter '$1'.",
+	"dpl_log_15": "Warning: Wrong '$1' parameter: '$2'! Using default: '$3' (no limit). Help: <code>$1= <i>empty string</i> (no limit) | n</code>, with <code>n</code> a positive integer.",
+	"dpl_log_16": "Warning: No results.",
+	"dpl_log_17": "Warning: Add* parameters ('adduser', 'addeditdate', etc.)' and 'includepage' have no effect with 'mode=category'. Only the page namespace/title can be viewed in this mode.",
+	"dpl_log_18": "Warning: 'headingmode=$1' has no effect with 'ordermethod' on a single component. Using: '$2'. Help: you can use not-$2 'headingmode' values with 'ordermethod' on multiple components. The first component is used for headings. E.g. 'ordermethod=category,<i>comp</i>' (<i>comp</i> is another component) for category headings.",
+	"dpl_log_19": "Warning: 'debug=$1' is not in first position in the DPL element. The new debug settings are not applied before all previous parameters have been parsed and checked.",
+	"dpl_log_20": "Warning: An infinite transclusion loop is created by page '$0'.",
+	"dpl_log_21": "Query: <code>$0</code>",
+	"dpl_log_22": "Warning: No parameter option supplied for '$1'. (Missing '=')",
+	"dpl_articlecount": "There {{PLURAL:$1|is one article|are $1 articles}} in this heading.",
+	"dpl_description": "A flexible report generator for MediaWiki. See [http://semeb.com/dpldemo] for the manual and examples",
+	"action-dpl_param_update_rules": "to use the parameter 'updaterules'",
+	"action-dpl_param_delete_rules": "to use the parameter 'deleterules'",
+	"dpl_query_error": "The DPL extension (version $1) produced a SQL statement which led to a Database error.<br/>The reason may be an internal error of DPL or an error which you made; especially when using parameters like 'categoryregexp' or 'titleregexp'. Usage of non-greedy *? matching patterns are not supported.<br/>Error message was:<br/><tt>$2</tt>",
+	"dpl-tag-tracking-category": "Pages using DynamicPageList parser tag",
+	"dpl-intersection-tracking-category": "Pages using DynamicPageList Intersection parser tag",
+	"dpl-parserfunc-tracking-category": "Pages using DynamicPageList parser function",
+	"dplnum-parserfunc-tracking-category": "Pages using DynamicPageList dplnum parser function",
+	"dplvar-parserfunc-tracking-category": "Pages using DynamicPageList dplvar parser function",
+	"dplreplace-parserfunc-tracking-category": "Pages using DynamicPageList dplreplace parser function",
+	"dplchapter-parserfunc-tracking-category": "Pages using DynamicPageList dplchapter parser function",
+	"dplmatrix-parserfunc-tracking-category": "Pages using DynamicPageList dplmatrix parser function",
+	"right-dpl_param_delete_rules": "Mass deletion of pages using DPL",
+	"right-dpl_param_update_rules": "Mass update of pages using DPL"
+}
diff --git a/i18n/eo.json b/i18n/eo.json
deleted file mode 100644
index ff80baa8..00000000
--- a/i18n/eo.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Yekrats"
-        ]
-    },
-    "intersection-desc": "Eligas bulpunktitan liston de la plej lastaj kategorianoj, aŭ unuigo de pluraj kategorioj",
-    "intersection_toomanycats": "Eraro: Tro da kategorioj!",
-    "intersection_toofewcats": "Error: Tro malmultaj da kategorioj!",
-    "intersection_noresults": "Error: Neniom da rezultoj!",
-    "intersection_noincludecats": "Error: Vi devas inkluzivi almenaŭ unu kategorion, aŭ specifigu nomspacon!"
-}
\ No newline at end of file
diff --git a/i18n/es.json b/i18n/es.json
deleted file mode 100644
index b0d59238..00000000
--- a/i18n/es.json
+++ /dev/null
@@ -1,14 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Aleator",
-            "Remember the dot",
-            "Sanbec"
-        ]
-    },
-    "intersection-desc": "Devuelve una lista de los elementos más recientes que están en una categoría o en una intersección de varias categorías",
-    "intersection_toomanycats": "¡Error: Demasiadas categorías!",
-    "intersection_toofewcats": "Error: ¡Muy pocas categorías!",
-    "intersection_noresults": "Error: ¡Sin resultados!",
-    "intersection_noincludecats": "Error: ¡Necesita incluir al menos una categoría, o especificar un espacio de nombres!"
-}
\ No newline at end of file
diff --git a/i18n/eu.json b/i18n/eu.json
deleted file mode 100644
index 1fb9c77e..00000000
--- a/i18n/eu.json
+++ /dev/null
@@ -1,11 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "An13sa"
-        ]
-    },
-    "intersection_toomanycats": "Errorea: Kategoria gehiegi!",
-    "intersection_toofewcats": "Errorea: Kategoria gutxiegi!",
-    "intersection_noresults": "Errorea: Emaitzarik ez!",
-    "intersection_noincludecats": "Errorea: Gutxienez kategoria bat gehitu edo izen bat zehaztu behar duzu!"
-}
\ No newline at end of file
diff --git a/i18n/fa.json b/i18n/fa.json
deleted file mode 100644
index 417748a1..00000000
--- a/i18n/fa.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Huji"
-        ]
-    },
-    "intersection-desc": "فهرست گلوله‌ای از صفحه‌هایی به نمایش در می‌آورد که به تازگی در یک یا چند رده وارد شده‌اند",
-    "intersection_toomanycats": "DynamicPageList: تعداد رده‌ها زیاد است!",
-    "intersection_toofewcats": "DynamicPageList: تعداد رده‌ها کم است!",
-    "intersection_noresults": "DynamicPageList: نتیجه‌ای وجود ندارد!",
-    "intersection_noincludecats": "DynamicPageList: شما حداقل باید یک رده را وارد کنید، یا یک فضای نام را مشخص کنید!"
-}
\ No newline at end of file
diff --git a/i18n/fi.json b/i18n/fi.json
deleted file mode 100644
index ef5cf1f5..00000000
--- a/i18n/fi.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Nike"
-        ]
-    },
-    "intersection-desc": "Tulostaa listan luokassa tai useamman luokan yhdisteessä olevista sivuista.",
-    "intersection_toomanycats": "Error: Liian monta luokkaa.",
-    "intersection_toofewcats": "Error: Liian vähän luokkia.",
-    "intersection_noresults": "Error: Ei tuloksia.",
-    "intersection_noincludecats": "Error: Lisää vähintään yksi luokka tai määritä nimiavaruus."
-}
\ No newline at end of file
diff --git a/i18n/fr.json b/i18n/fr.json
deleted file mode 100644
index 87f31d29..00000000
--- a/i18n/fr.json
+++ /dev/null
@@ -1,36 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Grondin",
-            "Urhixidur",
-            "Verdy p"
-        ]
-    },
-    "intersection-desc": "Affiche une liste, à puces, des articles les plus récents dans une catégorie, ou à partir d’une combinaison de plusieurs catégories.",
-    "intersection_toomanycats": "DynamicPageList : trop de catégories !",
-    "intersection_toofewcats": "DynamicPageList : pas assez de catégories !",
-    "intersection_noresults": "DynamicPageList : aucun résultat !",
-    "intersection_noincludecats": "Error : vous devez inclure au moins une catégorie, ou préciser un nom d’espace !",
-    "dpl_log_1": "ERREUR : Mauvais paramètre '$0' : '$1'! Aide :  <code>$0= <i>chaîne vide</i> (Principal)$3</code>. (Les équivalents avec des mots magiques sont aussi autorisés.)",
-    "dpl_log_2": "ERREUR : Mauvais paramètre '$0' : '$1'! Aide :  <code>$0= <i>Nom complet de la page</i></code>. (Les mots magiques sont autorisés.)",
-    "dpl_log_3": "ERREUR : Trop de catégories ! Maximum : $0. Aide : accroître <code>DynamicPageListHooks::$maxCategoryCount</code> pour autoriser plus de catégories ou régler <code>DynamicPageListHooks::$allowUnlimitedCategories=true</code> pour aucune limite. (À régler dans <code>LocalSettings.php</code>, après avoir inclus <code>DynamicPageList.php</code>.)",
-    "dpl_log_4": "ERREUR : Pas assez de catégories ! Minimum : $0. Aide : décroître <code>DynamicPageListHooks::$minCategoryCount</code> pour autoriser moins de catégories. (À régler dans <code>LocalSettings.php</code> de préférence, après avoir inclus <code>DynamicPageList.php</code>.)",
-    "dpl_log_5": "ERROR: No selection criteria found! You must use at least one of the following parameters: category, namespace, titlematch, linksto, uses, createdby, modifiedby, lastmodifiedby, or their 'not' variants",
-    "dpl_log_6": "ERREUR : Vous devez inclure au moins une catégorie si vous voulez utiliser 'addfirstcategorydate=true' ou 'ordermethod=categoryadd' !",
-    "dpl_log_7": "ERREUR : Si vous incluez plus d’une catégorie, vous ne pouvez pas utiliser 'addfirstcategorydate=true' ou 'ordermethod=categoryadd' !",
-    "dpl_log_8": "ERREUR : Vous ne pouvez pas utiliser plus d’un type de date à la fois !",
-    "dpl_log_9": "ERREUR : Vous ne pouvez utiliser '$0' qu’avec 'ordermethod=[...,]$1' !",
-    "dpl_log_10": "ERROR: the index for the dominant section must be between 1 and the number of arguments of includepage ($0 in this case)",
-    "dpl_log_11": "ERREUR : Ne peut pas effectuer d’opérations logiques sur les pages sans catégories (avec la paramètre 'category') car la vue $0 n’existe pas dans la base de données ! Aide : demander à un administrateur de la base de données d'effectuer : <code>$1</code>.",
-    "dpl_log_12": "ERROR: specifying \"openreferences\" is incompatible with some other option you specified. See the manual for details.",
-    "dpl_log_13": "AVERTISSEMENT : Le paramètre inconnu '$1' est ignoré. Aide : paramètres disponibles : <code>$2</code>.",
-    "dpl_log_14": "AVERTISSEMENT : Mauvais paramètre '$0' : '$1'! Utilisation de la valeur par défaut : '$2'. Aide : <code>$0= $3</code>.",
-    "dpl_log_15": "AVERTISSEMENT : Mauvais paramètre '$0' : '$1'! Utilisattion de la valeur par défaut : '$2' (aucune limite). Aide : <code>$0= <i>chaîne vide</i> (aucune limite) | n</code>, avec <code>n</code> un entier positif.",
-    "dpl_log_16": "AVERTISSEMENT : Aucun résultat !",
-    "dpl_log_17": "AVERTISSEMENT : Les paramètres Add* ('adduser', 'addeditdate', etc.)' et 'includepage' n’ont aucun effet avec 'mode=category'. Seuls l’espace de nom et le titre de la page peuvent être vus dans ce mode..",
-    "dpl_log_18": "AVERTISSEMENT : 'headingmode=$0' n'a aucun effet avec 'ordermethod' sur une simple composante. Utiliser : '$1'. Aide : vous pouvez utiliser not-$1  sur les valeurs de 'headingmode' avec 'ordermethod' sur plusieurs composantes.  La première composante est utilisée pour les en-têtes. Exemple : 'ordermethod=category,<i>comp</i>' (<i>comp</i> est une autre composante) pour les en-têtes de catégorie.",
-    "dpl_log_19": "AVERTISSEMENT : 'debug=$0' n’est pas en première position dans l’élément DPL. Les nouveaux réglages de débogage ne seront appliqués qu’après que les paramètres précédents aient été vérifiés.",
-    "dpl_log_20": "AVERTISSEMENT : Une boucle d’inclusion infinie est créée par la page '$0'.",
-    "dpl_log_21": "REQUÊTE : <code>$0</code>",
-    "dpl_articlecount": "Il y a {{PLURAL:$1|un article|$1 articles}} dans cette section."
-}
\ No newline at end of file
diff --git a/i18n/frp.json b/i18n/frp.json
deleted file mode 100644
index 117d18d9..00000000
--- a/i18n/frp.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "ChrisPtDe"
-        ]
-    },
-    "intersection-desc": "Afiche una lista de puges des articllos los ples novéls dens una catègorie, ou ben dês una combinèson de plusiors catègories.",
-    "intersection_toomanycats": "Error : trop de catègories !",
-    "intersection_toofewcats": "Error : pas prod de catègories !",
-    "intersection_noresults": "Error : nion rèsultat !",
-    "intersection_noincludecats": "Error : vos avéd fôta d’encllure u muens yona catègorie, ou ben de spècefiar un èspâço de nom !"
-}
\ No newline at end of file
diff --git a/i18n/gl.json b/i18n/gl.json
deleted file mode 100644
index cd6f16ea..00000000
--- a/i18n/gl.json
+++ /dev/null
@@ -1,13 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Toliño",
-            "Xosé"
-        ]
-    },
-    "intersection-desc": "Devolve unha lista punteada dos elementos máis recentes que están nunha categoría ou nunha unión de varias categorías",
-    "intersection_toomanycats": "Erro: demasiadas categorías!",
-    "intersection_toofewcats": "Erro: moi poucas categorías!",
-    "intersection_noresults": "Erro: ningún resultado!",
-    "intersection_noincludecats": "Erro: ten que incluír unha categoría polo menos ou especificar un espazo de nomes!"
-}
\ No newline at end of file
diff --git a/i18n/grc.json b/i18n/grc.json
deleted file mode 100644
index 0e7d17d4..00000000
--- a/i18n/grc.json
+++ /dev/null
@@ -1,9 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Omnipaedista"
-        ]
-    },
-    "intersection_noresults": "Σφάλμα: οὐδὲν ἀποτέλεσμα",
-    "intersection_noincludecats": "Σφάλμα: Ἔξεστί σοι περιλαμβάνειν μίαν τοὐλάχιστον κατηγορίαν, ἢ καθορίζειν ὀνοματεῖον τι!"
-}
\ No newline at end of file
diff --git a/i18n/gsw.json b/i18n/gsw.json
deleted file mode 100644
index 84177999..00000000
--- a/i18n/gsw.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Als-Holder"
-        ]
-    },
-    "intersection-desc": "Usgabe vun ere Lischt vu dr aktuällschte Yyträg in ere Kategorii, oder vu dr Schnittmängi vu mehrere Kategorie",
-    "intersection_toomanycats": "Fähler: Zvyyl Kategorie!",
-    "intersection_toofewcats": "Fähler: Zwenig Kategorie!",
-    "intersection_noresults": "Fähler: Kei Ergebnis!",
-    "intersection_noincludecats": "Fähler: S muess zmindescht ei Kategorii yybunde wäre oder gib e Namensruum aa!"
-}
\ No newline at end of file
diff --git a/i18n/he.json b/i18n/he.json
deleted file mode 100644
index 498e188e..00000000
--- a/i18n/he.json
+++ /dev/null
@@ -1,34 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Rotem Liss"
-        ]
-    },
-    "intersection-desc": "רשימה עם תבליטים של הפריטים האחרונים המצויים בקטגוריה, או במספר קטגוריות",
-    "intersection_toomanycats": "DynamicPageList: קטגוריות רבות מדי!",
-    "intersection_toofewcats": "DynamicPageList: קטגוריות מעטות מדי!",
-    "intersection_noresults": "DynamicPageList: אין תוצאות!",
-    "intersection_noincludecats": "DynamicPageList: עליכם לכלול לפחות קטגוריה אחת, או לציין מרחב שם!",
-    "dpl_log_1": "שגיאה: פרמטר '$0' שגוי: '$1'! עזרה: <code>$0= <i>מחרוזת ריקה</i> (ראשי)$3</code>. (ניתן להשתמש גם בשווי ערך באמצעות מילות קסם.)",
-    "dpl_log_2": "שגיאה: פרמטר '$0' שגוי: '$1'! עזרה: <code>$0= <i>שם הדף המלא</i></code>. (ניתן להשתמש במילות קסם.)",
-    "dpl_log_3": "שגיאה: קטגוריות רבות מדי! מקסימום: $0. עזרה: העלו את <code>DynamicPageListHooks::$maxCategoryCount</code> כדי לציין עוד קטגוריות או הגדירו <code>DynamicPageListHooks::$allowUnlimitedCategories=true</code> כדי לבטל את ההגבלה. (הגידרו את המשתנה בקובץ <code>LocalSettings.php</code>, לאחר הכללת <code>DynamicPageList.php</code>.)",
-    "dpl_log_4": "שגיאה: קטגוריות מעטות מדי! מינימום: $0. עזרה: הורידו את <code>DynamicPageListHooks::$minCategoryCount</code> כדי לציין פחות קטגוריות. (הגידרו את המשתנה בקובץ <code>LocalSettings.php</code>, לאחר הכללת <code>DynamicPageList.php</code>.)",
-    "dpl_log_5": "ERROR: No selection criteria found! You must use at least one of the following parameters: category, namespace, titlematch, linksto, uses, createdby, modifiedby, lastmodifiedby, or their 'not' variants",
-    "dpl_log_6": "שגיאה: עליכם להכליל לפחות קטגוריה אחת אם ברצונכם להשתמש ב־'addfirstcategorydate=true' או ב־'ordermethod=categoryadd'!",
-    "dpl_log_7": "שגיאה: אם אתם מכלילים יותר מקטגוריה אחת, אינכם יכולים להשתמש ב־'addfirstcategorydate=true' או ב־'ordermethod=categoryadd'!",
-    "dpl_log_8": "שגיאה: אינכם יכולים להוסיף יותר מסוג אחד של תאריך בו זמנית!",
-    "dpl_log_9": "?????: ????????? ?????? ??'$0' ?? 'ordermethod=[...,]$1' ????!",
-    "dpl_log_10": "ERROR: the index for the dominant section must be between 1 and the number of arguments of includepage ($0 in this case)",
-    "dpl_log_11": "שגיאה: לא ניתן לבצע פעולות לוגיות על דפים ללא קטגוריות (למשל, עם הפרמטר 'קטגוריה') כיוון שתצוגת $0 אינה קיימת במסד הנתונים! עזרה: מנהל מסד הנתונים צריך להריץ את השאילתה: <code>$1</code>.",
-    "dpl_log_12": "ERROR: specifying \"openreferences\" is incompatible with some other option you specified. See the manual for details.",
-    "dpl_log_13": "אזהרה: בוצעה התעלמות מהפרמטר הלא ידוע '$1'. עזרה: פרמטרים זמינים: <code>$2</code>.",
-    "dpl_log_14": "אזהרה: פרמטר '$0' שגוי: '$1'! משתמש בברירת המחדל: '$2'. עזרה: <code>$0= $3</code>.",
-    "dpl_log_15": "אזהרה: פרמטר '$0' שגוי: '$1'! משתמש בברירת המחדל: '$2' (ללא הגבלה). עזרה: <code>$0= <i>מחרוזת ריקה</i> (ללא הגבלה) | n</code>, עם <code>n</code> כמספר שלם וחיובי.",
-    "dpl_log_16": "?????: ??? ??????!",
-    "dpl_log_17": "אזהרה: להוספת* הפרמטרים ('adduser',‏ 'addeditdate' וכדומה) וכן ל־'includepage' אין השפעה עם 'mode=category'. ניתן לצפות רק במרחב השם או בכותרת הדף במצב זה.",
-    "dpl_log_18": "אזהרה: ל־'headingmode=$0' אין השפעה עם 'ordermethod' על פריט יחיד. משתמש ב: '$1'. עזרה: באפשרותכם להשתמש בערכים של 'headingmode' שאינם $1 עם 'ordermethod' על פריטים מרובים. משתמשים בפריט הראשון לכותרת. למשל, 'ordermethod=category,<i>comp</i>' (<i>comp</i> הוא פריט אחר) לכותרות הקטגוריה.",
-    "dpl_log_19": "אזהרה: 'debug=$0w הוא לא במקום הראשון ברכיב ה־DPL. הגדרות ניפוי השגיאות החדשות לא יחולו לפני שכל הפרמטרים הקודמים ינותחו וייבדקו.",
-    "dpl_log_20": "אזהרה: לולאת הכללה אינסופית נוצרה בדף '$0'.",
-    "dpl_log_21": "שאילתה: <code>$0</code>",
-    "dpl_articlecount": "{{PLURAL:$1|ישנם $1 דפים|ישנו דף אחד}} תחת כותרת זו."
-}
\ No newline at end of file
diff --git a/i18n/hi.json b/i18n/hi.json
deleted file mode 100644
index b465e1a0..00000000
--- a/i18n/hi.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Kaustubh"
-        ]
-    },
-    "intersection-desc": "एक श्रेणी या श्रेणीसमूहमें उपलब्ध नवीनतम लेख दर्शायें।",
-    "intersection_toomanycats": "Error: बहुत ज्यादा श्रेणीयां!",
-    "intersection_toofewcats": "Error: बहुत कम श्रेणीयां!",
-    "intersection_noresults": "Error: रिज़ल्ट नहीं!",
-    "intersection_noincludecats": "Error: कमसे कम एक श्रेणी या नामस्थान देना अनिवार्य हैं!"
-}
\ No newline at end of file
diff --git a/i18n/hr.json b/i18n/hr.json
deleted file mode 100644
index 97242d77..00000000
--- a/i18n/hr.json
+++ /dev/null
@@ -1,13 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Dalibor Bosits",
-            "Dnik"
-        ]
-    },
-    "intersection-desc": "Omogućava popis najnovijih stranica ili datoteka iz kategorije, ili presjeka nekoliko kategorija",
-    "intersection_toomanycats": "Error: Previše kategorija!",
-    "intersection_toofewcats": "Error: Premalo kategorija!",
-    "intersection_noresults": "Error: Nema rezultata!",
-    "intersection_noincludecats": "Error: Morate uključiti bar jednu kategoriju, ili odabrati imenski prostor!"
-}
\ No newline at end of file
diff --git a/i18n/hsb.json b/i18n/hsb.json
deleted file mode 100644
index 877a893d..00000000
--- a/i18n/hsb.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Michawiki"
-        ]
-    },
-    "intersection-desc": "Wudaće lisćiny najaktualnišich zapiskow w jednej kategoriji abo w skupinje kategorijow",
-    "intersection_toomanycats": "Error: Přewjele kategorijow!",
-    "intersection_toofewcats": "Error: Přemało kategorijow!",
-    "intersection_noresults": "Error: Žane wuslědki!",
-    "intersection_noincludecats": "Error: Dyrbiš znajmjeńša kednu kategoriju zapřijeć abo mjenowy rum podać!"
-}
\ No newline at end of file
diff --git a/i18n/hu.json b/i18n/hu.json
deleted file mode 100644
index 3c0491fc..00000000
--- a/i18n/hu.json
+++ /dev/null
@@ -1,14 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Dani",
-            "Gondnok",
-            "KossuthRad"
-        ]
-    },
-    "intersection-desc": "Megjeleníti egy adott kategóriában, vagy kategóriák uniójában lévő legújabb szócikkek listáját",
-    "intersection_toomanycats": "Hiba: Túl sok kategória!",
-    "intersection_toofewcats": "Hiba: Túl kevés kategória!",
-    "intersection_noresults": "Hiba: Nincs eredmény!",
-    "intersection_noincludecats": "Hiba: Legalább egy listázandó kategóriát meg kell adnod, vagy pedig egy névteret!"
-}
\ No newline at end of file
diff --git a/i18n/ia.json b/i18n/ia.json
deleted file mode 100644
index 61016131..00000000
--- a/i18n/ia.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "McDutchie"
-        ]
-    },
-    "intersection-desc": "Face un lista a punctos del elementos le plus recente in un categoria, o un union de plure categorias",
-    "intersection_toomanycats": "Error: Troppo de categorias!",
-    "intersection_toofewcats": "Error: Non bastante categorias!",
-    "intersection_noresults": "Error: Nulle resultatos!",
-    "intersection_noincludecats": "Error: Tu debe includer al minus un categoria, o specificar un spatio de nomines!"
-}
\ No newline at end of file
diff --git a/i18n/id.json b/i18n/id.json
deleted file mode 100644
index de3b97da..00000000
--- a/i18n/id.json
+++ /dev/null
@@ -1,34 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "IvanLanin"
-        ]
-    },
-    "intersection-desc": "Menghasilkan suatu daftar item terbaru pada suatu kategori atau gabungan beberapa kategori",
-    "intersection_toomanycats": "DynamicPageList: Terlalu banyak kategori!",
-    "intersection_toofewcats": "DynamicPageList: Terlalu sedikit kategori!",
-    "intersection_noresults": "DynamicPageList: Tak ada hasil yang sesuai!",
-    "intersection_noincludecats": "DynamicPageList: Anda perlu mencantumkan paling tidak satu kategori, atau menyebutkan satu ruang nama!",
-    "dpl_log_1": "KESALAHAN: Parameter '$0' salah: '$1'! Bantuan: <code>$0= <i>string kosong</i> (Utama)$3</code>. (Ekivalen kata kunci juga diizinkan.)",
-    "dpl_log_2": "KESALAHAN: Parameter '$0' salah: '$1'! Bantuan:  <code>$0= <i>nama lengkap halaman</i></code>. (Kata kunci diizinkan.)",
-    "dpl_log_3": "KESALAHAN: Kategori terlalu banyak! Maksimum: $0. Bantuan: perbesar <code>DynamicPageListHooks::$maxCategoryCount</code> untuk memberikan lebih banyak kategori atau atur  <code>DynamicPageListHooks::$allowUnlimitedCategories=true</code> untuk menghapus batasan. (Atur variabel tersebut di <code>LocalSettings.php</code>, setelah mencantumkan <code>DynamicPageList.php</code>.)",
-    "dpl_log_4": "KESALAHAN: Kategori terlalu sedikit! Minimum: $0. Bantuan: kurangi <code>DynamicPageListHooks::$minCategoryCount</code> untuk mengurangi kategori. (Atur variabel tersebut di <code>LocalSettings.php</code>, setelah mencantumkan <code>DynamicPageList.php</code>.)",
-    "dpl_log_5": "ERROR: No selection criteria found! You must use at least one of the following parameters: category, namespace, titlematch, linksto, uses, createdby, modifiedby, lastmodifiedby, or their 'not' variants",
-    "dpl_log_6": "KESALAHAN: Anda harus memberikan paling tidak satu kategori jika menggunakan 'addfirstcategorydate=true' atau 'ordermethod=categoryadd'!",
-    "dpl_log_7": "KESALAHAN: Jika Anda memberikan lebih dari satu kategori, Anda tidak dapat menggunakan 'addfirstcategorydate=true' atau 'ordermethod=categoryadd'!",
-    "dpl_log_8": "KESALAHAN: Anda tidak dapat memberikan lebih dari satu jenis tanggal dalam satu waktu!",
-    "dpl_log_9": "KESALAHAN: Anda dapat menggunakan '$0' hanya dengan 'ordermethod=[...,]$1'!",
-    "dpl_log_10": "ERROR: the index for the dominant section must be between 1 and the number of arguments of includepage ($0 in this case)",
-    "dpl_log_11": "KESALAHAN: Tidak dapat melakukan operasi logika pada halaman yang tak terkategori (misalnya dengan parameter 'kategori') karena view $0 tidak ada di basis data! Bantuan: mintalah admin basis data untuk menjalankan kueri berikut: <code>$1</code>.",
-    "dpl_log_12": "ERROR: specifying \"openreferences\" is incompatible with some other option you specified. See the manual for details.",
-    "dpl_log_13": "KESALAHAN: Paramater yang tak dikenal '$1' diabaikan. Bantuan: parameter yang tersedia: <code>$2</code>.",
-    "dpl_log_14": "KESALAHAN: Parameter '$0' salah: '$1'! Menggunakan konfigurasi baku: '$2'. Bantuan: <code>$0= $3</code>.",
-    "dpl_log_15": "KESALAHAN: Parameter '$0' salah: '$1'! Menggunakan konfigurasi baku: '$2' (tanpa limitasi). Bantuan: <code>$0= <i>string kosong</i> (tanpa limitasi) | n</code>, dengan <code>n</code> suatu bilangan positif.",
-    "dpl_log_16": "KESALAHAN: Hasil tak ditemukan!",
-    "dpl_log_17": "KESALAHAN: Menambahkan * parameter ('adduser', 'addeditdate', dll.)' dan 'includepage' tidak berpengaruh pada 'mode=category'. Hanya ruang nama/judul halaman yang dapat ditampilkan dengan mode ini.",
-    "dpl_log_18": "KESALAHAN: 'headingmode=$0' tidak berpengaruh dengan 'ordermethod' pada suatu komponen tunggal. Menggunakan: '$1'. Bantuan: Anda dapat menggunakan nilai not-$1 'headingmode' dengan 'ordermethod' terhadap beberapa komponen. Komponen pertama digunakan sebagai judul. Misalnya 'ordermethod=category,<i>comp</i>' (<i>comp</i> adalah komponen lain) untuk judul kategori.",
-    "dpl_log_19": "KESALAHAN: 'debug=$0' tidak pada posisi pertama pada elemen DPL. Aturan debug tidak diterapkan sebelum semua variabel sebelumnya telah diparsing dan dicek.",
-    "dpl_log_20": "KESALAHAN: Suatu lingkaran transklusi tak hingga ditimbulkan oleh halaman '$0'.",
-    "dpl_log_21": "KUERI: <code>$0</code>",
-    "dpl_articlecount": "Terdapat {{PLURAL:$1|artikel|artikel}} dalam judul ini."
-}
\ No newline at end of file
diff --git a/i18n/io.json b/i18n/io.json
deleted file mode 100644
index 3e4352af..00000000
--- a/i18n/io.json
+++ /dev/null
@@ -1,11 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Malafaya"
-        ]
-    },
-    "intersection_toomanycats": "Eroro: Tro multa kategorii!",
-    "intersection_toofewcats": "Eroro: Tro poka kategorii!",
-    "intersection_noresults": "Eroro: Nula rezultaji!",
-    "intersection_noincludecats": "Eroro: Vu mustas inkluzar adminime un kategorio, o specigez nomaro!"
-}
\ No newline at end of file
diff --git a/i18n/it.json b/i18n/it.json
deleted file mode 100644
index 69214b11..00000000
--- a/i18n/it.json
+++ /dev/null
@@ -1,34 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "BrokenArrow",
-            "Darth Kule"
-        ]
-    },
-    "intersection-desc": "Visualizza un elenco puntato con gli elementi più recenti inseriti in una categoria o nell'unione di più categorie",
-    "intersection_toomanycats": "Errore: Numero di categorie eccessivo.",
-    "intersection_toofewcats": "Errore: Numero di categorie insufficiente.",
-    "intersection_noresults": "Errore: Nessun risultato.",
-    "intersection_noincludecats": "Errore: È necessario includere almeno una categoria oppure specificare un namespace.",
-    "dpl_log_1": "ERRORE nel parametro '$0': '$1'. Suggerimento:  <code>$0= <i>stringa vuota</i> (Principale)$3</code>.",
-    "dpl_log_2": "ERRORE nel parametro '$0': '$1'. Suggerimento:  <code>$0= <i>nome completo della pagina</i></code>.",
-    "dpl_log_3": "ERRORE: Categorie sovrabbondanti (massimo $0). Suggerimento: aumentare il valore di <code>DynamicPageListHooks::$maxCategoryCount</code> per indicare un numero maggiore di categorie, oppure impostare <code>DynamicPageListHooks::$allowUnlimitedCategories=true</code> per non avere alcun limite. (Impostare le variabili nel file <code>LocalSettings.php</code>, dopo l'inclusione di <code>DynamicPageList.php</code>.)",
-    "dpl_log_4": "ERRORE: Categorie insufficienti (minimo $0). Suggerimento: diminuire il valore di <code>DynamicPageListHooks::$minCategoryCount</code> per indicare un numero minore di categorie. (Impostare la variabile nel file <code>LocalSettings.php</code>, dopo l'inclusione di <code>DynamicPageList.php</code>.)",
-    "dpl_log_5": "ERROR: No selection criteria found! You must use at least one of the following parameters: category, namespace, titlematch, linksto, uses, createdby, modifiedby, lastmodifiedby, or their 'not' variants",
-    "dpl_log_6": "ERRORE: L'uso dei parametri 'addfirstcategorydate=true' e 'ordermethod=categoryadd' richiede l'inserimento di una o più categorie.",
-    "dpl_log_7": "ERRORE: L'inserimento di più categorie impedisce l'uso dei parametri 'addfirstcategorydate=true' e 'ordermethod=categoryadd'.",
-    "dpl_log_8": "ERRORE: Non è consentito l'uso contemporaneo di più tipi di data.",
-    "dpl_log_9": "ERRORE: L'uso del parametro '$0' è consentito unicamente con 'ordermethod=[...,]$1'.",
-    "dpl_log_10": "ERROR: the index for the dominant section must be between 1 and the number of arguments of includepage ($0 in this case)",
-    "dpl_log_11": "ERRORE: Impossibile effettuare operazioni logiche sulle pagine prive di categoria (ad es. con il parametro 'category') in quanto il database non contiene la vista $0. Suggerimento: chiedere all'amministratore del database di eseguire la seguente query: <code>$1</code>.",
-    "dpl_log_12": "ERROR: specifying \"openreferences\" is incompatible with some other option you specified. See the manual for details.",
-    "dpl_log_13": "ATTENZIONE: Il parametro non riconosciuto '$1' è stato ignorato. Suggerimento: i parametri disponibili sono: <code>$2</code>.",
-    "dpl_log_14": "ATTENZIONE: Errore nel parametro '$0': '$1'. È stato usato il valore predefinito '$2'. Suggerimento: <code>$0= $3</code>.",
-    "dpl_log_15": "ATTENZIONE: errore nel parametro '$0': '$1'. È stato usato il valore predefinito '$2' (nessun limite). Suggerimento: <code>$0= <i>stringa vuota</i> (nessun limite) | n</code>, con <code>n</code> intero positivo.",
-    "dpl_log_16": "ATTENZIONE: Nessun risultato.",
-    "dpl_log_17": "ATTENZIONE: I parametri add* ('adduser', 'addeditdate', ecc.)' non hanno alcun effetto quando è specificato 'mode=category'. In tale modalità vengono visualizzati unicamente il namespace e il titolo della pagina.",
-    "dpl_log_18": "ATTENZIONE: Il parametro 'headingmode=$0' non ha alcun effetto quando è specificato 'ordermethod' su un solo componente. Verrà utilizzato il valore '$1'. Suggerimento: è posibile utilizzare i valori diversi da $1 per il parametro 'headingmode' nel caso di 'ordermethod' su più componenti. Il primo componente viene usato per generare i titoli di sezione. Ad es. 'ordermethod=category,<i>comp</i>' (dove <i>comp</i> è un altro componente) per avere titoli di sezione basati sulla categoria.",
-    "dpl_log_19": "ATTENZIONE: Il parametro 'debug=$0' non è il primo elemento della sezione DPL. Le nuove impostazioni di debug non verranno applicate prima di aver completato il parsing e la verifica di tutti i parametri che lo precedono.",
-    "dpl_log_21": "QUERY: <code>$0</code>",
-    "dpl_articlecount": "Questa sezione contiene {{PLURAL:$1|una voce|$1 voci}}."
-}
\ No newline at end of file
diff --git a/i18n/ja.json b/i18n/ja.json
deleted file mode 100644
index 7ff0d92b..00000000
--- a/i18n/ja.json
+++ /dev/null
@@ -1,13 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Fryed-peach",
-            "JtFuruhata"
-        ]
-    },
-    "intersection-desc": "単一カテゴリ内または複数カテゴリ内において最近更新された項目を箇条書きで表示する",
-    "intersection_toomanycats": "エラー: カテゴリ指定が多すぎます！",
-    "intersection_toofewcats": "エラー: カテゴリ指定が少なすぎます！",
-    "intersection_noresults": "エラー: 最近更新された項目はありません！",
-    "intersection_noincludecats": "エラー: 1つ以上のカテゴリ、または名前空間を指定する必要があります！"
-}
\ No newline at end of file
diff --git a/i18n/jut.json b/i18n/jut.json
deleted file mode 100644
index fcfefc77..00000000
--- a/i18n/jut.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Huslåke"
-        ]
-    },
-    "intersection-desc": "Outputs en bulleted liste der senestste itemer ræsidende i en klynge, æller æ unje der severæl klynger",
-    "intersection_toomanycats": "Error: Åverføl klynger!",
-    "intersection_toofewcats": "Error: Åverwæneg klynger!",
-    "intersection_noresults": "Error: Ekke ræsultåter!",
-    "intersection_noincludecats": "Error: Du nødst til inkludær til mendst en klynge, æller spæsifiær en navnerum!"
-}
\ No newline at end of file
diff --git a/i18n/jv.json b/i18n/jv.json
deleted file mode 100644
index d5550319..00000000
--- a/i18n/jv.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Meursault2004"
-        ]
-    },
-    "intersection-desc": "Ngasilaké sawijining daftar item paling anyar ing sawijining kategori utawa gabungan sawetara kategori",
-    "intersection_toomanycats": "Error: Kakèhan kategori!",
-    "intersection_toofewcats": "Error: Kesithikan kategori!",
-    "intersection_noresults": "Error: Ora ana pituwasé (kasilé)!",
-    "intersection_noincludecats": "Error: Panjenengan perlu minimal mènèhi kategori sawiji, utawa spésifikasi bilik nama sawiji!"
-}
\ No newline at end of file
diff --git a/i18n/km.json b/i18n/km.json
deleted file mode 100644
index c4cfbd5b..00000000
--- a/i18n/km.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Chhorran",
-            "Thearith"
-        ]
-    },
-    "intersection_toomanycats": "កំហុស​៖ ចំណាត់ថ្នាក់ក្រុម​ច្រើនពេក​!",
-    "intersection_toofewcats": "កំហុស​៖ ចំណាត់ថ្នាក់ក្រុម​តិចពេក​!",
-    "intersection_noresults": "កំហុស​៖ គ្មាន​លទ្ធផល​!",
-    "intersection_noincludecats": "កំហុស​៖ អ្នក​ត្រូវតែ​មាន​ចំណាត់ថ្នាក់ក្រុម​មួយយ៉ាងតិច ឬ សំដៅ​មួយ​លំហឈ្មោះ​!"
-}
\ No newline at end of file
diff --git a/i18n/ko.json b/i18n/ko.json
deleted file mode 100644
index 2744c068..00000000
--- a/i18n/ko.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Kwj2772",
-            "Yknok29"
-        ]
-    },
-    "intersection_toomanycats": "에러: 분류가 너무 많습니다!",
-    "intersection_toofewcats": "에러: 분류가 너무 적습니다!",
-    "intersection_noresults": "오류: 결과가 없습니다!",
-    "intersection_noincludecats": "에러: 최소한 하나의 분류에 포함시켜 주시거나 이름공간을 명확히 적어 주세요!"
-}
\ No newline at end of file
diff --git a/i18n/ksh.json b/i18n/ksh.json
deleted file mode 100644
index 0d4bc455..00000000
--- a/i18n/ksh.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Purodha"
-        ]
-    },
-    "intersection-desc": "Zeij_en Liß met de neuste Enndrääsch en en Saachjrupp, udder de neuste Enndrääsch, die en alle Jruppe uss_enem Knubbel fun Saachjrupp dren sin.",
-    "intersection_toomanycats": "<i lang=\"en\">DynamicPageList</i> hät ene Fääler jefonge: Dat sinn_er zo vill Saachjroppe!",
-    "intersection_toofewcats": "<i lang=\"en\">DynamicPageList</i> hät ene Fääler jefonge: Dat sin ze winnisch Saachjruppe!",
-    "intersection_noresults": "<i lang=\"en\">DynamicPageList</i> hät ene Fääler jefonge: Do kohm nix bei erus!",
-    "intersection_noincludecats": "<i lang=\"en\">DynamicPageList</i> hät ene Fääler jefonge: Mer bruch winnischßdens ein Saachjrupp. Söns jivv e Appachtemang aan!"
-}
\ No newline at end of file
diff --git a/i18n/lb.json b/i18n/lb.json
deleted file mode 100644
index df887610..00000000
--- a/i18n/lb.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Robby"
-        ]
-    },
-    "intersection-desc": "Generéiert eng Lëscht mat de rezentesten Androungen an eng Kategorie, oder an eng Intersektioun vu méi Kategorien",
-    "intersection_toomanycats": "Dynamesch Säite-Lëscht: Zevill Kategorien!",
-    "intersection_toofewcats": "Dynamesch Säite-Lëscht: Ze wéineg Kategorien!",
-    "intersection_noresults": "Dynamesch Säite-Lëscht: Kee Resultat!",
-    "intersection_noincludecats": "Dynamesch Säite-Lëscht: Dir musst mindestens eng Kategorie abannen, oder de Nummraum uginn!"
-}
\ No newline at end of file
diff --git a/i18n/li.json b/i18n/li.json
deleted file mode 100644
index ffb07ec0..00000000
--- a/i18n/li.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Matthias"
-        ]
-    },
-    "intersection-desc": "Geeft als uitvoer een ongenummerde lijst met de meest recent toegevoegde items in een categorie, of een combinatie van categorieë",
-    "intersection_toomanycats": "Error: Te veel categorieë!",
-    "intersection_toofewcats": "Error: Te weinig categorieë!",
-    "intersection_noresults": "Error: Gein resultate!",
-    "intersection_noincludecats": "Error: U moet tenminste een categorie of een naamruimte opgeve!"
-}
\ No newline at end of file
diff --git a/i18n/lt.json b/i18n/lt.json
deleted file mode 100644
index 10bbfcf3..00000000
--- a/i18n/lt.json
+++ /dev/null
@@ -1,11 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Matasg"
-        ]
-    },
-    "intersection_toomanycats": "Error: Per daug kategorijų!",
-    "intersection_toofewcats": "Error: Per mažai kategorijų!",
-    "intersection_noresults": "Error: Nėra rezultatų!",
-    "intersection_noincludecats": "Error: Jums reikia įtraukti bent vieną kategoriją, arba nurodyti vardų sritį!"
-}
\ No newline at end of file
diff --git a/i18n/lv.json b/i18n/lv.json
deleted file mode 100644
index 5c33cedc..00000000
--- a/i18n/lv.json
+++ /dev/null
@@ -1,9 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Xil"
-        ]
-    },
-    "intersection_toomanycats": "Kļūda: pārāk daudz kategoriju!",
-    "intersection_toofewcats": "Kļūda: pārāk maz kategoriju!"
-}
\ No newline at end of file
diff --git a/i18n/mg.json b/i18n/mg.json
deleted file mode 100644
index 89773ec0..00000000
--- a/i18n/mg.json
+++ /dev/null
@@ -1,8 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Jagwar"
-        ]
-    },
-    "intersection_toomanycats": "DynamicPageList : Be laotra ny sokajy"
-}
\ No newline at end of file
diff --git a/i18n/ml.json b/i18n/ml.json
deleted file mode 100644
index dbc45b1e..00000000
--- a/i18n/ml.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Shijualex"
-        ]
-    },
-    "intersection-desc": "ഒരു കാറ്റഗറിയില്‍ പുതിയതായി വന്ന ഇനങ്ങളുടെ ബുള്ളറ്റ് പട്ടികയോ, അല്ലെങ്കില്‍ നിരവധി കാറ്റഗറികളുടെ കൂട്ടത്തെയോ ഔട്ട് പുട്ടായി കിട്ടുന്നു.",
-    "intersection_toomanycats": "Error: വളരെയധികം കാറ്റഗറികള്‍!",
-    "intersection_toofewcats": "Error: വളരെ കുറച്ച് കാറ്റഗറികള്‍!",
-    "intersection_noresults": "Error: ഫലങ്ങള്‍ ഒന്നുമില്ല!",
-    "intersection_noincludecats": "Error: ചുരുങ്ങിയത് ഒരു കാറ്റഗറിയെങ്കിലും ഉള്‍പ്പെടുത്തുകയോ അല്ലെങ്കില്‍ ഒരു നേംസ്പേസ് എങ്കിലും നിഷ്കര്‍ഷിച്ചിരിക്കുകയോ വേണം!"
-}
\ No newline at end of file
diff --git a/i18n/mr.json b/i18n/mr.json
deleted file mode 100644
index f1956082..00000000
--- a/i18n/mr.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Kaustubh"
-        ]
-    },
-    "intersection-desc": "एखाद्या वर्गातील अथवा वर्गसमूहातील नवीनतम लेख दर्शवितो.",
-    "intersection_toomanycats": "Error: खूप जास्त वर्ग!",
-    "intersection_toofewcats": "Error: खूप कमी वर्ग!",
-    "intersection_noresults": "Error: निकाल नाहीत!",
-    "intersection_noincludecats": "Error: कमीतकमी एक वर्ग अथवा नामविश्व देणे गरजेचे आहे!"
-}
\ No newline at end of file
diff --git a/i18n/ms.json b/i18n/ms.json
deleted file mode 100644
index 5de2fcc4..00000000
--- a/i18n/ms.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Aviator"
-        ]
-    },
-    "intersection-desc": "Mengoutput senarai item terkini dalam sesebuah kategori atau kesatuan beberapa buah kategori",
-    "intersection_toomanycats": "Error: Kategori terlalu banyak!",
-    "intersection_toofewcats": "Error: Kategori terlalu sedikit!",
-    "intersection_noresults": "Error: Tiada hasil!",
-    "intersection_noincludecats": "Error: Anda hendaklah memasukkan sekurang-kurangnya sebuah kategori atau menyatakan sebuah ruang nama!"
-}
\ No newline at end of file
diff --git a/i18n/nb.json b/i18n/nb.json
deleted file mode 100644
index 08d085a1..00000000
--- a/i18n/nb.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Jon Harald Søby"
-        ]
-    },
-    "intersection-desc": "Gir en punktliste over de nyeste elementene i en kategori, eller elementer som er felles i flere kategorier",
-    "intersection_toomanycats": "Dynamisk sideliste: For mange kategorier!",
-    "intersection_toofewcats": "Dynamisk sidelist: For få kategorier!",
-    "intersection_noresults": "Dynamisk sideliste: Ingen resultater!",
-    "intersection_noincludecats": "Dynamisk sideliste: Du må inkludere minst én kategori, eller oppgi et navnerom!"
-}
\ No newline at end of file
diff --git a/i18n/nds.json b/i18n/nds.json
deleted file mode 100644
index 384c1d3c..00000000
--- a/i18n/nds.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Slomox"
-        ]
-    },
-    "intersection-desc": "Wiest en List mit de aktuellsten Indrääg in en Kategorie, oder de Snittmengd vun mehr Kategorien",
-    "intersection_toomanycats": "Fehler: Toveel Kategorien!",
-    "intersection_toofewcats": "Fehler: To wenig Kategorien!",
-    "intersection_noresults": "Fehler: Nix funnen!",
-    "intersection_noincludecats": "Fehler: Dor mutt opminnst een Kategorie angeven warrn! ODer geev en Naamruum an."
-}
\ No newline at end of file
diff --git a/i18n/nl.json b/i18n/nl.json
deleted file mode 100644
index 0c3a2882..00000000
--- a/i18n/nl.json
+++ /dev/null
@@ -1,30 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "SPQRobin",
-            "Siebrand"
-        ]
-    },
-    "intersection-desc": "Geeft als uitvoer een ongenummerde lijst met de meest recent toegevoegde items in een categorie, of een combinatie van categorieën",
-    "intersection_toomanycats": "Fout: Te veel categorieën!",
-    "intersection_toofewcats": "Fout: Te weinig categorieën!",
-    "intersection_noresults": "Fout: Geen resultaten!",
-    "intersection_noincludecats": "Fout: U moet tenminste een categorie of een naamruimte opgeven!",
-    "dpl_log_1": "FOUT: Verkeerde parameter '$0': '$1'! Hulp:  <code>$0= <i>lege string</i> (Main)$3</code>.",
-    "dpl_log_2": "FOUT: Te veel categoriën! Maximum: $0. Hulp: verhoog <code>DynamicPageListHooks::$maxCategoryCount</code> om meer categorieën op te kunnen geven of stel geen limiet in met <code>DynamicPageListHooks::$allowUnlimitedCategories=true</code>. (Neem deze variabele op in <code>LocalSettings.php</code>, na het toevoegen van <code>DynamicPageList.php</code>.)",
-    "dpl_log_3": "FOUT: Te weinig categorieën! Minimum: $0. Hulp: verlaag <code>DynamicPageListHooks::$minCategoryCount</code> om minder categorieën aan te hoeven geven. (Stel de variabele bij voorkeur in via <code>LocalSettings.php</code>, na het toevoegen van <code>DynamicPageList.php</code>.)",
-    "dpl_log_4": "ERROR: No selection criteria found! You must use at least one of the following parameters: category, namespace, titlematch, linksto, uses, createdby, modifiedby, lastmodifiedby, or their 'not' variants",
-    "dpl_log_5": "FOUT: U dient tenminste één categorie op te nemen als u 'addfirstcategorydate=true' of 'ordermethod=categoryadd' wilt gebruiken!",
-    "dpl_log_6": "FOUT: Als u meer dan één categorie opneemt, kunt u 'addfirstcategorydate=true' of 'ordermethod=categoryadd' niet gebruiken!",
-    "dpl_log_8": "FOUT: U kunt niet meer dan één type of datum tegelijk gebruiken!",
-    "dpl_log_9": "FOUT: U kunt '$0' alleen met 'ordermethod=[...,]$1' gebruiken!",
-    "dpl_log_10": "ERROR: the index for the dominant section must be between 1 and the number of arguments of includepage ($0 in this case)",
-    "dpl_log_12": "ERROR: specifying \"openreferences\" is incompatible with some other option you specified. See the manual for details.",
-    "dpl_log_14": "WAARSCHUWING: Verkeerde parameter '$0': '$1'! Nu wordt de standaard gebruikt: '$2'. Hulp: <code>$0= $3</code>.",
-    "dpl_log_16": "WAARSCHUWING: Geen resultaten!",
-    "dpl_log_17": "WAARSCHUWING: Add* parameters ('adduser', 'addeditdate', etc.)' heeft geen effect bij 'mode=category'. Alleen de paginanaamruimte/titel is in deze modus te bekijken.",
-    "dpl_log_18": "WAARSCHUWING: 'headingmode=$0' heeft geen effect met 'ordermethod' op een enkele component. Nu wordt gebruikt: '$1'. Hulp: u kunt een niet-$1 'headingmode'-waarde gebruiken met 'ordermethod' op meerdere componenten. De eerste component wordt gebruikt als kop. Bijvoorbeeld 'ordermethod=category,<i>comp</i>' (<i>comp</i> is een ander component) voor categoriekoppen.",
-    "dpl_log_19": "WAARSCHUWING: 'debug=$0' is niet de eerste positie in het DPL-element. De nieuwe debuginstellingen zijn niet toegepast voor alle voorgaande parameters zijn verwerkt en gecontroleerd.",
-    "dpl_log_21": "QUERY: <code>$0</code>",
-    "dpl_articlecount": "Er {{PLURAL:$1|is één pagina|zijn $1 pagina's}} onder deze kop."
-}
\ No newline at end of file
diff --git a/i18n/nn.json b/i18n/nn.json
deleted file mode 100644
index 21a40b39..00000000
--- a/i18n/nn.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Harald Khan"
-        ]
-    },
-    "intersection-desc": "Gjev ei punktlista over dei nyaste elementa i ein kategori, eller element som er felles i fleire kategoriar",
-    "intersection_toomanycats": "Feil: For mange kategoriar!",
-    "intersection_toofewcats": "Feil: For få kategoriar!",
-    "intersection_noresults": "Feil: Ingen resultat!",
-    "intersection_noincludecats": "Feil: Du må inkludera minst éin kategori, eller oppgje eit namnerom!"
-}
\ No newline at end of file
diff --git a/i18n/oc.json b/i18n/oc.json
deleted file mode 100644
index 0883b46e..00000000
--- a/i18n/oc.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Cedric31"
-        ]
-    },
-    "intersection-desc": "Aficha una lista, amb de piuses, dels articles mai recents dins una categoria, o a partir d’una combinason de mantuna categoria.",
-    "intersection_toomanycats": "Error : Tròp de categorias !",
-    "intersection_toofewcats": "Error : Pas pro de categorias !",
-    "intersection_noresults": "Error : Pas cap de resultat !",
-    "intersection_noincludecats": "Error : avètz besonh d’inclure almens una categoria, o de precisar un nom d’espaci !"
-}
\ No newline at end of file
diff --git a/i18n/os.json b/i18n/os.json
deleted file mode 100644
index ea3c3223..00000000
--- a/i18n/os.json
+++ /dev/null
@@ -1,8 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Amikeco"
-        ]
-    },
-    "intersection_toomanycats": "Рæдыд: æгæр бирæ категоритæ!"
-}
\ No newline at end of file
diff --git a/i18n/pl.json b/i18n/pl.json
deleted file mode 100644
index 2fe97126..00000000
--- a/i18n/pl.json
+++ /dev/null
@@ -1,52 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Sp5uhe",
-            "Rail",
-            "Frisk"
-        ]
-    },
-    "intersection-desc": "Zwraca listę wypunktowaną najnowszych elementów w kategorii lub grupie kilku kategorii",
-    "intersection_toomanycats": "Błąd – zbyt wiele kategorii!",
-    "intersection_toofewcats": "Błąd – zbyt mało kategorii!",
-    "intersection_noresults": "Błąd – brak wyników!",
-    "intersection_noincludecats": "Błąd – musisz załączyć co najmniej jedną kategorię lub określić przestrzeń nazw!",
-    "dpl-desc": "Wysoce elastyczny generator raportów w MediaWiki",
-    "dpl_log_1": "Błąd – Błędny parametr „$1”: „$2”! Pomoc: <code>$1= <i>empty string</i> (Main)$3</code>.",
-    "dpl_log_2": "Błąd – Błędny parametr „$1”: „$2”! Pomoc: <code>$1= <i>full pagename</i></code>.",
-    "dpl_log_3": "Błąd – zbyt wiele kategorii! Maksymalnie $1. Pomoc: zwiększ wartość <code>$wgDplSettings['maxCategoryCount']</code> aby określić więcej kategorii lub ustaw <code>$wgDplSettings['allowUnlimitedCategories'] = true;</code> w celu wyłączeniu limitu (ustaw zmienną w pliku konfiguracyjnym <code>LocalSettings.php</code> wiki).",
-    "dpl_log_4": "Błąd – zbyt mało kategorii! Minimalnie $1. Pomoc: zmniejsz wartość decrease <code>$wgDplSettings['minCategoryCount']</code> aby określić mniej kategorii (ustaw zmienną w pliku konfiguracyjnym <code>LocalSettings.php</code> wiki).",
-    "dpl_log_5": "Błąd – nie odnaleziono kryteriów wyboru! Musisz użyć przynajmniej jednego z poniższych parametrów: category, namespace, titlematch, linksto, uses, createdby, modifiedby, lastmodifiedby lub ich wariantów „not”.",
-    "dpl_log_6": "Błąd – musisz wybrać przynajmniej jedną kategorię aby użyć „addfirstcategorydate=true” lub „ordermethod=categoryadd”.",
-    "dpl_log_7": "Błąd – nie możesz użyć „addfirstcategorydate=true” lub „ordermethod=categoryadd” jeśli podasz więcej niż jedną kategorię.",
-    "dpl_log_8": "Błąd – można dodać tylko jeden typ daty na raz.",
-    "dpl_log_9": "Błąd – parametr „$1” musi być używany wraz z „ordermethod=[ $2 ]”.",
-    "dpl_log_10": "Błąd – indeksem dominującej sekcji musi być liczba pomiędzy 1 a liczbą argumentów parametru „includepage” ($0 w tym przypadku).",
-    "dpl_log_11": "Błąd – nie można wykonywać logicznych operacji na nieskategoryzowanych stronach (np. z parametrem „category”), ponieważ podgląd $0 nie istnieje w bazie danych! Pomoc: administrator bazy danych musi wykonać to zapytanie: <code>$1</code>.",
-    "dpl_log_12": "Błąd – podawanie parametru „openreferences” jest niekompatybilne z inną podaną opcją. Usuń proszę tę inną opcję lub „openreferences”. Zobacz poradnik aby dowiedzieć się więcej.",
-    "dpl_log_13": "Ostrzeżenie – nieznany parametr „$1” został zignorowany. Pomoc: dostępne parametry – <code>$2</code>.",
-    "dpl_log_14": "Ostrzeżenie – pominięto złą opcję „$2” dla parametru „$1”.",
-    "dpl_log_15": "Ostrzeżenie – zły parametr „$1”: „$2”! Użyto domyślnego – „$3” (brak limitu). Pomoc: <code>$1= <i>empty string</i> (no limit) | n</code> z <code>n</code> jako liczbą dodatnią.",
-    "dpl_log_16": "Ostrzeżenie – brak wyników.",
-    "dpl_log_17": "Ostrzeżenie – podane parametry („adduser”, „addeditdate”, itd.) oraz „includepage” nie przyniosą zamierzonego efektu wraz z „mode=category”. W tym trybie widać tylko tytuł oraz przestrzeń nazw strony.",
-    "dpl_log_18": "Ostrzeżenie – „headingmode=$1” nie przyniesie zamierzonego efektu z „ordermethod” na pojedynczym komponencie. Użyto „$2”. Pomoc: możesz użyć wartości innych niż $2 dla „headingmode” na wielu komponentach. Pierwszy komponent jest używany w nagłówkach. Np. „ordermethod=category,<i>comp</i>” (gdzie <i>comp</i> jest kolejnym komponentem) dla nagłówków kategorii.",
-    "dpl_log_19": "Ostrzeżenie – „debug=$1” nie jest w pierwszej pozycji w elemencie DPL. Nowe ustawienia debugowania nie są aplikowane przed sprawdzeniem i sparsowaniem wszystkich poprzednich parametrów.",
-    "dpl_log_20": "Ostrzeżenie – strona „$0” tworzy nieskończoną pętlę transkluzji.",
-    "dpl_log_21": "Zapytanie – <code>$0</code>",
-    "dpl_log_22": "Ostrzeżenie – nie podano opcji parametru dla „$1” (brakujący znak „=”).",
-    "dpl_articlecount": "W tym nagłówku {{PLURAL:$1|znajduje się jeden artykuł|znajdują się $1 artykuły|znajduje się $1 artykułów}}.",
-    "dpl_description": "Wysoce elastyczny generator raportów w MediaWiki. Zobacz http://semeb.com/dpldemo po poradnik i przykłady",
-    "action-dpl_param_update_rules": "używania parametru „updaterules”",
-    "action-dpl_param_delete_rules": "używania parametru „deleterules”",
-    "dpl_query_error": "Rozszerzenie DPL (wersja $1) wyprodukowało wyrażenie SQL które doprowadziło do błędu bazy danych.<br />Powodem może być wewnętrzny błąd DPL lub problem spowodowany przez Ciebie; szczególnie podczas używania takich parametrów jak „categoryregexp” lub „titleregexp”. Używanie wzorców dopasowywania takich jak *? nie jest wspierane.<br />Komunikat błędu:<br /><code>$2</code>",
-    "dpl-tag-tracking-category": "Strony używające znacznika parsera DynamicPageList",
-    "dpl-intersection-tracking-category": "Strony używające znacznika parsera DynamicPageList Intersection",
-    "dpl-parserfunc-tracking-category": "Strony używające funkcji parsera DynamicPageList",
-    "dplnum-parserfunc-tracking-category": "Strony używające funkcji parsera DynamicPageList dplnum",
-    "dplvar-parserfunc-tracking-category": "Strony używające funkcji parsera DynamicPageList dplvar",
-    "dplreplace-parserfunc-tracking-category": "Strony używające funkcji parsera DynamicPageList dplreplace",
-    "dplchapter-parserfunc-tracking-category": "Strony używające funkcji parsera DynamicPageList dplchapter",
-    "dplmatrix-parserfunc-tracking-category": "Strony używające funkcji parsera DynamicPageList dplmatrix",
-    "right-dpl_param_delete_rules": "Masowe usuwanie stron używających DPL",
-    "right-dpl_param_update_rules": "Masowe aktualizowanie stron używających DPL"
-}
\ No newline at end of file
diff --git a/i18n/pt-br.json b/i18n/pt-br.json
deleted file mode 100644
index 35d7cc76..00000000
--- a/i18n/pt-br.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Eduardo.mps"
-        ]
-    },
-    "intersection-desc": "Exibe uma lista pontuada dos itens mais recentes presentes numa categoria, ou uma intersecção de várias categorias",
-    "intersection_toomanycats": "Erro: Categorias demais!",
-    "intersection_toofewcats": "Erro: Poucas categorias!",
-    "intersection_noresults": "Erro: Sem resultados!",
-    "intersection_noincludecats": "Erro: É necessário incluir no mínimo uma categoria ou especificar um espaço nominal!"
-}
\ No newline at end of file
diff --git a/i18n/pt.json b/i18n/pt.json
deleted file mode 100644
index 448157d6..00000000
--- a/i18n/pt.json
+++ /dev/null
@@ -1,13 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "555",
-            "Malafaya"
-        ]
-    },
-    "intersection-desc": "constrói uma lista pontuada dos itens mais recentes presentes numa categoria, ou uma união de várias categorias",
-    "intersection_toomanycats": "Error: Categorias em excesso!",
-    "intersection_toofewcats": "Error: Poucas categorias!",
-    "intersection_noresults": "Error: Sem resultados!",
-    "intersection_noincludecats": "Error: É necessário incluir no mínimo uma categoria ou especificar um espaço nominal!"
-}
\ No newline at end of file
diff --git a/i18n/qqq.json b/i18n/qqq.json
deleted file mode 100644
index 1072c302..00000000
--- a/i18n/qqq.json
+++ /dev/null
@@ -1,8 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Purodha"
-        ]
-    },
-    "intersection-desc": "{{desc}}"
-}
\ No newline at end of file
diff --git a/i18n/ro.json b/i18n/ro.json
deleted file mode 100644
index 456097f2..00000000
--- a/i18n/ro.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Mihai"
-        ]
-    },
-    "intersection-desc": "Întoarce o lista celor mai recenţi itemi care fac parte dintr-o categorie, sau intersecţia a mai multor categorii",
-    "intersection_toomanycats": "Eroare: Prea multe categorii!",
-    "intersection_toofewcats": "Eroare: Prea puţine categorii!",
-    "intersection_noresults": "Eroare: Niciun rezultat!",
-    "intersection_noincludecats": "Eroare: Trebuie să incluzi cel puţin o categorie, sau să specifici un spaţiu de nume!"
-}
\ No newline at end of file
diff --git a/i18n/roa-tara.json b/i18n/roa-tara.json
deleted file mode 100644
index 0705f462..00000000
--- a/i18n/roa-tara.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Joetaras"
-        ]
-    },
-    "intersection-desc": "Fa assè 'na liste cu le palle de le urteme urteme artichele ca stonne jndr'à 'na categorije, o 'n'interseziona de cchiù categorije",
-    "intersection_toomanycats": "Errore: Troppe categorije!",
-    "intersection_toofewcats": "Errore: Troppe picche categorije!",
-    "intersection_noresults": "Errore: Nisciune resultete!",
-    "intersection_noincludecats": "Errore: Tu è abbesogne de 'ngludere ninde ninde 'na categorije, o specificà 'nu namespace!"
-}
\ No newline at end of file
diff --git a/i18n/ru.json b/i18n/ru.json
deleted file mode 100644
index 87d7b436..00000000
--- a/i18n/ru.json
+++ /dev/null
@@ -1,31 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Александр Сигачёв"
-        ]
-    },
-    "intersection-desc": "Выводит в маркированный список последние добавления в категорию или объединение нескольких категорий",
-    "intersection_toomanycats": "Error: слишком много категорий!",
-    "intersection_toofewcats": "Error: слишком мало категорий!",
-    "intersection_noresults": "Error: нет результатов!",
-    "intersection_noincludecats": "Error: вы должны включить хотя бы одну категорию или указать пространство имён!",
-    "dpl_log_1": "ОШИБКА: неправильный «$0»-параметр: «$1»! Подсказка:  <code>$0= <i>пустая строка</i> (Основное)$3</code>.",
-    "dpl_log_3": "ОШИБКА: слишком много категорий! Максимум: $0. Подсказка: увеличте <code>DynamicPageListHooks::$maxCategoryCount</code> чтобы разрешить больше категорий или установите <code>DynamicPageListHooks::$allowUnlimitedCategories=true</code> для снятия ограничения. (Устанавливайте переменные в <code>LocalSettings.php</code>, после подключения <code>DynamicPageList.php</code>.)",
-    "dpl_log_4": "ОШИБКА: слишком мало категорий! Минимум: $0. Подсказка: уменьшите <code>DynamicPageListHooks::$minCategoryCount</code> чтобы разрешить меньше категорий. (Устанавливайте переменную в <code>LocalSettings.php</code>, после подключения <code>DynamicPageList.php</code>.)",
-    "dpl_log_5": "ERROR: No selection criteria found! You must use at least one of the following parameters: category, namespace, titlematch, linksto, uses, createdby, modifiedby, lastmodifiedby, or their 'not' variants",
-    "dpl_log_6": "ОШИБКА: вы должны включить хотя бы одну категорию, если вы хотите использовать «addfirstcategorydate=true» или «ordermethod=categoryadd»!",
-    "dpl_log_7": "ОШИБКА: если вы включаете больше одной категории, то вы не можете использовать «addfirstcategorydate=true» или «ordermethod=categoryadd»!",
-    "dpl_log_8": "ОШИБКА: вы не можете добавить более одного типа данных за раз!",
-    "dpl_log_9": "ОШИБКА: вы можете использовать «$0» только с «ordermethod=[...,]$1»!",
-    "dpl_log_10": "ERROR: the index for the dominant section must be between 1 and the number of arguments of includepage ($0 in this case)",
-    "dpl_log_12": "ERROR: specifying \"openreferences\" is incompatible with some other option you specified. See the manual for details.",
-    "dpl_log_13": "ПРЕДУПРЕЖДЕНИЕ: неизвестный параметр «$1» проигнорирован. Подсказка: доступные параметры: <code>$2</code>.",
-    "dpl_log_14": "ПРЕДУПРЕЖДЕНИЕ: неправильный параметр «$0»: «$1»! Использование параметра по умолчанию: «$2». Подсказка: <code>$0= $3</code>.",
-    "dpl_log_15": "ПРЕДУПРЕЖДЕНИЕ: неправильный параметр «$0»: «$1»! Использование параметра по умолчанию: «$2» (без ограничений). Подсказка: <code>$0= <i>пустая строка</i> (без ограничений) | n</code>, с <code>n</code> равным положительному целому числу.",
-    "dpl_log_16": "ПРЕДУПРЕЖДЕНИЕ: не найдено!",
-    "dpl_log_17": "ПРЕДУПРЕЖДЕНИЕ: Добавление* параметров («adduser», «addeditdate», и др.) не действительны с «mode=category». Только пространства имён или названия могут просматриваться в этом режиме.",
-    "dpl_log_18": "ПРЕДУПРЕЖДЕНИЕ: «headingmode=$0» не действителен с «ordermethod» в одном компоненте. Использование: «$1». Подсказка: вы можете использоватьe не-$1 «headingmode» значения с «ordermethod» во множестве компонентов. Первый компонент используется для заголовков. Например, «ordermethod=category,<i>comp</i>» (<i>comp</i> является другим компонентом) для заголовков категорий.",
-    "dpl_log_19": "ПРЕДУПРЕЖДЕНИЕ: «debug=$0» не находится на первом месте в DPL-элементе. Новые настройки отладки не будут применены пока все предыдущие параметры не будут разобраны и проверены.",
-    "dpl_log_21": "ЗАПРОС: <code>$0</code>",
-    "dpl_articlecount": "В этом заголовке $1 {{PLURAL:$1|статья|статьи|статей}}."
-}
\ No newline at end of file
diff --git a/i18n/sah.json b/i18n/sah.json
deleted file mode 100644
index b3502530..00000000
--- a/i18n/sah.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "HalanTul"
-        ]
-    },
-    "intersection-desc": "Категорияларга бүтэһик эбиилэри эбэтэр категориялар холбонууларын бэлиэлээх (маркированнай) испииһэк курдук таһаарар",
-    "intersection_toomanycats": "Error: категорийата наһаа элбэх!",
-    "intersection_toofewcats": "Error: Категорията наһаа аҕыйах",
-    "intersection_noresults": "Error: Түмүк суох!",
-    "intersection_noincludecats": "Error: Биир эмит категорияны эбэтэр ааты (пространство имен) талыахтааххын!"
-}
\ No newline at end of file
diff --git a/i18n/sk.json b/i18n/sk.json
deleted file mode 100644
index 5ec03387..00000000
--- a/i18n/sk.json
+++ /dev/null
@@ -1,33 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Helix84"
-        ]
-    },
-    "intersection-desc": "Vypíše zoznam najnovších položiek v kategórii alebo zjednotení niekoľkých kategórií",
-    "intersection_toomanycats": "Error: Príliš veľa kategórií!",
-    "intersection_toofewcats": "Error: Príliš málo kategórií!",
-    "intersection_noresults": "Error: Žiadne výsledky!",
-    "intersection_noincludecats": "Error: Musíte uviesť aspoň jednu kategóriu alebo menný priestor!",
-    "dpl_log_1": "CHYBA: nesprávny parameter '$0': '$1'! Pomocník <code>$0= <i>prázdny retazec</i> (Hlavný)$3<code>.",
-    "dpl_log_2": "CHYBA: Zlý parameter '$0': '$1'! Pomocník <code>$0= <i>plný názov stránky</i></code>.",
-    "dpl_log_3": "CHYBA: Príli vela kategórií! Maximum: $0. Pomocník: zväcite <code>DynamicPageListHooks::$maxCategoryCount</code>, aby ste mohli pecifikovat viac kategórií alebo nastavte <code>DynamicPageListHooks::$allowUnlimitedCategories=true</code> pre vypnutie limitu. (Premennú nastatavte v <code>LocalSettings.php</code>, potom ako bol includovaný <code>DynamicPageList.php</code>.)",
-    "dpl_log_4": "CHYBA: Príli málo kategórií! Minimum: $0. Pomocník: zníte <code>DynamicPageListHooks::$minCategoryCount</code>, aby ste mohli pecifikovat menej kategórií. (Premennú nastavte najlepie v <code>LocalSettings.php</code> potom, ako v nom bol includovaný <code>DynamicPageList.php</code>.)",
-    "dpl_log_5": "ERROR: No selection criteria found! You must use at least one of the following parameters: category, namespace, titlematch, linksto, uses, createdby, modifiedby, lastmodifiedby, or their 'not' variants",
-    "dpl_log_6": "CHYBA: Musíte uviest aspon jednu kategóriu ak chcete pouit 'addfirstcategorydate=true' alebo 'ordermethod=categoryadd'!",
-    "dpl_log_7": "CHYBA: Ak zahrniete viac ako jednu kategóriu, nemôete pouit 'addfirstcategorydate=true' alebo 'ordermethod=categoryadd'!",
-    "dpl_log_8": "CHYBA: Nemôete naraz pridat viac ako jeden typ dátumu!",
-    "dpl_log_9": "CHYBA: '$0' môete pouit iba s 'ordermethod=[...,]$1'!",
-    "dpl_log_10": "ERROR: the index for the dominant section must be between 1 and the number of arguments of includepage ($0 in this case)",
-    "dpl_log_11": "CHYBA: Nie je momoné vykonávat logické operácie na nekategorizovaných kategóriách (napr. s parametrom 'Kategória') lebo neexistuje na databázu pohlad $0! Pomocník: nech admin databázy vykoná tento dotaz: <code>$1</code>.",
-    "dpl_log_12": "ERROR: specifying \"openreferences\" is incompatible with some other option you specified. See the manual for details.",
-    "dpl_log_13": "VAROVANIE: Neznámy parameter '$1' ignorovaný. Pomocník: dostupné parametre: <code>$2</code>.",
-    "dpl_log_14": "VAROVANIE: Nesprávny '$0' parameter: '$1'! Pouívam tandardný '$2'. Pomocník: <code>$0= $3</code>.",
-    "dpl_log_15": "VAROVANIE: Nesprávny parameter  '$0': '$1'! Pouívam tandardný: '$2' (bez obmedzenia). Pomocník: <code>$0= <i>prázdny retazec</i> (bez obmedzenia) | n</code>, s kladným celým císlom <code>n</code>.",
-    "dpl_log_16": "VAROVANIE: No results!",
-    "dpl_log_17": "VAROVANIE: Parametre Add* ('adduser', 'addeditdate', atd' nepracujú s mode=category'. V tomto reime je moné prehliadat iba menná priestor/titulok stránky.",
-    "dpl_log_18": "VAROVANIE: 'headingmode=$0' nepracuje s 'ordermethod' na jednom komponente. Pouitie: '$1'. Pomocník: môete pouit not-$1 hodnoty 'headingmode' s 'ordermethod' na viaceré komponenty. Prvý komponent sa pouíva na nadpisy. Napr. 'ordermethod=category,<i>comp</i>' (<i>comp</i> je iný komponent) pre nadpisy kategórií.",
-    "dpl_log_19": "VAROVANIE: 'debug=$0' nie je na prvej pozícii v prvku DPL. Nové ladiacie nastavenia nebudú pouíté skôr ne budú parsované a skontrolované vetky predchádzajúce.",
-    "dpl_log_21": "DOTAZ: <code>$0</code>",
-    "dpl_articlecount": "V tomto nadpise {{PLURAL:$1|je jeden clánok|sú $1 clánky|je $1 clánkov}}."
-}
\ No newline at end of file
diff --git a/i18n/sr-ec.json b/i18n/sr-ec.json
deleted file mode 100644
index 1f22fb46..00000000
--- a/i18n/sr-ec.json
+++ /dev/null
@@ -1,34 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Millosh"
-        ]
-    },
-    "intersection-desc": "Даје редни списак најскорије додатих чланака у једну или више категорија.",
-    "intersection_toomanycats": "Грешка: Превише категорија!",
-    "intersection_toofewcats": "Грешка:Премало категорија!",
-    "intersection_noresults": "Грешка: Нема резулатата!",
-    "intersection_noincludecats": "Грешка: Потребно је укључити бар једну категорију или одредити именски простор!",
-    "dpl_log_1": "ГРЕШКА: Погреан '$0' параметар: '$1'! Помоћ:  <code>$0= <i>погрешан стринг</i> (Главно)$3</code>. (Еквиваленти са магичним речима су такође дозвољени.)",
-    "dpl_log_2": "ГРЕШКА: Погрешан '$0' параметар: '$1'! Помоћ:  <code>$0= <i>пуно име странице</i></code>. (Магичне речи су дозвољене.)",
-    "dpl_log_3": "ГРЕШКА: Превише категорија! Максимум је: $0. Помоћ: повећајте <code>DynamicPageListHooks::$maxCategoryCount</code> како бисте поставили више категорија или промените <code>DynamicPageListHooks::$allowUnlimitedCategories=true</code> за без граница. (Подесите варијаблу у <code>LocalSettings.php</code>, након укључивања <code>DynamicPageList.php</code>.)",
-    "dpl_log_4": "ГРЕШКА: Премало категорија! Минимум је: $0. Помоћ: повећајте <code>DynamicPageListHooks::$minCategoryCount</code> како бисте поставили мање категорија. (Подесите варијаблу у <code>LocalSettings.php</code>, након укључивања <code>DynamicPageList.php</code>.)",
-    "dpl_log_5": "ERROR: No selection criteria found! You must use at least one of the following parameters: category, namespace, titlematch, linksto, uses, createdby, modifiedby, lastmodifiedby, or their 'not' variants",
-    "dpl_log_6": "ГРЕШКА: Морате укључити бар једну категорију уколико желите да користите 'addfirstcategorydate=true' или 'ordermethod=categoryadd'!",
-    "dpl_log_7": "ГРЕШКА: Уколико укључујете више од једне категорије, не можете користити 'addfirstcategorydate=true' или 'ordermethod=categoryadd'!",
-    "dpl_log_8": "ГРЕШКА: Не можете додати више од једног типа датума!",
-    "dpl_log_9": "ГРЕШКА: Можете користити '$0' са 'ordermethod=[...,]$1' искључиво!",
-    "dpl_log_10": "ГРЕШКА: Немогуће извршити операцију на некатегоризованим страницама (нпр. са 'category' параметром) зато што $0 преглед не постоји у бази података! Помоћ: нека администратор базе изврши овај упит: <code>$1</code>.",
-    "dpl_log_11": "ERROR: Cannot perform logical operations on the Uncategorized pages (f.e. with the 'category' parameter) because the $0 view does not exist on the database! Help: have the database administrator execute this query: <code>$1</code>.",
-    "dpl_log_12": "ERROR: specifying \"openreferences\" is incompatible with some other option you specified. See the manual for details.",
-    "dpl_log_13": "ПАЖЊА: Непознат параметар '$1' је игнорисан. Помоћ: доступни параметри су: <code>$2</code>.",
-    "dpl_log_14": "ПАЖЊА: Погрешан '$0' параметар: '$1'! Користи се основни: '$2'. Помоћ: <code>$0= $3</code>.",
-    "dpl_log_15": "ПАЖЊА: Погрешан '$0' параметар: '$1'! Користи се основни: '$2' (без границе). Помоћ: <code>$0= <i>празан стринг</i> (без границе) | n</code>, с <code>n</code> је позитиван интегер.",
-    "dpl_log_16": "ПАЖЊА: Нема резултата!",
-    "dpl_log_17": "ПАЖЊА: Додавање* параметара ('adduser', 'addeditdate', итд.)' и 'includepage' нема ефекта са 'mode=category'. Искључиво име странице/именски простор могу да се виде у овом моду.",
-    "dpl_log_18": "ПАЖЊА: 'headingmode=$0' нема ефекта са 'ordermethod' на једној компоненти. Користи се: '$1'. Помоћ: не морате користити-$1 'headingmode' податке 'ordermethod' на више компоненти. Прва компонента се користи за наслов. Нпр. 'ordermethod=category,<i>компонента</i>' (<i>компонента</i> је друга компонента) за наслове категорија.",
-    "dpl_log_29": "ПАЖЊА: 'debug=$0' није на првом месту у DPL елементу. Нова дебаг подешавања нису примењена пре свих параметара који су проверени",
-    "dpl_log_20": "ПАЖЊА: Бесконачна петљаса странице '$0'.",
-    "dpl_log_21": "УПИТ: <code>$0</code>",
-    "dpl_articlecount": "У овом наслову се тренутно налази {{PLURAL:$1|један чланак|$1 чланка|$1 чланака}}."
-}
\ No newline at end of file
diff --git a/i18n/sr-el.json b/i18n/sr-el.json
deleted file mode 100644
index bc98e3d8..00000000
--- a/i18n/sr-el.json
+++ /dev/null
@@ -1,29 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Millosh"
-        ]
-    },
-    "dpl_log_1": "GREŠKA: Pogrean '$0' parametar: '$1'! Pomoć:  <code>$0= <i>pogrešan string</i> (Glavno)$3</code>. (Ekvivalenti sa magičnim rečima su takođe dozvoljeni.)",
-    "dpl_log_2": "GREŠKA: Pogrešan '$0' parametar: '$1'! Pomoć:  <code>$0= <i>puno ime stranice</i></code>. (Magične reči su dozvoljene.)",
-    "dpl_log_3": "GREŠKA: Previše kategorija! Maksimum je: $0. Pomoć: povećajte <code>DynamicPageListHooks::$maxCategoryCount</code> kako biste postavili više kategorija ili promenite <code>DynamicPageListHooks::$allowUnlimitedCategories=true</code> za bez granica. (Podesite varijablu u <code>LocalSettings.php</code>, nakon uključivanja <code>DynamicPageList.php</code>.)",
-    "dpl_log_4": "GREŠKA: Premalo kategorija! Minimum je: $0. Pomoć: povećajte <code>DynamicPageListHooks::$minCategoryCount</code> kako biste postavili manje kategorija. (Podesite varijablu u <code>LocalSettings.php</code>, nakon uključivanja <code>DynamicPageList.php</code>.)",
-    "dpl_log_5": "ERROR: No selection criteria found! You must use at least one of the following parameters: category, namespace, titlematch, linksto, uses, createdby, modifiedby, lastmodifiedby, or their 'not' variants",
-    "dpl_log_6": "GREŠKA: Morate uključiti bar jednu kategoriju ukoliko želite da koristite 'addfirstcategorydate=true' ili 'ordermethod=categoryadd'!",
-    "dpl_log_7": "GREŠKA: Ukoliko uključujete više od jedne kategorije, ne možete koristiti 'addfirstcategorydate=true' ili 'ordermethod=categoryadd'!",
-    "dpl_log_8": "GREŠKA: Ne možete dodati više od jednog tipa datuma!",
-    "dpl_log_9": "GREŠKA: Možete koristiti '$0' sa 'ordermethod=[...,]$1' isključivo!",
-    "dpl_log_10": "ERROR: the index for the dominant section must be between 1 and the number of arguments of includepage ($0 in this case)",
-    "dpl_log_11": "GREŠKA: Nemoguće izvršiti operaciju na nekategorizovanim stranicama (npr. sa 'category' parametrom) zato što $0 pregled ne postoji u bazi podataka! Pomoć: neka administrator baze izvrši ovaj upit: <code>$1</code>.",
-    "dpl_log_12": "ERROR: specifying \"openreferences\" is incompatible with some other option you specified. See the manual for details.",
-    "dpl_log_13": "PAŽNJA: Nepoznat parametar '$1' je ignorisan. Pomoć: dostupni parametri su: <code>$2</code>.",
-    "dpl_log_14": "PAŽNJA: Pogrešan '$0' parametar: '$1'! Koristi se osnovni: '$2'. Pomoć: <code>$0= $3</code>.",
-    "dpl_log_15": "PAŽNJA: Pogrešan '$0' parametar: '$1'! Koristi se osnovni: '$2' (bez granice). Pomoć: <code>$0= <i>prazan string</i> (bez granice) | n</code>, s <code>n</code> je pozitivan integer.",
-    "dpl_log_16": "PAŽNJA: Nema rezultata!",
-    "dpl_log_17": "PAŽNJA: Dodavanje* parametara ('adduser', 'addeditdate', itd.)' i 'includepage' nema efekta sa 'mode=category'. Isključivo ime stranice/imenski prostor mogu da se vide u ovom modu.",
-    "dpl_log_18": "PAŽNJA: 'headingmode=$0' nema efekta sa 'ordermethod' na jednoj komponenti. Koristi se: '$1'. Pomoć: ne morate koristiti-$1 'headingmode' podatke 'ordermethod' na više komponenti. Prva komponenta se koristi za naslov. Npr. 'ordermethod=category,<i>komponenta</i>' (<i>komponenta</i> je druga komponenta) za naslove kategorija.",
-    "dpl_log_19": "PAŽNJA: 'debug=$0' nije na prvom mestu u DPL elementu. Nova debag podešavanja nisu primenjena pre svih parametara koji su provereni",
-    "dpl_log_20": "PAŽNJA: Beskonačna petljasa stranice '$0'.",
-    "dpl_log_21": "UPIT: <code>$0</code>",
-    "dpl_articlecount": "U ovom naslovu se trenutno nalazi {{PLURAL:$1|jedan članak|$1 članka|$1 članaka}}"
-}
\ No newline at end of file
diff --git a/i18n/sr.json b/i18n/sr.json
deleted file mode 100644
index 1f22fb46..00000000
--- a/i18n/sr.json
+++ /dev/null
@@ -1,34 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Millosh"
-        ]
-    },
-    "intersection-desc": "Даје редни списак најскорије додатих чланака у једну или више категорија.",
-    "intersection_toomanycats": "Грешка: Превише категорија!",
-    "intersection_toofewcats": "Грешка:Премало категорија!",
-    "intersection_noresults": "Грешка: Нема резулатата!",
-    "intersection_noincludecats": "Грешка: Потребно је укључити бар једну категорију или одредити именски простор!",
-    "dpl_log_1": "ГРЕШКА: Погреан '$0' параметар: '$1'! Помоћ:  <code>$0= <i>погрешан стринг</i> (Главно)$3</code>. (Еквиваленти са магичним речима су такође дозвољени.)",
-    "dpl_log_2": "ГРЕШКА: Погрешан '$0' параметар: '$1'! Помоћ:  <code>$0= <i>пуно име странице</i></code>. (Магичне речи су дозвољене.)",
-    "dpl_log_3": "ГРЕШКА: Превише категорија! Максимум је: $0. Помоћ: повећајте <code>DynamicPageListHooks::$maxCategoryCount</code> како бисте поставили више категорија или промените <code>DynamicPageListHooks::$allowUnlimitedCategories=true</code> за без граница. (Подесите варијаблу у <code>LocalSettings.php</code>, након укључивања <code>DynamicPageList.php</code>.)",
-    "dpl_log_4": "ГРЕШКА: Премало категорија! Минимум је: $0. Помоћ: повећајте <code>DynamicPageListHooks::$minCategoryCount</code> како бисте поставили мање категорија. (Подесите варијаблу у <code>LocalSettings.php</code>, након укључивања <code>DynamicPageList.php</code>.)",
-    "dpl_log_5": "ERROR: No selection criteria found! You must use at least one of the following parameters: category, namespace, titlematch, linksto, uses, createdby, modifiedby, lastmodifiedby, or their 'not' variants",
-    "dpl_log_6": "ГРЕШКА: Морате укључити бар једну категорију уколико желите да користите 'addfirstcategorydate=true' или 'ordermethod=categoryadd'!",
-    "dpl_log_7": "ГРЕШКА: Уколико укључујете више од једне категорије, не можете користити 'addfirstcategorydate=true' или 'ordermethod=categoryadd'!",
-    "dpl_log_8": "ГРЕШКА: Не можете додати више од једног типа датума!",
-    "dpl_log_9": "ГРЕШКА: Можете користити '$0' са 'ordermethod=[...,]$1' искључиво!",
-    "dpl_log_10": "ГРЕШКА: Немогуће извршити операцију на некатегоризованим страницама (нпр. са 'category' параметром) зато што $0 преглед не постоји у бази података! Помоћ: нека администратор базе изврши овај упит: <code>$1</code>.",
-    "dpl_log_11": "ERROR: Cannot perform logical operations on the Uncategorized pages (f.e. with the 'category' parameter) because the $0 view does not exist on the database! Help: have the database administrator execute this query: <code>$1</code>.",
-    "dpl_log_12": "ERROR: specifying \"openreferences\" is incompatible with some other option you specified. See the manual for details.",
-    "dpl_log_13": "ПАЖЊА: Непознат параметар '$1' је игнорисан. Помоћ: доступни параметри су: <code>$2</code>.",
-    "dpl_log_14": "ПАЖЊА: Погрешан '$0' параметар: '$1'! Користи се основни: '$2'. Помоћ: <code>$0= $3</code>.",
-    "dpl_log_15": "ПАЖЊА: Погрешан '$0' параметар: '$1'! Користи се основни: '$2' (без границе). Помоћ: <code>$0= <i>празан стринг</i> (без границе) | n</code>, с <code>n</code> је позитиван интегер.",
-    "dpl_log_16": "ПАЖЊА: Нема резултата!",
-    "dpl_log_17": "ПАЖЊА: Додавање* параметара ('adduser', 'addeditdate', итд.)' и 'includepage' нема ефекта са 'mode=category'. Искључиво име странице/именски простор могу да се виде у овом моду.",
-    "dpl_log_18": "ПАЖЊА: 'headingmode=$0' нема ефекта са 'ordermethod' на једној компоненти. Користи се: '$1'. Помоћ: не морате користити-$1 'headingmode' податке 'ordermethod' на више компоненти. Прва компонента се користи за наслов. Нпр. 'ordermethod=category,<i>компонента</i>' (<i>компонента</i> је друга компонента) за наслове категорија.",
-    "dpl_log_29": "ПАЖЊА: 'debug=$0' није на првом месту у DPL елементу. Нова дебаг подешавања нису примењена пре свих параметара који су проверени",
-    "dpl_log_20": "ПАЖЊА: Бесконачна петљаса странице '$0'.",
-    "dpl_log_21": "УПИТ: <code>$0</code>",
-    "dpl_articlecount": "У овом наслову се тренутно налази {{PLURAL:$1|један чланак|$1 чланка|$1 чланака}}."
-}
\ No newline at end of file
diff --git a/i18n/stq.json b/i18n/stq.json
deleted file mode 100644
index 1c1e6eae..00000000
--- a/i18n/stq.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Pyt"
-        ]
-    },
-    "intersection-desc": "Uutgoawe fon ne Lieste fon do aktuälste Iendraage in ne Kategorie, of n Truchsnit fon moorere Kategorien.",
-    "intersection_toomanycats": "Error: Toufuul Kategorien!",
-    "intersection_toofewcats": "Error: Toumin Kategorien!",
-    "intersection_noresults": "Error: Neen Resultoat!",
-    "intersection_noincludecats": "Error: Der mout mindestens een Kategorie ienbuunen weese of reek n Noomensruum oun!"
-}
\ No newline at end of file
diff --git a/i18n/sv.json b/i18n/sv.json
deleted file mode 100644
index 98e320b4..00000000
--- a/i18n/sv.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Lejonel"
-        ]
-    },
-    "intersection-desc": "Skapar punktlistor över de nyaste sidorna i en eller flera kategorier",
-    "intersection_toomanycats": "Fel: För många kategorier!",
-    "intersection_toofewcats": "Fel: För få kategorier!",
-    "intersection_noresults": "Fel: Inga resultat!",
-    "intersection_noincludecats": "Fel: Du måste inkludera minst en kategori eller ange en namnrymd!"
-}
\ No newline at end of file
diff --git a/i18n/te.json b/i18n/te.json
deleted file mode 100644
index 6fff4b9b..00000000
--- a/i18n/te.json
+++ /dev/null
@@ -1,11 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Veeven"
-        ]
-    },
-    "intersection_toomanycats": "Error: చాలా ఎక్కువ వర్గాలు!",
-    "intersection_toofewcats": "Error: మరీ తక్కువ వర్గాలు!",
-    "intersection_noresults": "Error: ఫలితాలు లేవు!",
-    "intersection_noincludecats": "Error: మీరు కనీసం ఒక్క వర్గాన్నైనా చేర్చాలి, లేదా ఓ నేమ్&zwnj;స్పేసునైనా ఇవ్వాలి!"
-}
\ No newline at end of file
diff --git a/i18n/tg-cyrl.json b/i18n/tg-cyrl.json
deleted file mode 100644
index 1a4c59e1..00000000
--- a/i18n/tg-cyrl.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Ibrahim"
-        ]
-    },
-    "intersection-desc": "Феҳристи гулулае аз саҳифаҳое ба намоиш дар меояд, ки ба тозагӣ дар як ё чанд гурӯҳ ворид шудаанд",
-    "intersection_toomanycats": "Error: Теъдоди гурӯҳҳо зиёд аст!",
-    "intersection_toofewcats": "Error: Теъдоди гурӯҳҳо кам аст!",
-    "intersection_noresults": "Error: Натиҷае вуҷуд надорад!",
-    "intersection_noincludecats": "Error: Шумо ҳадди ақал бояд як гурӯҳро ворид кунед, ё як фазои номро мушаххас кунед!"
-}
\ No newline at end of file
diff --git a/i18n/tl.json b/i18n/tl.json
deleted file mode 100644
index 735806e7..00000000
--- a/i18n/tl.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "AnakngAraw"
-        ]
-    },
-    "intersection-desc": "Naglalabas ng isang tinuldukang talaan ng pinakakamakailang mga bagay-bagay na naninirahan sa loob ng isang kaurian, o isang pinagsangahang daanan ng ilang mga kaurian",
-    "intersection_toomanycats": "Kamalian: Napakaraming mga kaurian!",
-    "intersection_toofewcats": "Kamalian: Napakakaunti ng mga kaurian!",
-    "intersection_noresults": "Kaurian: Walang mga kinalabasan/resulta!",
-    "intersection_noincludecats": "Kamalian: Kinakailangan mong magsama ng kahit na isang kaurian, o tumukoy ng isang espasyo ng pangalan!"
-}
\ No newline at end of file
diff --git a/i18n/tr.json b/i18n/tr.json
deleted file mode 100644
index f92fc081..00000000
--- a/i18n/tr.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Joseph"
-        ]
-    },
-    "intersection-desc": "Bir kategoride, yada birçok kategorinin kesişiminde bulunan en son öğelerin, madde işaretli listesini üretir",
-    "intersection_toomanycats": "Hata: Çok fazla kategori!",
-    "intersection_toofewcats": "Hata: Çok az kategori!",
-    "intersection_noresults": "Hata: Sonuç yok!",
-    "intersection_noincludecats": "Hata: En az bir kategori eklemeli, ya da bir ad alanı belirtmelisiniz!"
-}
\ No newline at end of file
diff --git a/i18n/uk.json b/i18n/uk.json
deleted file mode 100644
index d704fff0..00000000
--- a/i18n/uk.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Ahonc"
-        ]
-    },
-    "intersection-desc": "Виводить у маркований список останні додавання до категорії або об'єднання кількох категорій",
-    "intersection_toomanycats": "Error: дуже багато категорій!",
-    "intersection_toofewcats": "Error: дуже мало категорій!",
-    "intersection_noresults": "Error: нема результатів!",
-    "intersection_noincludecats": "Error: ви повинні включити хоча б одну категорію або зазначити простір назв!"
-}
\ No newline at end of file
diff --git a/i18n/vec.json b/i18n/vec.json
deleted file mode 100644
index 7eff1d24..00000000
--- a/i18n/vec.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Candalua"
-        ]
-    },
-    "intersection-desc": "Mostra un elenco puntato coi elementi piassè reçenti inserìi in te na categoria o ne l'union de più categorie",
-    "intersection_toomanycats": "Error: Ghe xe massa categorie!",
-    "intersection_toofewcats": "Error: Ghe xe massa póche categorie!",
-    "intersection_noresults": "Error: Nissun risultato!",
-    "intersection_noincludecats": "Error: Te ghè da inclùdar almanco na categoria opure specificar un namespace."
-}
\ No newline at end of file
diff --git a/i18n/vep.json b/i18n/vep.json
deleted file mode 100644
index a578f904..00000000
--- a/i18n/vep.json
+++ /dev/null
@@ -1,10 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Игорь Бродский"
-        ]
-    },
-    "intersection_toomanycats": "Error: äjahk kategorijoid!",
-    "intersection_toofewcats": "Error: Vähähk kategorijoid!",
-    "intersection_noresults": "Error: Ei ole rezul'tatoid!"
-}
\ No newline at end of file
diff --git a/i18n/vi.json b/i18n/vi.json
deleted file mode 100644
index de9f25eb..00000000
--- a/i18n/vi.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Minh Nguyen"
-        ]
-    },
-    "intersection-desc": "Cho ra danh sách những khoản gần đây nhất được xếp vào một thể loại hay hợp của hơn một thể loại",
-    "intersection_toomanycats": "Error: Nhiều thể loại quá!",
-    "intersection_toofewcats": "Error: Ít thể loại quá!",
-    "intersection_noresults": "Error: Không tìm thấy trang nào!",
-    "intersection_noincludecats": "Error: Cần phải bao gồm ít nhất một thể loại hay định rõ một không gian tên!"
-}
\ No newline at end of file
diff --git a/i18n/vo.json b/i18n/vo.json
deleted file mode 100644
index e4bc55ff..00000000
--- a/i18n/vo.json
+++ /dev/null
@@ -1,11 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Smeira"
-        ]
-    },
-    "intersection_toomanycats": "Error: Klads tu mödiks!",
-    "intersection_toofewcats": "Error: Klads tu nemödiks!",
-    "intersection_noresults": "Error: Seks nonik!",
-    "intersection_noincludecats": "Error: Nedol välön kladi pu bali, u nemaspadi!"
-}
\ No newline at end of file
diff --git a/i18n/yue.json b/i18n/yue.json
deleted file mode 100644
index dc65190c..00000000
--- a/i18n/yue.json
+++ /dev/null
@@ -1,32 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Shinjiman"
-        ]
-    },
-    "intersection-desc": "輸出一個點列最近響分類嘅項目，或者係幾個分類嘅一個聯繫",
-    "intersection_toomanycats": "DynamicPageList: 太多分類!",
-    "intersection_toofewcats": "DynamicPageList: 太少分類!",
-    "intersection_noresults": "DynamicPageList: 無結果!",
-    "intersection_noincludecats": "DynamicPageList: 你需要去包含最少一個分類，或者指定一個空間名!",
-    "dpl-desc": "一個畀MediaWiki嘅高彈性報告產生器",
-    "dpl_log_1": "錯誤: 錯嘅 '$0' 參數: '$1'! 幫助:  <code>$0= <i>空字串</i> (主)$3</code>。",
-    "dpl_log_3": "錯誤: 太多分類! 最大值: $0。 幫助: 增加 <code>DynamicPageListHooks::$maxCategoryCount</code> 嘅值去指定更多嘅分類或者設定 <code>DynamicPageListHooks::$allowUnlimitedCategories=true</code> 以解除限制。 (當加上 <code>DynamicPageList.php</code>之後，響<code>LocalSettings.php</code>度設定變數。)",
-    "dpl_log_4": "錯誤: 太少分類! 最小值: $0. 幫助: 減少 <code>DynamicPageListHooks::$minCategoryCount</code> 嘅值去指定更少嘅分類。 (當加上 <code>DynamicPageList.php</code>之後，響<code>LocalSettings.php</code>度設定一個合適嘅變數。)",
-    "dpl_log_5": "ERROR: No selection criteria found! You must use at least one of the following parameters: category, namespace, titlematch, linksto, uses, createdby, modifiedby, lastmodifiedby, or their 'not' variants",
-    "dpl_log_6": "錯誤: 如果你想去用 'addfirstcategorydate=true' 或者 'ordermethod=categoryadd' ，你需要包含最少一個分類!",
-    "dpl_log_7": "錯誤: 如果你包含多過一個分類，你唔可以用 'addfirstcategorydate=true' 或者 'ordermethod=categoryadd'!",
-    "dpl_log_8": "錯誤: 你唔可以響一個時間度加入多個一種嘅日期!",
-    "dpl_log_9": "錯誤: 你只可以用 'ordermethod=[...,]$1' 響 '$0' 上!",
-    "dpl_log_10": "ERROR: the index for the dominant section must be between 1 and the number of arguments of includepage ($0 in this case)",
-    "dpl_log_12": "ERROR: specifying \"openreferences\" is incompatible with some other option you specified. See the manual for details.",
-    "dpl_log_13": "警告: 不明嘅參數 '$1' 被忽略。 幫助: 可用嘅參數: <code>$2</code>。",
-    "dpl_log_14": "警告: 錯誤嘅 '$0' 參數: '$1'! 用緊預設嘅: '$2'。 幫助: <code>$0= $3</code>。",
-    "dpl_log_15": "警告: 錯誤嘅 '$0' 參數: '$1'! 用緊預設嘅: '$2' (冇上限)。 幫助: <code>$0= <i>空字串</i> (冇上限) | n</code>, <code>n</code>係一個正整數。",
-    "dpl_log_16": "警告: 無結果!",
-    "dpl_log_17": "警告: 加入* 參數 ('adduser', 'addeditdate', 等)' 係對 'mode=category' 冇作用嘅。只有頁空間名／標題至可以響呢個模式度睇到。",
-    "dpl_log_18": "警告: 響單一部件中， 'ordermethod' 度用 'headingmode=$0' 係冇作用嘅。 用緊: '$1'。 幫助: 你可以用非$1 'headingmode' 數值，響多個部件中用 'ordermethod' 。第一個部件係用嚟做標題。例如響分類標題度用 'ordermethod=category,<i>comp</i>' (<i>comp</i>係另外一個部件) 。",
-    "dpl_log_19": "警告: 'debug=$0' 唔係第一個響DPL元素嘅第一位。新嘅除錯設定響所有參數都能夠處理同檢查之前都唔會應用。",
-    "dpl_log_21": "查訽: <code>$0</code>",
-    "dpl_articlecount": "響呢個標題度有$1篇文。"
-}
\ No newline at end of file
diff --git a/i18n/zh-hans.json b/i18n/zh-hans.json
deleted file mode 100644
index 52577456..00000000
--- a/i18n/zh-hans.json
+++ /dev/null
@@ -1,32 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Shinjiman"
-        ]
-    },
-    "intersection-desc": "输出一个点列最近在分类中的项目，或者系数个分类的一个联系",
-    "intersection_toomanycats": "DynamicPageList: 太多分类!",
-    "intersection_toofewcats": "DynamicPageList: 太少分类!",
-    "intersection_noresults": "DynamicPageList: 没有结果!",
-    "intersection_noincludecats": "DynamicPageList: 您需要去包含最少一个分类，或者指定一个空间名!",
-    "dpl-desc": "一个给MediaWiki的高弹性报告产生器",
-    "dpl_log_1": "错误: 错误的 '$0' 参数: '$1'! 帮助:  <code>$0= <i>空白字符串</i> (主)$3</code>。",
-    "dpl_log_3": "错误: 过多分类! 最大值: $0。 帮助: 增加 <code>DynamicPageListHooks::$maxCategoryCount</code> 的值去指定更多的分类或设定 <code>DynamicPageListHooks::$allowUnlimitedCategories=true</code> 以解除限制。 (当加上 <code>DynamicPageList.php</code>后，在<code>LocalSettings.php</code>中设定变量。)",
-    "dpl_log_4": "错误: 过少分类! 最小值: $0。 帮助: 减少 <code>DynamicPageListHooks::$minCategoryCount</code> 的值去指定更少的分类。 (当加上 <code>DynamicPageList.php</code>后，在<code>LocalSettings.php</code>中设定一个合适的变量。)",
-    "dpl_log_5": "ERROR: No selection criteria found! You must use at least one of the following parameters: category, namespace, titlematch, linksto, uses, createdby, modifiedby, lastmodifiedby, or their 'not' variants",
-    "dpl_log_6": "错误: 如果您想用 'addfirstcategorydate=true' 或 'ordermethod=categoryadd' ，您需要包含最少一个分类!",
-    "dpl_log_7": "错误: 如果您包含多一个分类，您不可以用 'addfirstcategorydate=true' 或 'ordermethod=categoryadd'!",
-    "dpl_log_8": "错误: 您不可以在一个时间里加入多于一种的日期!",
-    "dpl_log_9": "错误: 你只可以用 'ordermethod=[...,]$1' 在 '$0' 上!",
-    "dpl_log_10": "ERROR: the index for the dominant section must be between 1 and the number of arguments of includepage ($0 in this case)",
-    "dpl_log_12": "ERROR: specifying \"openreferences\" is incompatible with some other option you specified. See the manual for details.",
-    "dpl_log_13": "警告: 不明的参数 '$1' 被忽略。 帮助: 可用的参数: <code>$2</code>。",
-    "dpl_log_14": "警告: 错误的 '$0' 参数: '$1'! 正在使用默认值: '$2'。 帮助: <code>$0= $3</code>。",
-    "dpl_log_15": "警告: 错误的 '$0' 参数: '$1'! 正在使用默认值: '$2' (没有上限)。 帮助: <code>$0= <i>空白字符串</i> (没有上限) | n</code>, <code>n</code>是一个正整数。",
-    "dpl_log_16": "警告: 无结果!",
-    "dpl_log_17": "警告: 加入* 参数 ('adduser', 'addeditdate', 等)' 是对 'mode=category' 没有作用。只有页面空间名／标题才可以在这个模式度看到。",
-    "dpl_log_18": "警告: 在单一部件中， 'ordermethod' 用 'headingmode=$0' 是没有作用的。 正在使用: '$1'。 帮助: 你可以用非$1 'headingmode' 数值，在多个部件中用 'ordermethod' 。第一个部是用来作标题。例如在分类标题中用 'ordermethod=category,<i>comp</i>' (<i>comp</i>是另外一个部件) 。",
-    "dpl_log_19": "警告: 'debug=$0' 不是第一个在DPL元素嘅第一位置。新的除错设定在所有参数都能处理和检查前都不会应用。",
-    "dpl_log_21": "查訽: <code>$0</code>",
-    "dpl_articlecount": "在这个标题中有$1篇条目。"
-}
\ No newline at end of file
diff --git a/i18n/zh-hant.json b/i18n/zh-hant.json
deleted file mode 100644
index 53d638c5..00000000
--- a/i18n/zh-hant.json
+++ /dev/null
@@ -1,32 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Shinjiman"
-        ]
-    },
-    "intersection-desc": "輸出一個點列最近在分類中的項目，或者係數個分類的一個聯繫",
-    "intersection_toomanycats": "DynamicPageList: 太多分類!",
-    "intersection_toofewcats": "DynamicPageList: 太少分類!",
-    "intersection_noresults": "DynamicPageList: 沒有結果!",
-    "intersection_noincludecats": "DynamicPageList: 您需要去包含最少一個分類，或者指定一個空間名!",
-    "dpl-desc": "一個給MediaWiki的高彈性報告產生器",
-    "dpl_log_1": "錯誤: 錯誤的 '$0' 參數: '$1'! 說明:  <code>$0= <i>空白字串</i> (主)$3</code>。",
-    "dpl_log_3": "錯誤: 過多分類! 最大值: $0。 說明: 增加 <code>DynamicPageListHooks::$maxCategoryCount</code> 的值去指定更多的分類或設定 <code>DynamicPageListHooks::$allowUnlimitedCategories=true</code> 以解除限制。 (當加上 <code>DynamicPageList.php</code>後，在<code>LocalSettings.php</code>中設定變數。)",
-    "dpl_log_4": "錯誤: 過少分類! 最小值: $0。 說明: 減少 <code>DynamicPageListHooks::$minCategoryCount</code> 的值去指定更少的分類。 (當加上 <code>DynamicPageList.php</code>後，在<code>LocalSettings.php</code>中設定一個合適的變數。)",
-    "dpl_log_5": "ERROR: No selection criteria found! You must use at least one of the following parameters: category, namespace, titlematch, linksto, uses, createdby, modifiedby, lastmodifiedby, or their 'not' variants",
-    "dpl_log_6": "錯誤: 如果您想用 'addfirstcategorydate=true' 或 'ordermethod=categoryadd' ，您需要包含最少一個分類!",
-    "dpl_log_7": "錯誤: 如果您包含多一個分類，您不可以用 'addfirstcategorydate=true' 或 'ordermethod=categoryadd'!",
-    "dpl_log_8": "錯誤: 您不可以在一個時間裡加入多於一種的日期!",
-    "dpl_log_9": "錯誤: 你只可以用 'ordermethod=[...,]$1' 在 '$0' 上!",
-    "dpl_log_10": "ERROR: the index for the dominant section must be between 1 and the number of arguments of includepage ($0 in this case)",
-    "dpl_log_12": "ERROR: specifying \"openreferences\" is incompatible with some other option you specified. See the manual for details.",
-    "dpl_log_13": "警告: 不明的參數 '$1' 被忽略。 說明: 可用的參數: <code>$2</code>。",
-    "dpl_log_14": "警告: 錯誤的 '$0' 參數: '$1'! 正在使用預設值: '$2'。 說明: <code>$0= $3</code>。",
-    "dpl_log_15": "警告: 錯誤的 '$0' 參數: '$1'! 正在使用預設值: '$2' (沒有上限)。 說明: <code>$0= <i>空白字串</i> (沒有上限) | n</code>, <code>n</code>是一個正整數。",
-    "dpl_log_16": "警告: 無結果!",
-    "dpl_log_17": "警告: 加入* 參數 ('adduser', 'addeditdate', 等)' 是對 'mode=category' 沒有作用。只有頁面空間名／標題才可以在這個模式度看到。",
-    "dpl_log_18": "警告: 在單一部件中， 'ordermethod' 用 'headingmode=$0' 是沒有作用的。 正在使用: '$1'。 說明: 你可以用非$1 'headingmode' 數值，在多個部件中用 'ordermethod' 。第一個部是用來作標題。例如在分類標題中用 'ordermethod=category,<i>comp</i>' (<i>comp</i>是另外一個部件) 。",
-    "dpl_log_19": "警告: 'debug=$0' 不是第一個在DPL元素嘅第一位置。新的除錯設定在所有參數都能處理和檢查前都不會應用。",
-    "dpl_log_21": "查訽: <code>$0</code>",
-    "dpl_articlecount": "在這個標題中有$1篇條目。"
-}
\ No newline at end of file
diff --git a/includes/Article.php b/includes/Article.php
index 8f591813..f4241ec2 100644
--- a/includes/Article.php
+++ b/includes/Article.php
@@ -1,31 +1,22 @@
 <?php
-/**
- * DynamicPageList3
- * DPL Article Class
- *
- * @author		IlyaHaykinson, Unendlich, Dangerville, Algorithmix, Theaitetos, Alexia E. Smith, Universal Omega
- * @license		GPL-2.0-or-later
- * @package		DynamicPageList3
- *
- */
 
 namespace DPL;
 
 use MediaWiki\MediaWikiServices;
-use User;
+use Title;
 
 class Article {
 	/**
 	 * Title
 	 *
-	 * @var object
+	 * @var Title
 	 */
-	public $mTitle = null;
+	public $mTitle;
 
 	/**
 	 * Namespace ID
 	 *
-	 * @var string
+	 * @var int
 	 */
 	public $mNamespace = -1;
 
@@ -46,7 +37,7 @@ class Article {
 	/**
 	 * Selected namespace ID of initial page.
 	 *
-	 * @var string
+	 * @var int
 	 */
 	public $mSelNamespace = -1;
 
@@ -116,7 +107,7 @@ class Article {
 	/**
 	 * Timestamp depending on the user's request (can be first/last edit, page_touched, ...)
 	 *
-	 * @var string
+	 * @var string|int
 	 */
 	public $mDate = null;
 
@@ -184,52 +175,46 @@ class Article {
 	private static $headings = [];
 
 	/**
-	 * Main Constructor
-	 *
-	 * @access	public
-	 * @param	string	Title
-	 * @param	integer	Namespace
-	 * @return	void
+	 * @param Title $title
+	 * @param int $namespace
 	 */
-	public function __construct( $title, $namespace ) {
-		$this->mTitle     = $title;
+	public function __construct( Title $title, $namespace ) {
+		$this->mTitle = $title;
 		$this->mNamespace = $namespace;
 	}
 
 	/**
 	 * Initialize a new instance from a database row.
 	 *
-	 * @access	public
-	 * @param	array	Database Row
-	 * @param	object	\DPL\Parameters Object
-	 * @param	object	Mediawiki Title Object
-	 * @param	integer	Page Namespace ID
-	 * @param	string	Page Title as Selected from Query
-	 * @return	object	\DPL\Article Object
+	 * @param array	$row
+	 * @param Parameters $parameters
+	 * @param Title	$title
+	 * @param int $pageNamespace
+	 * @param string $pageTitle
+	 * @return Article
 	 */
-	public static function newFromRow( $row, Parameters $parameters, \Title $title, $pageNamespace, $pageTitle ) {
+	public static function newFromRow( $row, Parameters $parameters, Title $title, $pageNamespace, $pageTitle ) {
 		global $wgLang;
 
-		$article = new Article( $title, $pageNamespace );
+		$contentLanguage = MediaWikiServices::getInstance()->getContentLanguage();
 
-		$revActorName = null;
-		if ( isset( $row['revactor_actor'] ) ) {
-			$revActorName = User::newFromActorId( $row['revactor_actor'] )->getName();
-		}
+		$article = new Article( $title, $pageNamespace );
 
 		$titleText = $title->getText();
 		if ( $parameters->getParameter( 'shownamespace' ) === true ) {
 			$titleText = $title->getPrefixedText();
 		}
+
 		$replaceInTitle = $parameters->getParameter( 'replaceintitle' );
 		if ( is_array( $replaceInTitle ) && count( $replaceInTitle ) === 2 ) {
 			$titleText = preg_replace( $replaceInTitle[0], $replaceInTitle[1], $titleText );
 		}
 
-		//Chop off title if longer than the 'titlemaxlen' parameter.
+		// Chop off title if longer than the 'titlemaxlen' parameter.
 		if ( $parameters->getParameter( 'titlemaxlen' ) !== null && strlen( $titleText ) > $parameters->getParameter( 'titlemaxlen' ) ) {
 			$titleText = substr( $titleText, 0, $parameters->getParameter( 'titlemaxlen' ) ) . '...';
 		}
+
 		if ( $parameters->getParameter( 'showcurid' ) === true && isset( $row['page_id'] ) ) {
 			$articleLink = '[' . $title->getLinkURL( [ 'curid' => $row['page_id'] ] ) . ' ' . htmlspecialchars( $titleText ) . ']';
 		} else {
@@ -237,43 +222,47 @@ public static function newFromRow( $row, Parameters $parameters, \Title $title,
 		}
 
 		$article->mLink = $articleLink;
-		$contLang = MediaWikiServices::getInstance()->getContentLanguage();
 
-		//get first char used for category-style output
+		$languageConverter = MediaWikiServices::getInstance()
+			->getLanguageConverterFactory()
+			->getLanguageConverter();
+
+		// get first char used for category-style output
 		if ( isset( $row['sortkey'] ) ) {
-			$article->mStartChar = $contLang->convert( $contLang->firstChar( $row['sortkey'] ) );
+			$article->mStartChar = $languageConverter->convert( $contentLanguage->firstChar( $row['sortkey'] ) );
 		} else {
-			$article->mStartChar = $contLang->convert( $contLang->firstChar( $pageTitle ) );
+			$article->mStartChar = $languageConverter->convert( $contentLanguage->firstChar( $pageTitle ) );
 		}
 
 		$article->mID = intval( $row['page_id'] );
 
-		//External link
+		// External link
 		if ( isset( $row['el_to'] ) ) {
 			$article->mExternalLink = $row['el_to'];
 		}
 
-		//SHOW PAGE_COUNTER
+		// SHOW PAGE_COUNTER
 		if ( isset( $row['page_counter'] ) ) {
 			$article->mCounter = intval( $row['page_counter'] );
 		}
 
-		//SHOW PAGE_SIZE
+		// SHOW PAGE_SIZE
 		if ( isset( $row['page_len'] ) ) {
 			$article->mSize = intval( $row['page_len'] );
 		}
-		//STORE initially selected PAGE
+
+		// STORE initially selected PAGE
 		if ( is_array( $parameters->getParameter( 'linksto' ) ) && ( count( $parameters->getParameter( 'linksto' ) ) || count( $parameters->getParameter( 'linksfrom' ) ) ) ) {
 			if ( !isset( $row['sel_title'] ) ) {
-				$article->mSelTitle     = 'unknown page';
+				$article->mSelTitle = 'unknown page';
 				$article->mSelNamespace = 0;
 			} else {
-				$article->mSelTitle     = $row['sel_title'];
+				$article->mSelTitle = $row['sel_title'];
 				$article->mSelNamespace = $row['sel_ns'];
 			}
 		}
 
-		//STORE selected image
+		// STORE selected image
 		if ( is_array( $parameters->getParameter( 'imageused' ) ) && count( $parameters->getParameter( 'imageused' ) ) > 0 ) {
 			if ( !isset( $row['image_sel_title'] ) ) {
 				$article->mImageSelTitle = 'unknown image';
@@ -283,49 +272,51 @@ public static function newFromRow( $row, Parameters $parameters, \Title $title,
 		}
 
 		if ( $parameters->getParameter( 'goal' ) != 'categories' ) {
-			//REVISION SPECIFIED
+			// REVISION SPECIFIED
 			if ( $parameters->getParameter( 'lastrevisionbefore' ) || $parameters->getParameter( 'allrevisionsbefore' ) || $parameters->getParameter( 'firstrevisionsince' ) || $parameters->getParameter( 'allrevisionssince' ) ) {
-				$article->mRevision = $row['revactor_rev'];
-				$article->mUser     = $revActorName;
-				$article->mDate     = $row['revactor_timestamp'];
+				$article->mRevision = $row['rev_id'];
+				$article->mUser = $row['rev_user_text'];
+				$article->mDate = $row['rev_timestamp'];
+				$article->mComment = $row['rev_comment'];
 			}
 
-			//SHOW "PAGE_TOUCHED" DATE, "FIRSTCATEGORYDATE" OR (FIRST/LAST) EDIT DATE
+			// SHOW "PAGE_TOUCHED" DATE, "FIRSTCATEGORYDATE" OR (FIRST/LAST) EDIT DATE
 			if ( $parameters->getParameter( 'addpagetoucheddate' ) ) {
 				$article->mDate = $row['page_touched'];
 			} elseif ( $parameters->getParameter( 'addfirstcategorydate' ) ) {
 				$article->mDate = $row['cl_timestamp'];
-			} elseif ( $parameters->getParameter( 'addeditdate' ) && isset( $row['revactor_timestamp'] ) ) {
-				$article->mDate = $row['revactor_timestamp'];
+			} elseif ( $parameters->getParameter( 'addeditdate' ) && isset( $row['rev_timestamp'] ) ) {
+				$article->mDate = $row['rev_timestamp'];
 			} elseif ( $parameters->getParameter( 'addeditdate' ) && isset( $row['page_touched'] ) ) {
 				$article->mDate = $row['page_touched'];
 			}
 
-			//Time zone adjustment
+			// Time zone adjustment
 			if ( $article->mDate ) {
 				$article->mDate = $wgLang->userAdjust( $article->mDate );
 			}
 
 			if ( $article->mDate && $parameters->getParameter( 'userdateformat' ) ) {
-				//Apply the userdateformat
-				$article->myDate = gmdate( $parameters->getParameter( 'userdateformat' ), wfTimeStamp( TS_UNIX, $article->mDate ) );
+				// Apply the userdateformat
+				$article->myDate = gmdate( $parameters->getParameter( 'userdateformat' ), (int)wfTimestamp( TS_UNIX, $article->mDate ) );
 			}
+
 			// CONTRIBUTION, CONTRIBUTOR
 			if ( $parameters->getParameter( 'addcontribution' ) ) {
 				$article->mContribution = $row['contribution'];
-				$article->mContributor  = User::newFromActorId( $row['contributor'] )->getName();
-				$article->mContrib      = substr( '*****************', 0, (int)round( log( $row['contribution'] ) ) );
+				$article->mContributor = $row['contributor'];
+				$article->mContrib = substr( '*****************', 0, (int)round( log( $row['contribution'] ) ) );
 			}
 
-			//USER/AUTHOR(S)
+			// USER/AUTHOR(S)
 			// because we are going to do a recursive parse at the end of the output phase
 			// we have to generate wiki syntax for linking to a user´s homepage
 			if ( $parameters->getParameter( 'adduser' ) || $parameters->getParameter( 'addauthor' ) || $parameters->getParameter( 'addlasteditor' ) ) {
-				$article->mUserLink = '[[User:' . $revActorName . '|' . $revActorName . ']]';
-				$article->mUser     = $revActorName;
+				$article->mUserLink = '[[User:' . $row['rev_user_text'] . '|' . $row['rev_user_text'] . ']]';
+				$article->mUser = $row['rev_user_text'];
 			}
 
-			//CATEGORY LINKS FROM CURRENT PAGE
+			// CATEGORY LINKS FROM CURRENT PAGE
 			if ( $parameters->getParameter( 'addcategories' ) && ( $row['cats'] ) ) {
 				$artCatNames = explode( ' | ', $row['cats'] );
 				foreach ( $artCatNames as $artCatName ) {
@@ -333,26 +324,24 @@ public static function newFromRow( $row, Parameters $parameters, \Title $title,
 					$article->mCategoryTexts[] = str_replace( '_', ' ', $artCatName );
 				}
 			}
+
 			// PARENT HEADING (category of the page, editor (user) of the page, etc. Depends on ordermethod param)
 			if ( $parameters->getParameter( 'headingmode' ) != 'none' ) {
 				switch ( $parameters->getParameter( 'ordermethod' )[0] ) {
 					case 'category':
-						//Count one more page in this heading
+						// Count one more page in this heading
 						self::$headings[$row['cl_to']] = ( isset( self::$headings[$row['cl_to']] ) ? self::$headings[$row['cl_to']] + 1 : 1 );
 						if ( $row['cl_to'] == '' ) {
-							//uncategorized page (used if ordermethod=category,...)
+							// uncategorized page (used if ordermethod=category,...)
 							$article->mParentHLink = '[[:Special:Uncategorizedpages|' . wfMessage( 'uncategorizedpages' ) . ']]';
 						} else {
 							$article->mParentHLink = '[[:Category:' . $row['cl_to'] . '|' . str_replace( '_', ' ', $row['cl_to'] ) . ']]';
 						}
 						break;
 					case 'user':
-						self::$headings[$revActorName] = ( isset( self::$headings[$revActorName] ) ? self::$headings[$revActorName] + 1 : 1 );
-						if ( $row['revactor_actor'] == 0 ) { //anonymous user
-							$article->mParentHLink = '[[User:' . $revActorName . '|' . $revActorName . ']]';
-						} else {
-							$article->mParentHLink = '[[User:' . $revActorName . '|' . $revActorName . ']]';
-						}
+						self::$headings[$row['rev_user_text']] = ( isset( self::$headings[$row['rev_user_text']] ) ? self::$headings[$row['rev_user_text']] + 1 : 1 );
+
+						$article->mParentHLink = '[[User:' . $row['rev_user_text'] . '|' . $row['rev_user_text'] . ']]';
 						break;
 				}
 			}
@@ -364,8 +353,7 @@ public static function newFromRow( $row, Parameters $parameters, \Title $title,
 	/**
 	 * Returns all heading information processed from all newly instantiated article objects.
 	 *
-	 * @access	public
-	 * @return	array	Headings
+	 * @return array
 	 */
 	public static function getHeadings() {
 		return self::$headings;
@@ -375,9 +363,6 @@ public static function getHeadings() {
 	 * Reset the headings to their initial state.
 	 * Ideally this Article class should not exist and be handled by the built in MediaWiki class.
 	 * Bug: https://jira/browse/HYD-913
-	 *
-	 * @access	public
-	 * @return	void
 	 */
 	public static function resetHeadings() {
 		self::$headings = [];
@@ -386,16 +371,17 @@ public static function resetHeadings() {
 	/**
 	 * Get the formatted date for this article if available.
 	 *
-	 * @access	public
-	 * @return	mixed	Formatted string or null for none set.
+	 * @return mixed Formatted string or null for none set.
 	 */
 	public function getDate() {
 		global $wgLang;
+
 		if ( $this->myDate !== null ) {
 			return $this->myDate;
 		} elseif ( $this->mDate !== null ) {
-			return $wgLang->timeanddate( $article->mDate, true );
+			return $wgLang->timeanddate( $this->mDate, true );
 		}
+
 		return null;
 	}
 }
diff --git a/includes/Config.php b/includes/Config.php
index 3bd7b0a6..659ce367 100644
--- a/includes/Config.php
+++ b/includes/Config.php
@@ -1,15 +1,9 @@
 <?php
-/**
- * DynamicPageList3
- * DPL Config Class
- *
- * @author		IlyaHaykinson, Unendlich, Dangerville, Algorithmix, Theaitetos, Alexia E. Smith
- * @license		GPL-2.0-or-later
- * @package		DynamicPageList3
- *
- */
+
 namespace DPL;
 
+use MWException;
+
 class Config {
 	/**
 	 * Configuration Settings
@@ -21,15 +15,13 @@ class Config {
 	/**
 	 * Initialize the static object with settings.
 	 *
-	 * @access	public
-	 * @param	array	Settings to initialize for DPL.
-	 * @return	void
+	 * @param array|false $settings
 	 */
 	public static function init( $settings = false ) {
 		if ( $settings === false ) {
 			global $wgDplSettings;
 
-			$settings = $wgDplSettings;
+			$settings = $wgDplSettings ?? false;
 		}
 
 		if ( !is_array( $settings ) ) {
@@ -42,19 +34,17 @@ public static function init( $settings = false ) {
 	/**
 	 * Return a single setting.
 	 *
-	 * @access	public
-	 * @param	string	Setting Key
-	 * @return	mixed	The setting's actual setting or null if it does not exist.
+	 * @param string $setting
+	 * @return mixed|null
 	 */
 	public static function getSetting( $setting ) {
-		return ( array_key_exists( $setting, self::$settings ) ? self::$settings[$setting] : null );
+		return ( self::$settings[$setting] ?? null );
 	}
 
 	/**
 	 * Return a all settings.
 	 *
-	 * @access	public
-	 * @return	array	All settings
+	 * @return array
 	 */
 	public static function getAllSettings() {
 		return self::$settings;
@@ -63,15 +53,14 @@ public static function getAllSettings() {
 	/**
 	 * Set a single setting.
 	 *
-	 * @access	public
-	 * @param	string	Setting Key
-	 * @param	mixed	[Optional] Appropriate value for the setting key.
-	 * @return	void
+	 * @param string $setting
+	 * @param mixed|null $value
 	 */
 	public static function setSetting( $setting, $value = null ) {
 		if ( empty( $setting ) || !is_string( $setting ) ) {
 			throw new MWException( __METHOD__ . ": Setting keys can not be blank." );
 		}
+
 		self::$settings[$setting] = $value;
 	}
 }
diff --git a/DynamicPageListHooks.php b/includes/DynamicPageListHooks.php
similarity index 62%
rename from DynamicPageListHooks.php
rename to includes/DynamicPageListHooks.php
index 2dfa4355..a1a14259 100644
--- a/DynamicPageListHooks.php
+++ b/includes/DynamicPageListHooks.php
@@ -1,130 +1,96 @@
 <?php
-/**
- *
- * @file
- * @ingroup Extensions
- * @link http://www.mediawiki.org/wiki/Extension:DynamicPageList3 Documentation
- * @author n:en:User:IlyaHaykinson
- * @author n:en:User:Amgine
- * @author w:de:Benutzer:Unendlich
- * @author m:User:Dangerman <cyril.dangerville@gmail.com>
- * @author m:User:Algorithmix <gero.scholz@gmx.de>
- * @license GPL-2.0-or-later
- *
- */
 
-class DynamicPageListHooks {
-	// FATAL
-	const FATAL_WRONGNS = 1001;	// $1: 'namespace' or 'notnamespace'
-															// $2: wrong parameter given by user
-															// $3: list of possible titles of namespaces (except pseudo-namespaces: Media, Special)
-
-	const FATAL_WRONGLINKSTO = 1002;	// $1: linksto'
-															// $2: the wrong parameter given by user
-
-	const FATAL_TOOMANYCATS = 1003;	// $1: max number of categories that can be included
+namespace DPL;
 
-	const FATAL_TOOFEWCATS = 1004;	// $1: min number of categories that have to be included
+use DatabaseUpdater;
+use Parser;
+use PPFrame;
 
-	const FATAL_NOSELECTION = 1005;
+class DynamicPageListHooks {
 
-	const FATAL_CATDATEBUTNOINCLUDEDCATS = 1006;
+	public const FATAL_WRONGNS = 1001;
 
-	const FATAL_CATDATEBUTMORETHAN1CAT = 1007;
+	public const FATAL_WRONGLINKSTO = 1002;
 
-	const FATAL_MORETHAN1TYPEOFDATE = 1008;
+	public const FATAL_TOOMANYCATS = 1003;
 
-	const FATAL_WRONGORDERMETHOD = 1009;	// $1: param=val that is possible only with $1 as last 'ordermethod' parameter
-															// $2: last 'ordermethod' parameter required for $0
+	public const FATAL_TOOFEWCATS = 1004;
 
-	const FATAL_DOMINANTSECTIONRANGE = 1010;	// $1: the number of arguments in includepage
+	public const FATAL_NOSELECTION = 1005;
 
-	const FATAL_OPENREFERENCES = 1012;
+	public const FATAL_CATDATEBUTNOINCLUDEDCATS = 1006;
 
-	const FATAL_MISSINGPARAMFUNCTION = 1022;
+	public const FATAL_CATDATEBUTMORETHAN1CAT = 1007;
 
-	const FATAL_NOTPROTECTED = 1023;
+	public const FATAL_MORETHAN1TYPEOFDATE = 1008;
 
-	const FATAL_SQLBUILDERROR = 1024;
+	public const FATAL_WRONGORDERMETHOD = 1009;
 
-	// ERROR
+	public const FATAL_DOMINANTSECTIONRANGE = 1010;
 
-	// WARN
+	public const FATAL_OPENREFERENCES = 1012;
 
-	const WARN_UNKNOWNPARAM = 2013;	// $1: unknown parameter given by user
-															// $2: list of DPL available parameters separated by ', '
+	public const FATAL_MISSINGPARAMFUNCTION = 1022;
 
-	const WARN_PARAMNOOPTION = 2022;	// $1: Parameter given by user
+	public const FATAL_NOTPROTECTED = 1023;
 
-	const WARN_WRONGPARAM = 2014;	// $3: list of valid param values separated by ' | '
+	public const FATAL_SQLBUILDERROR = 1024;
 
-	const WARN_WRONGPARAM_INT = 2015;	// $1: param name
-															// $2: wrong param value given by user
-															// $3: default param value used instead by program
+	public const WARN_UNKNOWNPARAM = 2013;
 
-	const WARN_NORESULTS = 2016;
+	public const WARN_PARAMNOOPTION = 2022;
 
-	const WARN_CATOUTPUTBUTWRONGPARAMS = 2017;
+	public const WARN_WRONGPARAM = 2014;
 
-	const WARN_HEADINGBUTSIMPLEORDERMETHOD = 2018;	// $1: 'headingmode' value given by user
-															// $2: value used instead by program (which means no heading)
+	public const WARN_WRONGPARAM_INT = 2015;
 
-	const WARN_DEBUGPARAMNOTFIRST = 2019;	// $1: 'log' value
+	public const WARN_NORESULTS = 2016;
 
-	const WARN_TRANSCLUSIONLOOP = 2020;	// $1: title of page that creates an infinite transclusion loop
+	public const WARN_CATOUTPUTBUTWRONGPARAMS = 2017;
 
-	// INFO
+	public const WARN_HEADINGBUTSIMPLEORDERMETHOD = 2018;
 
-	// DEBUG
+	public const WARN_DEBUGPARAMNOTFIRST = 2019;
 
-	const DEBUG_QUERY = 3021;	// $1: SQL query executed to generate the dynamic page list
+	public const WARN_TRANSCLUSIONLOOP = 2020;
 
-	// TRACE
-															// Output formatting
-															// $1: number of articles
+	public const DEBUG_QUERY = 3021;
 
+	/** @var array */
 	public static $fixedCategories = [];
 
-	public static $createdLinks; // the links created by DPL are collected here;
-								 // they can be removed during the final ouput
-								 // phase of the MediaWiki parser
+	/** @var array */
+	public static $createdLinks;
 
-	/**
-	 * DPL acting like Extension:Intersection
-	 *
-	 * @var bool
-	 */
+	/** @var bool */
 	private static $likeIntersection = false;
 
-	/**
-	 * Debugging Level
-	 *
-	 * @var int
-	 */
+	/** @var int */
 	private static $debugLevel = 0;
 
 	/**
-	 * Handle special on extension registration bits.
-	 *
-	 * @return void
+	 * @return string
 	 */
-	public static function onRegistration() {
-		if ( !defined( 'DPL_VERSION' ) ) {
-			define( 'DPL_VERSION', '3.3.5' );
+	public static function getVersion(): string {
+		static $version = null;
+
+		if ( $version === null ) {
+			$version = json_decode( file_get_contents( __DIR__ . '/../extension.json' ) )->version;
 		}
+
+		return $version;
 	}
 
 	/**
 	 * Sets up this extension's parser functions.
 	 *
-	 * @param object Parser object passed as a reference.
-	 * @return bool	true
+	 * @param Parser $parser
 	 */
-	public static function onParserFirstCallInit( Parser &$parser ) {
+	public static function onParserFirstCallInit( Parser $parser ) {
 		self::init();
 
-		//DPL offers the same functionality as Intersection.  So we register the <DynamicPageList> tag in case LabeledSection Extension is not installed so that the section markers are removed.
-		if ( \DPL\Config::getSetting( 'handleSectionTag' ) ) {
+		// DPL offers the same functionality as Intersection. So we register the <DynamicPageList> tag in case LabeledSection Extension is not installed so that the section markers are removed.
+		if ( Config::getSetting( 'handleSectionTag' ) ) {
 			$parser->setHook( 'section', [ __CLASS__, 'dplTag' ] );
 		}
 
@@ -137,33 +103,25 @@ public static function onParserFirstCallInit( Parser &$parser ) {
 		$parser->setFunctionHook( 'dplreplace', [ __CLASS__, 'dplReplaceParserFunction' ] );
 		$parser->setFunctionHook( 'dplchapter', [ __CLASS__, 'dplChapterParserFunction' ] );
 		$parser->setFunctionHook( 'dplmatrix', [ __CLASS__, 'dplMatrixParserFunction' ] );
-
-		return true;
 	}
 
 	/**
 	 * Sets up this extension's parser functions for migration from Intersection.
 	 *
-	 * @param object Parser object passed as a reference.
-	 * @returnbool true
+	 * @param Parser $parser
 	 */
-	public static function setupMigration( Parser &$parser ) {
+	public static function setupMigration( Parser $parser ) {
 		$parser->setHook( 'Intersection', [ __CLASS__, 'intersectionTag' ] );
 		$parser->addTrackingCategory( 'dpl-intersection-tracking-category' );
 
 		self::init();
-
-		return true;
 	}
 
 	/**
 	 * Common initializer for usage from parser entry points.
-	 *
-	 * @private
-	 * @return void
 	 */
 	private static function init() {
-		\DPL\Config::init();
+		Config::init();
 
 		if ( !isset( self::$createdLinks ) ) {
 			self::$createdLinks = [
@@ -180,9 +138,7 @@ private static function init() {
 	/**
 	 * Set to behave like intersection.
 	 *
-	 * @private
-	 * @param bool	Behave Like Intersection
-	 * @return void
+	 * @param bool $mode
 	 */
 	private static function setLikeIntersection( $mode = false ) {
 		self::$likeIntersection = $mode;
@@ -191,7 +147,7 @@ private static function setLikeIntersection( $mode = false ) {
 	/**
 	 * Is like intersection?
 	 *
-	 * @return bool	Behaving Like Intersection
+	 * @return bool
 	 */
 	public static function isLikeIntersection() {
 		return (bool)self::$likeIntersection;
@@ -200,70 +156,77 @@ public static function isLikeIntersection() {
 	/**
 	 * Tag <section> entry point.
 	 *
-	 * @param string Raw User Input
-	 * @param array Arguments on the tag.
-	 * @param object Parser object.
-	 * @param object PPFrame object.
-	 * @return string HTML
+	 * @param string $input
+	 * @param array $args
+	 * @param Parser $parser
+	 * @param PPFrame $frame
+	 * @return string
 	 */
 	public static function intersectionTag( $input, array $args, Parser $parser, PPFrame $frame ) {
 		self::setLikeIntersection( true );
+
 		return self::executeTag( $input, $args, $parser, $frame );
 	}
 
 	/**
 	 * Tag <dpl> entry point.
 	 *
-	 * @param string Raw User Input
-	 * @param array Arguments on the tag.
-	 * @param object Parser object.
-	 * @param object PPFrame object.
-	 * @return string HTML
+	 * @param string $input
+	 * @param array $args
+	 * @param Parser $parser
+	 * @param PPFrame $frame
+	 * @return string
 	 */
 	public static function dplTag( $input, array $args, Parser $parser, PPFrame $frame ) {
 		self::setLikeIntersection( false );
 		$parser->addTrackingCategory( 'dpl-tag-tracking-category' );
+
 		return self::executeTag( $input, $args, $parser, $frame );
 	}
 
 	/**
 	 * The callback function wrapper for converting the input text to HTML output
 	 *
-	 * @param string Raw User Input
-	 * @param array Arguments on the tag.(While not used, it is left here for future compatibility.)
-	 * @param object Parser object.
-	 * @param object PPFrame object.
-	 * @return string HTML
+	 * @param string $input
+	 * @param array $args
+	 * @param Parser $parser
+	 * @param PPFrame $frame
+	 * @return string
 	 */
 	private static function executeTag( $input, array $args, Parser $parser, PPFrame $frame ) {
-		// entry point for user tag <dpl>  or  <DynamicPageList>
+		// entry point for user tag <dpl> or <DynamicPageList>
 		// create list and do a recursive parse of the output
 
-		$parse = new \DPL\Parse();
-		if ( \DPL\Config::getSetting( 'recursiveTagParse' ) ) {
+		$parse = new Parse();
+		if ( Config::getSetting( 'recursiveTagParse' ) ) {
 			$input = $parser->recursiveTagParse( $input, $frame );
 		}
 
 		$text = $parse->parse( $input, $parser, $reset, $eliminate, true );
 
-		if ( isset( $reset['templates'] ) && $reset['templates'] ) {	// we can remove the templates by save/restore
+		if ( $reset['templates'] ?? false ) { // we can remove the templates by save/restore
 			$saveTemplates = $parser->getOutput()->mTemplates;
 		}
-		if ( isset( $reset['categories'] ) && $reset['categories'] ) {	// we can remove the categories by save/restore
+
+		if ( $reset['categories'] ?? false ) { // we can remove the categories by save/restore
 			$saveCategories = $parser->getOutput()->mCategories;
 		}
-		if ( isset( $reset['images'] ) && $reset['images'] ) {	// we can remove the images by save/restore
+
+		if ( $reset['images'] ?? false ) { // we can remove the images by save/restore
 			$saveImages = $parser->getOutput()->mImages;
 		}
+
 		$parsedDPL = $parser->recursiveTagParse( $text );
-		if ( isset( $reset['templates'] ) && $reset['templates'] ) {
-			$parser->getOutput()->mTemplates = $saveTemplates;
+		if ( $reset['templates'] ?? false ) {
+			$parser->getOutput()->mTemplates = $saveTemplates ?? [];
 		}
-		if ( isset( $reset['categories'] ) && $reset['categories'] ) {
-			$parser->getOutput()->mCategories = $saveCategories;
+
+		if ( $reset['categories'] ?? false ) {
+			$parser->getOutput()->mCategories = $saveCategories ?? [];
 		}
-		if ( isset( $reset['images'] ) && $reset['images'] ) {
-			$parser->getOutput()->mImages = $saveImages;
+
+		if ( $reset['images'] ?? false ) {
+			$parser->getOutput()->mImages = $saveImages ?? [];
 		}
 
 		return $parsedDPL;
@@ -272,20 +235,21 @@ private static function executeTag( $input, array $args, Parser $parser, PPFrame
 	/**
 	 * The #dpl parser tag entry point.
 	 *
-	 * @param object Parser object passed as a reference.
-	 * @return string Wiki Text
+	 * @param Parser $parser
+	 * @return array|string
 	 */
-	public static function dplParserFunction( &$parser ) {
+	public static function dplParserFunction( $parser ) {
 		self::setLikeIntersection( false );
 
 		$parser->addTrackingCategory( 'dpl-parserfunc-tracking-category' );
 
-		// callback for the parser function {{#dpl:	  or   {{DynamicPageList::
+		// callback for the parser function {{#dpl: or {{DynamicPageList::
 		$input = "";
 
 		$numargs = func_num_args();
 		if ( $numargs < 2 ) {
 			$input = "#dpl: no arguments specified";
+
 			return str_replace( '§', '<', '§pre>§nowiki>' . $input . '§/nowiki>§/pre>' );
 		}
 
@@ -293,13 +257,16 @@ public static function dplParserFunction( &$parser ) {
 		$arg_list = func_get_args();
 		for ( $i = 1; $i < $numargs; $i++ ) {
 			$p1 = $arg_list[$i];
+
 			$input .= str_replace( "\n", "", $p1 ) . "\n";
 		}
 
-		$parse = new \DPL\Parse();
+		$parse = new Parse();
 		$dplresult = $parse->parse( $input, $parser, $reset, $eliminate, false );
-		return [ // parser needs to be coaxed to do further recursive processing
-			$parser->getPreprocessor()->preprocessToObj( $dplresult, Parser::PTD_FOR_INCLUSION ),
+
+		return [
+			// @phan-suppress-next-line PhanPluginMixedKeyNoKey
+			$parser->getPreprocessor()->preprocessToObj( $dplresult, 1 ),
 			'isLocalObj' => true,
 			'title' => $parser->getTitle()
 		];
@@ -307,13 +274,15 @@ public static function dplParserFunction( &$parser ) {
 
 	/**
 	 * The #dplnum parser tag entry point.
-	 * From the old documentation: "Tries to guess a number that is buried in the text.  Uses a set of heuristic rules which may work or not.  The idea is to extract the number so that it can be used as a sorting value in the column of a DPL table output."
+	 * From the old documentation: "Tries to guess a number that is buried in the text. Uses a set of heuristic rules which may work or not. The idea is to extract the number so that it can be used as a sorting value in the column of a DPL table output."
 	 *
-	 * @param object Parser object passed as a reference.
-	 * @return string Wiki Text
+	 * @param Parser $parser
+	 * @param string $text
+	 * @return string
 	 */
-	public static function dplNumParserFunction( &$parser, $text = '' ) {
+	public static function dplNumParserFunction( $parser, $text = '' ) {
 		$parser->addTrackingCategory( 'dplnum-parserfunc-tracking-category' );
+
 		$num = str_replace( '&#160;', ' ', $text );
 		$num = str_replace( '&nbsp;', ' ', $text );
 		$num = preg_replace( '/([0-9])([.])([0-9][0-9]?[^0-9,])/', '\1,\3', $num );
@@ -328,34 +297,41 @@ public static function dplNumParserFunction( &$parser, $text = '' ) {
 		$num = preg_replace( '/[. ]/', '', $num );
 		$num = preg_replace( '/^[^0-9]+/', '', $num );
 		$num = preg_replace( '/[^0-9].*/', '', $num );
+
 		return $num;
 	}
 
 	public static function dplVarParserFunction( &$parser, $cmd ) {
 		$parser->addTrackingCategory( 'dplvar-parserfunc-tracking-category' );
 		$args = func_get_args();
+
 		if ( $cmd == 'set' ) {
-			return \DPL\Variables::setVar( $args );
+			return Variables::setVar( $args );
 		} elseif ( $cmd == 'default' ) {
-			return \DPL\Variables::setVarDefault( $args );
+			return Variables::setVarDefault( $args );
 		}
-		return \DPL\Variables::getVar( $cmd );
+
+		return Variables::getVar( $cmd );
 	}
 
 	private static function isRegexp( $needle ) {
 		if ( strlen( $needle ) < 3 ) {
 			return false;
 		}
+
 		if ( ctype_alnum( $needle[0] ) ) {
 			return false;
 		}
+
 		$nettoNeedle = preg_replace( '/[ismu]*$/', '', $needle );
 		if ( strlen( $nettoNeedle ) < 2 ) {
 			return false;
 		}
+
 		if ( $needle[0] == $nettoNeedle[strlen( $nettoNeedle ) - 1] ) {
 			return true;
 		}
+
 		return false;
 	}
 
@@ -364,7 +340,8 @@ public static function dplReplaceParserFunction( &$parser, $text, $pat = '', $re
 		if ( $text == '' || $pat == '' ) {
 			return '';
 		}
-		# convert \n to a real newline character
+
+		// convert \n to a real newline character
 		$repl = str_replace( '\n', "\n", $repl );
 
 		# replace
@@ -372,40 +349,47 @@ public static function dplReplaceParserFunction( &$parser, $text, $pat = '', $re
 			$pat = '`' . str_replace( '`', '\`', $pat ) . '`';
 		}
 
+		// phpcs:ignore Generic.PHP.NoSilencedErrors.Discouraged
 		return @preg_replace( $pat, $repl, $text );
 	}
 
 	public static function dplChapterParserFunction( &$parser, $text = '', $heading = ' ', $maxLength = -1, $page = '?page?', $link = 'default', $trim = false ) {
 		$parser->addTrackingCategory( 'dplchapter-parserfunc-tracking-category' );
-		$output = \DPL\LST::extractHeadingFromText( $parser, $page, '?title?', $text, $heading, '', $sectionHeading, true, $maxLength, $link, $trim );
+		$output = LST::extractHeadingFromText( $parser, $page, '?title?', $text, $heading, '', $sectionHeading, true, $maxLength, $link, $trim );
 		return $output[0];
 	}
 
 	public static function dplMatrixParserFunction( &$parser, $name = '', $yes = '', $no = '', $flip = '', $matrix = '' ) {
 		$parser->addTrackingCategory( 'dplmatrix-parserfunc-tracking-category' );
-		$lines   = explode( "\n", $matrix );
-		$m       = [];
+		$lines = explode( "\n", $matrix );
+		$m = [];
 		$sources = [];
 		$targets = [];
-		$from    = '';
-		$to      = '';
-		if ( $flip == '' | $flip == 'normal' ) {
+		$from = '';
+		$to = '';
+
+		if ( $flip == '' || $flip == 'normal' ) {
 			$flip = false;
 		} else {
 			$flip = true;
 		}
+
 		if ( $name == '' ) {
 			$name = '&#160;';
 		}
+
 		if ( $yes == '' ) {
 			$yes = ' x ';
 		}
+
 		if ( $no == '' ) {
 			$no = '&#160;';
 		}
+
 		if ( $no[0] == '-' ) {
 			$no = " $no ";
 		}
+
 		foreach ( $lines as $line ) {
 			if ( strlen( $line ) <= 0 ) {
 				continue;
@@ -419,18 +403,23 @@ public static function dplMatrixParserFunction( &$parser, $name = '', $yes = '',
 					} else {
 						$sources[$from[0]] = $from[1];
 					}
+
 					$m[$from[0]] = [];
 				}
 			} elseif ( trim( $line ) != '' ) {
 				$to = preg_split( ' *\~\~ *', trim( $line ), 2 );
+
 				if ( count( $to ) < 2 || $to[1] == '' ) {
 					$targets[$to[0]] = $to[0];
 				} else {
 					$targets[$to[0]] = $to[1];
 				}
+
+				// @phan-suppress-next-line PhanTypeInvalidDimOffset
 				$m[$from[0]][$to[0]] = true;
 			}
 		}
+
 		ksort( $targets );
 
 		$header = "\n";
@@ -439,8 +428,10 @@ public static function dplMatrixParserFunction( &$parser, $name = '', $yes = '',
 			foreach ( $sources as $from => $fromName ) {
 				$header .= "![[$from|" . $fromName . "]]\n";
 			}
+
 			foreach ( $targets as $to => $toName ) {
 				$targets[$to] = "[[$to|$toName]]";
+
 				foreach ( $sources as $from => $fromName ) {
 					if ( array_key_exists( $to, $m[$from] ) ) {
 						$targets[$to] .= "\n|$yes";
@@ -448,15 +439,19 @@ public static function dplMatrixParserFunction( &$parser, $name = '', $yes = '',
 						$targets[$to] .= "\n|$no";
 					}
 				}
+
 				$targets[$to] .= "\n|--\n";
 			}
+
 			return "{|class=dplmatrix\n|$name" . "\n" . $header . "|--\n!" . implode( "\n!", $targets ) . "\n|}";
 		} else {
 			foreach ( $targets as $to => $toName ) {
 				$header .= "![[$to|" . $toName . "]]\n";
 			}
+
 			foreach ( $sources as $from => $fromName ) {
 				$sources[$from] = "[[$from|$fromName]]";
+
 				foreach ( $targets as $to => $toName ) {
 					if ( array_key_exists( $to, $m[$from] ) ) {
 						$sources[$from] .= "\n|$yes";
@@ -464,14 +459,15 @@ public static function dplMatrixParserFunction( &$parser, $name = '', $yes = '',
 						$sources[$from] .= "\n|$no";
 					}
 				}
+
 				$sources[$from] .= "\n|--\n";
 			}
+
 			return "{|class=dplmatrix\n|$name" . "\n" . $header . "|--\n!" . implode( "\n!", $sources ) . "\n|}";
 		}
 	}
 
 	private static function dumpParsedRefs( $parser, $label ) {
-		// if (!preg_match("/Query Q/",$parser->mTitle->getText())) return '';
 		echo '<pre>parser mLinks: ';
 		ob_start();
 		var_dump( $parser->getOutput()->mLinks );
@@ -502,9 +498,7 @@ public static function fixCategory( $cat ) {
 	/**
 	 * Set Debugging Level
 	 *
-	 * @access	public
-	 * @param	integer	Debug Level
-	 * @return	void
+	 * @param int|string $level
 	 */
 	public static function setDebugLevel( $level ) {
 		self::$debugLevel = intval( $level );
@@ -513,87 +507,82 @@ public static function setDebugLevel( $level ) {
 	/**
 	 * Return Debugging Level
 	 *
-	 * @access	public
-	 * @return	void
+	 * @return int
 	 */
 	public static function getDebugLevel() {
 		return self::$debugLevel;
 	}
 
-	// reset everything; some categories may have been fixed, however via  fixcategory=
-	public static function endReset( &$parser, $text ) {
+	// reset everything; some categories may have been fixed, however via fixcategory=
+	public static function endReset( $parser, $text ) {
 		if ( !self::$createdLinks['resetdone'] ) {
 			self::$createdLinks['resetdone'] = true;
+
 			foreach ( $parser->getOutput()->mCategories as $key => $val ) {
 				if ( array_key_exists( $key, self::$fixedCategories ) ) {
 					self::$fixedCategories[$key] = $val;
 				}
 			}
-			// $text .= self::dumpParsedRefs($parser,"before final reset");
+
 			if ( self::$createdLinks['resetLinks'] ) {
 				$parser->getOutput()->mLinks = [];
 			}
+
 			if ( self::$createdLinks['resetCategories'] ) {
 				$parser->getOutput()->mCategories = self::$fixedCategories;
 			}
+
 			if ( self::$createdLinks['resetTemplates'] ) {
 				$parser->getOutput()->mTemplates = [];
 			}
+
 			if ( self::$createdLinks['resetImages'] ) {
 				$parser->getOutput()->mImages = [];
 			}
-			// $text .= self::dumpParsedRefs( $parser, 'after final reset' );
+
 			self::$fixedCategories = [];
 		}
-		return true;
 	}
 
-	public static function endEliminate( &$parser, &$text ) {
+	public static function endEliminate( $parser, &$text ) {
 		// called during the final output phase; removes links created by DPL
 		if ( isset( self::$createdLinks ) ) {
-			// self::dumpParsedRefs($parser,"before final eliminate");
 			if ( array_key_exists( 0, self::$createdLinks ) ) {
 				foreach ( $parser->getOutput()->getLinks() as $nsp => $link ) {
 					if ( !array_key_exists( $nsp, self::$createdLinks[0] ) ) {
 						continue;
 					}
-					// echo ("<pre> elim: created Links [$nsp] = ". count(DynamicPageListHooks::$createdLinks[0][$nsp])."</pre>\n");
-					// echo ("<pre> elim: parser  Links [$nsp] = ". count($parser->getOutput()->mLinks[$nsp])			 ."</pre>\n");
+
 					$parser->getOutput()->mLinks[$nsp] = array_diff_assoc( $parser->getOutput()->mLinks[$nsp], self::$createdLinks[0][$nsp] );
-					// echo ("<pre> elim: parser  Links [$nsp] nachher = ". count($parser->getOutput()->mLinks[$nsp])	  ."</pre>\n");
+
 					if ( count( $parser->getOutput()->mLinks[$nsp] ) == 0 ) {
 						unset( $parser->getOutput()->mLinks[$nsp] );
 					}
 				}
 			}
+
 			if ( isset( self::$createdLinks ) && array_key_exists( 1, self::$createdLinks ) ) {
 				foreach ( $parser->getOutput()->mTemplates as $nsp => $tpl ) {
 					if ( !array_key_exists( $nsp, self::$createdLinks[1] ) ) {
 						continue;
 					}
-					// echo ("<pre> elim: created Tpls [$nsp] = ". count(DynamicPageListHooks::$createdLinks[1][$nsp])."</pre>\n");
-					// echo ("<pre> elim: parser  Tpls [$nsp] = ". count($parser->getOutput()->mTemplates[$nsp])			."</pre>\n");
+
 					$parser->getOutput()->mTemplates[$nsp] = array_diff_assoc( $parser->getOutput()->mTemplates[$nsp], self::$createdLinks[1][$nsp] );
-					// echo ("<pre> elim: parser  Tpls [$nsp] nachher = ". count($parser->getOutput()->mTemplates[$nsp])	 ."</pre>\n");
+
 					if ( count( $parser->getOutput()->mTemplates[$nsp] ) == 0 ) {
 						unset( $parser->getOutput()->mTemplates[$nsp] );
 					}
 				}
 			}
+
 			if ( isset( self::$createdLinks ) && array_key_exists( 2, self::$createdLinks ) ) {
 				$parser->getOutput()->mCategories = array_diff_assoc( $parser->getOutput()->mCategories, self::$createdLinks[2] );
 			}
+
 			if ( isset( self::$createdLinks ) && array_key_exists( 3, self::$createdLinks ) ) {
 				$parser->getOutput()->mImages = array_diff_assoc( $parser->getOutput()->mImages, self::$createdLinks[3] );
 			}
-			// $text .= self::dumpParsedRefs($parser,"after final eliminate".$parser->mTitle->getText());
 		}
-
-		/* self::$createdLinks = [
-				'resetLinks'=> false, 'resetTemplates' => false,
-				'resetCategories' => false, 'resetImages' => false, 'resetdone' => false
-		]; */
-		return true;
 	}
 
 	/**
diff --git a/DynamicPageList.i18n.magic.php b/includes/DynamicPageListMagic.php
similarity index 68%
rename from DynamicPageList.i18n.magic.php
rename to includes/DynamicPageListMagic.php
index 9c6d7eca..834c8742 100644
--- a/DynamicPageList.i18n.magic.php
+++ b/includes/DynamicPageListMagic.php
@@ -1,13 +1,4 @@
 <?php
-/**
- * DynamicPageList3
- * Magic Words
- *
- * @author Alexia E. Smith
- * @license GPL-2.0-or-later
- * @package DynamicPageList3
- *
- */
 
 $magicWords = [];
 
diff --git a/includes/LST.php b/includes/LST.php
index d5af9f88..d2dfdabf 100644
--- a/includes/LST.php
+++ b/includes/LST.php
@@ -29,35 +29,44 @@
 
 use DPL\Lister\Lister;
 use MediaWiki\MediaWikiServices;
+use Parser;
+use Title;
 
 class LST {
-	##############################################################
+	# #############################################################
 	# To do transclusion from an extension, we need to interact with the parser
 	# at a low level. This is the general transclusion functionality
 	##############################################################
 
 	/**
 	 * Register what we're working on in the parser, so we don't fall into a trap.
-	 * @param $parser Parser
+	 *
+	 * @param Parser $parser
 	 * @param $part1
 	 * @return bool
+	 *
+	 * @suppress PhanUndeclaredProperty Use of Parser::mTemplatePath
 	 */
 	public static function open( $parser, $part1 ) {
 		// Infinite loop test
 		if ( isset( $parser->mTemplatePath[$part1] ) ) {
 			wfDebug( __METHOD__ . ": template loop broken at '$part1'\n" );
+
 			return false;
 		} else {
 			$parser->mTemplatePath[$part1] = 1;
+
 			return true;
 		}
 	}
 
 	/**
 	 * Finish processing the function.
-	 * @param $parser Parser
+	 *
+	 * @param Parser $parser
 	 * @param $part1
-	 * @return bool
+	 *
+	 * @suppress PhanUndeclaredProperty Use of Parser::mTemplatePath
 	 */
 	public static function close( $parser, $part1 ) {
 		// Infinite loop test
@@ -72,7 +81,7 @@ public static function close( $parser, $part1 ) {
 	 * Handle recursive substitution here, so we can break cycles, and set up
 	 * return values so that edit sections will resolve correctly.
 	 */
-	private static function parse( $parser, $title, $text, $part1, $skiphead = 0, $recursionCheck = true, $maxLength = -1, $link = '', $trim = false, $skipPattern = [] ) {
+	private static function parse( $parser, $text, $part1, $skiphead = 0, $recursionCheck = true, $maxLength = -1, $link = '', $trim = false, $skipPattern = [] ) {
 		// if someone tries something like<section begin=blah>lst only</section>
 		// text, may as well do the right thing.
 		$text = str_replace( '</section>', '', $text );
@@ -84,9 +93,9 @@ private static function parse( $parser, $title, $text, $part1, $skiphead = 0, $r
 
 		if ( self::open( $parser, $part1 ) ) {
 
-			//Handle recursion here, so we can break cycles.
+			// Handle recursion here, so we can break cycles.
 			if ( $recursionCheck == false ) {
-				$text = $parser->preprocess( $text, $parser->mTitle, $parser->mOptions );
+				$text = $parser->preprocess( $text, $parser->getTitle(), $parser->getOptions() );
 				self::close( $parser, $part1 );
 			}
 
@@ -99,11 +108,11 @@ private static function parse( $parser, $title, $text, $part1, $skiphead = 0, $r
 				return $text;
 			}
 		} else {
-			return "[[" . $title->getPrefixedText() . "]]" . "<!-- WARNING: LST loop detected -->";
+			return "[[" . $parser->getTitle()->getPrefixedText() . "]]" . "<!-- WARNING: LST loop detected -->";
 		}
 	}
 
-	##############################################################
+	# #############################################################
 	# And now, the labeled section transclusion
 	##############################################################
 
@@ -114,16 +123,17 @@ private static function parse( $parser, $title, $text, $part1, $skiphead = 0, $r
 	 * @param string $in
 	 * @param array $assocArgs
 	 * @param Parser $parser
-	 * @return string HTML output
+	 * @return string
 	 */
 	private static function noop( $in, $assocArgs = [], $parser = null ) {
 		return '';
 	}
 
-	///Generate a regex to match the section(s) we're interested in.
+	// Generate a regex to match the section(s) we're interested in.
 	private static function createSectionPattern( $sec, $to, &$any ) {
-		$any    = false;
+		$any = false;
 		$to_sec = ( $to == '' ) ? $sec : $to;
+
 		if ( $sec[0] == '*' ) {
 			$any = true;
 			if ( $sec == '**' ) {
@@ -134,6 +144,7 @@ private static function createSectionPattern( $sec, $to, &$any ) {
 		} else {
 			$sec = preg_quote( $sec, '/' );
 		}
+
 		if ( $to_sec[0] == '*' ) {
 			if ( $to_sec == '**' ) {
 				$to_sec = '[^\/>"' . "']+";
@@ -143,20 +154,21 @@ private static function createSectionPattern( $sec, $to, &$any ) {
 		} else {
 			$to_sec = preg_quote( $to_sec, '/' );
 		}
-		$ws = "(?:\s+[^>]+)?"; //was like $ws="\s*"
+
+		$ws = "(?:\s+[^>]+)?";
+
 		return "/<section$ws\s+(?i:begin)=['\"]?" . "($sec)" . "['\"]?$ws\/?>(.*?)\n?<section$ws\s+(?:[^>]+\s+)?(?i:end)=" . "['\"]?\\1['\"]?" . "$ws\/?>/s";
 	}
 
 	/**
 	 * Count headings in skipped text.
 	 *
-	 * Count skipped headings, so parser (as of r18218) can skip them, to
-	 * prevent wrong heading links (see bug 6563).
+	 * Count skipped headings, so parser can skip them, to
+	 * prevent wrong heading links.
 	 *
 	 * @param string $text
-	 * @param int $limit Cutoff point in the text to stop searching
-	 * @return int Number of matches
-	 * @private
+	 * @param int $limit
+	 * @return int
 	 */
 	private static function countHeadings( $text, $limit ) {
 		$pat = '^(={1,6}).+\1\s*$()';
@@ -164,6 +176,7 @@ private static function countHeadings( $text, $limit ) {
 		$count = 0;
 		$offset = 0;
 		$m = [];
+
 		while ( preg_match( "/$pat/im", $text, $m, PREG_OFFSET_CAPTURE, $offset ) ) {
 			if ( $m[2][1] > $limit ) {
 				break;
@@ -177,7 +190,7 @@ private static function countHeadings( $text, $limit ) {
 	}
 
 	public static function text( $parser, $page, &$title, &$text ) {
-		$title = \Title::newFromText( $page );
+		$title = Title::newFromText( $page );
 
 		if ( $title === null ) {
 			$text = '';
@@ -186,7 +199,7 @@ public static function text( $parser, $page, &$title, &$text ) {
 			$text = $parser->fetchTemplateAndTitle( $title )[0];
 		}
 
-		//if article doesn't exist, return a red link.
+		// if article doesn't exist, return a red link.
 		if ( $text == false ) {
 			$text = "[[" . $title->getPrefixedText() . "]]";
 			return false;
@@ -195,26 +208,30 @@ public static function text( $parser, $page, &$title, &$text ) {
 		}
 	}
 
-	///section inclusion - include all matching sections
+	// section inclusion - include all matching sections
 	public static function includeSection( $parser, $page = '', $sec = '', $to = '', $recursionCheck = true, $trim = false, $skipPattern = [] ) {
 		$output = [];
+
 		if ( self::text( $parser, $page, $title, $text ) == false ) {
 			$output[] = $text;
 			return $output;
 		}
+
 		$any = false;
 		$pat = self::createSectionPattern( $sec, $to, $any );
 
 		preg_match_all( $pat, $text, $m, PREG_PATTERN_ORDER );
 
 		foreach ( $m[2] as $nr => $piece ) {
-			$piece = self::parse( $parser, $title, $piece, "#lst:${page}|${sec}", 0, $recursionCheck, $trim, $skipPattern );
+			$piece = self::parse( $parser, $piece, "#lst:${page}|${sec}", 0, $recursionCheck, $trim, $skipPattern );
+
 			if ( $any ) {
 				$output[] = $m[1][$nr] . '::' . $piece;
 			} else {
 				$output[] = $piece;
 			}
 		}
+
 		return $output;
 	}
 
@@ -225,10 +242,12 @@ public static function includeSection( $parser, $page = '', $sec = '', $to = '',
 	 * ... it is balanced in terms of braces, brackets and tags
 	 * ... it is cut at a word boundary (white space) if possible
 	 * ... can be used as content of a wikitable field without spoiling the whole surrounding wikitext structure
-	 * @param  $lim     limit of character count for the result
-	 * @param  $text    the wikitext to be truncated
-	 * @param  $link    an optional link which will be appended to the text if it was truncatedt
-	 * @return the truncated text;
+	 *
+	 * @param $text the wikitext to be truncated
+	 * @param $limit limit of character count for the result
+	 * @param $link an optional link which will be appended to the text if it was truncated
+	 *
+	 * @return string the truncated text;
 	 *         note that the returned text may be longer than the limit if this is necessary
 	 *         to return something at all. We do not want to return an empty string if the input is not empty
 	 *         if the text is already shorter than the limit, the text
@@ -249,24 +268,29 @@ public static function limitTranscludedText( $text, $limit, $link = '' ) {
 		// search latest position with balanced brackets/braces
 		// store also the position of the last preceding space
 
-		$brackets  = 0;
+		$brackets = 0;
 		$cbrackets = 0;
-		$n0        = -1;
-		$nb        = 0;
+		$n0 = -1;
+		$nb = 0;
+
 		for ( $i = 0; $i < $limit; $i++ ) {
 			$c = $text[$i];
 			if ( $c == '[' ) {
 				$brackets++;
 			}
+
 			if ( $c == ']' ) {
 				$brackets--;
 			}
+
 			if ( $c == '{' ) {
 				$cbrackets++;
 			}
+
 			if ( $c == '}' ) {
 				$cbrackets--;
 			}
+
 			// we store the position if it is valid in terms of parentheses balancing
 			if ( $brackets == 0 && $cbrackets == 0 ) {
 				$n0 = $i;
@@ -279,9 +303,11 @@ public static function limitTranscludedText( $text, $limit, $link = '' ) {
 		// if there is a valid cut-off point we use it; it will be the largest one which is not above the limit
 		if ( $n0 >= 0 ) {
 			// we try to cut off at a word boundary, this may lead to a shortening of max. 15 chars
+			// @phan-suppress-next-line PhanSuspiciousValueComparison
 			if ( $nb > 0 && $nb + 15 > $n0 ) {
 				$n0 = $nb;
 			}
+
 			$cut = substr( $text, 0, $n0 + 1 );
 
 			// an open html comment would be fatal, but this should not happen as we already have
@@ -293,9 +319,9 @@ public static function limitTranscludedText( $text, $limit, $link = '' ) {
 			// currently we ignore the nesting, i.e. all closing tags are appended at the end.
 			// This simple approach may fail in some cases ...
 
-			$matches   = [];
+			$matches = [];
 			$noMatches = preg_match_all( '#<\s*(/?ref|/?pre|/?nowiki)(\s+[^>]*?)*>#im', $cut, $matches );
-			$tags      = [
+			$tags = [
 				'ref' => 0,
 				'pre' => 0,
 				'nowiki' => 0
@@ -310,8 +336,10 @@ public static function limitTranscludedText( $text, $limit, $link = '' ) {
 						$tags[$mm]++;
 					}
 				}
+
 				// append missing closing tags - should the tags be ordered by precedence ?
 				foreach ( $tags as $tagName => $level ) {
+					// @phan-suppress-next-line PhanPluginLoopVariableReuse
 					while ( $level > 0 ) {
 						// avoid empty ref tag
 						if ( $tagName == 'ref' && substr( $cut, strlen( $cut ) - 5 ) == '<ref>' ) {
@@ -319,10 +347,12 @@ public static function limitTranscludedText( $text, $limit, $link = '' ) {
 						} else {
 							$cut .= '</' . $tagName . '>';
 						}
+
 						$level--;
 					}
 				}
 			}
+
 			return $cut . $link;
 		} elseif ( $limit == 0 ) {
 			return $link;
@@ -335,43 +365,57 @@ public static function limitTranscludedText( $text, $limit, $link = '' ) {
 	}
 
 	public static function includeHeading( $parser, $page = '', $sec = '', $to = '', &$sectionHeading, $recursionCheck = true, $maxLength = -1, $link = 'default', $trim = false, $skipPattern = [] ) {
+		// @phan-suppress-previous-line PhanParamReqAfterOpt
+
 		$output = [];
+
 		if ( self::text( $parser, $page, $title, $text ) == false ) {
 			$output[0] = $text;
+
 			return $output;
 		}
-		/* throw away comments */
+
+		// throw away comments
 		$text = preg_replace( '/<!--.*?-->/s', '', $text );
+
 		return self::extractHeadingFromText( $parser, $page, $title, $text, $sec, $to, $sectionHeading, $recursionCheck, $maxLength, $link, $trim, $skipPattern );
 	}
 
-	//section inclusion - include all matching sections (return array)
+	// section inclusion - include all matching sections (return array)
 	public static function extractHeadingFromText( $parser, $page, $title, $text, $sec = '', $to = '', &$sectionHeading, $recursionCheck = true, $maxLength = -1, $cLink = 'default', $trim = false, $skipPattern = [] ) {
+		// @phan-suppress-previous-line PhanParamReqAfterOpt
+
 		$continueSearch = true;
-		$n              = 0;
-		$output[$n]     = '';
-		$nr             = 0;
+		$output = [];
+
+		$n = 0;
+		$output[$n] = '';
+		$nr = 0;
+
 		// check if we are going to fetch the n-th section
 		if ( preg_match( '/^%-?[1-9][0-9]*$/', $sec ) ) {
 			$nr = substr( $sec, 1 );
 		}
+
 		if ( preg_match( '/^%0$/', $sec ) ) {
 			$nr = -2; // transclude text before the first section
 		}
 
 		// if the section name starts with a # or with a @ we use it as regexp, otherwise as plain string
 		$isPlain = true;
+
 		if ( $sec != '' && ( $sec[0] == '#' || $sec[0] == '@' ) ) {
-			$sec     = substr( $sec, 1 );
+			$sec = substr( $sec, 1 );
 			$isPlain = false;
 		}
+
 		do {
-			//Generate a regex to match the === classical heading section(s) === we're
+			// Generate a regex to match the === classical heading section(s) === we're
 			//interested in.
 			$headLine = '';
+			$begin_off = 0;
 			if ( $sec == '' ) {
-				$begin_off = 0;
-				$head_len  = 6;
+				$head_len = 6;
 			} else {
 				if ( $nr != 0 ) {
 					$pat = '^(={1,6})\s*[^=\s\n][^\n=]*\s*\1\s*($)';
@@ -380,12 +424,13 @@ public static function extractHeadingFromText( $parser, $page, $title, $text, $s
 				} else {
 					$pat = '^(={1,6})\s*' . str_replace( '/', '\/', $sec ) . '\s*\1\s*($)';
 				}
+
 				if ( preg_match( "/$pat/im", $text, $m, PREG_OFFSET_CAPTURE ) ) {
-					$mata           = [];
+					$mata = [];
 					$no_parenthesis = preg_match_all( '/\(/', $pat, $mata );
-					$begin_off      = $m[$no_parenthesis][1];
-					$head_len       = strlen( $m[1][0] );
-					$headLine       = trim( $m[0][0], "\n =\t" );
+					$begin_off = $m[$no_parenthesis][1];
+					$head_len = strlen( $m[1][0] );
+					$headLine = trim( $m[0][0], "\n =\t" );
 				} elseif ( $nr == -2 ) {
 					$m[1][1] = strlen( $text ) + 1; // take whole article if no heading found
 				} else {
@@ -393,6 +438,7 @@ public static function extractHeadingFromText( $parser, $page, $title, $text, $s
 					return $output;
 				}
 			}
+
 			// create a link symbol (arrow, img, ...) in case we have to cut the text block to maxLength
 			$link = $cLink;
 			if ( $link == 'default' ) {
@@ -404,33 +450,40 @@ public static function extractHeadingFromText( $parser, $page, $title, $text, $s
 			} else {
 				$link = str_replace( '%SECTION%', $page . '#' . $headLine, $link );
 			}
+
 			if ( $nr == -2 ) {
 				// output text before first section and done
-				$piece     = substr( $text, 0, $m[1][1] - 1 );
-				$output[0] = self::parse( $parser, $title, $piece, "#lsth:${page}|${sec}", 0, $recursionCheck, $maxLength, $link, $trim, $skipPattern );
+				$piece = substr( $text, 0, $m[1][1] - 1 );
+				$output[0] = self::parse( $parser, $piece, "#lsth:${page}|${sec}", 0, $recursionCheck, $maxLength, $link, $trim, $skipPattern );
+
 				return $output;
 			}
 
 			if ( isset( $end_off ) ) {
 				unset( $end_off );
 			}
+
 			if ( $to != '' ) {
-				//if $to is supplied, try and match it.  If we don't match, just ignore it.
+				// if $to is supplied, try and match it. If we don't match, just ignore it.
 				if ( $isPlain ) {
 					$pat = '^(={1,6})\s*' . preg_quote( $to, '/' ) . '\s*\1\s*$';
 				} else {
 					$pat = '^(={1,6})\s*' . str_replace( '/', '\/', $to ) . '\s*\1\s*$';
 				}
+
 				if ( preg_match( "/$pat/im", $text, $mm, PREG_OFFSET_CAPTURE, $begin_off ) ) {
 					$end_off = $mm[0][1] - 1;
 				}
 			}
+
 			if ( !isset( $end_off ) ) {
 				if ( $nr != 0 ) {
 					$pat = '^(={1,6})\s*[^\s\n=][^\n=]*\s*\1\s*$';
 				} else {
+					// @phan-suppress-next-line PhanPossiblyUndeclaredVariable
 					$pat = '^(={1,' . $head_len . '})(?!=)\s*.*?\1\s*$';
 				}
+
 				if ( preg_match( "/$pat/im", $text, $mm, PREG_OFFSET_CAPTURE, $begin_off ) ) {
 					$end_off = $mm[0][1] - 1;
 				} elseif ( $sec == '' ) {
@@ -439,12 +492,14 @@ public static function extractHeadingFromText( $parser, $page, $title, $text, $s
 			}
 
 			$nhead = self::countHeadings( $text, $begin_off );
+
 			wfDebug( "LSTH: head offset = $nhead" );
 
 			if ( isset( $end_off ) ) {
 				if ( $end_off == -1 ) {
 					return $output;
 				}
+
 				$piece = substr( $text, $begin_off, $end_off - $begin_off );
 				if ( $sec == '' ) {
 					$continueSearch = false;
@@ -452,7 +507,7 @@ public static function extractHeadingFromText( $parser, $page, $title, $text, $s
 					$text = substr( $text, $end_off );
 				}
 			} else {
-				$piece          = substr( $text, $begin_off );
+				$piece = substr( $text, $begin_off );
 				$continueSearch = false;
 			}
 
@@ -464,27 +519,25 @@ public static function extractHeadingFromText( $parser, $page, $title, $text, $s
 
 			if ( isset( $m[0][0] ) ) {
 				$sectionHeading[$n] = $headLine;
-				//$sectionHeading[$n]=preg_replace("/^=+\s*/","",$m[0][0]);
-				//$sectionHeading[$n]=preg_replace("/\s*=+\s*$/","",$sectionHeading[$n]);
 			} else {
-				// $sectionHeading[$n] = '';
 				$sectionHeading[0] = $headLine;
 			}
 
 			if ( $nr == 1 ) {
 				// output n-th section and done
-				$output[0] = self::parse( $parser, $title, $piece, "#lsth:${page}|${sec}", $nhead, $recursionCheck, $maxLength, $link, $trim, $skipPattern );
+				$output[0] = self::parse( $parser, $piece, "#lsth:${page}|${sec}", $nhead, $recursionCheck, $maxLength, $link, $trim, $skipPattern );
 				break;
 			}
+
 			if ( $nr == -1 ) {
 				if ( !isset( $end_off ) ) {
 					// output last section and done
-					$output[0] = self::parse( $parser, $title, $piece, "#lsth:${page}|${sec}", $nhead, $recursionCheck, $maxLength, $link, $trim, $skipPattern );
+					$output[0] = self::parse( $parser, $piece, "#lsth:${page}|${sec}", $nhead, $recursionCheck, $maxLength, $link, $trim, $skipPattern );
 					break;
 				}
 			} else {
 				// output section by name and continue search for another section with the same name
-				$output[$n++] = self::parse( $parser, $title, $piece, "#lsth:${page}|${sec}", $nhead, $recursionCheck, $maxLength, $link, $trim, $skipPattern );
+				$output[$n++] = self::parse( $parser, $piece, "#lsth:${page}|${sec}", $nhead, $recursionCheck, $maxLength, $link, $trim, $skipPattern );
 			}
 		} while ( $continueSearch );
 
@@ -497,21 +550,26 @@ public static function extractHeadingFromText( $parser, $page, $title, $text, $s
 	// and do NOT match the condition "$mustNotMatch" (if specified)
 	// we use a callback function to format retrieved parameters, accessible via $lister->formatTemplateArg()
 	public static function includeTemplate( $parser, Lister $lister, $dplNr, $article, $template1 = '', $template2 = '', $defaultTemplate, $mustMatch, $mustNotMatch, $matchParsed, $catlist ) {
-		$page  = $article->mTitle->getPrefixedText();
-		$date  = $article->myDate;
-		$user  = $article->mUserLink;
-		$title = \Title::newFromText( $page );
-		/* get text and throw away html comments */
+		// @phan-suppress-previous-line PhanParamReqAfterOpt
+
+		$page = $article->mTitle->getPrefixedText();
+		$date = $article->myDate;
+		$user = $article->mUserLink;
+		$title = Title::newFromText( $page );
+
+		// get text and throw away html comments
 		$text = preg_replace( '/<!--.*?-->/s', '', $parser->fetchTemplateAndTitle( $title )[0] );
 
 		if ( $template1 != '' && $template1[0] == '#' ) {
 			// --------------------------------------------- looking for a parser function call
-			$template1       = substr( $template1, 1 );
-			$template2       = substr( $template2, 1 );
+			$template1 = substr( $template1, 1 );
+			$template2 = substr( $template2, 1 );
 			$defaultTemplate = substr( $defaultTemplate, 1 );
+
 			// when looking for parser function calls we accept regexp search patterns
-			$text2           = preg_replace( "/\{\{\s*#(" . $template1 . ')(\s*[:}])/i', '°³²|%PFUNC%=\1\2|', $text );
-			$tCalls          = preg_split( '/°³²/', ' ' . $text2 );
+			$text2 = preg_replace( "/\{\{\s*#(" . $template1 . ')(\s*[:}])/i', '°³²|%PFUNC%=\1\2|', $text );
+			$tCalls = preg_split( '/°³²/', ' ' . $text2 );
+
 			foreach ( $tCalls as $i => $tCall ) {
 				if ( ( $n = strpos( $tCall, ':' ) ) !== false ) {
 					$tCalls[$i][$n] = ' ';
@@ -519,12 +577,14 @@ public static function includeTemplate( $parser, Lister $lister, $dplNr, $articl
 			}
 		} elseif ( $template1 != '' && $template1[0] == '~' ) {
 			// --------------------------------------------- looking for an xml-tag extension call
-			$template1       = substr( $template1, 1 );
-			$template2       = substr( $template2, 1 );
+			$template1 = substr( $template1, 1 );
+			$template2 = substr( $template2, 1 );
 			$defaultTemplate = substr( $defaultTemplate, 1 );
+
 			// looking for tags
-			$text2           = preg_replace( '/\<\s*(' . $template1 . ')\s*\>/i', '°³²|%TAG%=\1|%TAGBODY%=', $text );
-			$tCalls          = preg_split( '/°³²/', ' ' . $text2 );
+			$text2 = preg_replace( '/\<\s*(' . $template1 . ')\s*\>/i', '°³²|%TAG%=\1|%TAGBODY%=', $text );
+			$tCalls = preg_split( '/°³²/', ' ' . $text2 );
+
 			foreach ( $tCalls as $i => $tCall ) {
 				$tCalls[$i] = preg_replace( '/\<\s*\/' . $template1 . '\s*\>.*/is', '}}', $tCall );
 			}
@@ -536,7 +596,8 @@ public static function includeTemplate( $parser, Lister $lister, $dplNr, $articl
 			$contLang = MediaWikiServices::getInstance()->getContentLanguage();
 
 			$nsNames = $contLang->getNamespaces();
-			$tCalls  = preg_split( '/\{\{\s*(Template:|' . $nsNames[10] . ':)?' . self::spaceOrUnderscore( preg_quote( $template1, '/' ) ) . '\s*[|}]/i', ' ' . $text );
+			$tCalls = preg_split( '/\{\{\s*(Template:|' . $nsNames[10] . ':)?' . self::spaceOrUnderscore( preg_quote( $template1, '/' ) ) . '\s*[|}]/i', ' ' . $text );
+
 			// We restore the first separator symbol (we had to include that symbol into the SPLIT, because we must make
 			// sure that we only accept exact matches of the complete template name
 			// (e.g. when looking for "foo" we must not accept "foo xyz")
@@ -549,7 +610,7 @@ public static function includeTemplate( $parser, Lister $lister, $dplNr, $articl
 			}
 		}
 
-		$output      = [];
+		$output = [];
 		$extractParm = [];
 
 		// check if we want to extract parameters directly from the call
@@ -565,6 +626,7 @@ public static function includeTemplate( $parser, Lister $lister, $dplNr, $articl
 				// if parameters are required directly: return empty columns
 				if ( count( $extractParm ) > 1 ) {
 					$output[0] = $lister->formatTemplateArg( '', $dplNr, 0, true, -1, $article );
+
 					for ( $i = 1; $i < count( $extractParm ); $i++ ) {
 						$output[0] .= "\n|" . $lister->formatTemplateArg( '', $dplNr, $i, true, -1, $article );
 					}
@@ -573,134 +635,164 @@ public static function includeTemplate( $parser, Lister $lister, $dplNr, $articl
 				}
 			} else {
 				// put a red link into the output
-				$output[0] = $parser->preprocess( '{{' . $defaultTemplate . '|%PAGE%=' . $page . '|%TITLE%=' . $title->getText() . '|%DATE%=' . $date . '|%USER%=' . $user . '}}', $parser->mTitle, $parser->mOptions );
+				$output[0] = $parser->preprocess( '{{' . $defaultTemplate . '|%PAGE%=' . $page . '|%TITLE%=' . $title->getText() . '|%DATE%=' . $date . '|%USER%=' . $user . '}}', $parser->getTitle(), $parser->getOptions() );
 			}
+
 			unset( $title );
+
 			return $output;
 		}
 
 		$output[0] = '';
-		$n         = -2;
+		$n = -2;
+
 		// loop for all template invocations
 		$firstCall = true;
+
 		foreach ( $tCalls as $iii => $tCall ) {
 			if ( $n == -2 ) {
 				$n++;
 				continue;
 			}
+
 			$c = $tCall[0];
 			// normally we construct a call for template2 with the parameters of template1
 			if ( count( $extractParm ) == 0 ) {
 				// find the end of the call: bracket level must be zero
-				$cbrackets    = 0;
+				$cbrackets = 0;
 				$templateCall = '{{' . $template2 . $tCall;
-				$size         = strlen( $templateCall );
+				$size = strlen( $templateCall );
 
 				for ( $i = 0; $i < $size; $i++ ) {
 					$c = $templateCall[$i];
 					if ( $c == '{' ) {
 						$cbrackets++;
 					}
+
 					if ( $c == '}' ) {
 						$cbrackets--;
 					}
+
 					if ( $cbrackets == 0 ) {
 						// if we must match a condition: test against it
 						if ( ( $mustMatch == '' || preg_match( $mustMatch, substr( $templateCall, 0, $i - 1 ) ) ) && ( $mustNotMatch == '' || !preg_match( $mustNotMatch, substr( $templateCall, 0, $i - 1 ) ) ) ) {
 							$invocation = substr( $templateCall, 0, $i - 1 );
-							$argChain   = $invocation . '|%PAGE%=' . $page . '|%TITLE%=' . $title->getText();
+							$argChain = $invocation . '|%PAGE%=' . $page . '|%TITLE%=' . $title->getText();
+
 							if ( $catlist != '' ) {
 								$argChain .= "|%CATLIST%=$catlist";
 							}
+
 							$argChain .= '|%DATE%=' . $date . '|%USER%=' . $user . '|%ARGS%=' . str_replace( '|', '§', preg_replace( '/[}]+/', '}', preg_replace( '/[{]+/', '{', substr( $invocation, strlen( $template2 ) + 2 ) ) ) ) . '}}';
-							$output[++$n] = $parser->preprocess( $argChain, $parser->mTitle, $parser->mOptions );
+							$output[++$n] = $parser->preprocess( $argChain, $parser->getTitle(), $parser->getOptions() );
 						}
 						break;
 					}
 				}
 			} else {
 				// if the user wants parameters directly from the call line of template1 we return just those
-				$cbrackets    = 2;
+				$cbrackets = 2;
 				$templateCall = $tCall;
-				$size         = strlen( $templateCall );
-				$parms        = [];
-				$parm         = '';
-				$hasParm      = false;
+				$size = strlen( $templateCall );
+				$parms = [];
+				$parm = '';
+				$hasParm = false;
 
 				for ( $i = 0; $i < $size; $i++ ) {
 					$c = $templateCall[$i];
+
 					if ( $c == '{' || $c == '[' ) {
 						$cbrackets++; // we count both types of brackets
 					}
+
 					if ( $c == '}' || $c == ']' ) {
 						$cbrackets--;
 					}
+
 					if ( $cbrackets == 2 && $c == '|' ) {
 						$parms[] = trim( $parm );
 						$hasParm = true;
-						$parm    = '';
+						$parm = '';
 					} else {
 						$parm .= $c;
 					}
+
 					if ( $cbrackets == 0 ) {
 						if ( $hasParm ) {
 							$parms[] = trim( substr( $parm, 0, strlen( $parm ) - 2 ) );
 						}
-						array_splice( $parms, 0, 1 ); // remove artifact;
+
+						array_splice( $parms, 0, 1 );
 						// if we must match a condition: test against it
 						$callText = substr( $templateCall, 0, $i - 1 );
+
 						if ( ( $mustMatch == '' || ( ( $matchParsed && preg_match( $mustMatch, $parser->recursiveTagParse( $callText ) ) ) || ( !$matchParsed && preg_match( $mustMatch, $callText ) ) ) ) && ( $mustNotMatch == '' || ( ( $matchParsed && !preg_match( $mustNotMatch, $parser->recursiveTagParse( $callText ) ) ) || ( !$matchParsed && !preg_match( $mustNotMatch, $callText ) ) ) ) ) {
 							$output[++$n] = '';
-							$second       = false;
+							$second = false;
+
 							foreach ( $extractParm as $exParmKey => $exParm ) {
 								$maxlen = -1;
 								if ( ( $limpos = strpos( $exParm, '[' ) ) > 0 && $exParm[strlen( $exParm ) - 1] == ']' ) {
 									$maxlen = intval( substr( $exParm, $limpos + 1, strlen( $exParm ) - $limpos - 2 ) );
 									$exParm = substr( $exParm, 0, $limpos );
 								}
+
 								if ( $second ) {
+									// @phan-suppress-next-line PhanTypeInvalidDimOffset
 									if ( $output[$n] == '' || $output[$n][strlen( $output[$n] ) - 1] != "\n" ) {
 										$output[$n] .= "\n";
 									}
+
 									$output[$n] .= "|"; // \n";
 								}
+
 								$found = false;
+
 								// % in parameter name
 								if ( strpos( $exParm, '%' ) !== false ) {
 									// %% is a short form for inclusion of %PAGE% and %TITLE%
 									$found = true;
 									$output[$n] .= $lister->formatTemplateArg( $exParm, $dplNr, $exParmKey, $firstCall, $maxlen, $article );
 								}
+
 								if ( !$found ) {
 									// named parameter
 									$exParmQuote = str_replace( '/', '\/', $exParm );
+
 									foreach ( $parms as $parm ) {
 										if ( !preg_match( "/^\s*$exParmQuote\s*=/", $parm ) ) {
 											continue;
 										}
+
 										$found = true;
 										$output[$n] .= $lister->formatTemplateArg( preg_replace( "/^$exParmQuote\s*=\s*/", "", $parm ), $dplNr, $exParmKey, $firstCall, $maxlen, $article );
 										break;
 									}
 								}
+
 								if ( !$found && is_numeric( $exParm ) && intval( $exParm ) == $exParm ) {
 									// numeric parameter
 									$np = 0;
+
 									foreach ( $parms as $parm ) {
 										if ( strstr( $parm, '=' ) === false ) {
 											++$np;
 										}
+
 										if ( $np != $exParm ) {
 											continue;
 										}
+
 										$found = true;
 										$output[$n] .= $lister->formatTemplateArg( $parm, $dplNr, $exParmKey, $firstCall, $maxlen, $article );
 										break;
 									}
 								}
+
 								if ( !$found ) {
 									$output[$n] .= $lister->formatTemplateArg( '', $dplNr, $exParmKey, $firstCall, $maxlen, $article );
 								}
+
 								$second = true;
 							}
 						}
@@ -708,6 +800,7 @@ public static function includeTemplate( $parser, Lister $lister, $dplNr, $articl
 					}
 				}
 			}
+
 			$firstCall = false;
 		}
 
diff --git a/includes/Logger.php b/includes/Logger.php
index 2484da3a..28bb9651 100644
--- a/includes/Logger.php
+++ b/includes/Logger.php
@@ -1,13 +1,5 @@
 <?php
-/**
- * DynamicPageList3
- * DPL Logger Class
- *
- * @author		IlyaHaykinson, Unendlich, Dangerville, Algorithmix, Theaitetos, Alexia E. Smith
- * @license		GPL-2.0-or-later
- * @package		DynamicPageList3
- *
- */
+
 namespace DPL;
 
 class Logger {
@@ -18,63 +10,57 @@ class Logger {
 	 */
 	private $buffer = [];
 
-	/**
-	 * Function Documentation
-	 *
-	 * @access	public
-	 * @return	void
-	 */
-	public function addMessage( $errorId ) {
+	public function addMessage() {
 		$args = func_get_args();
 		$args = array_map( 'htmlspecialchars', $args );
-		return call_user_func_array( [ $this, 'msg' ], $args );
+
+		call_user_func_array( [ $this, 'msg' ], $args );
 	}
 
 	/**
 	 * Return the buffer of messages.
 	 *
-	 * @access	public
-	 * @param	boolean	[Optional] Clear the message buffer.
-	 * @return	array	Messages in the order added.
+	 * @param bool $clearBuffer
+	 * @return array
 	 */
 	public function getMessages( $clearBuffer = true ) {
 		$buffer = $this->buffer;
+
 		if ( $clearBuffer === true ) {
 			$this->buffer = [];
 		}
+
 		return $buffer;
 	}
 
 	/**
 	 * Get a message, with optional parameters
 	 * Parameters from user input must be escaped for HTML *before* passing to this function
-	 *
-	 * @access	public
-	 * @param	integer	Message ID
-	 * @return	string
 	 */
 	public function msg() {
 		$args = func_get_args();
 		$errorId = array_shift( $args );
 		$errorLevel = floor( $errorId / 1000 );
 		$errorMessageId = $errorId % 1000;
-		if ( \DynamicPageListHooks::getDebugLevel() >= $errorLevel ) {
-			if ( \DynamicPageListHooks::isLikeIntersection() ) {
-				if ( $errorId == \DynamicPageListHooks::FATAL_TOOMANYCATS ) {
+
+		if ( DynamicPageListHooks::getDebugLevel() >= $errorLevel ) {
+			if ( DynamicPageListHooks::isLikeIntersection() ) {
+				if ( $errorId == DynamicPageListHooks::FATAL_TOOMANYCATS ) {
 					$text = wfMessage( 'intersection_toomanycats', $args )->text();
-				} elseif ( $errorId == \DynamicPageListHooks::FATAL_TOOFEWCATS ) {
+				} elseif ( $errorId == DynamicPageListHooks::FATAL_TOOFEWCATS ) {
 					$text = wfMessage( 'intersection_toofewcats', $args )->text();
-				} elseif ( $errorId == \DynamicPageListHooks::WARN_NORESULTS ) {
+				} elseif ( $errorId == DynamicPageListHooks::WARN_NORESULTS ) {
 					$text = wfMessage( 'intersection_noresults', $args )->text();
-				} elseif ( $errorId == \DynamicPageListHooks::FATAL_NOSELECTION ) {
+				} elseif ( $errorId == DynamicPageListHooks::FATAL_NOSELECTION ) {
 					$text = wfMessage( 'intersection_noincludecats', $args )->text();
 				}
 			}
+
 			if ( empty( $text ) ) {
 				$text = wfMessage( 'dpl_log_' . $errorMessageId, $args )->text();
 			}
-			$this->buffer[] = '<p>Extension:DynamicPageList (DPL), version ' . DPL_VERSION . ': ' . $text . '</p>';
+
+			$this->buffer[] = '<p>Extension:DynamicPageList (DPL), version ' . DynamicPageListHooks::getVersion() . ': ' . $text . '</p>';
 		}
-		return false;
 	}
 }
diff --git a/includes/Parameters.php b/includes/Parameters.php
index 614fa926..992cf75e 100644
--- a/includes/Parameters.php
+++ b/includes/Parameters.php
@@ -1,17 +1,12 @@
 <?php
-/**
- * DynamicPageList3
- * DPL Variables Class
- *
- * @author IlyaHaykinson, Unendlich, Dangerville, Algorithmix, Theaitetos, Alexia E. Smith
- * @license GPL-2.0-or-later
- * @package DynamicPageList3
- *
- */
 
 namespace DPL;
 
 use MediaWiki\MediaWikiServices;
+use MWException;
+use PermissionsError;
+use RequestContext;
+use Title;
 
 class Parameters extends ParametersData {
 	/**
@@ -42,21 +37,17 @@ class Parameters extends ParametersData {
 	 */
 	private $parametersProcessed = [];
 
-	/**
-	 * Main Constructor
-	 *
-	 * @return void
-	 */
 	public function __construct() {
 		parent::__construct();
+
 		$this->setDefaults();
 	}
 
 	/**
 	 * Handle simple parameter functions.
 	 *
-	 * @param string $parameter Function(Parameter) Called
-	 * @param string $arguments Function Arguments
+	 * @param string $parameter
+	 * @param mixed $arguments
 	 * @return bool
 	 */
 	public function __call( $parameter, $arguments ) {
@@ -68,16 +59,17 @@ public function __call( $parameter, $arguments ) {
 
 		// Check permission to use this parameter.
 		if ( array_key_exists( 'permission', $parameterData ) ) {
-			global $wgUser;
-			if ( !$wgUser->isAllowed( $parameterData['permission'] ) ) {
-				throw new \PermissionsError( $parameterData['permission'] );
-				return;
+			$user = RequestContext::getMain()->getUser();
+
+			if ( !$user->isAllowed( $parameterData['permission'] ) ) {
+				throw new PermissionsError( $parameterData['permission'] );
 			}
 		}
 
-		// Subvert to the real function if it exists.  This keeps code elsewhere clean from needed to check if it exists first.
-		$function = "_" . $parameter;
+		// Subvert to the real function if it exists. This keeps code elsewhere clean from needed to check if it exists first.
+		$function = '_' . $parameter;
 		$this->parametersProcessed[$parameter] = true;
+
 		if ( method_exists( $this, $function ) ) {
 			return call_user_func_array( [ $this, $function ], $arguments );
 		}
@@ -118,6 +110,7 @@ public function __call( $parameter, $arguments ) {
 			// Booleans
 			if ( array_key_exists( 'boolean', $parameterData ) && $parameterData['boolean'] === true ) {
 				$option = $this->filterBoolean( $option );
+
 				if ( $option === null ) {
 					$success = false;
 				}
@@ -126,6 +119,7 @@ public function __call( $parameter, $arguments ) {
 			// Timestamps
 			if ( array_key_exists( 'timestamp', $parameterData ) && $parameterData['timestamp'] === true ) {
 				$option = strtolower( $option );
+
 				switch ( $option ) {
 					case 'today':
 					case 'last hour':
@@ -148,10 +142,13 @@ public function __call( $parameter, $arguments ) {
 			// List of Pages
 			if ( array_key_exists( 'page_name_list', $parameterData ) && $parameterData['page_name_list'] === true ) {
 				$pageGroups = $this->getParameter( $parameter );
+
 				if ( !is_array( $pageGroups ) ) {
 					$pageGroups = [];
 				}
+
 				$pages = $this->getPageNameList( $option, (bool)$parameterData['page_name_must_exist'] );
+
 				if ( $pages === false ) {
 					$success = false;
 				} else {
@@ -163,7 +160,7 @@ public function __call( $parameter, $arguments ) {
 			// Regex Pattern Matching
 			if ( array_key_exists( 'pattern', $parameterData ) ) {
 				if ( preg_match( $parameterData['pattern'], $option, $matches ) ) {
-					//Nuke the total pattern match off the beginning of the array.
+					// Nuke the total pattern match off the beginning of the array.
 					array_shift( $matches );
 					$option = $matches;
 				} else {
@@ -177,15 +174,15 @@ public function __call( $parameter, $arguments ) {
 			}
 
 			// If none of the above checks marked this as a failure then set it.
-			if ( $success === true ) {
+			if ( $success ) {
 				$this->setParameter( $parameter, $option );
 
-				//Set that criteria was found for a selection.
+				// Set that criteria was found for a selection.
 				if ( array_key_exists( 'set_criteria_found', $parameterData ) && $parameterData['set_criteria_found'] === true ) {
 					$this->setSelectionCriteriaFound( true );
 				}
 
-				//Set open references conflict possibility.
+				// Set open references conflict possibility.
 				if ( array_key_exists( 'open_ref_conflict', $parameterData ) && $parameterData['open_ref_conflict'] === true ) {
 					$this->setOpenReferencesConflict( true );
 				}
@@ -197,28 +194,29 @@ public function __call( $parameter, $arguments ) {
 
 	/**
 	 * Sort cleaned parameter arrays by priority.
-	 * Users can not be told to put the parameters into a specific order each time.  Some parameters are dependent on each other coming in a certain order due to some procedural legacy issues.
+	 * Users can not be told to put the parameters into a specific order each time. Some parameters are dependent on each other coming in a certain order due to some procedural legacy issues.
 	 *
 	 * @param array	$parameters
 	 * @return array
 	 */
 	public static function sortByPriority( $parameters ) {
 		if ( !is_array( $parameters ) ) {
-			throw new \MWException( __METHOD__ . ': A non-array was passed.' );
+			throw new MWException( __METHOD__ . ': A non-array was passed.' );
 		}
-		//'category' to get category headings first for ordermethod.
-		//'include'/'includepage' to make sure section labels are ready for 'table'.
+
+		// 'category' to get category headings first for ordermethod.
+		// 'include'/'includepage' to make sure section labels are ready for 'table'.
 		$priority = [
-			'distinct'			=> 1,
-			'openreferences'	=> 2,
-			'ignorecase'		=> 3,
-			'category'			=> 4,
-			'title'				=> 5,
-			'goal'				=> 6,
-			'ordercollation'	=> 7,
-			'ordermethod'		=> 8,
-			'includepage'		=> 9,
-			'include'			=> 10
+			'distinct' => 1,
+			'openreferences' => 2,
+			'ignorecase' => 3,
+			'category' => 4,
+			'title' => 5,
+			'goal' => 6,
+			'ordercollation' => 7,
+			'ordermethod' => 8,
+			'includepage' => 9,
+			'include' => 10
 		];
 
 		$_first = [];
@@ -237,7 +235,7 @@ public static function sortByPriority( $parameters ) {
 	/**
 	 * Set Selection Criteria Found
 	 *
-	 * @param bool $found|true
+	 * @param bool $found
 	 * @return void
 	 */
 	private function setSelectionCriteriaFound( $found = true ) {
@@ -282,9 +280,6 @@ public function isOpenReferencesConflict() {
 
 	/**
 	 * Set default parameters based on ParametersData.
-	 *
-	 * @private
-	 * @return void
 	 */
 	private function setDefaults() {
 		$this->setParameter( 'defaulttemplatesuffix', '.default' );
@@ -293,8 +288,9 @@ private function setDefaults() {
 		foreach ( $parameters as $parameter ) {
 			if ( $this->getData( $parameter )['default'] !== null && !( $this->getData( $parameter )['default'] === false && $this->getData( $parameter )['boolean'] === true ) ) {
 				if ( $parameter == 'debug' ) {
-					\DynamicPageListHooks::setDebugLevel( $this->getData( $parameter )['default'] );
+					DynamicPageListHooks::setDebugLevel( $this->getData( $parameter )['default'] );
 				}
+
 				$this->setParameter( $parameter, $this->getData( $parameter )['default'] );
 			}
 		}
@@ -305,7 +301,6 @@ private function setDefaults() {
 	 *
 	 * @param string $parameter
 	 * @param mixed	$option
-	 * @return void
 	 */
 	public function setParameter( $parameter, $option ) {
 		$this->parameterOptions[$parameter] = $option;
@@ -324,7 +319,7 @@ public function getParameter( $parameter ) {
 	/**
 	 * Get all parameters.
 	 *
-	 * @return array Parameter => Options
+	 * @return array
 	 */
 	public function getAllParameters() {
 		return self::sortByPriority( $this->parameterOptions );
@@ -333,7 +328,7 @@ public function getAllParameters() {
 	/**
 	 * Filter a standard boolean like value into an actual boolean.
 	 *
-	 * @param mixed	Integer or string to evaluated through filter_var().
+	 * @param int|string|bool $boolean
 	 * @return bool
 	 */
 	public function filterBoolean( $boolean ) {
@@ -343,9 +338,8 @@ public function filterBoolean( $boolean ) {
 	/**
 	 * Strip <html> tags.
 	 *
-	 * @private
-	 * @param string $text Dirty Text
-	 * @return string $text Clean Text
+	 * @param string $text
+	 * @return string
 	 */
 	private function stripHtmlTags( $text ) {
 		$text = preg_replace( "#<.*?html.*?>#is", "", $text );
@@ -356,25 +350,29 @@ private function stripHtmlTags( $text ) {
 	/**
 	 * Get a list of valid page names.
 	 *
-	 * @private
-	 * @param string Raw Text of Pages
-	 * @param bool [Optional] Each Title MUST Exist
-	 * @return mixed List of page titles or false on error.
+	 * @param string $text
+	 * @param bool $mustExist
+	 * @return array|bool
 	 */
 	private function getPageNameList( $text, $mustExist = true ) {
 		$list = [];
 		$pages = explode( '|', trim( $text ) );
+
 		foreach ( $pages as $page ) {
 			$page = trim( $page );
-			$page = rtrim( $page, '\\' ); //This was fixed from the original code, but I am not sure what its intended purpose was.
+			$page = rtrim( $page, '\\' );
+
 			if ( empty( $page ) ) {
 				continue;
 			}
+
 			if ( $mustExist === true ) {
-				$title = \Title::newFromText( $page );
+				$title = Title::newFromText( $page );
+
 				if ( !$title ) {
 					return false;
 				}
+
 				$list[] = $title;
 			} else {
 				$list[] = $page;
@@ -387,9 +385,8 @@ private function getPageNameList( $text, $mustExist = true ) {
 	/**
 	 * Check if a regular expression is valid.
 	 *
-	 * @private
-	 * @param mixed	Regular Expression(s) in an array or a single expression in a string.
-	 * @param bool Is this a database REGEXP?
+	 * @param array|string $regexes
+	 * @param bool $forDb
 	 * @return bool
 	 */
 	private function isRegexValid( $regexes, $forDb = false ) {
@@ -401,11 +398,17 @@ private function isRegexValid( $regexes, $forDb = false ) {
 			if ( empty( trim( $regex ) ) ) {
 				continue;
 			}
+
 			if ( $forDb ) {
 				$regex = '#' . str_replace( '#', '\#', $regex ) . '#';
 			}
-			//Purposely silencing the errors here since we are testing if preg_match would throw an error due to a bad regex from user input.
+
+			// Purposely silencing the errors here since we are testing if preg_match
+			// would throw an error due to a bad regex from user input.
+
+			// phpcs:ignore Generic.PHP.NoSilencedErrors.Discouraged
 			if ( @preg_match( $regex, null ) === false ) {
+				// @phan-suppress-previous-line PhanParamSuspiciousOrder, PhanTypeMismatchArgumentInternalProbablyReal
 				return false;
 			}
 		}
@@ -416,30 +419,34 @@ private function isRegexValid( $regexes, $forDb = false ) {
 	/**
 	 * Clean and test 'category' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _category( $option ) {
 		$option = trim( $option );
+
 		if ( empty( $option ) ) {
 			return false;
 		}
 
 		// Init array of categories to include
 		$categories = [];
-		$heading    = false;
+		$heading = false;
 		$notHeading = false;
+
 		if ( substr( $option, 0, 1 ) == '+' ) { // categories are headings
 			$heading = true;
 			$option = ltrim( $option, '+' );
 		}
+
 		if ( substr( $option, 0, 1 ) == '-' ) { // categories are NOT headings
 			$notHeading = true;
 			$option = ltrim( $option, '-' );
 		}
 
-		//We expand html entities because they contain an '& 'which would be interpreted as an AND condition
+		// We expand html entities because they contain an '& 'which would be interpreted as an AND condition
 		$option = html_entity_decode( $option, ENT_QUOTES );
+
 		if ( strpos( $option, '|' ) !== false ) {
 			$parameters = explode( '|', $option );
 			$operator = 'OR';
@@ -447,8 +454,10 @@ public function _category( $option ) {
 			$parameters = explode( '&', $option );
 			$operator = 'AND';
 		}
+
 		foreach ( $parameters as $parameter ) {
 			$parameter = trim( $parameter );
+
 			if ( $parameter === '_none_' || $parameter === '' ) {
 				$this->setParameter( 'includeuncat', true );
 				$categories[] = '';
@@ -461,55 +470,68 @@ public function _category( $option ) {
 						$parameter = substr( $parameter, 1 );
 						$subCategories = Query::getSubcategories( $parameter, 1 );
 					}
+
 					$subCategories[] = $parameter;
 					foreach ( $subCategories as $subCategory ) {
-						$title = \Title::newFromText( $subCategory );
+						$title = Title::newFromText( $subCategory );
+
 						if ( $title !== null ) {
-							//The * helper is just like listing "Category1|SubCategory1".  This gets hard coded here for this purpose.
+							// The * helper is just like listing "Category1|SubCategory1". This gets hard coded here for this purpose.
 							$categories['OR'][] = $title->getDbKey();
 						}
 					}
 				} else {
-					$title = \Title::newFromText( $parameter );
+					$title = Title::newFromText( $parameter );
+
 					if ( $title !== null ) {
 						$categories[$operator][] = $title->getDbKey();
 					}
 				}
 			}
 		}
+
 		if ( !empty( $categories ) ) {
 			$data = $this->getParameter( 'category' );
-			//Do a bunch of data integrity checks to avoid E_NOTICE.
+
+			// Do a bunch of data integrity checks to avoid E_NOTICE.
 			if ( !is_array( $data ) ) {
 				$data = [];
 			}
+
 			if ( !array_key_exists( '=', $data ) || !is_array( $data['='] ) ) {
 				$data['='] = [];
 			}
+
 			foreach ( $categories as $_operator => $_categories ) {
 				if ( !array_key_exists( $_operator, $data['='] ) || !is_array( $data['='][$_operator] ) ) {
 					$data['='][$_operator] = [];
 				}
+
 				$data['='][$_operator][] = $_categories;
 			}
+
 			$this->setParameter( 'category', $data );
 			if ( $heading ) {
 				$this->setParameter( 'catheadings', array_unique( array_merge( ( is_array( $this->getParameter( 'catheadings' ) ) ? $this->getParameter( 'catheadings' ) : [] ), $categories ) ) );
 			}
+
 			if ( $notHeading ) {
 				$this->setParameter( 'catnotheadings', array_unique( array_merge( ( is_array( $this->getParameter( 'catnotheadings' ) ) ? $this->getParameter( 'catnotheadings' ) : [] ), $categories ) ) );
 			}
+
 			$this->setOpenReferencesConflict( true );
+
 			return true;
 		}
+
 		return false;
 	}
 
 	/**
 	 * Clean and test 'categoryregexp' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _categoryregexp( $option ) {
 		if ( !$this->isRegexValid( $option, true ) ) {
@@ -517,18 +539,21 @@ public function _categoryregexp( $option ) {
 		}
 
 		$data = $this->getParameter( 'category' );
-		//REGEXP input only supports AND operator.
-		$data['REGEXP']['AND'][] = [ $option ]; //Wrapped in an array since the category Query handler expects an array.
+
+		// REGEXP input only supports AND operator.
+		$data['REGEXP']['AND'][] = [ $option ];
+
 		$this->setParameter( 'category', $data );
 		$this->setOpenReferencesConflict( true );
+
 		return true;
 	}
 
 	/**
 	 * Clean and test 'categorymatch' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _categorymatch( $option ) {
 		if ( strpos( $option, '|' ) !== false ) {
@@ -545,34 +570,40 @@ public function _categorymatch( $option ) {
 		}
 
 		$data['LIKE'][$operator][] = $newMatches;
+
 		$this->setParameter( 'category', $data );
 		$this->setOpenReferencesConflict( true );
+
 		return true;
 	}
 
 	/**
 	 * Clean and test 'notcategory' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _notcategory( $option ) {
-		$title = \Title::newFromText( $option );
+		$title = Title::newFromText( $option );
+
 		if ( $title !== null ) {
 			$data = $this->getParameter( 'notcategory' );
 			$data['='][] = $title->getDbKey();
+
 			$this->setParameter( 'notcategory', $data );
 			$this->setOpenReferencesConflict( true );
+
 			return true;
 		}
+
 		return false;
 	}
 
 	/**
 	 * Clean and test 'notcategoryregexp' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _notcategoryregexp( $option ) {
 		if ( !$this->isRegexValid( $option, true ) ) {
@@ -581,48 +612,56 @@ public function _notcategoryregexp( $option ) {
 
 		$data = $this->getParameter( 'notcategory' );
 		$data['regexp'][] = $option;
+
 		$this->setParameter( 'notcategory', $data );
 		$this->setOpenReferencesConflict( true );
+
 		return true;
 	}
 
 	/**
 	 * Clean and test 'notcategorymatch' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _notcategorymatch( $option ) {
 		$data = $this->getParameter( 'notcategory' );
-		if ( !isset( $data['like'] ) || !is_array( $data['like'] ) ) {
+
+		if ( !is_array( $data['like'] ?? false ) ) {
 			$data['like'] = [];
 		}
+
 		$newMatches = explode( '|', $option );
 		$data['like'] = array_merge( $data['like'], $newMatches );
+
 		$this->setParameter( 'notcategory', $data );
 		$this->setOpenReferencesConflict( true );
+
 		return true;
 	}
 
 	/**
 	 * Clean and test 'count' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string|int $option
+	 * @return bool
 	 */
 	public function _count( $option ) {
 		if ( !Config::getSetting( 'allowUnlimitedResults' ) && $option <= Config::getSetting( 'maxResultCount' ) && $option > 0 ) {
 			$this->setParameter( 'count', intval( $option ) );
+
 			return true;
 		}
+
 		return false;
 	}
 
 	/**
 	 * Clean and test 'namespace' parameter.
 	 *
-	 * @param string Option passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _namespace( $option ) {
 		$contLang = MediaWikiServices::getInstance()->getContentLanguage();
@@ -631,24 +670,28 @@ public function _namespace( $option ) {
 		foreach ( $extraParams as $parameter ) {
 			$parameter = trim( $parameter );
 			$namespaceId = $contLang->getNsIndex( $parameter );
+
 			if ( $namespaceId === false || ( is_array( Config::getSetting( 'allowedNamespaces' ) ) && !in_array( $parameter, Config::getSetting( 'allowedNamespaces' ) ) ) ) {
-				//Let the user know this namespace is not allowed or does not exist.
+				// Let the user know this namespace is not allowed or does not exist.
 				return false;
 			}
+
 			$data = $this->getParameter( 'namespace' );
 			$data[] = $namespaceId;
 			$data = array_unique( $data );
+
 			$this->setParameter( 'namespace', $data );
 			$this->setSelectionCriteriaFound( true );
 		}
+
 		return true;
 	}
 
 	/**
 	 * Clean and test 'notnamespace' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _notnamespace( $option ) {
 		$contLang = MediaWikiServices::getInstance()->getContentLanguage();
@@ -657,32 +700,37 @@ public function _notnamespace( $option ) {
 		foreach ( $extraParams as $parameter ) {
 			$parameter = trim( $parameter );
 			$namespaceId = $contLang->getNsIndex( $parameter );
+
 			if ( $namespaceId === false ) {
-				//Let the user know this namespace is not allowed or does not exist.
+				// Let the user know this namespace is not allowed or does not exist.
 				return false;
 			}
+
 			$data = $this->getParameter( 'notnamespace' );
 			$data[] = $namespaceId;
 			$data = array_unique( $data );
+
 			$this->setParameter( 'notnamespace', $data );
 			$this->setSelectionCriteriaFound( true );
 		}
+
 		return true;
 	}
 
 	/**
 	 * Clean and test 'openreferences' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _openreferences( $option ) {
 		$option = $this->filterBoolean( $option );
+
 		if ( $option === null ) {
 			return false;
 		}
 
-		//Force 'ordermethod' back to none.
+		// Force 'ordermethod' back to none.
 		$this->setParameter( 'ordermethod', [ 'none' ] );
 		$this->setParameter( 'openreferences', $option );
 
@@ -692,12 +740,13 @@ public function _openreferences( $option ) {
 	/**
 	 * Clean and test 'ordermethod' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _ordermethod( $option ) {
 		$methods = explode( ',', $option );
 		$success = true;
+
 		foreach ( $methods as $method ) {
 			if ( !in_array( $method, $this->getData( 'ordermethod' )['values'] ) ) {
 				return false;
@@ -715,12 +764,12 @@ public function _ordermethod( $option ) {
 	/**
 	 * Clean and test 'mode' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _mode( $option ) {
 		if ( in_array( $option, $this->getData( 'mode' )['values'] ) ) {
-			//'none' mode is implemented as a specific submode of 'inline' with <br/> as inline text
+			// 'none' mode is implemented as a specific submode of 'inline' with <br/> as inline text
 			if ( $option == 'none' ) {
 				$this->setParameter( 'mode', 'inline' );
 				$this->setParameter( 'inlinetext', '<br/>' );
@@ -731,6 +780,7 @@ public function _mode( $option ) {
 			} else {
 				$this->setParameter( 'mode', $option );
 			}
+
 			return true;
 		} else {
 			return false;
@@ -740,11 +790,12 @@ public function _mode( $option ) {
 	/**
 	 * Clean and test 'distinct' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _distinct( $option ) {
 		$boolean = $this->filterBoolean( $option );
+
 		if ( $option == 'strict' ) {
 			$this->setParameter( 'distinctresultset', 'strict' );
 		} elseif ( $boolean !== null ) {
@@ -752,14 +803,15 @@ public function _distinct( $option ) {
 		} else {
 			return false;
 		}
+
 		return true;
 	}
 
 	/**
 	 * Clean and test 'ordercollation' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _ordercollation( $option ) {
 		if ( $option == 'bridge' ) {
@@ -769,6 +821,7 @@ public function _ordercollation( $option ) {
 		} else {
 			return false;
 		}
+
 		return true;
 	}
 
@@ -784,28 +837,32 @@ public function _listseparators() {
 	/**
 	 * Clean and test 'format' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _format( $option ) {
-		//Parsing of wikitext will happen at the end of the output phase.  Replace '\n' in the input by linefeed because wiki syntax depends on linefeeds.
+		// Parsing of wikitext will happen at the end of the output phase. Replace '\n' in the input by linefeed because wiki syntax depends on linefeeds.
 		$option = $this->stripHtmlTags( $option );
 		$option = Parse::replaceNewLines( $option );
+
 		$this->setParameter( 'listseparators', explode( ',', $option, 4 ) );
-		//Set the 'mode' parameter to userformat automatically.
+
+		// Set the 'mode' parameter to userformat automatically.
 		$this->setParameter( 'mode', 'userformat' );
 		$this->setParameter( 'inlinetext', '' );
+
 		return true;
 	}
 
 	/**
 	 * Clean and test 'title' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _title( $option ) {
-		$title = \Title::newFromText( $option );
+		$title = Title::newFromText( $option );
+
 		if ( $title ) {
 			$data = $this->getParameter( 'title' );
 			$data['='][] = str_replace( ' ', '_', $title->getText() );
@@ -814,27 +871,32 @@ public function _title( $option ) {
 			$data = $this->getParameter( 'namespace' );
 			$data[] = $title->getNamespace();
 			$data = array_unique( $data );
-			$this->setParameter( 'namespace', $data );
 
+			$this->setParameter( 'namespace', $data );
 			$this->setParameter( 'mode', 'userformat' );
+
 			$this->setSelectionCriteriaFound( true );
 			$this->setOpenReferencesConflict( true );
+
 			return true;
 		}
+
 		return false;
 	}
 
 	/**
 	 * Clean and test 'titleregexp' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _titleregexp( $option ) {
 		$data = $this->getParameter( 'title' );
-		if ( !isset( $data['regexp'] ) || !is_array( $data['regexp'] ) ) {
+
+		if ( !is_array( $data['regexp'] ?? false ) ) {
 			$data['regexp'] = [];
 		}
+
 		$newMatches = explode( '|', str_replace( ' ', '\_', $option ) );
 
 		if ( !$this->isRegexValid( $newMatches, true ) ) {
@@ -842,26 +904,29 @@ public function _titleregexp( $option ) {
 		}
 
 		$data['regexp'] = array_merge( $data['regexp'], $newMatches );
+
 		$this->setParameter( 'title', $data );
 		$this->setSelectionCriteriaFound( true );
+
 		return true;
 	}
 
 	/**
 	 * Clean and test 'titlematch' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _titlematch( $option ) {
 		$data = $this->getParameter( 'title' );
 
-		if ( !isset( $data['like'] ) || !is_array( $data['like'] ) ) {
+		if ( !is_array( $data['like'] ?? false ) ) {
 			$data['like'] = [];
 		}
 
 		$newMatches = explode( '|', str_replace( ' ', '\_', $option ) );
 		$data['like'] = array_merge( $data['like'], $newMatches );
+
 		$this->setParameter( 'title', $data );
 		$this->setSelectionCriteriaFound( true );
 
@@ -871,14 +936,16 @@ public function _titlematch( $option ) {
 	/**
 	 * Clean and test 'nottitleregexp' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _nottitleregexp( $option ) {
 		$data = $this->getParameter( 'nottitle' );
+
 		if ( !is_array( $data['regexp'] ) ) {
 			$data['regexp'] = [];
 		}
+
 		$newMatches = explode( '|', str_replace( ' ', '\_', $option ) );
 		$data['regexp'] = array_merge( $data['regexp'], $newMatches );
 
@@ -888,24 +955,26 @@ public function _nottitleregexp( $option ) {
 
 		$this->setParameter( 'nottitle', $data );
 		$this->setSelectionCriteriaFound( true );
+
 		return true;
 	}
 
 	/**
 	 * Clean and test 'nottitlematch' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _nottitlematch( $option ) {
 		$data = $this->getParameter( 'nottitle' );
 
-		if ( !isset( $data['like'] ) || !is_array( $data['like'] ) ) {
+		if ( !is_array( $data['like'] ?? false ) ) {
 			$data['like'] = [];
 		}
 
 		$newMatches = explode( '|', str_replace( ' ', '\_', $option ) );
 		$data['like'] = array_merge( $data['like'], $newMatches );
+
 		$this->setParameter( 'nottitle', $data );
 		$this->setSelectionCriteriaFound( true );
 
@@ -915,50 +984,56 @@ public function _nottitlematch( $option ) {
 	/**
 	 * Clean and test 'scroll' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _scroll( $option ) {
 		$option = $this->filterBoolean( $option );
 		$this->setParameter( 'scroll', $option );
-		//If scrolling is active we adjust the values for certain other parameters based on URL arguments
+
+		// If scrolling is active we adjust the values for certain other parameters based on URL arguments
 		if ( $option === true ) {
 			global $wgRequest;
 
-			//The 'findTitle' option has argument over the 'fromTitle' argument.
+			// The 'findTitle' option has argument over the 'fromTitle' argument.
 			$titlegt = $wgRequest->getVal( 'DPL_findTitle', '' );
+
 			if ( !empty( $titlegt ) ) {
 				$titlegt = '=_' . ucfirst( $titlegt );
 			} else {
 				$titlegt = $wgRequest->getVal( 'DPL_fromTitle', '' );
 				$titlegt = ucfirst( $titlegt );
 			}
+
 			$this->setParameter( 'titlegt', str_replace( ' ', '_', $titlegt ) );
 
-			//Lets get the 'toTitle' argument.
+			// Lets get the 'toTitle' argument.
 			$titlelt = $wgRequest->getVal( 'DPL_toTitle', '' );
 			$titlelt = ucfirst( $titlelt );
+
 			$this->setParameter( 'titlelt', str_replace( ' ', '_', $titlelt ) );
 
-			//Make sure the 'scrollDir' arugment is captured.  This is mainly used for the Variables extension and in the header/footer replacements.
+			// Make sure the 'scrollDir' arugment is captured. This is mainly used for the Variables extension and in the header/footer replacements.
 			$this->setParameter( 'scrolldir', $wgRequest->getVal( 'DPL_scrollDir', '' ) );
 
-			//Also set count limit from URL if not otherwise set.
+			// Also set count limit from URL if not otherwise set.
 			$this->_count( $wgRequest->getInt( 'DPL_count' ) );
 		}
-		//We do not return false since they could have just left it out.  Who knows why they put the parameter in the list in the first place.
+
+		// We do not return false since they could have just left it out. Who knows why they put the parameter in the list in the first place.
 		return true;
 	}
 
 	/**
 	 * Clean and test 'replaceintitle' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _replaceintitle( $option ) {
-		//We offer a possibility to replace some part of the title
+		// We offer a possibility to replace some part of the title
 		$replaceInTitle = explode( ',', $option, 2 );
+
 		if ( isset( $replaceInTitle[1] ) ) {
 			$replaceInTitle[1] = $this->stripHtmlTags( $replaceInTitle[1] );
 		}
@@ -971,12 +1046,12 @@ public function _replaceintitle( $option ) {
 	/**
 	 * Clean and test 'debug' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _debug( $option ) {
 		if ( in_array( $option, $this->getData( 'debug' )['values'] ) ) {
-			\DynamicPageListHooks::setDebugLevel( $option );
+			DynamicPageListHooks::setDebugLevel( $option );
 		} else {
 			return false;
 		}
@@ -996,8 +1071,8 @@ public function _includepage() {
 	/**
 	 * Clean and test 'include' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _include( $option ) {
 		if ( !empty( $option ) ) {
@@ -1006,14 +1081,15 @@ public function _include( $option ) {
 		} else {
 			return false;
 		}
+
 		return true;
 	}
 
 	/**
 	 * Clean and test 'includematch' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _includematch( $option ) {
 		$regexes = explode( ',', $option );
@@ -1023,14 +1099,15 @@ public function _includematch( $option ) {
 		}
 
 		$this->setParameter( 'seclabelsmatch', $regexes );
+
 		return true;
 	}
 
 	/**
 	 * Clean and test 'includematchparsed' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _includematchparsed( $option ) {
 		$regexes = explode( ',', $option );
@@ -1041,14 +1118,15 @@ public function _includematchparsed( $option ) {
 
 		$this->setParameter( 'incparsed', true );
 		$this->setParameter( 'seclabelsmatch', $regexes );
+
 		return true;
 	}
 
 	/**
 	 * Clean and test 'includenotmatch' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _includenotmatch( $option ) {
 		$regexes = explode( ',', $option );
@@ -1058,14 +1136,15 @@ public function _includenotmatch( $option ) {
 		}
 
 		$this->setParameter( 'seclabelsnotmatch', $regexes );
+
 		return true;
 	}
 
 	/**
 	 * Clean and test 'includenotmatchparsed' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _includenotmatchparsed( $option ) {
 		$regexes = explode( ',', $option );
@@ -1076,82 +1155,94 @@ public function _includenotmatchparsed( $option ) {
 
 		$this->setParameter( 'incparsed', true );
 		$this->setParameter( 'seclabelsnotmatch', $regexes );
+
 		return true;
 	}
 
 	/**
 	 * Clean and test 'secseparators' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _secseparators( $option ) {
-		//We replace '\n' by newline to support wiki syntax within the section separators
+		// We replace '\n' by newline to support wiki syntax within the section separators
 		$this->setParameter( 'secseparators', explode( ',', Parse::replaceNewLines( $option ) ) );
+
 		return true;
 	}
 
 	/**
 	 * Clean and test 'multisecseparators' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _multisecseparators( $option ) {
-		//We replace '\n' by newline to support wiki syntax within the section separators
+		// We replace '\n' by newline to support wiki syntax within the section separators
 		$this->setParameter( 'multisecseparators', explode( ',', Parse::replaceNewLines( $option ) ) );
+
 		return true;
 	}
 
 	/**
 	 * Clean and test 'table' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _table( $option ) {
 		$this->setParameter( 'defaulttemplatesuffix', '' );
 		$this->setParameter( 'mode', 'userformat' );
 		$this->setParameter( 'inlinetext', '' );
+
 		$withHLink = "[[%PAGE%|%TITLE%]]\n|";
+		$listSeparators = [];
 
 		foreach ( explode( ',', $option ) as $tabnr => $tab ) {
 			if ( $tabnr == 0 ) {
 				if ( $tab == '' ) {
 					$tab = 'class=wikitable';
 				}
+
 				$listSeparators[0] = '{|' . $tab;
 			} else {
 				if ( $tabnr == 1 && $tab == '-' ) {
 					$withHLink = '';
 					continue;
 				}
+
 				if ( $tabnr == 1 && $tab == '' ) {
 					$tab = wfMessage( 'article' )->text();
 				}
+
 				$listSeparators[0] .= "\n!{$tab}";
 			}
 		}
+
 		$listSeparators[1] = '';
+
 		// the user may have specified the third parameter of 'format' to add meta attributes of articles to the table
-		if ( !array_key_exists( 2, $listSeparators ) ) {
-			$listSeparators[2] = '';
-		}
+		$listSeparators[2] = '';
+
 		$listSeparators[3] = "\n|}";
-		//Overwrite 'listseparators'.
+
+		// Overwrite 'listseparators'.
 		$this->setParameter( 'listseparators', $listSeparators );
 
 		$sectionLabels = (array)$this->getParameter( 'seclabels' );
 		$sectionSeparators = $this->getParameter( 'secseparators' );
 		$multiSectionSeparators = $this->getParameter( 'multisecseparators' );
+
 		for ( $i = 0; $i < count( $sectionLabels ); $i++ ) {
 			if ( $i == 0 ) {
-				$sectionSeparators[0]		= "\n|-\n|" . $withHLink; //."\n";
-				$sectionSeparators[1]		= '';
-				$multiSectionSeparators[0]	= "\n|-\n|" . $withHLink; // ."\n";
+				$sectionSeparators[0] = "\n|-\n|" . $withHLink; // ."\n";
+				$sectionSeparators[1] = '';
+				$multiSectionSeparators[0] = "\n|-\n|" . $withHLink; // ."\n";
 			} else {
-				$sectionSeparators[2 * $i]		= "\n|"; // ."\n";
-				$sectionSeparators[2 * $i + 1]	= '';
+				$sectionSeparators[2 * $i] = "\n|"; // ."\n";
+				$sectionSeparators[2 * $i + 1] = '';
+
 				if ( is_array( $sectionLabels[$i] ) && $sectionLabels[$i][0] == '#' ) {
 					$multiSectionSeparators[$i] = "\n----\n";
 				} else {
@@ -1159,27 +1250,31 @@ public function _table( $option ) {
 				}
 			}
 		}
-		//Overwrite 'secseparators' and 'multisecseparators'.
+
+		// Overwrite 'secseparators' and 'multisecseparators'.
 		$this->setParameter( 'secseparators', $sectionSeparators );
 		$this->setParameter( 'multisecseparators', $multiSectionSeparators );
 
 		$this->setParameter( 'table', Parse::replaceNewLines( $option ) );
+
 		return true;
 	}
 
 	/**
 	 * Clean and test 'tablerow' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _tablerow( $option ) {
 		$option = Parse::replaceNewLines( trim( $option ) );
+
 		if ( empty( $option ) ) {
 			$this->setParameter( 'tablerow', [] );
 		} else {
 			$this->setParameter( 'tablerow', explode( ',', $option ) );
 		}
+
 		return true;
 	}
 
@@ -1187,17 +1282,19 @@ public function _tablerow( $option ) {
 	 * Clean and test 'allowcachedresults' parameter.
 	 * This function is necessary for the custom 'yes+warn' option that sets 'warncachedresults'.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool|int|string
 	 */
 	public function _allowcachedresults( $option ) {
-		//If execAndExit was previously set (i.e. if it is not empty) we will ignore all cache settings which are placed AFTER the execandexit statement thus we make sure that the cache will only become invalid if the query is really executed.
+		// If execAndExit was previously set (i.e. if it is not empty) we will ignore all cache settings which are placed AFTER the execandexit statement thus we make sure that the cache will only become invalid if the query is really executed.
 		if ( $this->getParameter( 'execandexit' ) === null ) {
 			if ( $option === 'yes+warn' ) {
 				$this->setParameter( 'allowcachedresults', true );
 				$this->setParameter( 'warncachedresults', true );
+
 				return true;
 			}
+
 			$option = $this->filterBoolean( $option );
 			if ( $option !== null ) {
 				$this->setParameter( 'allowcachedresults', $this->filterBoolean( $option ) );
@@ -1207,31 +1304,35 @@ public function _allowcachedresults( $option ) {
 		} else {
 			$this->setParameter( 'allowcachedresults', false );
 		}
+
 		return true;
 	}
 
 	/**
 	 * Clean and test 'fixcategory' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _fixcategory( $option ) {
-		\DynamicPageListHooks::fixCategory( $option );
+		DynamicPageListHooks::fixCategory( $option );
+
 		return true;
 	}
 
 	/**
 	 * Clean and test 'reset' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _reset( $option ) {
 		$arguments = explode( ',', $option );
 		$reset = [];
+
 		foreach ( $arguments as $argument ) {
 			$argument = trim( $argument );
+
 			if ( empty( $argument ) ) {
 				continue;
 			}
@@ -1241,9 +1342,10 @@ public function _reset( $option ) {
 				return false;
 			} else {
 				if ( $argument == 'all' || $argument == 'none' ) {
-					$boolean = ( $argument == 'all' ? true : false );
+					$boolean = ( $argument == 'all' );
 					$values = array_diff( $values, [ 'all', 'none' ] );
 					$reset = array_flip( $values );
+
 					foreach ( $reset as $value => $key ) {
 						$reset[$value] = $boolean;
 					}
@@ -1252,35 +1354,42 @@ public function _reset( $option ) {
 				}
 			}
 		}
+
 		$data = $this->getParameter( 'reset' );
 		$data = array_merge( $data, $reset );
+
 		$this->setParameter( 'reset', $data );
+
 		return true;
 	}
 
 	/**
 	 * Clean and test 'eliminate' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _eliminate( $option ) {
 		$arguments = explode( ',', $option );
 		$eliminate = [];
+
 		foreach ( $arguments as $argument ) {
 			$argument = trim( $argument );
+
 			if ( empty( $argument ) ) {
 				continue;
 			}
 
 			$values = $this->getData( 'eliminate' )['values'];
+
 			if ( !in_array( $argument, $values ) ) {
 				return false;
 			} else {
 				if ( $argument == 'all' || $argument == 'none' ) {
-					$boolean = ( $argument == 'all' ? true : false );
+					$boolean = ( $argument == 'all' );
 					$values = array_diff( $values, [ 'all', 'none' ] );
 					$eliminate = array_flip( $values );
+
 					foreach ( $eliminate as $value => $key ) {
 						$eliminate[$value] = $boolean;
 					}
@@ -1289,9 +1398,11 @@ public function _eliminate( $option ) {
 				}
 			}
 		}
+
 		$data = $this->getParameter( 'eliminate' );
 		$data = array_merge( $data, $eliminate );
 		$this->setParameter( 'eliminate', $data );
+
 		return true;
 	}
 }
diff --git a/includes/ParametersData.php b/includes/ParametersData.php
index eb9cc382..01bb047a 100644
--- a/includes/ParametersData.php
+++ b/includes/ParametersData.php
@@ -1,15 +1,9 @@
 <?php
-/**
- * DynamicPageList3
- * DPL ParametersData Class
- *
- * @author		IlyaHaykinson, Unendlich, Dangerville, Algorithmix, Theaitetos, Alexia E. Smith
- * @license		GPL-2.0-or-later
- * @package		DynamicPageList3
- *
- */
+
 namespace DPL;
 
+use MWException;
+
 class ParametersData {
 	/**
 	 * Parameter Richness
@@ -167,72 +161,72 @@ class ParametersData {
 	 */
 	private $data = [
 		'addauthor' => [
-			'default'			=> false,
-			'boolean'			=> true,
-			'open_ref_conflict'	=> true
+			'default' => false,
+			'boolean' => true,
+			'open_ref_conflict' => true
 		],
 		'addcategories' => [
-			'default'			=> false,
-			'boolean'			=> true,
-			'open_ref_conflict'	=> true
+			'default' => false,
+			'boolean' => true,
+			'open_ref_conflict' => true
 		],
 		'addcontribution' => [
-			'default'			=> false,
-			'boolean'			=> true,
-			'open_ref_conflict'	=> true
+			'default' => false,
+			'boolean' => true,
+			'open_ref_conflict' => true
 		],
 		'addeditdate' => [
-			'default'			=> false,
-			'boolean'			=> true,
-			'open_ref_conflict'	=> true
+			'default' => false,
+			'boolean' => true,
+			'open_ref_conflict' => true
 		],
 		'addexternallink' => [
-			'default'			=> false,
-			'boolean'			=> true,
-			'open_ref_conflict'	=> true
+			'default' => false,
+			'boolean' => true,
+			'open_ref_conflict' => true
 		],
 		'addfirstcategorydate' => [
-			'default'			=> false,
-			'boolean'			=> true,
-			'open_ref_conflict'	=> true
+			'default' => false,
+			'boolean' => true,
+			'open_ref_conflict' => true
 		],
 		'addlasteditor' => [
-			'default'			=> false,
-			'boolean'			=> true,
-			'open_ref_conflict'	=> true
+			'default' => false,
+			'boolean' => true,
+			'open_ref_conflict' => true
 		],
 		'addpagecounter' => [
-			'default'			=> false,
-			'boolean'			=> true,
-			'open_ref_conflict'	=> true
+			'default' => false,
+			'boolean' => true,
+			'open_ref_conflict' => true
 		],
 		'addpagesize' => [
-			'default'			=> false,
-			'boolean'			=> true,
-			'open_ref_conflict'	=> true
+			'default' => false,
+			'boolean' => true,
+			'open_ref_conflict' => true
 		],
 		'addpagetoucheddate' => [
-			'default'			=> false,
-			'boolean'			=> true,
-			'open_ref_conflict'	=> true
+			'default' => false,
+			'boolean' => true,
+			'open_ref_conflict' => true
 		],
 		'adduser' => [
-			'default'			=> false,
-			'boolean'			=> true,
-			'open_ref_conflict'	=> true
+			'default' => false,
+			'boolean' => true,
+			'open_ref_conflict' => true
 		],
 
 		// default of allowcachedresults depends on behaveasIntersetion and on LocalSettings ...
 		'allowcachedresults' => [
-			'default'			=> true,
-			'boolean'			=> true
+			'default' => true,
+			'boolean' => true
 		],
 		/**
 		 * search for a page with the same title in another namespace (this is normally the article to a talk page)
 		 */
 		'articlecategory' => [
-			'default'			=> null,
-			'db_format'			=> true
+			'default' => null,
+			'db_format' => true
 		],
 
 		/**
@@ -247,13 +241,13 @@ class ParametersData {
 		 * @todo define 'category' options (retrieve list of categories from 'categorylinks' table?)
 		 */
 		'category' => [
-			'default'	=> null,
+			'default' => null,
 		],
 		'categorymatch' => [
-			'default'	=> null,
+			'default' => null,
 		],
 		'categoryregexp' => [
-			'default'	=> null,
+			'default' => null,
 		],
 		/**
 		 * Min and Max of categories allowed for an article
@@ -266,14 +260,14 @@ class ParametersData {
 		 * hiddencategories
 		 */
 		'hiddencategories' => [
-			'default'	=> 'include',
-			'values'	=> [ 'include', 'exclude', 'only' ]
+			'default' => 'include',
+			'values' => [ 'include', 'exclude', 'only' ]
 		],
 		/**
 		 * Perform the command and do not query the database.
 		 */
 		'execandexit' => [
-			'default'	=> null
+			'default' => null
 		],
 
 		/**
@@ -281,40 +275,40 @@ class ParametersData {
 		 * default is 0
 		 */
 		'offset' => [
-			'default'	=> 0,
-			'integer'	=> true
+			'default' => 0,
+			'integer' => true
 		],
 		/**
 		 * Max of results to display, selection is based on random.
 		 */
 		'count' => [
-			'default'	=> 500,
-			'integer'	=> true
+			'default' => 500,
+			'integer' => true
 		],
 		/**
 		 * Max number of results to display, selection is based on random.
 		 */
 		'randomcount' => [
-			'default'	=> null,
-			'integer'	=> true
+			'default' => null,
+			'integer' => true
 		],
 		/**
 		 * shall the result set be distinct (=default) or not?
 		 */
 		'distinct' => [
-			'default'	=> true,
-			'values'	=> [ 'strict' ]
+			'default' => true,
+			'values' => [ 'strict' ]
 		],
 		'cacheperiod' => [
-			'default'	=> 3600, // Number of seconds, default one day at 86400 seconds.
-			'integer'	=> true
+			'default' => 3600,
+			'integer' => true
 		],
 		/**
 		 * number of columns for output, default is 1
 		 */
 		'columns' => [
-			'default'	=> 1,
-			'integer'	=> true
+			'default' => 1,
+			'integer' => true
 		],
 
 		/**
@@ -327,8 +321,8 @@ class ParametersData {
 		 * - 5: <nowiki> tags around the ouput
 		 */
 		'debug' => [
-			'default'	=> 1,
-			'values'	=> [ 0, 1, 2, 3, 4, 5 ]
+			'default' => 1,
+			'values' => [ 0, 1, 2, 3, 4, 5 ]
 		],
 
 		/**
@@ -341,8 +335,8 @@ class ParametersData {
 		 * all		   all of the above
 		 */
 		'eliminate' => [
-			'default'	=> [],
-			'values'	=> [
+			'default' => [],
+			'values' => [
 				'categories',
 				'templates',
 				'links',
@@ -353,22 +347,22 @@ class ParametersData {
 		],
 
 		'format' => [
-			'default'	=> null,
+			'default' => null,
 		],
 
 		'goal' => [
-			'default'	=> 'pages',
-			'values'	=> [
+			'default' => 'pages',
+			'values' => [
 				'pages',
 				'categories'
 			],
-			'open_ref_conflict'	=> true
+			'open_ref_conflict' => true
 		],
 
-		//Include the lowercase variants of header tiers for ease of use.
+		// Include the lowercase variants of header tiers for ease of use.
 		'headingmode' => [
-			'default'	=> 'none',
-			'values'	=> [
+			'default' => 'none',
+			'values' => [
 				'H1',
 				'H2',
 				'H3',
@@ -381,22 +375,22 @@ class ParametersData {
 				'h4',
 				'h5',
 				'h6',
-				//'header',
+				// 'header',
 				'definition',
 				'none',
 				'ordered',
 				'unordered'
 			],
-			'open_ref_conflict'	=> true
+			'open_ref_conflict' => true
 		],
 
 		/**
 		 * we can display the number of articles within a heading group
 		 */
 		'headingcount' => [
-			'default'			=> false,
-			'boolean'			=> true,
-			'open_ref_conflict'	=> true
+			'default' => false,
+			'boolean' => true,
+			'open_ref_conflict' => true
 		],
 
 		/**
@@ -406,7 +400,7 @@ class ParametersData {
 		 * Example: hitemattr= class="topmenuli" style="color: red;"
 		 */
 		'hitemattr' => [
-			'default'	=> null
+			'default' => null
 		],
 
 		/**
@@ -416,7 +410,7 @@ class ParametersData {
 		 * Example: hlistattr= class="topmenul" id="dmenu"
 		 */
 		'hlistattr' => [
-			'default'	=> null
+			'default' => null
 		],
 
 		/**
@@ -434,58 +428,58 @@ class ParametersData {
 		 */
 
 		'includepage' => [
-			'default'	=> null
+			'default' => null
 		],
 
 		/**
 		 * make comparisons (linksto, linksfrom ) case insensitive
 		 */
 		'ignorecase' => [
-			'default'	=> false,
-			'boolean'	=> true
+			'default' => false,
+			'boolean' => true
 		],
-		'include'			   => [
-			'default'	=> null
+		'include' => [
+			'default' => null
 		],
 
 		/**
 		 * includesubpages
 		 */
 		'includesubpages' => [
-			'default'	=> true,
-			'boolean'	=> true
+			'default' => true,
+			'boolean' => true
 		],
 
 		/**
 		 * includematch=..,..	 allows to specify regular expressions which must match the included contents
 		 */
 		'includematch' => [
-			'default'	=> null
+			'default' => null
 		],
 		'includematchparsed' => [
-			'default'	=> false,
-			'boolean'	=> true
+			'default' => false,
+			'boolean' => true
 		],
 		/**
 		 * includenotmatch=..,..	allows to specify regular expressions which must NOT match the included contents
 		 */
 		'includenotmatch' => [
-			'default'	=> null
+			'default' => null
 		],
 		'includenotmatchparsed' => [
-			'default'	=> false,
-			'boolean'	=> true
+			'default' => false,
+			'boolean' => true
 		],
 		'includetrim' => [
-			'default'	=> false,
-			'boolean'	=> true
+			'default' => false,
+			'boolean' => true
 		],
 		/**
 		 * Inline text is some wiki text used to separate list items with 'mode=inline'.
 		 */
 		'inlinetext' => [
-			'default'		=> '&#160;-&#160;',
-			'strip_html'	=> true
+			'default' => '&#160;-&#160;',
+			'strip_html' => true
 		],
 		/**
 		 * Max # characters of included page to display.
@@ -493,8 +487,8 @@ class ParametersData {
 		 * If we include sections the limit will apply to each section.
 		 */
 		'includemaxlength' => [
-			'default'	=> null,
-			'integer'	=> true
+			'default' => null,
+			'integer' => true
 		],
 		/**
 		 * Attributes for HTML list items, depending on 'mode' ('li' for ordered/unordered, 'span' for others).
@@ -503,7 +497,7 @@ class ParametersData {
 		 * Example: itemattr= class="submenuli" style="color: red;"
 		 */
 		'itemattr' => [
-			'default'	=> null
+			'default' => null
 		],
 		/**
 		 * listseparators is an array of four tags (in wiki syntax) which defines the output of DPL
@@ -517,7 +511,7 @@ class ParametersData {
 		 *		   : listseparators={|,\n|-\n|[[%PAGE%]],,\n|}
 		 */
 		'listseparators' => [
-			'default'	=> []
+			'default' => []
 		],
 		/**
 		 * sequence of four wiki tags (separated by ",") to be used together with mode = 'userformat'
@@ -526,167 +520,167 @@ class ParametersData {
 		 *	 example:	listattr=<ul>,<li>,</li>,</ul>
 		 */
 		'listattr' => [
-			'default'	=> null
+			'default' => null
 		],
 		/**
 		 * this parameter restricts the output to articles which can reached via a link from the specified pages.
 		 * Examples:   linksfrom=my article|your article
 		 */
 		'linksfrom' => [
-			'default'				=> null,
-			'page_name_list'		=> true,
-			'page_name_must_exist'	=> true,
-			'set_criteria_found'	=> true
+			'default' => null,
+			'page_name_list' => true,
+			'page_name_must_exist' => true,
+			'set_criteria_found' => true
 		],
 		/**
 		 * this parameter restricts the output to articles which cannot be reached via a link from the specified pages.
 		 * Examples:   notlinksfrom=my article|your article
 		 */
 		'notlinksfrom' => [
-			'default'				=> null,
-			'page_name_list'		=> true,
-			'page_name_must_exist'	=> true,
-			'set_criteria_found'	=> true
+			'default' => null,
+			'page_name_list' => true,
+			'page_name_must_exist' => true,
+			'set_criteria_found' => true
 		],
 		/**
 		 * this parameter restricts the output to articles which contain a reference to one of the specified pages.
 		 * Examples:   linksto=my article|your article	 ,	linksto=Template:my template   ,  linksto = {{FULLPAGENAME}}
 		 */
 		'linksto' => [
-			'default'				=> null,
-			'open_ref_conflict'		=> true,
-			'page_name_list'		=> true,
-			'page_name_must_exist'	=> true,
-			'set_criteria_found'	=> true
+			'default' => null,
+			'open_ref_conflict' => true,
+			'page_name_list' => true,
+			'page_name_must_exist' => true,
+			'set_criteria_found' => true
 		],
 		/**
 		 * this parameter restricts the output to articles which do not contain a reference to the specified page.
 		 */
 		'notlinksto' => [
-			'default'				=> null,
-			'open_ref_conflict'		=> true,
-			'page_name_list'		=> true,
-			'page_name_must_exist'	=> true,
-			'set_criteria_found'	=> true
+			'default' => null,
+			'open_ref_conflict' => true,
+			'page_name_list' => true,
+			'page_name_must_exist' => true,
+			'set_criteria_found' => true
 		],
 		/**
 		 * this parameter restricts the output to articles which contain an external reference that conatins a certain pattern
 		 * Examples:   linkstoexternal= www.xyz.com|www.xyz2.com
 		 */
 		'linkstoexternal' => [
-			'default'				=> null,
-			'open_ref_conflict'		=> true,
-			'page_name_list'		=> true,
-			'page_name_must_exist'	=> false,
-			'set_criteria_found'	=> true
+			'default' => null,
+			'open_ref_conflict' => true,
+			'page_name_list' => true,
+			'page_name_must_exist' => false,
+			'set_criteria_found' => true
 		],
 		/**
 		 * this parameter restricts the output to articles which use one of the specified images.
 		 * Examples:   imageused=Image:my image|Image:your image
 		 */
 		'imageused' => [
-			'default'				=> null,
-			'open_ref_conflict'		=> true,
-			'page_name_list'		=> true,
-			'page_name_must_exist'	=> true,
-			'set_criteria_found'	=> true
+			'default' => null,
+			'open_ref_conflict' => true,
+			'page_name_list' => true,
+			'page_name_must_exist' => true,
+			'set_criteria_found' => true
 		],
 		 /**
 		  * this parameter restricts the output to images which are used (contained) by one of the specified pages.
 		  * Examples:   imagecontainer=my article|your article
 		  */
 		'imagecontainer' => [
-			'default'				=> null,
-			'open_ref_conflict'		=> false,
-			'page_name_list'		=> true,
-			'page_name_must_exist'	=> true,
-			'set_criteria_found'	=> true
+			'default' => null,
+			'open_ref_conflict' => false,
+			'page_name_list' => true,
+			'page_name_must_exist' => true,
+			'set_criteria_found' => true
 		],
 		/**
 		 * this parameter restricts the output to articles which use the specified template.
 		 * Examples:   uses=Template:my template
 		 */
 		'uses' => [
-			'default'				=> null,
-			'open_ref_conflict'		=> true,
-			'page_name_list'		=> true,
-			'page_name_must_exist'	=> true,
-			'set_criteria_found'	=> true
+			'default' => null,
+			'open_ref_conflict' => true,
+			'page_name_list' => true,
+			'page_name_must_exist' => true,
+			'set_criteria_found' => true
 		],
 		/**
 		 * this parameter restricts the output to articles which do not use the specified template.
 		 * Examples:   notuses=Template:my template
 		 */
 		'notuses' => [
-			'default'				=> null,
-			'open_ref_conflict'		=> true,
-			'page_name_list'		=> true,
-			'page_name_must_exist'	=> true,
-			'set_criteria_found'	=> true
+			'default' => null,
+			'open_ref_conflict' => true,
+			'page_name_list' => true,
+			'page_name_must_exist' => true,
+			'set_criteria_found' => true
 		],
 		/**
 		 * this parameter restricts the output to the template used by the specified page.
 		 */
 		'usedby' => [
-			'default'				=> null,
-			'open_ref_conflict'		=> true,
-			'page_name_list'		=> true,
-			'page_name_must_exist'	=> true,
-			'set_criteria_found'	=> true
+			'default' => null,
+			'open_ref_conflict' => true,
+			'page_name_list' => true,
+			'page_name_must_exist' => true,
+			'set_criteria_found' => true
 		],
 		/**
 		 * allows to specify a username who must be the first editor of the pages we select
 		 */
-		'createdby'	=> [
-			'default'				=> null,
-			'set_criteria_found'	=> true,
-			'open_ref_conflict'		=> true,
-			'preserve_case'			=> true
+		'createdby' => [
+			'default' => null,
+			'set_criteria_found' => true,
+			'open_ref_conflict' => true,
+			'preserve_case' => true
 		],
 		/**
 		 * allows to specify a username who must not be the first editor of the pages we select
 		 */
-		'notcreatedby'	=> [
-			'default'				=> null,
-			'set_criteria_found'	=> true,
-			'open_ref_conflict'		=> true,
-			'preserve_case'			=> true
+		'notcreatedby' => [
+			'default' => null,
+			'set_criteria_found' => true,
+			'open_ref_conflict' => true,
+			'preserve_case' => true
 		],
 		/**
 		 * allows to specify a username who must be among the editors of the pages we select
 		 */
-		'modifiedby'	=> [
-			'default'				=> null,
-			'set_criteria_found'	=> true,
-			'open_ref_conflict'		=> true,
-			'preserve_case'			=> true
+		'modifiedby' => [
+			'default' => null,
+			'set_criteria_found' => true,
+			'open_ref_conflict' => true,
+			'preserve_case' => true
 		],
 		/**
 		 * allows to specify a username who must not be among the editors of the pages we select
 		 */
-		'notmodifiedby'	=> [
-			'default'				=> null,
-			'set_criteria_found'	=> true,
-			'open_ref_conflict'		=> true,
-			'preserve_case'			=> true
+		'notmodifiedby' => [
+			'default' => null,
+			'set_criteria_found' => true,
+			'open_ref_conflict' => true,
+			'preserve_case' => true
 		],
 		/**
 		 * allows to specify a username who must be the last editor of the pages we select
 		 */
 		'lastmodifiedby' => [
-			'default'				=> null,
-			'set_criteria_found'	=> true,
-			'open_ref_conflict'		=> true,
-			'preserve_case'			=> true
+			'default' => null,
+			'set_criteria_found' => true,
+			'open_ref_conflict' => true,
+			'preserve_case' => true
 		],
 		/**
 		 * allows to specify a username who must not be the last editor of the pages we select
 		 */
-		'notlastmodifiedby'	=> [
-			'default'				=> null,
-			'set_criteria_found'	=> true,
-			'open_ref_conflict'		=> true,
-			'preserve_case'			=> true
+		'notlastmodifiedby' => [
+			'default' => null,
+			'set_criteria_found' => true,
+			'open_ref_conflict' => true,
+			'preserve_case' => true
 		],
 		/**
 		 * Mode for list of pages (possibly within a heading, see 'headingmode' param).
@@ -694,8 +688,8 @@ class ParametersData {
 		 * 'userformat' does not produce any html tags unless 'listseparators' are specified
 		 */
 		'mode' => [
-			'default'	=> 'unordered',
-			'values'	=> [
+			'default' => 'unordered',
+			'values' => [
 				'category',
 				'definition',
 				'gallery',
@@ -714,8 +708,8 @@ class ParametersData {
 		 * 'false'	images are shown, categories are assigned to the current document
 		 */
 		'escapelinks' => [
-			'default'	=> true,
-			'boolean'	=> true
+			'default' => true,
+			'boolean' => true
 		],
 		/**
 		 * By default the page containingthe query will not be part of the result set.
@@ -723,8 +717,8 @@ class ParametersData {
 		 * problems which are hard to track down, esp. in combination with contents transclusion.
 		 */
 		'skipthispage' => [
-			'default'	=> true,
-			'boolean'	=> true
+			'default' => true,
+			'boolean' => true
 		],
 		/**
 		 * namespace= Ns1 | Ns2 | ...
@@ -733,7 +727,7 @@ class ParametersData {
 		 * Magic words allowed.
 		 */
 		'namespace' => [
-			'default'	=> null,
+			'default' => null,
 		],
 		/**
 		 * notcategory= Cat1
@@ -743,13 +737,13 @@ class ParametersData {
 		 * @todo define 'notcategory' options (retrieve list of categories from 'categorylinks' table?)
 		 */
 		'notcategory' => [
-			'default'	=> null,
+			'default' => null,
 		],
 		'notcategorymatch' => [
-			'default'	=> null,
+			'default' => null,
 		],
 		'notcategoryregexp' => [
-			'default'	=> null,
+			'default' => null,
 		],
 		/**
 		 * notnamespace= Ns1
@@ -760,50 +754,50 @@ class ParametersData {
 		 * Magic words allowed.
 		 */
 		'notnamespace' => [
-			'default'	=> null,
+			'default' => null,
 		],
 		/**
 		 * title is the exact name of a page; this is useful if you want to use DPL
 		 * just for contents inclusion; mode=userformat is automatically implied with title=
 		 */
 		'title' => [
-			'default'	=> null,
+			'default' => null,
 		],
 		/**
 		 * titlematch is a (SQL-LIKE-expression) pattern
 		 * which restricts the result to pages matching that pattern
 		 */
 		'titlelt' => [
-			'default'				=> null,
-			'db_format'				=> true,
-			'set_criteria_found'	=> true
+			'default' => null,
+			'db_format' => true,
+			'set_criteria_found' => true
 		],
 		'titlegt' => [
-			'default'				=> null,
-			'db_format'				=> true,
-			'set_criteria_found'	=> true
+			'default' => null,
+			'db_format' => true,
+			'set_criteria_found' => true
 		],
 		'scroll' => [
-			'default'	=> false,
-			'boolean'	=> true
+			'default' => false,
+			'boolean' => true
 		],
 		'titlematch' => [
-			'default'	=> null
+			'default' => null
 		],
 		'titleregexp' => [
-			'default'	=> null
+			'default' => null
 		],
 		'userdateformat' => [
-			'default'		=> 'Y-m-d H:i:s',
-			'strip_html'	=> true
+			'default' => 'Y-m-d H:i:s',
+			'strip_html' => true
 		],
 		'updaterules' => [
-			'default'		=> null,
-			'permission'	=> 'dpl_param_update_rules'
+			'default' => null,
+			'permission' => 'dpl_param_update_rules'
 		],
 		'deleterules' => [
-			'default'		=> null,
-			'permission'	=> 'dpl_param_delete_rules'
+			'default' => null,
+			'permission' => 'dpl_param_delete_rules'
 		],
 
 		/**
@@ -811,14 +805,14 @@ class ParametersData {
 		 * which excludes pages matching that pattern from the result
 		 */
 		'nottitlematch' => [
-			'default'	=> null
+			'default' => null
 		],
 		'nottitleregexp' => [
-			'default'	=> null
+			'default' => null
 		],
 		'order' => [
-			'default'	=> 'ascending',
-			'values'	=> [ 'ascending', 'descending', 'asc', 'desc' ]
+			'default' => 'ascending',
+			'values' => [ 'ascending', 'descending', 'asc', 'desc' ]
 		],
 		/**
 		 * we can specify something like "latin1_swedish_ci" for case insensitive sorting
@@ -831,8 +825,8 @@ class ParametersData {
 		 * @todo: add 'ordermethod=category,categoryadd' (for each category CAT, pages ordered by date when page was added to CAT).
 		 */
 		'ordermethod' => [
-			'default'	=> [ 'none' ],
-			'values'	=> [
+			'default' => [ 'none' ],
+			'values' => [
 				'counter',
 				'size',
 				'category',
@@ -854,56 +848,56 @@ class ParametersData {
 		 * - include: include minor edits
 		 */
 		'minoredits' => [
-			'default'			=> null,
-			'values'			=> [ 'include', 'exclude' ],
-			'open_ref_conflict'	=> true
+			'default' => null,
+			'values' => [ 'include', 'exclude' ],
+			'open_ref_conflict' => true
 		],
 		/**
 		 * lastrevisionbefore = select the latest revision which was existent before the specified point in time
 		 */
 		'lastrevisionbefore' => [
-			'default'			=> null,
-			'timestamp'			=> true,
-			'open_ref_conflict'	=> true
+			'default' => null,
+			'timestamp' => true,
+			'open_ref_conflict' => true
 		],
 		/**
 		 * allrevisionsbefore = select the revisions which were created before the specified point in time
 		 */
 		'allrevisionsbefore' => [
-			'default'			=> null,
-			'timestamp'			=> true,
-			'open_ref_conflict'	=> true
+			'default' => null,
+			'timestamp' => true,
+			'open_ref_conflict' => true
 		],
 		/**
 		 * firstrevisionsince = select the first revision which was created after the specified point in time
 		 */
 		'firstrevisionsince' => [
-			'default'			=> null,
-			'timestamp'			=> true,
-			'open_ref_conflict'	=> true
+			'default' => null,
+			'timestamp' => true,
+			'open_ref_conflict' => true
 		],
 		/**
 		 * allrevisionssince = select the latest revisions which were created after the specified point in time
 		 */
 		'allrevisionssince' => [
-			'default'			=> null,
-			'timestamp'			=> true,
-			'open_ref_conflict'	=> true
+			'default' => null,
+			'timestamp' => true,
+			'open_ref_conflict' => true
 		],
 		/**
 		 * Minimum/Maximum number of revisions required
 		 */
 		'minrevisions' => [
-			'default'	=> null,
-			'integer'	=> true
+			'default' => null,
+			'integer' => true
 		],
 		'maxrevisions' => [
-			'default'	=> null,
-			'integer'	=> true
+			'default' => null,
+			'integer' => true
 		],
 		'suppresserrors' => [
-			'default'	=> false,
-			'boolean'	=> true
+			'default' => false,
+			'boolean' => true
 		],
 		/**
 		 * noresultsheader / footer is some wiki text which will be output (instead of a warning message)
@@ -911,28 +905,28 @@ class ParametersData {
 		 * the warning about empty result set.
 		 */
 		'noresultsheader' => [
-			'default'		=> null,
-			'strip_html'	=> true,
-			'preserve_case'	=> true
+			'default' => null,
+			'strip_html' => true,
+			'preserve_case' => true
 		],
 		'noresultsfooter' => [
-			'default'		=> null,
-			'strip_html'	=> true,
-			'preserve_case'	=> true
+			'default' => null,
+			'strip_html' => true,
+			'preserve_case' => true
 		],
 		/**
 		 * oneresultsheader / footer is some wiki text which will be output
 		 * if the result set contains exactly one entry.
 		 */
 		'oneresultheader' => [
-			'default'		=> null,
-			'strip_html'	=> true,
-			'preserve_case'	=> true
+			'default' => null,
+			'strip_html' => true,
+			'preserve_case' => true
 		],
 		'oneresultfooter' => [
-			'default'		=> null,
-			'strip_html'	=> true,
-			'preserve_case'	=> true
+			'default' => null,
+			'strip_html' => true,
+			'preserve_case' => true
 		],
 		/**
 		 * openreferences =...
@@ -940,8 +934,8 @@ class ParametersData {
 		 * - yes: includes pages which do not exist -- this conflicts with some other options
 		 */
 		'openreferences' => [
-			'default'	=> false,
-			'boolean'	=> true
+			'default' => false,
+			'boolean' => true
 		],
 		/**
 		 * redirects =...
@@ -950,8 +944,8 @@ class ParametersData {
 		 * - only: lists only redirect pages in lists (page_is_redirect = 1 only)
 		 */
 		'redirects' => [
-			'default'	=> 'exclude',
-			'values'	=> [ 'include', 'exclude', 'only' ]
+			'default' => 'exclude',
+			'values' => [ 'include', 'exclude', 'only' ]
 		],
 		/**
 		 * stablepages =...
@@ -960,8 +954,8 @@ class ParametersData {
 		 * - only: lists only stable pages in lists
 		 */
 		'stablepages' => [
-			'default'	=> null,
-			'values'	=> [ 'exclude', 'only' ]
+			'default' => null,
+			'values' => [ 'exclude', 'only' ]
 		],
 		/**
 		 * qualitypages =...
@@ -970,8 +964,8 @@ class ParametersData {
 		 * - only: lists only quality pages in lists
 		 */
 		'qualitypages' => [
-			'default'	=> null,
-			'values'	=> [ 'exclude', 'only' ]
+			'default' => null,
+			'values' => [ 'exclude', 'only' ]
 		],
 		/**
 		 * resultsheader / footer is some wiki text which will be output before / after the result list
@@ -979,14 +973,14 @@ class ParametersData {
 		 * used if there are at least TWO results
 		 */
 		'resultsheader' => [
-			'default'		=> null,
-			'strip_html'	=> true,
-			'preserve_case'	=> true
+			'default' => null,
+			'strip_html' => true,
+			'preserve_case' => true
 		],
 		'resultsfooter' => [
-			'default'		=> null,
-			'strip_html'	=> true,
-			'preserve_case'	=> true
+			'default' => null,
+			'strip_html' => true,
+			'preserve_case' => true
 		],
 		/**
 		 * reset=..
@@ -999,7 +993,7 @@ class ParametersData {
 		 */
 		'reset' => [
 			'default' => [],
-			'values'	=> [
+			'values' => [
 				'categories',
 				'templates',
 				'links',
@@ -1021,8 +1015,8 @@ class ParametersData {
 		 * Note: a "row" is a group of lines for which the heading tags defined in listseparators/format will be repeated
 		 */
 		'rows' => [
-			'default'	=> 1,
-			'integer'	=> true
+			'default' => 1,
+			'integer' => true
 		],
 
 		/**
@@ -1030,16 +1024,16 @@ class ParametersData {
 		 * Note: a "row" is a group of lines for which the heading tags defined in listeseparators will be repeated
 		 */
 		'rowsize' => [
-			'default'	=> 0,
-			'integer'	=> true
+			'default' => 0,
+			'integer' => true
 		],
 
 		/**
 		 * The HTML attribute tags(class, cellspacing) used for columns and rows in MediaWiki table markup.
 		 */
 		'rowcolformat' => [
-			'default'		=> null,
-			'strip_html'	=> true
+			'default' => null,
+			'strip_html' => true
 		],
 		/**
 		 * secseparators  is a sequence of pairs of tags used to separate sections (see "includepage=name1, name2, ..")
@@ -1062,48 +1056,48 @@ class ParametersData {
 		 * dominant column
 		 */
 		'dominantsection' => [
-			'default'	=> 0,
-			'integer'	=> true
+			'default' => 0,
+			'integer' => true
 		],
 		/**
 		 * showcurid creates a stable link to the current revision of a page
 		 */
 		'showcurid' => [
-			'default'			=> false,
-			'boolean'			=> true,
-			'open_ref_conflict'	=> true
+			'default' => false,
+			'boolean' => true,
+			'open_ref_conflict' => true
 		],
 		/**
 		 * shownamespace decides whether to show the namespace prefix or not
 		 */
 		'shownamespace' => [
-			'default'	=> true,
-			'boolean'	=> true
+			'default' => true,
+			'boolean' => true
 		],
 		/**
 		 * replaceintitle applies a regex replacement to %TITLE%
 		 */
 		'replaceintitle' => [
-			'default'	=> null
+			'default' => null
 		],
 		/**
 		 * table is a short hand for combined values of listseparators, colseparators and mulicolseparators
 		 */
 		'table' => [
-			'default'	=> null
+			'default' => null
 		],
 		/**
 		 * tablerow allows to define individual formats for table columns
 		 */
 		'tablerow' => [
-			'default'	=> []
+			'default' => []
 		],
 		/**
 		 * The number (starting with 1) of the column to be used for sorting
 		 */
 		'tablesortcol' => [
-			'default'	=> null,
-			'integer'	=> true
+			'default' => null,
+			'integer' => true
 		],
 		/**
 		 * The sorting algorithm for table columns when 'tablesortcol'
@@ -1112,8 +1106,8 @@ class ParametersData {
 		 * - natural: Use PHP natsort()
 		 */
 		'tablesortmethod' => [
-			'default'	=> null,
-			'values'	=> ['standard', 'natural']
+			'default' => null,
+			'values' => [ 'standard', 'natural' ]
 		],
 		/**
 		 * Max # characters of page title to display.
@@ -1121,47 +1115,45 @@ class ParametersData {
 		 * Not applicable to mode=category.
 		 */
 		'titlemaxlength' => [
-			'default'	=> null,
-			'integer'	=> true
+			'default' => null,
+			'integer' => true
 		]
 	];
 
-	/**
-	 * Main Constructor
-	 *
-	 * @access	public
-	 * @return	void
-	 */
 	public function __construct() {
 		$this->setRichness( Config::getSetting( 'functionalRichness' ) );
 
-		if ( \DynamicPageListHooks::isLikeIntersection() ) {
+		if ( DynamicPageListHooks::isLikeIntersection() ) {
 			$this->data['ordermethod'] = [
-				'default'	=> 'categoryadd',
-				'values'	=> [
+				'default' => 'categoryadd',
+				'values' => [
 					'categoryadd',
 					'lastedit',
 					'none'
 				]
 			];
+
 			$this->data['order'] = [
-				'default'	=> 'descending',
-				'values'	=> [
+				'default' => 'descending',
+				'values' => [
 					'ascending',
 					'descending'
 				]
 			];
+
 			$this->data['mode'] = [
-				'default'	=> 'unordered',
-				'values'	=> [
+				'default' => 'unordered',
+				'values' => [
 					'none',
 					'ordered',
 					'unordered'
 				]
 			];
+
 			$this->data['userdateformat'] = [
 				'default' => 'Y-m-d: '
 			];
+
 			$this->data['allowcachedresults']['default'] = 'true';
 		}
 	}
@@ -1169,9 +1161,8 @@ public function __construct() {
 	/**
 	 * Return if the parameter exists.
 	 *
-	 * @access	public
-	 * @param	string	Parameter name.
-	 * @return	boolean	Exists
+	 * @param string $parameter
+	 * @return bool
 	 */
 	public function exists( $parameter ) {
 		return array_key_exists( $parameter, $this->data );
@@ -1180,9 +1171,8 @@ public function exists( $parameter ) {
 	/**
 	 * Return data for the supplied parameter.
 	 *
-	 * @access	public
-	 * @param	string	Parameter name.
-	 * @return	mixed	Parameter array or false if it does not exist.
+	 * @param string $parameter
+	 * @return mixed
 	 */
 	public function getData( $parameter ) {
 		if ( array_key_exists( $parameter, $this->data ) ) {
@@ -1195,9 +1185,7 @@ public function getData( $parameter ) {
 	/**
 	 * Sets the current parameter richness.
 	 *
-	 * @access	public
-	 * @param	integer	Integer level.
-	 * @return	void
+	 * @param int $level
 	 */
 	public function setRichness( $level ) {
 		$this->parameterRichness = intval( $level );
@@ -1206,8 +1194,7 @@ public function setRichness( $level ) {
 	/**
 	 * Returns the current parameter richness.
 	 *
-	 * @access	public
-	 * @return	integer
+	 * @return int
 	 */
 	public function getRichness() {
 		return $this->parameterRichness;
@@ -1216,27 +1203,27 @@ public function getRichness() {
 	/**
 	 * Tests if the function is valid for the current functional richness level.
 	 *
-	 * @access	public
-	 * @param	string	Function to test.
-	 * @return	boolean	Valid for this functional richness level.
+	 * @param string $function
+	 * @return bool
 	 */
 	public function testRichness( $function ) {
 		$valid = false;
+
 		for ( $i = 0; $i <= $this->getRichness(); $i++ ) {
 			if ( in_array( $function, self::$parametersForRichnessLevel[$i] ) ) {
 				$valid = true;
 				break;
 			}
 		}
+
 		return $valid;
 	}
 
 	/**
 	 * Returns all parameters for the current richness level or limited to the optional maximum richness.
 	 *
-	 * @access	public
-	 * @param	integer	[Optional] Maximum richness level
-	 * @return	array	The functional richness parameters list.
+	 * @param int|null $level
+	 * @return array
 	 */
 	public function getParametersForRichness( $level = null ) {
 		if ( $level === null ) {
@@ -1244,9 +1231,11 @@ public function getParametersForRichness( $level = null ) {
 		}
 
 		$parameters = [];
+
 		for ( $i = 0; $i <= $level; $i++ ) {
 			$parameters = array_merge( $parameters, self::$parametersForRichnessLevel[$i] );
 		}
+
 		sort( $parameters );
 
 		return $parameters;
@@ -1255,136 +1244,144 @@ public function getParametersForRichness( $level = null ) {
 	/**
 	 * Return the default value for the parameter.
 	 *
-	 * @access	public
-	 * @param	string	Parameter Name
-	 * @return	mixed
+	 * @param string $parameter
+	 * @return mixed
 	 */
 	public function getDefault( $parameter ) {
 		if ( array_key_exists( $parameter, $this->data ) ) {
 			if ( array_key_exists( 'default', $this->data[$parameter] ) ) {
 				return (bool)$this->data[$parameter]['default'];
 			}
+
 			return null;
 		}
+
 		throw new MWException( __METHOD__ . ": Attempted to load a parameter that does not exist." );
 	}
 
 	/**
 	 * Return the acceptable values for the parameter.
 	 *
-	 * @access	public
-	 * @param	string	Parameter Name
-	 * @return	mixed	Array of allowed values or false that the parameter allows any.
+	 * @param string $parameter
+	 * @return mixed
 	 */
 	public function getValues( $parameter ) {
 		if ( array_key_exists( $parameter, $this->data ) ) {
 			if ( array_key_exists( 'values', $this->data[$parameter] ) ) {
 				return (bool)$this->data[$parameter]['values'];
 			}
+
 			return false;
 		}
+
 		throw new MWException( __METHOD__ . ": Attempted to load a parameter that does not exist." );
 	}
 
 	/**
 	 * Does the parameter set that criteria for selection was found?
 	 *
-	 * @access	public
-	 * @param	string	Parameter Name
-	 * @return	bool
+	 * @param string $parameter
+	 * @return bool
 	 */
 	public function setsCriteriaFound( $parameter ) {
 		if ( array_key_exists( $parameter, $this->data ) ) {
 			if ( array_key_exists( 'set_criteria_found', $this->data[$parameter] ) ) {
 				return (bool)$this->data[$parameter]['set_criteria_found'];
 			}
+
 			return false;
 		}
+
 		throw new MWException( __METHOD__ . ": Attempted to load a parameter that does not exist." );
 	}
 
 	/**
 	 * Does the parameter cause an open reference conflict?
 	 *
-	 * @access	public
-	 * @param	string	Parameter Name
-	 * @return	bool
+	 * @param string $parameter
+	 * @return bool
 	 */
 	public function isOpenReferenceConflict( $parameter ) {
 		if ( array_key_exists( $parameter, $this->data ) ) {
 			if ( array_key_exists( 'open_ref_conflict', $this->data[$parameter] ) ) {
 				return (bool)$this->data[$parameter]['open_ref_conflict'];
 			}
+
 			return false;
 		}
+
 		throw new MWException( __METHOD__ . ": Attempted to load a parameter that does not exist." );
 	}
 
 	/**
 	 * Should this parameter preserve the case of the user supplied input?
 	 *
-	 * @access	public
-	 * @param	string	Parameter Name
-	 * @return	bool
+	 * @param string $parameter
+	 * @return bool
 	 */
 	public function shouldPreserveCase( $parameter ) {
 		if ( array_key_exists( $parameter, $this->data ) ) {
 			if ( array_key_exists( 'preserve_case', $this->data[$parameter] ) ) {
 				return (bool)$this->data[$parameter]['preserve_case'];
 			}
+
 			return false;
 		}
+
 		throw new MWException( __METHOD__ . ": Attempted to load a parameter that does not exist." );
 	}
 
 	/**
 	 * Does this parameter take a list of page names?
 	 *
-	 * @access	public
-	 * @param	string	Parameter Name
-	 * @return	bool
+	 * @param string $parameter
+	 * @return bool
 	 */
 	public function isPageNameList( $parameter ) {
 		if ( array_key_exists( $parameter, $this->data ) ) {
 			if ( array_key_exists( 'page_name_list', $this->data[$parameter] ) ) {
 				return (bool)$this->data[$parameter]['page_name_list'];
 			}
+
 			return false;
 		}
+
 		throw new MWException( __METHOD__ . ": Attempted to load a parameter that does not exist." );
 	}
 
 	/**
 	 * Is the parameter supposed to be parsed as a boolean?
 	 *
-	 * @access	public
-	 * @param	string	Parameter Name
-	 * @return	bool
+	 * @param string $parameter
+	 * @return bool
 	 */
 	public function isBoolean( $parameter ) {
 		if ( array_key_exists( $parameter, $this->data ) ) {
 			if ( array_key_exists( 'boolean', $this->data[$parameter] ) ) {
 				return (bool)$this->data[$parameter]['boolean'];
 			}
+
 			return false;
 		}
+
 		throw new MWException( __METHOD__ . ": Attempted to load a parameter that does not exist." );
 	}
 
 	/**
 	 * Is the parameter supposed to be parsed as a Mediawiki timestamp?
 	 *
-	 * @access	public
-	 * @param	string	Parameter Name
-	 * @return	bool
+	 * @param string $parameter
+	 * @return bool
 	 */
 	public function isTimestamp( $parameter ) {
 		if ( array_key_exists( $parameter, $this->data ) ) {
 			if ( array_key_exists( 'timestamp', $this->data[$parameter] ) ) {
 				return (bool)$this->data[$parameter]['timestamp'];
 			}
+
 			return false;
 		}
+
 		throw new MWException( __METHOD__ . ": Attempted to load a parameter that does not exist." );
 	}
 }
diff --git a/includes/Parse.php b/includes/Parse.php
index 97f09f49..f9de2fbe 100644
--- a/includes/Parse.php
+++ b/includes/Parse.php
@@ -1,51 +1,44 @@
 <?php
-/**
- * DynamicPageList3
- * DPL Parse Class
- *
- * @author		IlyaHaykinson, Unendlich, Dangerville, Algorithmix, Theaitetos, Alexia E. Smith, Universal Omega
- * @license		GPL-2.0-or-later
- * @package		DynamicPageList3
- *
- */
+
 namespace DPL;
 
+use ActorMigration;
 use DPL\Heading\Heading;
 use DPL\Lister\Lister;
+use ExtVariables;
+use MediaWiki\MediaWikiServices;
+use MWException;
+use Parser;
+use Title;
+use WebRequest;
+use Wikimedia\Rdbms\IDatabase;
 
 class Parse {
 	/**
 	 * Mediawiki Database Object
 	 *
-	 * @var object
+	 * @var IDatabase
 	 */
 	private $DB = null;
 
 	/**
-	 * Mediawiki Parser Object
-	 *
-	 * @var object
-	 */
-	private $parser = null;
-
-	/**
-	 * \DPL\Parameters Object
+	 * Parameters Object
 	 *
-	 * @var object
+	 * @var Parameters
 	 */
 	private $parameters = null;
 
 	/**
-	 * \DPL\Logger Object
+	 * Logger Object
 	 *
-	 * @var object
+	 * @var Logger
 	 */
 	private $logger = null;
 
 	/**
 	 * Array of prequoted table names.
 	 *
-	 * @var array
+	 * @var string[]
 	 */
 	private $tableNames = [];
 
@@ -84,6 +77,13 @@ class Parse {
 	 */
 	private $replacementVariables = [];
 
+	/**
+	 * WebRequest object
+	 *
+	 * @var WebRequest
+	 */
+	private $request;
+
 	/**
 	 * Array of possible URL arguments.
 	 *
@@ -97,50 +97,46 @@ class Parse {
 		'DPL_toTitle'
 	];
 
-	/**
-	 * Main Constructor
-	 *
-	 * @access	public
-	 * @return	void
-	 */
 	public function __construct() {
 		global $wgRequest;
 
-		$this->DB			= wfGetDB( DB_REPLICA, 'dpl' );
-		$this->parameters	= new Parameters();
-		$this->logger		= new Logger( $this->parameters->getData( 'debug' )['default'] );
-		$this->tableNames	= Query::getTableNames();
-		$this->wgRequest	= $wgRequest;
+		$this->DB = wfGetDB( DB_REPLICA, 'dpl' );
+		$this->parameters = new Parameters();
+		$this->logger = new Logger();
+		$this->tableNames = Query::getTableNames();
+		$this->request = $wgRequest;
 	}
 
 	/**
 	 * The real callback function for converting the input text to wiki text output
 	 *
-	 * @access	public
-	 * @param	string	Raw User Input
-	 * @param	object	Mediawiki Parser object.
-	 * @param	array	End Reset Booleans
-	 * @param	array	End Eliminate Booleans
-	 * @param	boolean	[Optional] Called as a parser tag
-	 * @return	string	Wiki/HTML Output
+	 * @param string $input
+	 * @param Parser $parser
+	 * @param array &$reset
+	 * @param array	&$eliminate
+	 * @param bool $isParserTag
+	 * @return string
+	 *
+	 * @suppress PhanUndeclaredProperty Use of Parser::mTemplatePath
 	 */
-	public function parse( $input, \Parser $parser, &$reset, &$eliminate, $isParserTag = false ) {
+	public function parse( $input, Parser $parser, &$reset, &$eliminate, $isParserTag = false ) {
 		$dplStartTime = microtime( true );
-		$this->parser = $parser;
 
-		//Reset headings when being ran more than once in the same page load.
+		// Reset headings when being ran more than once in the same page load.
 		Article::resetHeadings();
 
-		//Check that we are not in an infinite transclusion loop
-		if ( isset( $this->parser->mTemplatePath[$this->parser->mTitle->getPrefixedText()] ) ) {
-			$this->logger->addMessage( \DynamicPageListHooks::WARN_TRANSCLUSIONLOOP, $this->parser->mTitle->getPrefixedText() );
+		// Check that we are not in an infinite transclusion loop
+		if ( isset( $parser->mTemplatePath[$parser->getTitle()->getPrefixedText()] ) ) {
+			$this->logger->addMessage( DynamicPageListHooks::WARN_TRANSCLUSIONLOOP, $parser->getTitle()->getPrefixedText() );
+
 			return $this->getFullOutput();
 		}
 
-		//Check if DPL shall only be executed from protected pages.
-		if ( Config::getSetting( 'runFromProtectedPagesOnly' ) === true && !$this->parser->mTitle->isProtected( 'edit' ) ) {
-			//Ideally we would like to allow using a DPL query if the query istelf is coded on a template page which is protected. Then there would be no need for the article to be protected.  However, how can one find out from which wiki source an extension has been invoked???
-			$this->logger->addMessage( \DynamicPageListHooks::FATAL_NOTPROTECTED, $this->parser->mTitle->getPrefixedText() );
+		// Check if DPL shall only be executed from protected pages.
+		if ( Config::getSetting( 'runFromProtectedPagesOnly' ) === true && !$parser->getTitle()->isProtected( 'edit' ) ) {
+			// Ideally we would like to allow using a DPL query if the query istelf is coded on a template page which is protected. Then there would be no need for the article to be protected. However, how can one find out from which wiki source an extension has been invoked???
+			$this->logger->addMessage( DynamicPageListHooks::FATAL_NOTPROTECTED, $parser->getTitle()->getPrefixedText() );
+
 			return $this->getFullOutput();
 		}
 
@@ -152,10 +148,11 @@ public function parse( $input, \Parser $parser, &$reset, &$eliminate, $isParserT
 				$this->urlArguments[] = 'DPL_arg' . $i;
 			}
 		}
+
 		$input = $this->resolveUrlArguments( $input, $this->urlArguments );
-		$this->getUrlArgs( $this->parser );
+		$this->getUrlArgs( $parser );
 
-		$this->parameters->setParameter( 'offset', $this->wgRequest->getInt( 'DPL_offset', $this->parameters->getData( 'offset' )['default'] ) );
+		$this->parameters->setParameter( 'offset', $this->request->getInt( 'DPL_offset', $this->parameters->getData( 'offset' )['default'] ) );
 		$offset = $this->parameters->getParameter( 'offset' );
 
 		/***************************************/
@@ -163,19 +160,21 @@ public function parse( $input, \Parser $parser, &$reset, &$eliminate, $isParserT
 		/***************************************/
 		$cleanParameters = $this->prepareUserInput( $input );
 		if ( !is_array( $cleanParameters ) ) {
-			//Short circuit for dumb things.
-			$this->logger->addMessage( \DynamicPageListHooks::FATAL_NOSELECTION );
+			// Short circuit for dumb things.
+			$this->logger->addMessage( DynamicPageListHooks::FATAL_NOSELECTION );
+
 			return $this->getFullOutput();
 		}
+
 		$cleanParameters = Parameters::sortByPriority( $cleanParameters );
 		$this->parameters->setParameter( 'includeuncat', false ); // to check if pseudo-category of Uncategorized pages is included
 
 		foreach ( $cleanParameters as $parameter => $option ) {
 			foreach ( $option as $_option ) {
-				//Parameter functions return true or false.  The full parameter data will be passed into the Query object later.
+				// Parameter functions return true or false. The full parameter data will be passed into the Query object later.
 				if ( $this->parameters->$parameter( $_option ) === false ) {
-					//Do not build this into the output just yet.  It will be collected at the end.
-					$this->logger->addMessage( \DynamicPageListHooks::WARN_WRONGPARAM, $parameter, $_option );
+					// Do not build this into the output just yet. It will be collected at the end.
+					$this->logger->addMessage( DynamicPageListHooks::WARN_WRONGPARAM, $parameter, $_option );
 				}
 			}
 		}
@@ -184,15 +183,16 @@ public function parse( $input, \Parser $parser, &$reset, &$eliminate, $isParserT
 		/* Execute and Exit Only */
 		/*************************/
 		if ( $this->parameters->getParameter( 'execandexit' ) !== null ) {
-			//The keyword "geturlargs" is used to return the Url arguments and do nothing else.
+			// The keyword "geturlargs" is used to return the Url arguments and do nothing else.
 			if ( $this->parameters->getParameter( 'execandexit' ) == 'geturlargs' ) {
-				return;
+				return '';
 			}
-			//In all other cases we return the value of the argument which may contain parser function calls.
+
+			// In all other cases we return the value of the argument which may contain parser function calls.
 			return $this->parameters->getParameter( 'execandexit' );
 		}
 
-		//Construct internal keys for TableRow according to the structure of "include".  This will be needed in the output phase.
+		// Construct internal keys for TableRow according to the structure of "include". This will be needed in the output phase.
 		$secLabels = $this->parameters->getParameter( 'seclabels' );
 		if ( is_array( $secLabels ) && !empty( $this->parameters->getParameter( 'seclabels' ) ) ) {
 			$this->parameters->setParameter( 'tablerow', $this->updateTableRowKeys( $this->parameters->getParameter( 'tablerow' ), $this->parameters->getParameter( 'seclabels' ) ) );
@@ -203,7 +203,7 @@ public function parse( $input, \Parser $parser, &$reset, &$eliminate, $isParserT
 		/****************/
 		$errors = $this->doQueryErrorChecks();
 		if ( $errors === false ) {
-			//WHAT HAS HAPPENED OH NOOOOOOOOOOOOO.
+			// WHAT HAS HAPPENED OH NOOOOOOOOOOOOO.
 			return $this->getFullOutput();
 		}
 
@@ -216,48 +216,50 @@ public function parse( $input, \Parser $parser, &$reset, &$eliminate, $isParserT
 		/* Query */
 		/*********/
 		try {
-			$this->query = new Query( $this->parameters );
-			$result = $this->query->buildAndSelect( $calcRows );
+			$actorMigration = ActorMigration::newMigration();
+			$commentStore = MediaWikiServices::getInstance()->getCommentStore();
+			$query = new Query( $this->parameters, $actorMigration, $commentStore );
+			$result = $query->buildAndSelect( $calcRows );
 		} catch ( MWException $e ) {
-			$this->logger->addMessage( \DynamicPageListHooks::FATAL_SQLBUILDERROR, $e->getMessage() );
+			$this->logger->addMessage( DynamicPageListHooks::FATAL_SQLBUILDERROR, $e->getMessage() );
 			return $this->getFullOutput();
 		}
 
 		$numRows = $this->DB->numRows( $result );
-		$articles = $this->processQueryResults( $result );
+		$articles = $this->processQueryResults( $result, $parser );
 
 		global $wgDebugDumpSql;
-		if ( \DynamicPageListHooks::getDebugLevel() >= 4 && $wgDebugDumpSql ) {
-			$this->addOutput( $this->query->getSqlQuery() . "\n" );
+		if ( DynamicPageListHooks::getDebugLevel() >= 4 && $wgDebugDumpSql ) {
+			$this->addOutput( $query->getSqlQuery() . "\n" );
 		}
 
 		$this->addOutput( '{{Extension DPL}}' );
 
-		//Preset these to defaults.
-		$this->setVariable( 'TOTALPAGES', 0 );
-		$this->setVariable( 'PAGES', 0 );
-		$this->setVariable( 'VERSION', DPL_VERSION );
+		// Preset these to defaults.
+		$this->setVariable( 'TOTALPAGES', '0' );
+		$this->setVariable( 'PAGES', '0' );
+		$this->setVariable( 'VERSION', DynamicPageListHooks::getVersion() );
 
 		/*********************/
 		/* Handle No Results */
 		/*********************/
 		if ( $numRows <= 0 || empty( $articles ) ) {
-			//Shortcut out since there is no processing to do.
+			// Shortcut out since there is no processing to do.
 			$this->DB->freeResult( $result );
 			return $this->getFullOutput( 0, false );
 		}
 
 		$foundRows = null;
 		if ( $calcRows ) {
-			$foundRows = $this->query->getFoundRows();
+			$foundRows = $query->getFoundRows();
 		}
 
-		//Backward scrolling: If the user specified only titlelt with descending reverse the output order.
+		// Backward scrolling: If the user specified only titlelt with descending reverse the output order.
 		if ( $this->parameters->getParameter( 'titlelt' ) && !$this->parameters->getParameter( 'titlegt' ) && $this->parameters->getParameter( 'order' ) == 'descending' ) {
 			$articles = array_reverse( $articles );
 		}
 
-		//Special sort for card suits (Bridge)
+		// Special sort for card suits (Bridge)
 		if ( $this->parameters->getParameter( 'ordersuitsymbols' ) ) {
 			$articles = $this->cardSuitSort( $articles );
 		}
@@ -265,7 +267,7 @@ public function parse( $input, \Parser $parser, &$reset, &$eliminate, $isParserT
 		/*******************/
 		/* Generate Output */
 		/*******************/
-		$lister = Lister::newFromStyle( $this->parameters->getParameter( 'mode' ), $this->parameters, $this->parser );
+		$lister = Lister::newFromStyle( $this->parameters->getParameter( 'mode' ), $this->parameters, $parser );
 		$heading = Heading::newFromStyle( $this->parameters->getParameter( 'headingmode' ), $this->parameters );
 		if ( $heading !== null ) {
 			$this->addOutput( $heading->format( $articles, $lister ) );
@@ -273,30 +275,37 @@ public function parse( $input, \Parser $parser, &$reset, &$eliminate, $isParserT
 			$this->addOutput( $lister->format( $articles ) );
 		}
 
-		//$this->addOutput($lister->format($articles));
+		// $this->addOutput($lister->format($articles));
 		if ( $foundRows === null ) {
-			$foundRows = $lister->getRowCount(); //Get row count after calling format() otherwise the count will be inaccurate.
+			$foundRows = $lister->getRowCount(); // Get row count after calling format() otherwise the count will be inaccurate.
 		}
 
 		/*******************************/
 		/* Replacement Variables       */
 		/*******************************/
-		$this->setVariable( 'TOTALPAGES', $foundRows ); //Guaranteed to be an accurate count if SQL_CALC_FOUND_ROWS was used.  Otherwise only accurate if results are less than the SQL LIMIT.
-		$this->setVariable( 'PAGES', $lister->getRowCount() ); //This could be different than TOTALPAGES.  PAGES represents the total results within the constraints of SQL LIMIT.
+		$this->setVariable( 'TOTALPAGES', (string)$foundRows ); // Guaranteed to be an accurate count if SQL_CALC_FOUND_ROWS was used. Otherwise only accurate if results are less than the SQL LIMIT.
+		$this->setVariable( 'PAGES', $lister->getRowCount() ); // This could be different than TOTALPAGES. PAGES represents the total results within the constraints of SQL LIMIT.
 
 		//Replace %DPLTIME% by execution time and timestamp in header and footer
-		$nowTimeStamp   = date( 'Y/m/d H:i:s' );
+		$nowTimeStamp = date( 'Y/m/d H:i:s' );
 		$dplElapsedTime = sprintf( '%.3f sec.', microtime( true ) - $dplStartTime );
 		$dplTime = "{$dplElapsedTime} ({$nowTimeStamp})";
 		$this->setVariable( 'DPLTIME', $dplTime );
 
-		//Replace %LASTTITLE% / %LASTNAMESPACE% by the last title found in header and footer
-		if ( ( $n = count( $articles ) ) > 0 ) {
+		$firstNamespaceFound = '';
+		$firstTitleFound = '';
+		$lastNamespaceFound = '';
+		$lastTitleFound = '';
+
+		// Replace %LASTTITLE% / %LASTNAMESPACE% by the last title found in header and footer
+		$n = count( $articles );
+		if ( $n > 0 ) {
 			$firstNamespaceFound = str_replace( ' ', '_', $articles[0]->mTitle->getNamespace() );
-			$firstTitleFound     = str_replace( ' ', '_', $articles[0]->mTitle->getText() );
-			$lastNamespaceFound  = str_replace( ' ', '_', $articles[$n - 1]->mTitle->getNamespace() );
-			$lastTitleFound      = str_replace( ' ', '_', $articles[$n - 1]->mTitle->getText() );
+			$firstTitleFound = str_replace( ' ', '_', $articles[0]->mTitle->getText() );
+			$lastNamespaceFound = str_replace( ' ', '_', $articles[$n - 1]->mTitle->getNamespace() );
+			$lastTitleFound = str_replace( ' ', '_', $articles[$n - 1]->mTitle->getText() );
 		}
+
 		$this->setVariable( 'FIRSTNAMESPACE', $firstNamespaceFound );
 		$this->setVariable( 'FIRSTTITLE', $firstTitleFound );
 		$this->setVariable( 'LASTNAMESPACE', $lastNamespaceFound );
@@ -307,27 +316,28 @@ public function parse( $input, \Parser $parser, &$reset, &$eliminate, $isParserT
 		/* Scroll Variables            */
 		/*******************************/
 		$scrollVariables = [
-			'DPL_firstNamespace'	=> $firstNamespaceFound,
-			'DPL_firstTitle'		=> $firstTitleFound,
-			'DPL_lastNamespace'		=> $lastNamespaceFound,
-			'DPL_lastTitle'			=> $lastTitleFound,
-			'DPL_scrollDir'			=> $this->parameters->getParameter( 'scrolldir' ),
-			'DPL_time'				=> $dplTime,
-			'DPL_count'				=> $this->parameters->getParameter( 'count' ),
-			'DPL_totalPages'		=> $foundRows,
-			'DPL_pages'				=> $lister->getRowCount()
+			'DPL_firstNamespace' => $firstNamespaceFound,
+			'DPL_firstTitle' => $firstTitleFound,
+			'DPL_lastNamespace' => $lastNamespaceFound,
+			'DPL_lastTitle' => $lastTitleFound,
+			'DPL_scrollDir' => $this->parameters->getParameter( 'scrolldir' ),
+			'DPL_time' => $dplTime,
+			'DPL_count' => $this->parameters->getParameter( 'count' ),
+			'DPL_totalPages' => $foundRows,
+			'DPL_pages' => $lister->getRowCount()
 		];
-		$this->defineScrollVariables( $scrollVariables );
+
+		$this->defineScrollVariables( $scrollVariables, $parser );
 
 		if ( $this->parameters->getParameter( 'allowcachedresults' ) || Config::getSetting( 'alwaysCacheResults' ) ) {
-			$this->parser->getOutput()->updateCacheExpiry( $this->parameters->getParameter( 'cacheperiod' ) ?? 3600 );
+			$parser->getOutput()->updateCacheExpiry( $this->parameters->getParameter( 'cacheperiod' ) ?? 3600 );
 		} else {
-			$this->parser->getOutput()->updateCacheExpiry( 0 );
+			$parser->getOutput()->updateCacheExpiry( 0 );
 		}
 
 		$finalOutput = $this->getFullOutput( $foundRows, false );
 
-		$this->triggerEndResets( $finalOutput, $reset, $eliminate, $isParserTag );
+		$this->triggerEndResets( $finalOutput, $reset, $eliminate, $isParserTag, $parser );
 
 		return $finalOutput;
 	}
@@ -335,29 +345,29 @@ public function parse( $input, \Parser $parser, &$reset, &$eliminate, $isParserT
 	/**
 	 * Process Query Results
 	 *
-	 * @private
-	 * @param	object	Mediawiki Result Object
-	 * @return	array	Array of Article objects.
+	 * @param $result
+	 * @param Parser $parser
+	 * @return array
 	 */
-	private function processQueryResults( $result ) {
+	private function processQueryResults( $result, Parser $parser ) {
 		/*******************************/
 		/* Random Count Pick Generator */
 		/*******************************/
 		$randomCount = $this->parameters->getParameter( 'randomcount' );
 		if ( $randomCount > 0 ) {
 			$nResults = $this->DB->numRows( $result );
-			//mt_srand() seeding was removed due to PHP 5.2.1 and above no longer generating the same sequence for the same seed.
+			// mt_srand() seeding was removed due to PHP 5.2.1 and above no longer generating the same sequence for the same seed.
 			//Constrain the total amount of random results to not be greater than the total results.
 			if ( $randomCount > $nResults ) {
 				$randomCount = $nResults;
 			}
 
-			//This is 50% to 150% faster than the old while (true) version that could keep rechecking the same random key over and over again.
-			//Generate pick numbers for results.
+			// This is 50% to 150% faster than the old while (true) version that could keep rechecking the same random key over and over again.
+			// Generate pick numbers for results.
 			$pick = range( 1, $nResults );
-			//Shuffle the pick numbers.
+			// Shuffle the pick numbers.
 			shuffle( $pick );
-			//Select pick numbers from the beginning to the maximum of $randomCount.
+			// Select pick numbers from the beginning to the maximum of $randomCount.
 			$pick = array_slice( $pick, 0, $randomCount );
 		}
 
@@ -370,27 +380,27 @@ private function processQueryResults( $result ) {
 		while ( $row = $result->fetchRow() ) {
 			$i++;
 
-			//In random mode skip articles which were not chosen.
-			if ( $randomCount > 0 && !in_array( $i, $pick ) ) {
+			// In random mode skip articles which were not chosen.
+			if ( $randomCount > 0 && !in_array( $i, $pick ?? [] ) ) {
 				continue;
 			}
 
 			if ( $this->parameters->getParameter( 'goal' ) == 'categories' ) {
 				$pageNamespace = NS_CATEGORY;
-				$pageTitle     = $row['cl_to'];
+				$pageTitle = $row['cl_to'];
 			} elseif ( $this->parameters->getParameter( 'openreferences' ) ) {
 				if ( count( $this->parameters->getParameter( 'imagecontainer' ) ) > 0 ) {
 					$pageNamespace = NS_FILE;
-					$pageTitle     = $row['il_to'];
+					$pageTitle = $row['il_to'];
 				} else {
-					//Maybe non-existing title
+					// Maybe non-existing title
 					$pageNamespace = $row['pl_namespace'];
-					$pageTitle     = $row['pl_title'];
+					$pageTitle = $row['pl_title'];
 				}
 			} else {
-				//Existing PAGE TITLE
+				// Existing PAGE TITLE
 				$pageNamespace = $row['page_namespace'];
-				$pageTitle     = $row['page_title'];
+				$pageTitle = $row['page_title'];
 			}
 
 			// if subpages are to be excluded: skip them
@@ -398,16 +408,17 @@ private function processQueryResults( $result ) {
 				continue;
 			}
 
-			$title     = \Title::makeTitle( $pageNamespace, $pageTitle );
-			$thisTitle = $this->parser->getTitle();
+			$title = Title::makeTitle( $pageNamespace, $pageTitle );
+			$thisTitle = $parser->getTitle();
 
-			//Block recursion from happening by seeing if this result row is the page the DPL query was ran from.
+			// Block recursion from happening by seeing if this result row is the page the DPL query was ran from.
 			if ( $this->parameters->getParameter( 'skipthispage' ) && $thisTitle->equals( $title ) ) {
 				continue;
 			}
 
 			$articles[] = Article::newFromRow( $row, $this->parameters, $title, $pageNamespace, $pageTitle );
 		}
+
 		$this->DB->freeResult( $result );
 
 		return $articles;
@@ -416,70 +427,71 @@ private function processQueryResults( $result ) {
 	/**
 	 * Do basic clean up and structuring of raw user input.
 	 *
-	 * @private
-	 * @param	string	Raw User Input
-	 * @return	array	Array of raw text parameter => option.
+	 * @param string $input
+	 * @return array
 	 */
 	private function prepareUserInput( $input ) {
-		//We replace double angle brackets with single angle brackets to avoid premature tag expansion in the input.
-		//The ¦ symbol is an alias for |.
-		//The combination '²{' and '}²'will be translated to double curly braces; this allows postponed template execution which is crucial for DPL queries which call other DPL queries.
+		// We replace double angle brackets with single angle brackets to avoid premature tag expansion in the input.
+		// The ¦ symbol is an alias for |.
+		// The combination '²{' and '}²'will be translated to double curly braces; this allows postponed template execution which is crucial for DPL queries which call other DPL queries.
 		$input = str_replace( [ '«', '»', '¦', '²{', '}²' ], [ '<', '>', '|', '{{', '}}' ], $input );
 
-		//Standard new lines into the standard \n and clean up any hanging new lines.
+		// Standard new lines into the standard \n and clean up any hanging new lines.
 		$input = str_replace( [ "\r\n", "\r" ], "\n", $input );
 		$input = trim( $input, "\n" );
 		$rawParameters = explode( "\n", $input );
 
-		$parameters = false;
+		$parameters = [];
 		foreach ( $rawParameters as $parameterOption ) {
 			if ( empty( $parameterOption ) ) {
-				//Softly ignore blank lines.
+				// Softly ignore blank lines.
 				continue;
 			}
 
 			if ( strpos( $parameterOption, '=' ) === false ) {
-				$this->logger->addMessage( \DynamicPageListHooks::WARN_PARAMNOOPTION, $parameterOption );
+				$this->logger->addMessage( DynamicPageListHooks::WARN_PARAMNOOPTION, $parameterOption );
+
 				continue;
 			}
 
-			list( $parameter, $option ) = explode( '=', $parameterOption, 2 );
+			[ $parameter, $option ] = explode( '=', $parameterOption, 2 );
 			$parameter = trim( $parameter );
-			$option  = trim( $option );
+			$option = trim( $option );
 
 			if ( strpos( $parameter, '<' ) !== false || strpos( $parameter, '>' ) !== false ) {
-				//Having the actual less than and greater than symbols is nasty for programatic look up.  The old parameter is still supported along with the new, but we just fix it here before calling it.
+				// Having the actual less than and greater than symbols is nasty for programatic look up. The old parameter is still supported along with the new, but we just fix it here before calling it.
 				$parameter = str_replace( '<', 'lt', $parameter );
 				$parameter = str_replace( '>', 'gt', $parameter );
 			}
 
-			$parameter = strtolower( $parameter ); //Force lower case for ease of use.
+			$parameter = strtolower( $parameter ); // Force lower case for ease of use.
 			if ( empty( $parameter ) || substr( $parameter, 0, 1 ) == '#' || ( $this->parameters->exists( $parameter ) && !$this->parameters->testRichness( $parameter ) ) ) {
 				continue;
 			}
 
 			if ( !$this->parameters->exists( $parameter ) ) {
-				$this->logger->addMessage( \DynamicPageListHooks::WARN_UNKNOWNPARAM, $parameter, implode( ', ', $this->parameters->getParametersForRichness() ) );
+				$this->logger->addMessage( DynamicPageListHooks::WARN_UNKNOWNPARAM, $parameter, implode( ', ', $this->parameters->getParametersForRichness() ) );
+
 				continue;
 			}
 
-			//Ignore parameter settings without argument (except namespace and category).
+			// Ignore parameter settings without argument (except namespace and category).
 			if ( !strlen( $option ) ) {
 				if ( $parameter != 'namespace' && $parameter != 'notnamespace' && $parameter != 'category' && $this->parameters->exists( $parameter ) ) {
 					continue;
 				}
 			}
+
 			$parameters[$parameter][] = $option;
 		}
+
 		return $parameters;
 	}
 
 	/**
 	 * Concatenate output
 	 *
-	 * @private
-	 * @param	string	Output to add
-	 * @return	void
+	 * @param string $output
 	 */
 	private function addOutput( $output ) {
 		$this->output .= $output;
@@ -488,32 +500,32 @@ private function addOutput( $output ) {
 	/**
 	 * Set the output text.
 	 *
-	 * @private
-	 * @return	string	Output Text
+	 * @return string
 	 */
 	private function getOutput() {
-		//@TODO: 2015-08-28 Consider calling $this->replaceVariables() here.  Might cause issues with text returned in the results.
+		// @TODO: 2015-08-28 Consider calling $this->replaceVariables() here. Might cause issues with text returned in the results.
 		return $this->output;
 	}
 
 	/**
 	 * Return output optionally including header and footer.
 	 *
-	 * @private
-	 * @param	boolean	[Optional] Total results.
-	 * @param	boolean	[Optional] Skip adding the header and footer.
-	 * @return	string	Output
+	 * @param bool|int $totalResults
+	 * @param bool $skipHeaderFooter
+	 * @return string
 	 */
 	private function getFullOutput( $totalResults = false, $skipHeaderFooter = true ) {
 		if ( !$skipHeaderFooter ) {
 			$header = '';
 			$footer = '';
-			//Only override header and footers if specified.
-			$_headerType = $this->getHeaderFooterType( 'header', $totalResults );
+
+			// Only override header and footers if specified.
+			$_headerType = $this->getHeaderFooterType( 'header', (int)$totalResults );
 			if ( $_headerType !== false ) {
 				$header = $this->parameters->getParameter( $_headerType );
 			}
-			$_footerType = $this->getHeaderFooterType( 'footer', $totalResults );
+
+			$_footerType = $this->getHeaderFooterType( 'footer', (int)$totalResults );
 			if ( $_footerType !== false ) {
 				$footer = $this->parameters->getParameter( $_footerType );
 			}
@@ -523,8 +535,9 @@ private function getFullOutput( $totalResults = false, $skipHeaderFooter = true
 		}
 
 		if ( !$totalResults && !strlen( $this->getHeader() ) && !strlen( $this->getFooter() ) ) {
-			$this->logger->addMessage( \DynamicPageListHooks::WARN_NORESULTS );
+			$this->logger->addMessage( DynamicPageListHooks::WARN_NORESULTS );
 		}
+
 		$messages = $this->logger->getMessages( false );
 
 		return ( count( $messages ) ? implode( "<br/>\n", $messages ) : null ) . $this->getHeader() . $this->getOutput() . $this->getFooter();
@@ -533,22 +546,20 @@ private function getFullOutput( $totalResults = false, $skipHeaderFooter = true
 	/**
 	 * Set the header text.
 	 *
-	 * @private
-	 * @param	string	Header Text
-	 * @return	void
+	 * @param string $header
 	 */
 	private function setHeader( $header ) {
-		if ( \DynamicPageListHooks::getDebugLevel() == 5 ) {
+		if ( DynamicPageListHooks::getDebugLevel() == 5 ) {
 			$header = '<pre><nowiki>' . $header;
 		}
+
 		$this->header = $this->replaceVariables( $header );
 	}
 
 	/**
 	 * Set the header text.
 	 *
-	 * @private
-	 * @return	string	Header Text
+	 * @return string
 	 */
 	private function getHeader() {
 		return $this->header;
@@ -557,22 +568,20 @@ private function getHeader() {
 	/**
 	 * Set the footer text.
 	 *
-	 * @private
-	 * @param	string	Footer Text
-	 * @return	void
+	 * @param string $footer
 	 */
 	private function setFooter( $footer ) {
-		if ( \DynamicPageListHooks::getDebugLevel() == 5 ) {
+		if ( DynamicPageListHooks::getDebugLevel() == 5 ) {
 			$footer .= '</nowiki></pre>';
 		}
+
 		$this->footer = $this->replaceVariables( $footer );
 	}
 
 	/**
 	 * Set the footer text.
 	 *
-	 * @private
-	 * @return	string	Footer Text
+	 * @return string
 	 */
 	private function getFooter() {
 		return $this->footer;
@@ -581,13 +590,13 @@ private function getFooter() {
 	/**
 	 * Determine the header/footer type to use based on what output format parameters were chosen and the number of results.
 	 *
-	 * @private
-	 * @param	string	Page position to check: 'header' or 'footer'.
-	 * @param	integer	Count of pages.
-	 * @return	mixed	Type to use: 'results', 'oneresult', or 'noresults'.  False if invalid or none should be used.
+	 * @param string $position
+	 * @param int $count
+	 * @return mixed Type to use: 'results', 'oneresult', or 'noresults'. False if invalid or none should be used.
 	 */
 	private function getHeaderFooterType( $position, $count ) {
 		$count = intval( $count );
+
 		if ( $position != 'header' && $position != 'footer' ) {
 			return false;
 		}
@@ -601,16 +610,15 @@ private function getHeaderFooterType( $position, $count ) {
 		} else {
 			$_type = false;
 		}
+
 		return $_type;
 	}
 
 	/**
 	 * Set a variable to be replaced with the provided text later at the end of the output.
 	 *
-	 * @private
-	 * @param	string	Variable name, will be transformed to uppercase and have leading and trailing percent signs added.
-	 * @param	string	Text to replace the variable with.
-	 * @return	void
+	 * @param string $variable
+	 * @param string $replacement
 	 */
 	private function setVariable( $variable, $replacement ) {
 		$variable = "%" . mb_strtoupper( $variable, "UTF-8" ) . "%";
@@ -620,24 +628,24 @@ private function setVariable( $variable, $replacement ) {
 	/**
 	 * Return text with variables replaced.
 	 *
-	 * @private
-	 * @param	string	Text to perform replacements on.
-	 * @return	string	Replaced Text
+	 * @param string $text
+	 * @return string
 	 */
 	private function replaceVariables( $text ) {
 		$text = self::replaceNewLines( $text );
+
 		foreach ( $this->replacementVariables as $variable => $replacement ) {
 			$text = str_replace( $variable, $replacement, $text );
 		}
+
 		return $text;
 	}
 
 	/**
 	 * Return text with custom new line characters replaced.
 	 *
-	 * @private
-	 * @param	string	Text
-	 * @return	string	New Lined Text
+	 * @param string $text
+	 * @return string
 	 */
 	public static function replaceNewLines( $text ) {
 		return str_replace( [ '\n', "¶" ], "\n", $text );
@@ -646,8 +654,7 @@ public static function replaceNewLines( $text ) {
 	/**
 	 * Work through processed parameters and check for potential issues.
 	 *
-	 * @private
-	 * @return	void
+	 * @return bool
 	 */
 	private function doQueryErrorChecks() {
 		/**************************/
@@ -666,6 +673,7 @@ private function doQueryErrorChecks() {
 				}
 			}
 		}
+
 		if ( is_array( $this->parameters->getParameter( 'notcategory' ) ) ) {
 			foreach ( $this->parameters->getParameter( 'notcategory' ) as $comparisonType => $operatorTypes ) {
 				foreach ( $operatorTypes as $operatorType => $categories ) {
@@ -676,64 +684,73 @@ private function doQueryErrorChecks() {
 			}
 		}
 
-		//Too many categories.
+		// Too many categories.
 		if ( $totalCategories > Config::getSetting( 'maxCategoryCount' ) && !Config::getSetting( 'allowUnlimitedCategories' ) ) {
-			$this->logger->addMessage( \DynamicPageListHooks::FATAL_TOOMANYCATS, Config::getSetting( 'maxCategoryCount' ) );
+			$this->logger->addMessage( DynamicPageListHooks::FATAL_TOOMANYCATS, Config::getSetting( 'maxCategoryCount' ) );
+
 			return false;
 		}
 
-		//Not enough categories.(Really?)
+		// Not enough categories.(Really?)
 		if ( $totalCategories < Config::getSetting( 'minCategoryCount' ) ) {
-			$this->logger->addMessage( \DynamicPageListHooks::FATAL_TOOFEWCATS, Config::getSetting( 'minCategoryCount' ) );
+			$this->logger->addMessage( DynamicPageListHooks::FATAL_TOOFEWCATS, Config::getSetting( 'minCategoryCount' ) );
+
 			return false;
 		}
 
-		//Selection criteria needs to be found.
+		// Selection criteria needs to be found.
 		if ( !$totalCategories && !$this->parameters->isSelectionCriteriaFound() ) {
-			$this->logger->addMessage( \DynamicPageListHooks::FATAL_NOSELECTION );
+			$this->logger->addMessage( DynamicPageListHooks::FATAL_NOSELECTION );
+
 			return false;
 		}
 
-		//ordermethod=sortkey requires ordermethod=category
-		//Delayed to the construction of the SQL query, see near line 2211, gs
-		//if (in_array('sortkey',$aOrderMethods) && ! in_array('category',$aOrderMethods)) $aOrderMethods[] = 'category';
+		// ordermethod=sortkey requires ordermethod=category
+		// Delayed to the construction of the SQL query, see near line 2211, gs
+		// if (in_array('sortkey',$aOrderMethods) && ! in_array('category',$aOrderMethods)) $aOrderMethods[] = 'category';
 
 		$orderMethods = (array)$this->parameters->getParameter( 'ordermethod' );
-		//Throw an error in no categories were selected when using category sorting modes or requesting category information.
+		// Throw an error in no categories were selected when using category sorting modes or requesting category information.
 		if ( $totalCategories == 0 && ( in_array( 'categoryadd', $orderMethods ) || $this->parameters->getParameter( 'addfirstcategorydate' ) === true ) ) {
-			$this->logger->addMessage( \DynamicPageListHooks::FATAL_CATDATEBUTNOINCLUDEDCATS );
+			$this->logger->addMessage( DynamicPageListHooks::FATAL_CATDATEBUTNOINCLUDEDCATS );
+
 			return false;
 		}
 
-		//No more than one type of date at a time!
-		//@TODO: Can this be fixed to allow all three later after fixing the article class?
+		// No more than one type of date at a time!
+		// @TODO: Can this be fixed to allow all three later after fixing the article class?
 		if ( ( intval( $this->parameters->getParameter( 'addpagetoucheddate' ) ) + intval( $this->parameters->getParameter( 'addfirstcategorydate' ) ) + intval( $this->parameters->getParameter( 'addeditdate' ) ) ) > 1 ) {
-			$this->logger->addMessage( \DynamicPageListHooks::FATAL_MORETHAN1TYPEOFDATE );
+			$this->logger->addMessage( DynamicPageListHooks::FATAL_MORETHAN1TYPEOFDATE );
+
 			return false;
 		}
 
 		// the dominant section must be one of the sections mentioned in includepage
 		if ( $this->parameters->getParameter( 'dominantsection' ) > 0 && count( $this->parameters->getParameter( 'seclabels' ) ) < $this->parameters->getParameter( 'dominantsection' ) ) {
-			$this->logger->addMessage( \DynamicPageListHooks::FATAL_DOMINANTSECTIONRANGE, count( $this->parameters->getParameter( 'seclabels' ) ) );
+			$this->logger->addMessage( DynamicPageListHooks::FATAL_DOMINANTSECTIONRANGE, count( $this->parameters->getParameter( 'seclabels' ) ) );
+
 			return false;
 		}
 
 		// category-style output requested with not compatible order method
 		if ( $this->parameters->getParameter( 'mode' ) == 'category' && !array_intersect( $orderMethods, [ 'sortkey', 'title', 'titlewithoutnamespace' ] ) ) {
-			$this->logger->addMessage( \DynamicPageListHooks::FATAL_WRONGORDERMETHOD, 'mode=category', 'sortkey | title | titlewithoutnamespace' );
+			$this->logger->addMessage( DynamicPageListHooks::FATAL_WRONGORDERMETHOD, 'mode=category', 'sortkey | title | titlewithoutnamespace' );
+
 			return false;
 		}
 
 		// addpagetoucheddate=true with unappropriate order methods
 		if ( $this->parameters->getParameter( 'addpagetoucheddate' ) && !array_intersect( $orderMethods, [ 'pagetouched', 'title' ] ) ) {
-			$this->logger->addMessage( \DynamicPageListHooks::FATAL_WRONGORDERMETHOD, 'addpagetoucheddate=true', 'pagetouched | title' );
+			$this->logger->addMessage( DynamicPageListHooks::FATAL_WRONGORDERMETHOD, 'addpagetoucheddate=true', 'pagetouched | title' );
+
 			return false;
 		}
 
 		// addeditdate=true but not (ordermethod=...,firstedit or ordermethod=...,lastedit)
-		//firstedit (resp. lastedit) -> add date of first (resp. last) revision
+		// firstedit (resp. lastedit) -> add date of first (resp. last) revision
 		if ( $this->parameters->getParameter( 'addeditdate' ) && !array_intersect( $orderMethods, [ 'firstedit', 'lastedit' ] ) && ( $this->parameters->getParameter( 'allrevisionsbefore' ) || $this->parameters->getParameter( 'allrevisionssince' ) || $this->parameters->getParameter( 'firstrevisionsince' ) || $this->parameters->getParameter( 'lastrevisionbefore' ) ) ) {
-			$this->logger->addMessage( \DynamicPageListHooks::FATAL_WRONGORDERMETHOD, 'addeditdate=true', 'firstedit | lastedit' );
+			$this->logger->addMessage( DynamicPageListHooks::FATAL_WRONGORDERMETHOD, 'addeditdate=true', 'firstedit | lastedit' );
+
 			return false;
 		}
 
@@ -744,82 +761,92 @@ private function doQueryErrorChecks() {
 		 * Ideally, we could use values such as 'all', 'first' or 'last' for the adduser parameter.
 		 */
 		if ( $this->parameters->getParameter( 'adduser' ) && !array_intersect( $orderMethods, [ 'firstedit', 'lastedit' ] ) && !$this->parameters->getParameter( 'allrevisionsbefore' ) && !$this->parameters->getParameter( 'allrevisionssince' ) && !$this->parameters->getParameter( 'firstrevisionsince' ) && !$this->parameters->getParameter( 'lastrevisionbefore' ) ) {
-			$this->logger->addMessage( \DynamicPageListHooks::FATAL_WRONGORDERMETHOD, 'adduser=true', 'firstedit | lastedit' );
+			$this->logger->addMessage( DynamicPageListHooks::FATAL_WRONGORDERMETHOD, 'adduser=true', 'firstedit | lastedit' );
+
 			return false;
 		}
+
 		if ( $this->parameters->getParameter( 'minoredits' ) && !array_intersect( $orderMethods, [ 'firstedit', 'lastedit' ] ) ) {
-			$this->logger->addMessage( \DynamicPageListHooks::FATAL_WRONGORDERMETHOD, 'minoredits', 'firstedit | lastedit' );
+			$this->logger->addMessage( DynamicPageListHooks::FATAL_WRONGORDERMETHOD, 'minoredits', 'firstedit | lastedit' );
+
 			return false;
 		}
 
-		//add*** parameters have no effect with 'mode=category' (only namespace/title can be viewed in this mode)
+		// add*** parameters have no effect with 'mode=category' (only namespace/title can be viewed in this mode)
 		if ( $this->parameters->getParameter( 'mode' ) == 'category' && ( $this->parameters->getParameter( 'addcategories' ) || $this->parameters->getParameter( 'addeditdate' ) || $this->parameters->getParameter( 'addfirstcategorydate' ) || $this->parameters->getParameter( 'addpagetoucheddate' ) || $this->parameters->getParameter( 'incpage' ) || $this->parameters->getParameter( 'adduser' ) || $this->parameters->getParameter( 'addauthor' ) || $this->parameters->getParameter( 'addcontribution' ) || $this->parameters->getParameter( 'addlasteditor' ) ) ) {
-			$this->logger->addMessage( \DynamicPageListHooks::WARN_CATOUTPUTBUTWRONGPARAMS );
+			$this->logger->addMessage( DynamicPageListHooks::WARN_CATOUTPUTBUTWRONGPARAMS );
 		}
 
-		//headingmode has effects with ordermethod on multiple components only
+		// headingmode has effects with ordermethod on multiple components only
 		if ( $this->parameters->getParameter( 'headingmode' ) !== 'none' && count( $orderMethods ) < 2 ) {
-			$this->logger->addMessage( \DynamicPageListHooks::WARN_HEADINGBUTSIMPLEORDERMETHOD, $this->parameters->getParameter( 'headingmode' ), 'none' );
+			$this->logger->addMessage( DynamicPageListHooks::WARN_HEADINGBUTSIMPLEORDERMETHOD, $this->parameters->getParameter( 'headingmode' ), 'none' );
 			$this->parameters->setParameter( 'headingmode', 'none' );
 		}
 
-		//The 'openreferences' parameter is incompatible with many other options.
+		// The 'openreferences' parameter is incompatible with many other options.
 		if ( $this->parameters->isOpenReferencesConflict() && $this->parameters->getParameter( 'openreferences' ) === true ) {
-			$this->logger->addMessage( \DynamicPageListHooks::FATAL_OPENREFERENCES );
+			$this->logger->addMessage( DynamicPageListHooks::FATAL_OPENREFERENCES );
+
 			return false;
 		}
+
 		return true;
 	}
 
 	/**
 	 * Create keys for TableRow which represent the structure of the "include=" arguments.
 	 *
-	 * @access	public
-	 * @param	array	Array of 'tablerow' parameter data.
-	 * @param	array	Array of 'include' parameter data.
-	 * @return	array	Updated 'tablerow' parameter.
+	 * @param array	$tableRow
+	 * @param array	$sectionLabels
+	 * @return array
 	 */
 	private static function updateTableRowKeys( $tableRow, $sectionLabels ) {
-		$_tableRow	= (array)$tableRow;
-		$tableRow	= [];
-		$groupNr	= -1;
-		$t			= -1;
+		$_tableRow = (array)$tableRow;
+		$tableRow = [];
+		$groupNr = -1;
+		$t = -1;
+
 		foreach ( $sectionLabels as $label ) {
 			$t++;
 			$groupNr++;
 			$cols = explode( '}:', $label );
+
 			if ( count( $cols ) <= 1 ) {
 				if ( array_key_exists( $t, $_tableRow ) ) {
 					$tableRow[$groupNr] = $_tableRow[$t];
 				}
 			} else {
-				$n     = count( explode( ':', $cols[1] ) );
+				$n = count( explode( ':', $cols[1] ) );
 				$colNr = -1;
 				$t--;
+
 				for ( $i = 1; $i <= $n; $i++ ) {
 					$colNr++;
 					$t++;
+
 					if ( array_key_exists( $t, $_tableRow ) ) {
 						$tableRow[$groupNr . '.' . $colNr] = $_tableRow[$t];
 					}
 				}
 			}
 		}
+
 		return $tableRow;
 	}
 
 	/**
 	 * Resolve arguments in the input that would normally be in the URL.
 	 *
-	 * @access	public
-	 * @param	string	Raw Uncleaned User Input
-	 * @param	array	Array of URL arguments to resolve.  Non-arrays will be casted to an array.
-	 * @return	string	Raw input with variables replaced
+	 * @param string $input
+	 * @param array $arguments
+	 * @return string
 	 */
 	private function resolveUrlArguments( $input, $arguments ) {
 		$arguments = (array)$arguments;
+
 		foreach ( $arguments as $arg ) {
-			$dplArg = $this->wgRequest->getVal( $arg, '' );
+			$dplArg = $this->request->getVal( $arg, '' );
+
 			if ( $dplArg == '' ) {
 				$input = preg_replace( '/\{%' . $arg . ':(.*)%\}/U', '\1', $input );
 				$input = str_replace( '{%' . $arg . '%}', '', $input );
@@ -828,42 +855,45 @@ private function resolveUrlArguments( $input, $arguments ) {
 				$input = str_replace( '{%' . $arg . '%}', $dplArg, $input );
 			}
 		}
+
 		return $input;
 	}
 
 	/**
 	 * This function uses the Variables extension to provide URL-arguments like &DPL_xyz=abc in the form of a variable which can be accessed as {{#var:xyz}} if Extension:Variables is installed.
 	 *
-	 * @access	public
-	 * @return	void
+	 * @param Parser $parser
 	 */
-	private function getUrlArgs() {
-		$args = $this->wgRequest->getValues();
+	private function getUrlArgs( Parser $parser ) {
+		$args = $this->request->getValues();
+
 		foreach ( $args as $argName => $argValue ) {
 			if ( strpos( $argName, 'DPL_' ) === false ) {
 				continue;
 			}
+
 			Variables::setVar( [ '', '', $argName, $argValue ] );
+
 			if ( defined( 'ExtVariables::VERSION' ) ) {
-				\ExtVariables::get( $this->parser )->setVarValue( $argName, $argValue );
+				ExtVariables::get( $parser )->setVarValue( $argName, $argValue );
 			}
 		}
 	}
 
 	/**
-	 * This function uses the Variables extension to provide navigation aids such as DPL_firstTitle, DPL_lastTitle, or DPL_findTitle.  These variables can be accessed as {{#var:DPL_firstTitle}} if Extension:Variables is installed.
+	 * This function uses the Variables extension to provide navigation aids such as DPL_firstTitle, DPL_lastTitle, or DPL_findTitle. These variables can be accessed as {{#var:DPL_firstTitle}} if Extension:Variables is installed.
 	 *
-	 * @access	public
-	 * @param	array	Array of scroll variables with the key as the variable name and the value as the value.  Non-arrays will be casted to arrays.
-	 * @return	void
+	 * @param array $scrollVariables
+	 * @param Parser $parser
 	 */
-	private function defineScrollVariables( $scrollVariables ) {
+	private function defineScrollVariables( $scrollVariables, Parser $parser ) {
 		$scrollVariables = (array)$scrollVariables;
 
 		foreach ( $scrollVariables as $variable => $value ) {
 			Variables::setVar( [ '', '', $variable, $value ] );
+
 			if ( defined( 'ExtVariables::VERSION' ) ) {
-				\ExtVariables::get( $this->parser )->setVarValue( $variable, $value );
+				ExtVariables::get( $parser )->setVarValue( $variable, $value );
 			}
 		}
 	}
@@ -871,87 +901,100 @@ private function defineScrollVariables( $scrollVariables ) {
 	/**
 	 * Trigger Resets and Eliminates that run at the end of parsing.
 	 *
-	 * @private
-	 * @param	string	Full output including header, footer, and any warnings.
-	 * @param	array	End Reset Booleans
-	 * @param	array	End Eliminate Booleans
-	 * @param	boolean	Call as a parser tag
-	 * @return	void
+	 * @param string $output
+	 * @param array &$reset
+	 * @param array &$eliminate
+	 * @param bool $isParserTag
+	 * @param Parser $parser
 	 */
-	private function triggerEndResets( $output, &$reset, &$eliminate, $isParserTag ) {
+	private function triggerEndResets( $output, &$reset, &$eliminate, $isParserTag, Parser $parser ) {
 		global $wgHooks;
 
-		$localParser = \MediaWiki\MediaWikiServices::getInstance()->getParserFactory()->create();
-		$parserOutput = $localParser->parse( $output, $this->parser->mTitle, $this->parser->mOptions );
+		$localParser = MediaWikiServices::getInstance()->getParserFactory()->create();
+		$parserOutput = $localParser->parse( $output, $parser->getTitle(), $parser->getOptions() );
 
 		if ( !is_array( $reset ) ) {
 			$reset = [];
 		}
+
 		$reset = array_merge( $reset, (array)$this->parameters->getParameter( 'reset' ) );
 
 		if ( !is_array( $eliminate ) ) {
 			$eliminate = [];
 		}
+
 		$eliminate = array_merge( $eliminate, (array)$this->parameters->getParameter( 'eliminate' ) );
+
 		if ( $isParserTag === true ) {
-			//In tag mode 'eliminate' is the same as 'reset' for templates, categories, and images.
+			// In tag mode 'eliminate' is the same as 'reset' for templates, categories, and images.
 			if ( isset( $eliminate['templates'] ) && $eliminate['templates'] ) {
 				$reset['templates'] = true;
 				$eliminate['templates'] = false;
 			}
+
 			if ( isset( $eliminate['categories'] ) && $eliminate['categories'] ) {
 				$reset['categories'] = true;
 				$eliminate['categories'] = false;
 			}
+
 			if ( isset( $eliminate['images'] ) && $eliminate['images'] ) {
 				$reset['images'] = true;
 				$eliminate['images'] = false;
 			}
 		} else {
 			if ( isset( $reset['templates'] ) && $reset['templates'] ) {
-				\DynamicPageListHooks::$createdLinks['resetTemplates'] = true;
+				DynamicPageListHooks::$createdLinks['resetTemplates'] = true;
 			}
+
 			if ( isset( $reset['categories'] ) && $reset['categories'] ) {
-				\DynamicPageListHooks::$createdLinks['resetCategories'] = true;
+				DynamicPageListHooks::$createdLinks['resetCategories'] = true;
 			}
+
 			if ( isset( $reset['images'] ) && $reset['images'] ) {
-				\DynamicPageListHooks::$createdLinks['resetImages'] = true;
+				DynamicPageListHooks::$createdLinks['resetImages'] = true;
 			}
 		}
+
 		if ( ( $isParserTag === true && isset( $reset['links'] ) ) || $isParserTag === false ) {
 			if ( isset( $reset['links'] ) ) {
-				\DynamicPageListHooks::$createdLinks['resetLinks'] = true;
+				DynamicPageListHooks::$createdLinks['resetLinks'] = true;
 			}
-			//Register a hook to reset links which were produced during parsing DPL output.
+
+			// Register a hook to reset links which were produced during parsing DPL output.
 			if ( !isset( $wgHooks['ParserAfterTidy'] ) || !is_array( $wgHooks['ParserAfterTidy'] ) || !in_array( 'DynamicPageListHooks::endReset', $wgHooks['ParserAfterTidy'] ) ) {
 				$wgHooks['ParserAfterTidy'][] = 'DynamicPageListHooks::endReset';
 			}
 		}
 
 		if ( array_sum( $eliminate ) ) {
-			//Register a hook to reset links which were produced during parsing DPL output
+			// Register a hook to reset links which were produced during parsing DPL output
 			if ( !isset( $wgHooks['ParserAfterTidy'] ) || !is_array( $wgHooks['ParserAfterTidy'] ) || !in_array( 'DynamicPageListHooks::endEliminate', $wgHooks['ParserAfterTidy'] ) ) {
 				$wgHooks['ParserAfterTidy'][] = 'DynamicPageListHooks::endEliminate';
 			}
 
 			if ( isset( $eliminate['links'] ) && $eliminate['links'] ) {
-				//Trigger the mediawiki parser to find links, images, categories etc. which are contained in the DPL output.  This allows us to remove these links from the link list later.  If the article containing the DPL statement itself uses one of these links they will be thrown away!
-				\DynamicPageListHooks::$createdLinks[0] = [];
+				// Trigger the mediawiki parser to find links, images, categories etc. which are contained in the DPL output. This allows us to remove these links from the link list later. If the article containing the DPL statement itself uses one of these links they will be thrown away!
+				DynamicPageListHooks::$createdLinks[0] = [];
+
 				foreach ( $parserOutput->getLinks() as $nsp => $link ) {
-					\DynamicPageListHooks::$createdLinks[0][$nsp] = $link;
+					DynamicPageListHooks::$createdLinks[0][$nsp] = $link;
 				}
 			}
+
 			if ( isset( $eliminate['templates'] ) && $eliminate['templates'] ) {
-				\DynamicPageListHooks::$createdLinks[1] = [];
+				DynamicPageListHooks::$createdLinks[1] = [];
+
 				foreach ( $parserOutput->getTemplates() as $nsp => $tpl ) {
-					\DynamicPageListHooks::$createdLinks[1][$nsp] = $tpl;
+					DynamicPageListHooks::$createdLinks[1][$nsp] = $tpl;
 				}
 			}
+
 			if ( isset( $eliminate['categories'] ) && $eliminate['categories'] ) {
-				\DynamicPageListHooks::$createdLinks[2] = $parserOutput->mCategories;
+				DynamicPageListHooks::$createdLinks[2] = $parserOutput->mCategories;
 			}
+
 			if ( isset( $eliminate['images'] ) && $eliminate['images'] ) {
-				\DynamicPageListHooks::$createdLinks[3] = $parserOutput->mImages;
+				DynamicPageListHooks::$createdLinks[3] = $parserOutput->mImages;
 			}
 		}
 	}
@@ -959,21 +1002,24 @@ private function triggerEndResets( $output, &$reset, &$eliminate, $isParserTag )
 	/**
 	 * Sort an array of Article objects by the card suit symbol.
 	 *
-	 * @private
-	 * @param	array	Article objects in an array.
-	 * @return	array	Sorted objects
+	 * @param array	$articles
+	 * @return array
 	 */
 	private function cardSuitSort( $articles ) {
 		$sortKeys = [];
+
 		foreach ( $articles as $key => $article ) {
-			$title  = preg_replace( '/.*:/', '', $article->mTitle );
-			$tokens  = preg_split( '/ - */', $title );
+			$title = preg_replace( '/.*:/', '', $article->mTitle );
+			$tokens = preg_split( '/ - */', $title );
 			$newKey = '';
+
 			foreach ( $tokens as $token ) {
 				$initial = substr( $token, 0, 1 );
+
 				if ( $initial >= '1' && $initial <= '7' ) {
 					$newKey .= $initial;
 					$suit = substr( $token, 1 );
+
 					if ( $suit == '♣' ) {
 						$newKey .= '1';
 					} elseif ( $suit == '♦' ) {
@@ -995,12 +1041,18 @@ private function cardSuitSort( $articles ) {
 					$newKey .= $token;
 				}
 			}
+
 			$sortKeys[$key] = $newKey;
 		}
+
 		asort( $sortKeys );
+
+		$sortedArticles = [];
+
 		foreach ( $sortKeys as $oldKey => $newKey ) {
 			$sortedArticles[] = $articles[$oldKey];
 		}
+
 		return $sortedArticles;
 	}
 }
diff --git a/includes/Query.php b/includes/Query.php
index 01444811..2283a84e 100644
--- a/includes/Query.php
+++ b/includes/Query.php
@@ -1,32 +1,41 @@
 <?php
-/**
- * DynamicPageList3
- * DPL Variables Class
- *
- * @author		IlyaHaykinson, Unendlich, Dangerville, Algorithmix, Theaitetos, Alexia E. Smith, Universal Omega
- * @license		GPL-2.0-or-later
- * @package		DynamicPageList3
- *
- */
+
 namespace DPL;
 
+use ActorMigration;
+use CommentStore;
+use DateInterval;
+use DateTime;
+use Exception;
 use MediaWiki\MediaWikiServices;
+use MWException;
+use Wikimedia\Rdbms\IDatabase;
 
 class Query {
 	/**
 	 * Parameters Object
 	 *
-	 * @var object
+	 * @var Parameters
 	 */
 	private $parameters;
 
 	/**
 	 * Mediawiki DB Object
 	 *
-	 * @var object
+	 * @var IDatabase
 	 */
 	private $DB;
 
+	/**
+	 * @var ActorMigration
+	 */
+	private $actorMigration;
+
+	/** @var UserQueryBuilder */
+	private $userQueryBuilder;
+	/** @var RevisionJoinBuilder */
+	private $revisionJoinBuilder;
+
 	/**
 	 * Array of prefixed and escaped table names.
 	 *
@@ -100,14 +109,14 @@ class Query {
 	/**
 	 * Limit
 	 *
-	 * @var int
+	 * @var int|bool
 	 */
 	private $limit = false;
 
 	/**
 	 * Offset
 	 *
-	 * @var int
+	 * @var int|bool
 	 */
 	private $offset = false;
 
@@ -128,7 +137,7 @@ class Query {
 	/**
 	 * Character Set Collation
 	 *
-	 * @var string
+	 * @var string|bool
 	 */
 	private $collation = false;
 
@@ -147,26 +156,34 @@ class Query {
 	private $revisionAuxWhereAdded = false;
 
 	/**
-	 * Main Constructor
-	 *
-	 * @access	public
-	 * @param	\DPL\Parameters	$parameters
-	 * @return	void
+	 * @param Parameters $parameters
+	 * @param ActorMigration $actorMigration
+	 * @param CommentStore $commentStore
 	 */
-	public function __construct( Parameters $parameters ) {
+	public function __construct(
+		Parameters $parameters,
+		ActorMigration $actorMigration,
+		CommentStore $commentStore
+	) {
 		$this->parameters = $parameters;
 
 		$this->tableNames = self::getTableNames();
 
 		$this->DB = wfGetDB( DB_REPLICA, 'dpl' );
+		$this->actorMigration = $actorMigration;
+		$this->userQueryBuilder = new UserQueryBuilder( $this->DB, $this->actorMigration );
+		$this->revisionJoinBuilder = new RevisionJoinBuilder(
+			$this->DB,
+			$this->actorMigration,
+			$commentStore
+		);
 	}
 
 	/**
 	 * Start a query build.
 	 *
-	 * @access	public
-	 * @param	boolean	Calculate Found Rows
-	 * @return	mixed	Mediawiki Result Object or False
+	 * @param bool $calcRows
+	 * @return mixed Mediawiki Result Object or False
 	 */
 	public function buildAndSelect( $calcRows = false ) {
 		global $wgNonincludableNamespaces;
@@ -176,19 +193,39 @@ public function buildAndSelect( $calcRows = false ) {
 		$parameters = $this->parameters->getAllParameters();
 		foreach ( $parameters as $parameter => $option ) {
 			$function = "_" . $parameter;
-			//Some parameters do not modifiy the query so we check if the function to modify the query exists first.
+			// Some parameters do not modifiy the query so we check if the function to modify the query exists first.
 			$success = true;
 			if ( method_exists( $this, $function ) ) {
 				$success = $this->$function( $option );
 			}
+
 			if ( $success === false ) {
-				throw new \MWException( __METHOD__ . ": SQL Build Error returned from {$function} for " . serialize( $option ) . "." );
+				throw new MWException( __METHOD__ . ": SQL Build Error returned from {$function} for " . serialize( $option ) . "." );
 			}
+
 			$this->parametersProcessed[$parameter] = true;
 		}
 
+		$userQueryConds = $this->userQueryBuilder->getWhere();
+		if ( $userQueryConds ) {
+			$this->addWhere( $userQueryConds );
+		}
+
+		$revQueryInfo = $this->revisionJoinBuilder->getQueryInfo();
+		$this->addSelect( $revQueryInfo['fields'] );
+
+		foreach ( $revQueryInfo['tables'] as $alias => $table ) {
+			if ( !isset( $this->tables[$alias] ) ) {
+				$this->tables[$alias] = $table;
+			}
+		}
+
+		foreach ( $revQueryInfo['joins'] as $joinTarget => $joinConds ) {
+			$this->addJoin( $joinTarget, $joinConds );
+		}
+
 		if ( !$this->parameters->getParameter( 'openreferences' ) ) {
-			//Add things that are always part of the query.
+			// Add things that are always part of the query.
 			$this->addTable( 'page', $this->tableNames['page'] );
 			$this->addSelect(
 				[
@@ -198,7 +235,8 @@ public function buildAndSelect( $calcRows = false ) {
 				]
 			);
 		}
-		//Always add nonincludeable namespaces.
+
+		// Always add nonincludeable namespaces.
 		if ( is_array( $wgNonincludableNamespaces ) && count( $wgNonincludableNamespaces ) ) {
 			$this->addNotWhere(
 				[
@@ -210,26 +248,28 @@ public function buildAndSelect( $calcRows = false ) {
 		if ( $this->offset !== false ) {
 			$options['OFFSET'] = $this->offset;
 		}
+
 		if ( $this->limit !== false ) {
 			$options['LIMIT'] = $this->limit;
-		} elseif ( $this->offset !== false && $this->limit === false ) {
+		} elseif ( $this->offset !== false ) {
 			$options['LIMIT'] = $this->parameters->getParameter( 'count' );
 		}
 
 		if ( $this->parameters->getParameter( 'openreferences' ) ) {
 			if ( count( $this->parameters->getParameter( 'imagecontainer' ) ) > 0 ) {
-				//$sSqlSelectFrom = $sSqlCl_to.'ic.il_to, '.$sSqlSelPage."ic.il_to AS sortkey".' FROM '.$this->tableNames['imagelinks'].' AS ic';
+				// $sSqlSelectFrom = $sSqlCl_to.'ic.il_to, '.$sSqlSelPage."ic.il_to AS sortkey".' FROM '.$this->tableNames['imagelinks'].' AS ic';
 				$tables = [
 					'ic'	=> 'imagelinks'
 				];
 			} else {
-				//$sSqlSelectFrom = "SELECT $sSqlCalcFoundRows $sSqlDistinct ".$sSqlCl_to.'pl_namespace, pl_title'.$sSqlSelPage.$sSqlSortkey.' FROM '.$this->tableNames['pagelinks'];
+				// $sSqlSelectFrom = "SELECT $sSqlCalcFoundRows $sSqlDistinct ".$sSqlCl_to.'pl_namespace, pl_title'.$sSqlSelPage.$sSqlSortkey.' FROM '.$this->tableNames['pagelinks'];
 				$this->addSelect(
 					[
 						'pl_namespace',
 						'pl_title'
 					]
 				);
+
 				$tables = [
 					'pagelinks'
 				];
@@ -251,14 +291,17 @@ public function buildAndSelect( $calcRows = false ) {
 			$select = [
 				$this->tableNames['page'] . '.page_id'
 			];
+
 			$options[] = 'DISTINCT';
 		} else {
 			if ( $calcRows ) {
 				$options[] = 'SQL_CALC_FOUND_ROWS';
 			}
+
 			if ( $this->distinct ) {
 				$options[] = 'DISTINCT';
 			}
+
 			$categoriesGoal = false;
 			$select = $this->select;
 		}
@@ -275,22 +318,25 @@ public function buildAndSelect( $calcRows = false ) {
 					$this->join
 				);
 
+				$pageIds = [];
+
 				while ( $row = $result->fetchRow() ) {
 					$pageIds[] = $row['page_id'];
 				}
+
 				$sql = $this->DB->selectSQLText(
 					[
-						'clgoal'	=> 'categorylinks'
+						'clgoal' => 'categorylinks'
 					],
 					[
 						'clgoal.cl_to'
 					],
 					[
-						'clgoal.cl_from'	=> $pageIds
+						'clgoal.cl_from' => $pageIds
 					],
 					__METHOD__,
 					[
-						'ORDER BY'	=> 'clgoal.cl_to ' . $this->direction
+						'ORDER BY' => 'clgoal.cl_to ' . $this->direction
 					]
 				);
 			} else {
@@ -316,8 +362,9 @@ public function buildAndSelect( $calcRows = false ) {
 		} catch ( Exception $e ) {
 			$queryError = true;
 		}
-		if ( $queryError == true || $result === false ) {
-			throw new \MWException( __METHOD__ . ": " . wfMessage( 'dpl_query_error', DPL_VERSION, $this->DB->lastError() )->text() );
+
+		if ( $queryError || $result === false ) {
+			throw new MWException( __METHOD__ . ": " . wfMessage( 'dpl_query_error', DynamicPageListHooks::getVersion(), $this->DB->lastError() )->text() );
 		}
 
 		return $result;
@@ -326,8 +373,7 @@ public function buildAndSelect( $calcRows = false ) {
 	/**
 	 * Return the number of found rows.
 	 *
-	 * @access	public
-	 * @return	integer	Number of Found Rows
+	 * @return int
 	 */
 	public function getFoundRows() {
 		return $this->foundRows;
@@ -336,8 +382,7 @@ public function getFoundRows() {
 	/**
 	 * Returns the generated SQL Query
 	 *
-	 * @access	public
-	 * @return	string	SQL Query
+	 * @return string
 	 */
 	public function getSqlQuery() {
 		return $this->sqlQuery;
@@ -346,11 +391,11 @@ public function getSqlQuery() {
 	/**
 	 * Return prefixed and quoted tables that are needed.
 	 *
-	 * @access	public
-	 * @return	array	Prepared table names.
+	 * @return array
 	 */
 	public static function getTableNames() {
 		$DB = wfGetDB( DB_REPLICA, 'dpl' );
+
 		$tables = [
 			'categorylinks',
 			'dpl_clview',
@@ -361,7 +406,6 @@ public static function getTableNames() {
 			'pagelinks',
 			'recentchanges',
 			'revision',
-			'revision_actor_temp',
 			'templatelinks'
 		];
 
@@ -369,75 +413,88 @@ public static function getTableNames() {
 		foreach ( $tables as $table ) {
 			$tableNames[$table] = $DB->tableName( $table );
 		}
+
 		return $tableNames;
 	}
 
 	/**
 	 * Add a table to the output.
 	 *
-	 * @access	public
-	 * @param	string	Raw Table Name - Will be ran through tableName().
-	 * @param	string	Table Alias
-	 * @return	boolean	Success - Added, false if the table alias already exists.
+	 * @param string $table
+	 * @param string $alias
+	 * @return bool
 	 */
 	public function addTable( $table, $alias ) {
 		if ( empty( $table ) ) {
-			throw new \MWException( __METHOD__ . ': An empty table name was passed.' );
+			throw new MWException( __METHOD__ . ': An empty table name was passed.' );
 		}
+
 		if ( empty( $alias ) || is_numeric( $alias ) ) {
-			throw new \MWException( __METHOD__ . ': An empty or numeric table alias was passed.' );
+			throw new MWException( __METHOD__ . ': An empty or numeric table alias was passed.' );
 		}
+
 		if ( !isset( $this->tables[$alias] ) ) {
 			$this->tables[$alias] = $this->DB->tableName( $table );
+
 			return true;
 		} else {
 			return false;
 		}
 	}
 
+	/**
+	 * Add multiple tables to the output.
+	 *
+	 * @param array $tablesByAlias
+	 */
+	public function addTables( array $tablesByAlias ) {
+		foreach ( $tablesByAlias as $alias => $table ) {
+			$this->addTable( $table, $alias );
+		}
+	}
+
 	/**
 	 * Add a where clause to the output.
-	 * Where clauses get imploded together with AND at the end.	 Any custom where clauses should be preformed before placed into here.
+	 * Where clauses get imploded together with AND at the end. Any custom where clauses should be preformed before placed into here.
 	 *
-	 * @access	public
-	 * @param	string	Where clause
-	 * @return	boolean	Success
+	 * @param array|string $where
+	 * @return bool
 	 */
 	public function addWhere( $where ) {
 		if ( empty( $where ) ) {
-			throw new \MWException( __METHOD__ . ': An empty where clause was passed.' );
+			throw new MWException( __METHOD__ . ': An empty where clause was passed.' );
 		}
+
 		if ( is_string( $where ) ) {
 			$this->where[] = $where;
 		} elseif ( is_array( $where ) ) {
 			$this->where = array_merge( $this->where, $where );
 		} else {
-			throw new \MWException( __METHOD__ . ': An invalid where clause was passed.' );
-			return false;
+			throw new MWException( __METHOD__ . ': An invalid where clause was passed.' );
 		}
+
 		return true;
 	}
 
 	/**
 	 * Add a where clause to the output that uses NOT IN or !=.
 	 *
-	 * @access	public
-	 * @param	array	Field => Value(s)
-	 * @return	boolean	Success
+	 * @param array $where
+	 * @return bool
 	 */
 	public function addNotWhere( $where ) {
 		if ( empty( $where ) ) {
-			throw new \MWException( __METHOD__ . ': An empty not where clause was passed.' );
-			return false;
+			throw new MWException( __METHOD__ . ': An empty not where clause was passed.' );
 		}
+
 		if ( is_array( $where ) ) {
 			foreach ( $where as $field => $values ) {
 				$this->where[] = $field . ( count( $values ) > 1 ? ' NOT IN(' . $this->DB->makeList( $values ) . ')' : ' != ' . $this->DB->addQuotes( current( $values ) ) );
 			}
 		} else {
-			throw new \MWException( __METHOD__ . ': An invalid not where clause was passed.' );
-			return false;
+			throw new MWException( __METHOD__ . ': An invalid not where clause was passed.' );
 		}
+
 		return true;
 	}
 
@@ -445,88 +502,99 @@ public function addNotWhere( $where ) {
 	 * Add a field to select.
 	 * Will ignore duplicate values if the exact same alias and exact same field are passed.
 	 *
-	 * @access	public
-	 * @param	array	Array of fields with the array key being the field alias.  Leave the array key as a numeric index to not specify an alias.
-	 * @return	boolean	Success
+	 * @param array $fields
+	 * @return bool
 	 */
 	public function addSelect( $fields ) {
 		if ( !is_array( $fields ) ) {
-			throw new \MWException( __METHOD__ . ': A non-array was passed.' );
+			throw new MWException( __METHOD__ . ': A non-array was passed.' );
 		}
+
 		foreach ( $fields as $alias => $field ) {
 			if ( !is_numeric( $alias ) && array_key_exists( $alias, $this->select ) && $this->select[$alias] != $field ) {
-				//In case of a code bug that is overwriting an existing field alias throw an exception.
-				throw new \MWException( __METHOD__ . ": Attempted to overwrite existing field alias `{$this->select[$alias]}` AS `{$alias}` with `{$field}` AS `{$alias}`." );
+				// In case of a code bug that is overwriting an existing field alias throw an exception.
+				throw new MWException( __METHOD__ . ": Attempted to overwrite existing field alias `{$this->select[$alias]}` AS `{$alias}` with `{$field}` AS `{$alias}`." );
 			}
-			//String alias and does not exist already.
+
+			// String alias and does not exist already.
 			if ( !is_numeric( $alias ) && !array_key_exists( $alias, $this->select ) ) {
 				$this->select[$alias] = $field;
 			}
 
-			//Speed up by not using in_array() or array_key_exists().  Toss the field names into their own array as keys => true to exploit a speedy look up with isset().
+			// Speed up by not using in_array() or array_key_exists(). Toss the field names into their own array as keys => true to exploit a speedy look up with isset().
 			if ( is_numeric( $alias ) && !isset( $this->selectedFields[$field] ) ) {
 				$this->select[] = $field;
 				$this->selectedFields[$field] = true;
 			}
 		}
+
 		return true;
 	}
 
 	/**
 	 * Add a GROUP BY clause to the output.
 	 *
-	 * @access	public
-	 * @param	string	Group By Clause
-	 * @return	boolean	Success
+	 * @param string $groupBy
+	 * @return bool
 	 */
 	public function addGroupBy( $groupBy ) {
 		if ( empty( $groupBy ) ) {
-			throw new \MWException( __METHOD__ . ': An empty group by clause was passed.' );
+			throw new MWException( __METHOD__ . ': An empty group by clause was passed.' );
 		}
+
 		$this->groupBy[] = $groupBy;
+
 		return true;
 	}
 
 	/**
 	 * Add a ORDER BY clause to the output.
 	 *
-	 * @access	public
-	 * @param	string	Order By Clause
-	 * @return	boolean	Success
+	 * @param string $orderBy
+	 * @return bool
 	 */
 	public function addOrderBy( $orderBy ) {
 		if ( empty( $orderBy ) ) {
-			throw new \MWException( __METHOD__ . ': An empty order by clause was passed.' );
+			throw new MWException( __METHOD__ . ': An empty order by clause was passed.' );
 		}
+
 		$this->orderBy[] = $orderBy;
+
 		return true;
 	}
 
 	/**
 	 * Add a JOIN clause to the output.
 	 *
-	 * @access	public
-	 * @param	string	Table Alias
-	 * @param	array	Join Conditions in the format of the join type to the on where condition.  Example: ['JOIN TYPE' => 'this = that']
-	 * @return	boolean	Success
+	 * @param string $tableAlias
+	 * @param array $joinConditions
+	 * @return bool
 	 */
 	public function addJoin( $tableAlias, $joinConditions ) {
 		if ( empty( $tableAlias ) || empty( $joinConditions ) ) {
-			throw new \MWException( __METHOD__ . ': An empty join clause was passed.' );
+			throw new MWException( __METHOD__ . ': An empty join clause was passed.' );
 		}
+
 		if ( isset( $this->join[$tableAlias] ) ) {
-			throw new \MWException( __METHOD__ . ': Attempted to overwrite existing join clause.' );
+			throw new MWException( __METHOD__ . ': Attempted to overwrite existing join clause.' );
 		}
+
 		$this->join[$tableAlias] = $joinConditions;
+
 		return true;
 	}
 
+	public function addJoins( array $joins ) {
+		foreach ( $joins as $alias => $conds ) {
+			$this->addJoin( $alias, $conds );
+		}
+	}
+
 	/**
 	 * Set the limit.
 	 *
-	 * @access	public
-	 * @param	mixed	Integer limit or false to unset.
-	 * @return	boolean	Success
+	 * @param mixed $limit
+	 * @return bool
 	 */
 	public function setLimit( $limit ) {
 		if ( is_numeric( $limit ) ) {
@@ -534,15 +602,15 @@ public function setLimit( $limit ) {
 		} else {
 			$this->limit = false;
 		}
+
 		return true;
 	}
 
 	/**
 	 * Set the offset.
 	 *
-	 * @access	public
-	 * @param	mixed	Integer offset or false to unset.
-	 * @return	boolean	Success
+	 * @param mixed $offset
+	 * @return bool
 	 */
 	public function setOffset( $offset ) {
 		if ( is_numeric( $offset ) ) {
@@ -550,27 +618,26 @@ public function setOffset( $offset ) {
 		} else {
 			$this->offset = false;
 		}
+
 		return true;
 	}
 
 	/**
 	 * Set the ORDER BY direction
 	 *
-	 * @access	public
-	 * @param	string	SQL direction key word.
-	 * @return	boolean	Success
+	 * @param string $direction
+	 * @return bool
 	 */
 	public function setOrderDir( $direction ) {
 		$this->direction = $direction;
+
 		return true;
 	}
 
 	/**
 	 * Set the character set collation.
 	 *
-	 * @access	public
-	 * @param	string	Collation
-	 * @return	void
+	 * @param string $collation
 	 */
 	public function setCollation( $collation ) {
 		$this->collation = $collation;
@@ -579,8 +646,7 @@ public function setCollation( $collation ) {
 	/**
 	 * Return SQL prefixed collation.
 	 *
-	 * @access	public
-	 * @return	string	SQL Collation
+	 * @return string|null
 	 */
 	public function getCollateSQL() {
 		return ( $this->collation !== false ? 'COLLATE ' . $this->collation : null );
@@ -589,18 +655,18 @@ public function getCollateSQL() {
 	/**
 	 * Recursively get and return an array of subcategories.
 	 *
-	 * @access	public
-	 * @param	string	Category Name
-	 * @param	integer	[Optional] Maximum Depth
-	 * @return	array	Subcategories
+	 * @param string $categoryName
+	 * @param int $depth
+	 * @return array
 	 */
 	public static function getSubcategories( $categoryName, $depth = 1 ) {
 		$DB = wfGetDB( DB_REPLICA, 'dpl' );
 
 		if ( $depth > 2 ) {
-			//Hard constrain depth because lots of recursion is bad.
+			// Hard constrain depth because lots of recursion is bad.
 			$depth = 2;
 		}
+
 		$categories = [];
 		$result = $DB->select(
 			[ 'page', 'categorylinks' ],
@@ -618,23 +684,25 @@ public static function getSubcategories( $categoryName, $depth = 1 ) {
 				]
 			]
 		);
+
 		while ( $row = $result->fetchRow() ) {
 			$categories[] = $row['page_title'];
 			if ( $depth > 1 ) {
 				$categories = array_merge( $categories, self::getSubcategories( $row['page_title'], $depth - 1 ) );
 			}
 		}
+
 		$categories = array_unique( $categories );
 		$DB->freeResult( $result );
+
 		return $categories;
 	}
 
 	/**
 	 * Helper method to handle relative timestamps.
 	 *
-	 * @private
-	 * @param	mixed	Integer or string
-	 * @return	integer
+	 * @param mixed $inputDate
+	 * @return int|string
 	 */
 	private function convertTimestamp( $inputDate ) {
 		$timestamp = $inputDate;
@@ -643,28 +711,28 @@ private function convertTimestamp( $inputDate ) {
 				$timestamp = date( 'YmdHis' );
 				break;
 			case 'last hour':
-				$date = new \DateTime();
-				$date->sub( new \DateInterval( 'P1H' ) );
+				$date = new DateTime();
+				$date->sub( new DateInterval( 'P1H' ) );
 				$timestamp = $date->format( 'YmdHis' );
 				break;
 			case 'last day':
-				$date = new \DateTime();
-				$date->sub( new \DateInterval( 'P1D' ) );
+				$date = new DateTime();
+				$date->sub( new DateInterval( 'P1D' ) );
 				$timestamp = $date->format( 'YmdHis' );
 				break;
 			case 'last week':
-				$date = new \DateTime();
-				$date->sub( new \DateInterval( 'P7D' ) );
+				$date = new DateTime();
+				$date->sub( new DateInterval( 'P7D' ) );
 				$timestamp = $date->format( 'YmdHis' );
 				break;
 			case 'last month':
-				$date = new \DateTime();
-				$date->sub( new \DateInterval( 'P1M' ) );
+				$date = new DateTime();
+				$date->sub( new DateInterval( 'P1M' ) );
 				$timestamp = $date->format( 'YmdHis' );
 				break;
 			case 'last year':
-				$date = new \DateTime();
-				$date->sub( new \DateInterval( 'P1Y' ) );
+				$date = new DateTime();
+				$date->sub( new DateInterval( 'P1Y' ) );
 				$timestamp = $date->format( 'YmdHis' );
 				break;
 		}
@@ -672,36 +740,28 @@ private function convertTimestamp( $inputDate ) {
 		if ( is_numeric( $timestamp ) ) {
 			return $this->DB->addQuotes( $timestamp );
 		}
+
 		return 0;
 	}
 
 	/**
 	 * Set SQL for 'addauthor' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _addauthor( $option ) {
-		//Addauthor can not be used with addlasteditor.
+		// Addauthor can not be used with addlasteditor.
 		if ( !isset( $this->parametersProcessed['addlasteditor'] ) || !$this->parametersProcessed['addlasteditor'] ) {
-			$this->addTable( 'revision_actor_temp', 'rev' );
-			$this->addWhere(
-				[
-					$this->tableNames['page'] . '.page_id = rev.revactor_page',
-					'rev.revactor_timestamp = (SELECT MIN(rev_aux_min.revactor_timestamp) FROM ' . $this->tableNames['revision_actor_temp'] . ' AS rev_aux_min WHERE rev_aux_min.revactor_page = rev.revactor_page)'
-				]
+			$this->revisionJoinBuilder->addFieldsFromFirst(
+				[ 'rev_user_text' => 'rev_user_text' ]
 			);
-			$this->_adduser( null, 'rev' );
 		}
 	}
 
 	/**
 	 * Set SQL for 'addcategories' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _addcategories( $option ) {
 		$this->addTable( 'categorylinks', 'cl_gc' );
@@ -710,6 +770,7 @@ private function _addcategories( $option ) {
 				'cats' => "GROUP_CONCAT(DISTINCT cl_gc.cl_to ORDER BY cl_gc.cl_to ASC SEPARATOR ' | ')"
 			]
 		);
+
 		$this->addJoin(
 			'cl_gc',
 			[
@@ -717,48 +778,39 @@ private function _addcategories( $option ) {
 				'page_id = cl_gc.cl_from'
 			]
 		);
+
 		$this->addGroupBy( $this->tableNames['page'] . '.page_id' );
 	}
 
 	/**
 	 * Set SQL for 'addcontribution' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _addcontribution( $option ) {
-		$this->addTable( 'recentchanges', 'rc' );
+		$actorQuery = $this->actorMigration->getJoin( 'rc_user' );
 
-		$field = 'rc.rc_actor';
+		$this->addTables( [ 'rc' => 'recentchanges' ] + $actorQuery['tables'] );
+		$this->addSelect( [
+			'contribution' => 'SUM(ABS(rc_new_len - rc_old_len))',
+			'contributor' => $actorQuery['fields']['rc_user_text']
+		] );
 
-		$this->addSelect(
-			[
-				'contribution'	=> 'SUM(ABS(rc.rc_new_len - rc.rc_old_len))',
-				'contributor'	=> $field
-			]
-		);
-		$this->addWhere(
-			[
-				$this->tableNames['page'] . '.page_id = rc.rc_cur_id'
-			]
-		);
-		$this->addGroupBy( 'rc.rc_cur_id' );
+		$this->addGroupBy( 'rc_cur_id, ' . $actorQuery['fields']['rc_actor'] );
+		$this->addJoins( [ 'rc' => [ 'JOIN', 'page_id = rc_cur_id' ] ] + $actorQuery['joins'] );
 	}
 
 	/**
 	 * Set SQL for 'addeditdate' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _addeditdate( $option ) {
-		$this->addTable( 'revision_actor_temp', 'rev' );
-		$this->addSelect( [ 'rev.revactor_timestamp' ] );
+		$this->addTable( 'revision', 'rev' );
+		$this->addSelect( [ 'rev.rev_timestamp' ] );
 		$this->addWhere(
 			[
-				$this->tableNames['page'] . '.page_id = rev.revactor_page',
+				$this->tableNames['page'] . '.page_id = rev.rev_page',
 			]
 		);
 	}
@@ -766,12 +818,10 @@ private function _addeditdate( $option ) {
 	/**
 	 * Set SQL for 'addfirstcategorydate' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _addfirstcategorydate( $option ) {
-		//@TODO: This should be programmatically determining which categorylink table to use instead of assuming the first one.
+		// @TODO: This should be programmatically determining which categorylink table to use instead of assuming the first one.
 		$this->addSelect(
 			[
 				'cl_timestamp'	=> "DATE_FORMAT(cl1.cl_timestamp, '%Y%m%d%H%i%s')"
@@ -782,30 +832,19 @@ private function _addfirstcategorydate( $option ) {
 	/**
 	 * Set SQL for 'addlasteditor' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _addlasteditor( $option ) {
-		//Addlasteditor can not be used with addauthor.
+		// Addlasteditor can not be used with addauthor.
 		if ( !isset( $this->parametersProcessed['addauthor'] ) || !$this->parametersProcessed['addauthor'] ) {
-			$this->addTable( 'revision_actor_temp', 'rev' );
-			$this->addWhere(
-				[
-					$this->tableNames['page'] . '.page_id = rev.revactor_page',
-					'rev.revactor_timestamp = (SELECT MAX(rev_aux_max.revactor_timestamp) FROM ' . $this->tableNames['revision_actor_temp'] . ' AS rev_aux_max WHERE rev_aux_max.revactor_page = rev.revactor_page)'
-				]
-			);
-			$this->_adduser( null, 'rev' );
+			$this->revisionJoinBuilder->addFieldsFromLast( [ 'rev_user_text' => 'rev_user_text' ] );
 		}
 	}
 
 	/**
 	 * Set SQL for 'addpagecounter' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _addpagecounter( $option ) {
 		if ( class_exists( "\\HitCounters\\Hooks" ) ) {
@@ -815,6 +854,7 @@ private function _addpagecounter( $option ) {
 					"page_counter"	=> "hit_counter.page_counter"
 				]
 			);
+
 			if ( !isset( $this->join['hit_counter'] ) ) {
 				$this->addJoin(
 					'hit_counter',
@@ -830,9 +870,7 @@ private function _addpagecounter( $option ) {
 	/**
 	 * Set SQL for 'addpagesize' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _addpagesize( $option ) {
 		$this->addSelect(
@@ -845,9 +883,7 @@ private function _addpagesize( $option ) {
 	/**
 	 * Set SQL for 'addpagetoucheddate' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _addpagetoucheddate( $option ) {
 		$this->addSelect(
@@ -857,44 +893,26 @@ private function _addpagetoucheddate( $option ) {
 		);
 	}
 
-	/**
-	 * Set SQL for 'adduser' parameter.
-	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @param	string	[Optional] Table Alias
-	 * @return	void
-	 */
-	private function _adduser( $option, $tableAlias = '' ) {
-		$tableAlias = ( !empty( $tableAlias ) ? $tableAlias . '.' : '' );
-		$this->addSelect(
-			[
-				$tableAlias . 'revactor_actor',
-			]
-		);
-	}
-
 	/**
 	 * Set SQL for 'allrevisionsbefore' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _allrevisionsbefore( $option ) {
-		$this->addTable( 'revision_actor_temp', 'rev' );
+		$this->addTable( 'revision', 'rev' );
 		$this->addSelect(
 			[
-				'rev.revactor_rev',
-				'rev.revactor_timestamp'
+				'rev.rev_id',
+				'rev.rev_timestamp'
 			]
 		);
-		$this->addOrderBy( 'rev.revactor_rev' );
+
+		$this->addOrderBy( 'rev.rev_id' );
 		$this->setOrderDir( 'DESC' );
 		$this->addWhere(
 			[
-				$this->tableNames['page'] . '.page_id = rev.revactor_page',
-				'rev.revactor_timestamp < ' . $this->convertTimestamp( $option )
+				$this->tableNames['page'] . '.page_id = rev.rev_page',
+				'rev.rev_timestamp < ' . $this->convertTimestamp( $option )
 			]
 		);
 	}
@@ -902,24 +920,23 @@ private function _allrevisionsbefore( $option ) {
 	/**
 	 * Set SQL for 'allrevisionssince' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _allrevisionssince( $option ) {
-		$this->addTable( 'revision_actor_temp', 'rev' );
+		$this->addTable( 'revision', 'rev' );
 		$this->addSelect(
 			[
-				'rev.revactor_rev',
-				'rev.revactor_timestamp'
+				'rev.rev_id',
+				'rev.rev_timestamp'
 			]
 		);
-		$this->addOrderBy( 'rev.revactor_rev' );
+
+		$this->addOrderBy( 'rev.rev_id' );
 		$this->setOrderDir( 'DESC' );
 		$this->addWhere(
 			[
-				$this->tableNames['page'] . '.page_id = rev.revactor_page',
-				'rev.revactor_timestamp >= ' . $this->convertTimestamp( $option )
+				$this->tableNames['page'] . '.page_id = rev.rev_page',
+				'rev.rev_timestamp >= ' . $this->convertTimestamp( $option )
 			]
 		);
 	}
@@ -927,9 +944,7 @@ private function _allrevisionssince( $option ) {
 	/**
 	 * Set SQL for 'articlecategory' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _articlecategory( $option ) {
 		$this->addWhere( "{$this->tableNames['page']}.page_title IN (SELECT p2.page_title FROM {$this->tableNames['page']} p2 INNER JOIN {$this->tableNames['categorylinks']} clstc ON (clstc.cl_from = p2.page_id AND clstc.cl_to = " . $this->DB->addQuotes( $option ) . ") WHERE p2.page_namespace = 0)" );
@@ -938,34 +953,33 @@ private function _articlecategory( $option ) {
 	/**
 	 * Set SQL for 'categoriesminmax' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _categoriesminmax( $option ) {
 		if ( is_numeric( $option[0] ) ) {
 			$this->addWhere( intval( $option[0] ) . ' <= (SELECT count(*) FROM ' . $this->tableNames['categorylinks'] . ' WHERE ' . $this->tableNames['categorylinks'] . '.cl_from=page_id)' );
 		}
-		if ( is_numeric( $option[1] ) ) {
+
+		if ( isset( $option[1] ) && is_numeric( $option[1] ) ) {
 			$this->addWhere( intval( $option[1] ) . ' >= (SELECT count(*) FROM ' . $this->tableNames['categorylinks'] . ' WHERE ' . $this->tableNames['categorylinks'] . '.cl_from=page_id)' );
 		}
 	}
 
 	/**
-	 * Set SQL for 'category' parameter.  This includes 'category', 'categorymatch', and 'categoryregexp'.
+	 * Set SQL for 'category' parameter. This includes 'category', 'categorymatch', and 'categoryregexp'.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _category( $option ) {
 		$i = 0;
+
 		foreach ( $option as $comparisonType => $operatorTypes ) {
 			foreach ( $operatorTypes as $operatorType => $categoryGroups ) {
 				foreach ( $categoryGroups as $categories ) {
 					if ( !is_array( $categories ) ) {
 						continue;
 					}
+
 					$tableName = ( in_array( '', $categories ) ? 'dpl_clview' : 'categorylinks' );
 					if ( $operatorType == 'AND' ) {
 						foreach ( $categories as $category ) {
@@ -987,9 +1001,11 @@ private function _category( $option ) {
 
 						$joinOn = "{$this->tableNames['page']}.page_id = {$tableAlias}.cl_from AND (";
 						$ors = [];
+
 						foreach ( $categories as $category ) {
 							$ors[] = "{$tableAlias}.cl_to {$comparisonType} " . $this->DB->addQuotes( str_replace( ' ', '_', $category ) );
 						}
+
 						$joinOn .= implode( " {$operatorType} ", $ors );
 						$joinOn .= ')';
 
@@ -1009,9 +1025,7 @@ private function _category( $option ) {
 	/**
 	 * Set SQL for 'notcategory' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _notcategory( $option ) {
 		$i = 0;
@@ -1029,6 +1043,7 @@ private function _notcategory( $option ) {
 						"{$this->tableNames['page']}.page_id = {$tableAlias}.cl_from AND {$tableAlias}.cl_to {$operatorType}" . $this->DB->addQuotes( str_replace( ' ', '_', $category ) )
 					]
 				);
+
 				$this->addWhere(
 					[
 						"{$tableAlias}.cl_to"	=> null
@@ -1041,31 +1056,16 @@ private function _notcategory( $option ) {
 	/**
 	 * Set SQL for 'createdby' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _createdby( $option ) {
-		$this->addTable( 'revision', 'creation_rev' );
-		$this->addTable( 'revision_actor_temp', 'creation_rev_actor' );
-		$this->_adduser( null, 'creation_rev_actor' );
-		$user = new \User;
-
-		$this->addWhere(
-			[
-				$this->DB->addQuotes( $user->newFromName( $option )->getActorId() ) . ' = creation_rev_actor.revactor_actor',
-				'creation_rev_actor.revactor_page = page_id',
-				'creation_rev.rev_parent_id = 0'
-			]
-		);
+		$this->userQueryBuilder->addCreatedByConstraint( $option );
 	}
 
 	/**
 	 * Set SQL for 'distinct' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _distinct( $option ) {
 		if ( $option == 'strict' || $option === true ) {
@@ -1078,29 +1078,29 @@ private function _distinct( $option ) {
 	/**
 	 * Set SQL for 'firstrevisionsince' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _firstrevisionsince( $option ) {
-		$this->addTable( 'revision_actor_temp', 'rev' );
+		$this->addTable( 'revision', 'rev' );
 		$this->addSelect(
 			[
-				'rev.revactor_rev',
-				'rev.revactor_timestamp'
+				'rev.rev_id',
+				'rev.rev_timestamp'
 			]
 		);
+
 		// tell the query optimizer not to look at rows that the following subquery will filter out anyway
 		$this->addWhere(
 			[
-				$this->tableNames['page'] . '.page_id = rev.revactor_page',
-				'rev.revactor_timestamp >= ' . $this->DB->addQuotes( $option )
+				$this->tableNames['page'] . '.page_id = rev.rev_page',
+				'rev.rev_timestamp >= ' . $this->DB->addQuotes( $option )
 			]
 		);
+
 		$this->addWhere(
 			[
-				$this->tableNames['page'] . '.page_id = rev.revactor_page',
-				'rev.revactor_timestamp = (SELECT MIN(rev_aux_snc.revactor_timestamp) FROM ' . $this->tableNames['revision_actor_temp'] . ' AS rev_aux_snc WHERE rev_aux_snc.revactor_page=rev.revactor_page AND rev_aux_snc.revactor_timestamp >= ' . $this->convertTimestamp( $option ) . ')'
+				$this->tableNames['page'] . '.page_id = rev.rev_page',
+				'rev.rev_timestamp = (SELECT MIN(rev_aux_snc.rev_timestamp) FROM ' . $this->tableNames['revision'] . ' AS rev_aux_snc WHERE rev_aux_snc.rev_page=rev.rev_page AND rev_aux_snc.rev_timestamp >= ' . $this->convertTimestamp( $option ) . ')'
 			]
 		);
 	}
@@ -1108,9 +1108,7 @@ private function _firstrevisionsince( $option ) {
 	/**
 	 * Set SQL for 'goal' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _goal( $option ) {
 		if ( $option == 'categories' ) {
@@ -1122,34 +1120,34 @@ private function _goal( $option ) {
 	/**
 	 * Set SQL for 'hiddencategories' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _hiddencategories( $option ) {
-		//@TODO: Unfinished functionality!  Never implemented by original author.
+		// @TODO: Unfinished functionality! Never implemented by original author.
 	}
 
 	/**
 	 * Set SQL for 'imagecontainer' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _imagecontainer( $option ) {
+		$where = [];
+
 		$this->addTable( 'imagelinks', 'ic' );
 		$this->addSelect(
 			[
 				'sortkey'	=> 'ic.il_to'
 			]
 		);
+
 		if ( !$this->parameters->getParameter( 'openreferences' ) ) {
 			$where = [
 				"{$this->tableNames['page']}.page_namespace = " . intval( NS_FILE ),
 				"{$this->tableNames['page']}.page_title = ic.il_to"
 			];
 		}
+
 		$ors = [];
 		foreach ( $option as $linkGroup ) {
 			foreach ( $linkGroup as $link ) {
@@ -1160,6 +1158,7 @@ private function _imagecontainer( $option ) {
 				}
 			}
 		}
+
 		$where[] = '(' . implode( ' OR ', $ors ) . ')';
 		$this->addWhere( $where );
 	}
@@ -1167,22 +1166,25 @@ private function _imagecontainer( $option ) {
 	/**
 	 * Set SQL for 'imageused' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _imageused( $option ) {
+		$where = [];
+
 		if ( $this->parameters->getParameter( 'distinct' ) == 'strict' ) {
 			$this->addGroupBy( 'page_title' );
 		}
+
 		$this->addTable( 'imagelinks', 'il' );
 		$this->addSelect(
 			[
 				'image_sel_title'	=> 'il.il_to'
 			]
 		);
+
 		$where[] = $this->tableNames['page'] . '.page_id = il.il_from';
 		$ors = [];
+
 		foreach ( $option as $linkGroup ) {
 			foreach ( $linkGroup as $link ) {
 				if ( $this->parameters->getParameter( 'ignorecase' ) ) {
@@ -1192,6 +1194,7 @@ private function _imageused( $option ) {
 				}
 			}
 		}
+
 		$where[] = '(' . implode( ' OR ', $ors ) . ')';
 		$this->addWhere( $where );
 	}
@@ -1199,37 +1202,33 @@ private function _imageused( $option ) {
 	/**
 	 * Set SQL for 'lastmodifiedby' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _lastmodifiedby( $option ) {
-	   $user = new \User;
-
-	   $this->addWhere( $this->DB->addQuotes( $user->newFromName( $option )->getActorId() ) . ' = (SELECT revactor_actor FROM ' . $this->tableNames['revision_actor_temp'] . ' WHERE ' . $this->tableNames['revision_actor_temp'] . '.revactor_page=page_id ORDER BY ' . $this->tableNames['revision_actor_temp'] . '.revactor_timestamp DESC LIMIT 1)' );
+		$this->userQueryBuilder->addLastModifiedByConstraint( $option );
 	}
 
 	/**
 	 * Set SQL for 'lastrevisionbefore' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _lastrevisionbefore( $option ) {
-		$this->addTable( 'revision_actor_temp', 'rev' );
-		$this->addSelect( [ 'rev.revactor_rev', 'rev.revactor_timestamp' ] );
+		$this->addTable( 'revision', 'rev' );
+		$this->addSelect( [ 'rev.rev_id', 'rev.rev_timestamp' ] );
+
 		// tell the query optimizer not to look at rows that the following subquery will filter out anyway
 		$this->addWhere(
 			[
-				$this->tableNames['page'] . '.page_id = rev.revactor_page',
-				'rev.revactor_timestamp < ' . $this->convertTimestamp( $option )
+				$this->tableNames['page'] . '.page_id = rev.rev_page',
+				'rev.rev_timestamp < ' . $this->convertTimestamp( $option )
 			]
 		);
+
 		$this->addWhere(
 			[
-				$this->tableNames['page'] . '.page_id = rev.revactor_page',
-				'rev.revactor_timestamp = (SELECT MAX(rev_aux_bef.revactor_timestamp) FROM ' . $this->tableNames['revision_actor_temp'] . ' AS rev_aux_bef WHERE rev_aux_bef.revactor_page=rev.revactor_page AND rev_aux_bef.revactor_timestamp < ' . $this->convertTimestamp( $option ) . ')'
+				$this->tableNames['page'] . '.page_id = rev.rev_page',
+				'rev.rev_timestamp = (SELECT MAX(rev_aux_bef.rev_timestamp) FROM ' . $this->tableNames['revision'] . ' AS rev_aux_bef WHERE rev_aux_bef.rev_page=rev.rev_page AND rev_aux_bef.rev_timestamp < ' . $this->convertTimestamp( $option ) . ')'
 			]
 		);
 	}
@@ -1237,14 +1236,15 @@ private function _lastrevisionbefore( $option ) {
 	/**
 	 * Set SQL for 'linksfrom' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _linksfrom( $option ) {
+		$where = [];
+
 		if ( $this->parameters->getParameter( 'distinct' ) == 'strict' ) {
 			$this->addGroupBy( 'page_title' );
 		}
+
 		if ( $this->parameters->getParameter( 'openreferences' ) ) {
 			$ors = [];
 			foreach ( $option as $linkGroup ) {
@@ -1252,6 +1252,7 @@ private function _linksfrom( $option ) {
 					$ors[] = '(pl_from = ' . $link->getArticleID() . ')';
 				}
 			}
+
 			$where[] = '(' . implode( ' OR ', $ors ) . ')';
 		} else {
 			$this->addTable( 'pagelinks', 'plf' );
@@ -1262,40 +1263,45 @@ private function _linksfrom( $option ) {
 					'sel_ns' => 'pagesrc.page_namespace'
 				]
 			);
+
 			$where = [
 				$this->tableNames['page'] . '.page_namespace = plf.pl_namespace',
 				$this->tableNames['page'] . '.page_title = plf.pl_title',
 				'pagesrc.page_id = plf.pl_from'
 			];
+
 			$ors = [];
 			foreach ( $option as $linkGroup ) {
 				foreach ( $linkGroup as $link ) {
 					$ors[] = 'plf.pl_from = ' . $link->getArticleID();
 				}
 			}
+
 			$where[] = '(' . implode( ' OR ', $ors ) . ')';
 		}
+
 		$this->addWhere( $where );
 	}
 
 	/**
 	 * Set SQL for 'linksto' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _linksto( $option ) {
 		if ( $this->parameters->getParameter( 'distinct' ) == 'strict' ) {
 			$this->addGroupBy( 'page_title' );
 		}
+
 		if ( count( $option ) > 0 ) {
 			$this->addTable( 'pagelinks', 'pl' );
 			$this->addSelect( [ 'sel_title' => 'pl.pl_title', 'sel_ns' => 'pl.pl_namespace' ] );
+
 			foreach ( $option as $index => $linkGroup ) {
 				if ( $index == 0 ) {
 					$where = $this->tableNames['page'] . '.page_id=pl.pl_from AND ';
 					$ors = [];
+
 					foreach ( $linkGroup as $link ) {
 						$_or = '(pl.pl_namespace=' . intval( $link->getNamespace() );
 						if ( strpos( $link->getDbKey(), '%' ) >= 0 ) {
@@ -1303,18 +1309,22 @@ private function _linksto( $option ) {
 						} else {
 							$operator = '=';
 						}
+
 						if ( $this->parameters->getParameter( 'ignorecase' ) ) {
 							$_or .= ' AND LOWER(CAST(pl.pl_title AS char)) ' . $operator . ' LOWER(' . $this->DB->addQuotes( $link->getDbKey() ) . ')';
 						} else {
 							$_or .= ' AND pl.pl_title ' . $operator . ' ' . $this->DB->addQuotes( $link->getDbKey() );
 						}
+
 						$_or .= ')';
 						$ors[] = $_or;
 					}
+
 					$where .= '(' . implode( ' OR ', $ors ) . ')';
 				} else {
 					$where = 'EXISTS(select pl_from FROM ' . $this->tableNames['pagelinks'] . ' WHERE (' . $this->tableNames['pagelinks'] . '.pl_from=page_id AND ';
 					$ors = [];
+
 					foreach ( $linkGroup as $link ) {
 						$_or = '(' . $this->tableNames['pagelinks'] . '.pl_namespace=' . intval( $link->getNamespace() );
 						if ( strpos( $link->getDbKey(), '%' ) >= 0 ) {
@@ -1322,17 +1332,21 @@ private function _linksto( $option ) {
 						} else {
 							$operator = '=';
 						}
+
 						if ( $this->parameters->getParameter( 'ignorecase' ) ) {
 							$_or .= ' AND LOWER(CAST(' . $this->tableNames['pagelinks'] . '.pl_title AS char)) ' . $operator . ' LOWER(' . $this->DB->addQuotes( $link->getDbKey() ) . ')';
 						} else {
 							$_or .= ' AND ' . $this->tableNames['pagelinks'] . '.pl_title ' . $operator . ' ' . $this->DB->addQuotes( $link->getDbKey() );
 						}
+
 						$_or .= ')';
 						$ors[] = $_or;
 					}
+
 					$where .= '(' . implode( ' OR ', $ors ) . ')';
 					$where .= '))';
 				}
+
 				$this->addWhere( $where );
 			}
 		}
@@ -1341,14 +1355,13 @@ private function _linksto( $option ) {
 	/**
 	 * Set SQL for 'notlinksfrom' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _notlinksfrom( $option ) {
 		if ( $this->parameters->getParameter( 'distinct' ) == 'strict' ) {
 			$this->addGroupBy( 'page_title' );
 		}
+
 		if ( $this->parameters->getParameter( 'openreferences' ) ) {
 			$ands = [];
 			foreach ( $option as $linkGroup ) {
@@ -1356,34 +1369,38 @@ private function _notlinksfrom( $option ) {
 					$ands[] = 'pl_from <> ' . intval( $link->getArticleID() ) . ' ';
 				}
 			}
+
 			$where = '(' . implode( ' AND ', $ands ) . ')';
 		} else {
 			$where = 'CONCAT(page_namespace,page_title) NOT IN (SELECT CONCAT(' . $this->tableNames['pagelinks'] . '.pl_namespace,' . $this->tableNames['pagelinks'] . '.pl_title) FROM ' . $this->tableNames['pagelinks'] . ' WHERE ';
 			$ors = [];
+
 			foreach ( $option as $linkGroup ) {
 				foreach ( $linkGroup as $link ) {
 					$ors[] = $this->tableNames['pagelinks'] . '.pl_from = ' . intval( $link->getArticleID() );
 				}
 			}
+
 			$where .= implode( ' OR ', $ors ) . ')';
 		}
+
 		$this->addWhere( $where );
 	}
 
 	/**
 	 * Set SQL for 'notlinksto' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _notlinksto( $option ) {
 		if ( $this->parameters->getParameter( 'distinct' ) == 'strict' ) {
 			$this->addGroupBy( 'page_title' );
 		}
+
 		if ( count( $option ) ) {
 			$where = $this->tableNames['page'] . '.page_id NOT IN (SELECT ' . $this->tableNames['pagelinks'] . '.pl_from FROM ' . $this->tableNames['pagelinks'] . ' WHERE ';
 			$ors = [];
+
 			foreach ( $option as $linkGroup ) {
 				foreach ( $linkGroup as $link ) {
 					$_or = '(' . $this->tableNames['pagelinks'] . '.pl_namespace=' . intval( $link->getNamespace() );
@@ -1392,50 +1409,59 @@ private function _notlinksto( $option ) {
 					} else {
 						$operator = '=';
 					}
+
 					if ( $this->parameters->getParameter( 'ignorecase' ) ) {
 						$_or .= ' AND LOWER(CAST(' . $this->tableNames['pagelinks'] . '.pl_title AS char)) ' . $operator . ' LOWER(' . $this->DB->addQuotes( $link->getDbKey() ) . '))';
 					} else {
 						$_or .= ' AND ' . $this->tableNames['pagelinks'] . '.pl_title ' . $operator . ' ' . $this->DB->addQuotes( $link->getDbKey() ) . ')';
 					}
+
 					$ors[] = $_or;
 				}
 			}
+
 			$where .= '(' . implode( ' OR ', $ors ) . '))';
 		}
-		$this->addWhere( $where );
+
+		$this->addWhere( $where ?? '' );
 	}
 
 	/**
 	 * Set SQL for 'linkstoexternal' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _linkstoexternal( $option ) {
 		if ( $this->parameters->getParameter( 'distinct' ) == 'strict' ) {
 			$this->addGroupBy( 'page_title' );
 		}
+
 		if ( count( $option ) > 0 ) {
 			$this->addTable( 'externallinks', 'el' );
 			$this->addSelect( [ 'el_to' => 'el.el_to' ] );
+
 			foreach ( $option as $index => $linkGroup ) {
 				if ( $index == 0 ) {
 					$where = $this->tableNames['page'] . '.page_id=el.el_from AND ';
 					$ors = [];
+
 					foreach ( $linkGroup as $link ) {
 						$ors[] = 'el.el_to LIKE ' . $this->DB->addQuotes( $link );
 					}
+
 					$where .= '(' . implode( ' OR ', $ors ) . ')';
 				} else {
 					$where = 'EXISTS(SELECT el_from FROM ' . $this->tableNames['externallinks'] . ' WHERE (' . $this->tableNames['externallinks'] . '.el_from=page_id AND ';
 					$ors = [];
+
 					foreach ( $linkGroup as $link ) {
 						$ors[] = $this->tableNames['externallinks'] . '.el_to LIKE ' . $this->DB->addQuotes( $link );
 					}
+
 					$where .= '(' . implode( ' OR ', $ors ) . ')';
 					$where .= '))';
 				}
+
 				$this->addWhere( $where );
 			}
 		}
@@ -1444,62 +1470,48 @@ private function _linkstoexternal( $option ) {
 	/**
 	 * Set SQL for 'maxrevisions' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _maxrevisions( $option ) {
-		$this->addWhere( "((SELECT count(rev_aux3.revactor_page) FROM {$this->tableNames['revision_actor_temp']} AS rev_aux3 WHERE rev_aux3.revactor_page = {$this->tableNames['page']}.page_id) <= {$option})" );
+		$this->addWhere( "((SELECT count(rev_aux3.rev_page) FROM {$this->tableNames['revision']} AS rev_aux3 WHERE rev_aux3.rev_page = {$this->tableNames['page']}.page_id) <= {$option})" );
 	}
 
 	/**
 	 * Set SQL for 'minoredits' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _minoredits( $option ) {
 		if ( isset( $option ) && $option == 'exclude' ) {
-			$this->addTable( 'revision', 'revision' );
-			$this->addWhere( 'revision.rev_minor_edit = 0' );
+			$this->addTable( 'revision', 'rev' );
+			$this->addWhere( 'rev.rev_minor_edit = 0' );
 		}
 	}
 
 	/**
 	 * Set SQL for 'minrevisions' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _minrevisions( $option ) {
-		$this->addWhere( "((SELECT count(rev_aux2.revactor_page) FROM {$this->tableNames['revision_actor_temp']} AS rev_aux2 WHERE rev_aux2.revactor_page = {$this->tableNames['page']}.page_id) >= {$option})" );
+		$this->addWhere( "((SELECT count(rev_aux2.rev_page) FROM {$this->tableNames['revision']} AS rev_aux2 WHERE rev_aux2.rev_page = {$this->tableNames['page']}.page_id) >= {$option})" );
 	}
 
 	/**
 	 * Set SQL for 'modifiedby' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _modifiedby( $option ) {
-		$this->addTable( 'revision_actor_temp', 'change_rev' );
-		$user = new \User;
-
-		$this->addWhere( $this->DB->addQuotes( $user->newFromName( $option )->getActorId() ) . ' = change_rev.revactor_actor AND change_rev.revactor_page = page_id' );
+		$this->userQueryBuilder->addModifiedByConstraint( $option );
 	}
 
 	/**
 	 * Set SQL for 'namespace' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _namespace( $option ) {
-		$option === 0 ?? $option = '0';
 		if ( is_array( $option ) && count( $option ) ) {
 			if ( $this->parameters->getParameter( 'openreferences' ) ) {
 				$this->addWhere(
@@ -1520,48 +1532,34 @@ private function _namespace( $option ) {
 	/**
 	 * Set SQL for 'notcreatedby' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _notcreatedby( $option ) {
-		$this->addTable( 'revision', 'no_creation_rev' );
-		$this->addTable( 'revision_actor_temp', 'no_creation_rev_actor' );
-		$user = new \User;
-
-		$this->addWhere( $this->DB->addQuotes( $user->newFromName( $option )->getActorId() ) . ' != no_creation_rev_actor.revactor_actor AND no_creation_rev_actor.revactor_page = page_id AND no_creation_rev.rev_parent_id = 0' );
+		$this->userQueryBuilder->addNotCreatedByConstraint( $option );
 	}
 
 	/**
 	 * Set SQL for 'notlastmodifiedby' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _notlastmodifiedby( $option ) {
-		$user = new \User;
-		$this->addWhere( $this->DB->addQuotes( $user->newFromName( $option )->getActorId() ) . ' != (SELECT revactor_actor FROM ' . $this->tableNames['revision_actor_temp'] . ' WHERE ' . $this->tableNames['revision_actor_temp'] . '.revactor_page=page_id ORDER BY ' . $this->tableNames['revision_actor_temp'] . '.revactor_timestamp DESC LIMIT 1)' );
+		$this->userQueryBuilder->addNotLastModifiedByConstraint( $option );
 	}
 
 	/**
 	 * Set SQL for 'notmodifiedby' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _notmodifiedby( $option ) {
-		$user = new \User;
-		$this->addWhere( 'NOT EXISTS (SELECT 1 FROM ' . $this->tableNames['revision_actor_temp'] . ' WHERE ' . $this->tableNames['revision_actor_temp'] . '.revactor_page=page_id AND ' . $this->tableNames['revision_actor_temp'] . '.revactor_actor = ' . $this->DB->addQuotes( $user->newFromName( $option )->getActorId() ) . ' LIMIT 1)' );
+		$this->userQueryBuilder->addNotModifiedByConstraint( $option );
 	}
 
 	/**
 	 * Set SQL for 'notnamespace' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _notnamespace( $option ) {
 		if ( is_array( $option ) && count( $option ) ) {
@@ -1584,9 +1582,7 @@ private function _notnamespace( $option ) {
 	/**
 	 * Set SQL for 'count' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _count( $option ) {
 		$this->setLimit( $option );
@@ -1595,9 +1591,7 @@ private function _count( $option ) {
 	/**
 	 * Set SQL for 'offset' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _offset( $option ) {
 		$this->setOffset( $option );
@@ -1606,12 +1600,11 @@ private function _offset( $option ) {
 	/**
 	 * Set SQL for 'order' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _order( $option ) {
 		$orderMethod = $this->parameters->getParameter( 'ordermethod' );
+
 		if ( !empty( $orderMethod ) && is_array( $orderMethod ) && $orderMethod[0] !== 'none' ) {
 			if ( $option === 'descending' || $option === 'desc' ) {
 				$this->setOrderDir( 'DESC' );
@@ -1624,9 +1617,8 @@ private function _order( $option ) {
 	/**
 	 * Set SQL for 'ordercollation' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
+	 * @return bool
 	 */
 	private function _ordercollation( $option ) {
 		$option = mb_strtolower( $option );
@@ -1642,39 +1634,46 @@ private function _ordercollation( $option ) {
 				break;
 			}
 		}
+
 		return true;
 	}
 
 	/**
 	 * Set SQL for 'ordermethod' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _ordermethod( $option ) {
-		$contLang = MediaWikiServices::getInstance()->getContentLanguage();
-
 		if ( $this->parameters->getParameter( 'goal' ) == 'categories' ) {
-			//No order methods for returning categories.
+			// No order methods for returning categories.
 			return true;
 		}
 
-		$namespaces = $contLang->getNamespaces();
-		//$aStrictNs = array_slice((array) Config::getSetting('allowedNamespaces'), 1, count(Config::getSetting('allowedNamespaces')), true);
+		$services = MediaWikiServices::getInstance();
+		$namespaces = $services->getContentLanguage()->getNamespaces();
+
+		// $aStrictNs = array_slice( (array)Config::getSetting( 'allowedNamespaces' ), 1, count( Config::getSetting( 'allowedNamespaces' ) ), true );
+
 		$namespaces = array_slice( $namespaces, 3, count( $namespaces ), true );
 		$_namespaceIdToText = "CASE {$this->tableNames['page']}.page_namespace";
+
 		foreach ( $namespaces as $id => $name ) {
 			$_namespaceIdToText .= ' WHEN ' . intval( $id ) . " THEN " . $this->DB->addQuotes( $name . ':' );
 		}
+
 		$_namespaceIdToText .= ' END';
 
 		$option = (array)$option;
+
+		$willOrderByLastEdit = in_array( 'lastedit', $option );
+		$willOrderByFirstEdit = in_array( 'firstedit', $option );
+
 		foreach ( $option as $orderMethod ) {
 			switch ( $orderMethod ) {
 				case 'category':
 					$this->addOrderBy( 'cl_head.cl_to' );
-					$this->addSelect( [ 'cl_head.cl_to' ] ); //Gives category headings in the result.
+					$this->addSelect( [ 'cl_head.cl_to' ] );
+
 					if ( ( is_array( $this->parameters->getParameter( 'catheadings' ) ) && in_array( '', $this->parameters->getParameter( 'catheadings' ) ) ) || ( is_array( $this->parameters->getParameter( 'catnotheadings' ) ) && in_array( '', $this->parameters->getParameter( 'catnotheadings' ) ) ) ) {
 						$_clTableName = 'dpl_clview';
 						$_clTableAlias = $_clTableName;
@@ -1682,6 +1681,7 @@ private function _ordermethod( $option ) {
 						$_clTableName = 'categorylinks';
 						$_clTableAlias = 'cl_head';
 					}
+
 					$this->addTable( $_clTableName, $_clTableAlias );
 					$this->addJoin(
 						$_clTableAlias,
@@ -1690,6 +1690,7 @@ private function _ordermethod( $option ) {
 							"page_id = cl_head.cl_from"
 						]
 					);
+
 					if ( is_array( $this->parameters->getParameter( 'catheadings' ) ) && count( $this->parameters->getParameter( 'catheadings' ) ) ) {
 						$this->addWhere(
 							[
@@ -1697,6 +1698,7 @@ private function _ordermethod( $option ) {
 							]
 						);
 					}
+
 					if ( is_array( $this->parameters->getParameter( 'catnotheadings' ) ) && count( $this->parameters->getParameter( 'catnotheadings' ) ) ) {
 						$this->addNotWhere(
 							[
@@ -1706,12 +1708,12 @@ private function _ordermethod( $option ) {
 					}
 					break;
 				case 'categoryadd':
-					//@TODO: See TODO in __addfirstcategorydate().
+					// @TODO: See TODO in __addfirstcategorydate().
 					$this->addOrderBy( 'cl1.cl_timestamp' );
 					break;
 				case 'counter':
 					if ( class_exists( "\\HitCounters\\Hooks" ) ) {
-						//If the "addpagecounter" parameter was not used the table and join need to be added now.
+						// If the "addpagecounter" parameter was not used the table and join need to be added now.
 						if ( !array_key_exists( 'hit_counter', $this->tables ) ) {
 							$this->addTable( 'hit_counter', 'hit_counter' );
 
@@ -1725,29 +1727,19 @@ private function _ordermethod( $option ) {
 								);
 							}
 						}
+
 						$this->addOrderBy( 'hit_counter.page_counter' );
 					}
 					break;
 				case 'firstedit':
-					$this->addOrderBy( 'rev.revactor_timestamp' );
-					$this->addTable( 'revision_actor_temp', 'rev' );
-					$this->addSelect(
-						[
-							'rev.revactor_timestamp'
-						]
-					);
-					if ( !$this->revisionAuxWhereAdded ) {
-						$this->addWhere(
-							[
-								"{$this->tableNames['page']}.page_id = rev.revactor_page",
-								"rev.revactor_timestamp = (SELECT MIN(rev_aux.revactor_timestamp) FROM {$this->tableNames['revision_actor_temp']} AS rev_aux WHERE rev_aux.revactor_page=rev.revactor_page)"
-							]
-						);
-					}
-					$this->revisionAuxWhereAdded = true;
+					$this->revisionJoinBuilder->addFieldsFromFirst( [
+						'first_rev_timestamp' => 'rev_timestamp'
+					] );
+
+					$this->addOrderBy( 'first_rev_timestamp' );
 					break;
 				case 'lastedit':
-					if ( \DynamicPageListHooks::isLikeIntersection() ) {
+					if ( DynamicPageListHooks::isLikeIntersection() ) {
 						$this->addOrderBy( 'page_touched' );
 						$this->addSelect(
 							[
@@ -1755,18 +1747,11 @@ private function _ordermethod( $option ) {
 							]
 						);
 					} else {
-						$this->addOrderBy( 'rev.revactor_timestamp' );
-						$this->addTable( 'revision_actor_temp', 'rev' );
-						$this->addSelect( [ 'rev.revactor_timestamp' ] );
-						if ( !$this->revisionAuxWhereAdded ) {
-							$this->addWhere(
-								[
-									"{$this->tableNames['page']}.page_id = rev.revactor_page",
-									"rev.revactor_timestamp = (SELECT MAX(rev_aux.revactor_timestamp) FROM {$this->tableNames['revision_actor_temp']} AS rev_aux WHERE rev_aux.revactor_page = rev.revactor_page)"
-								]
-							);
-						}
-						$this->revisionAuxWhereAdded = true;
+						$this->revisionJoinBuilder->addFieldsFromLast( [
+							'latest_rev_timestamp' => 'rev_timestamp'
+						] );
+
+						$this->addOrderBy( 'latest_rev_timestamp' );
 					}
 					break;
 				case 'pagesel':
@@ -1790,6 +1775,7 @@ private function _ordermethod( $option ) {
 					break;
 				case 'sortkey':
 					$this->addOrderBy( 'sortkey' );
+
 					// If cl_sortkey is null (uncategorized page), generate a sortkey in the usual way (full page name, underscores replaced with spaces).
 					// UTF-8 created problems with non-utf-8 MySQL databases
 					$replaceConcat = "REPLACE(CONCAT({$_namespaceIdToText}, " . $this->tableNames['page'] . ".page_title), '_', ' ')";
@@ -1804,7 +1790,7 @@ private function _ordermethod( $option ) {
 								]
 							);
 						} else {
-							//This runs on the assumption that at least one category parameter was used and that numbering starts at 1.
+							// This runs on the assumption that at least one category parameter was used and that numbering starts at 1.
 							$this->addSelect(
 								[
 									'sortkey' => "IFNULL(cl1.cl_sortkey, {$replaceConcat}) " . $this->getCollateSQL()
@@ -1825,6 +1811,7 @@ private function _ordermethod( $option ) {
 					} else {
 						$this->addOrderBy( "page_title" );
 					}
+
 					$this->addSelect(
 						[
 							'sortkey' => "{$this->tableNames['page']}.page_title " . $this->getCollateSQL()
@@ -1836,11 +1823,11 @@ private function _ordermethod( $option ) {
 					if ( $this->parameters->getParameter( 'openreferences' ) ) {
 						$this->addSelect(
 							[
-								'sortkey' => "REPLACE(CONCAT(IF(pl_namespace  =0, '', CONCAT(" . $_namespaceIdToText . ", ':')), pl_title), '_', ' ') " . $this->getCollateSQL()
+								'sortkey' => "REPLACE(CONCAT(IF(pl_namespace =0, '', CONCAT(" . $_namespaceIdToText . ", ':')), pl_title), '_', ' ') " . $this->getCollateSQL()
 							]
 						);
 					} else {
-						//Generate sortkey like for category links. UTF-8 created problems with non-utf-8 MySQL databases.
+						// Generate sortkey like for category links. UTF-8 created problems with non-utf-8 MySQL databases.
 						$this->addSelect(
 							[
 								'sortkey' => "REPLACE(CONCAT(IF(" . $this->tableNames['page'] . ".page_namespace = 0, '', CONCAT(" . $_namespaceIdToText . ", ':')), " . $this->tableNames['page'] . ".page_title), '_', ' ') " . $this->getCollateSQL()
@@ -1849,10 +1836,26 @@ private function _ordermethod( $option ) {
 					}
 					break;
 				case 'user':
-					$user = new \User;
-					$this->addOrderBy( $user->newFromName( 'rev.revactor_actor' )->getActorId() );
-					$this->addTable( 'revision_actor_temp', 'rev' );
-					$this->_adduser( null, 'rev' );
+					$actorQuery = $this->actorMigration->getJoin( 'rev_user' );
+					$sortField = $actorQuery['fields']['rev_actor'] !== 'NULL' ? 'rev_actor' : 'rev_user_text';
+
+					if ( $willOrderByFirstEdit ) {
+						$this->revisionJoinBuilder->addFieldsFromFirst( [
+							'rev_user_text' => 'rev_user_text',
+							'first_rev_actor' => $sortField
+						] );
+
+						$this->addOrderBy( 'first_rev_actor' );
+					}
+
+					if ( $willOrderByLastEdit ) {
+						$this->revisionJoinBuilder->addFieldsFromLast( [
+							'rev_user_text' => 'rev_user_text',
+							'last_rev_actor' => $sortField
+						] );
+
+						$this->addOrderBy( 'last_rev_actor' );
+					}
 					break;
 				case 'none':
 					break;
@@ -1863,9 +1866,7 @@ private function _ordermethod( $option ) {
 	/**
 	 * Set SQL for 'redirects' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _redirects( $option ) {
 		if ( !$this->parameters->getParameter( 'openreferences' ) ) {
@@ -1891,13 +1892,11 @@ private function _redirects( $option ) {
 	/**
 	 * Set SQL for 'stablepages' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _stablepages( $option ) {
 		if ( function_exists( 'efLoadFlaggedRevs' ) ) {
-			//Do not add this again if 'qualitypages' has already added it.
+			// Do not add this again if 'qualitypages' has already added it.
 			if ( !$this->parametersProcessed['qualitypages'] ) {
 				$this->addJoin(
 					'flaggedpages',
@@ -1907,6 +1906,7 @@ private function _stablepages( $option ) {
 					]
 				);
 			}
+
 			switch ( $option ) {
 				case 'only':
 					$this->addWhere(
@@ -1929,13 +1929,11 @@ private function _stablepages( $option ) {
 	/**
 	 * Set SQL for 'qualitypages' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _qualitypages( $option ) {
 		if ( function_exists( 'efLoadFlaggedRevs' ) ) {
-			//Do not add this again if 'stablepages' has already added it.
+			// Do not add this again if 'stablepages' has already added it.
 			if ( !$this->parametersProcessed['stablepages'] ) {
 				$this->addJoin(
 					'flaggedpages',
@@ -1945,6 +1943,7 @@ private function _qualitypages( $option ) {
 					]
 				);
 			}
+
 			switch ( $option ) {
 				case 'only':
 					$this->addWhere( 'fp_quality >= 1' );
@@ -1959,12 +1958,11 @@ private function _qualitypages( $option ) {
 	/**
 	 * Set SQL for 'title' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _title( $option ) {
 		$ors = [];
+
 		foreach ( $option as $comparisonType => $titles ) {
 			foreach ( $titles as $title ) {
 				if ( $this->parameters->getParameter( 'openreferences' ) ) {
@@ -1980,9 +1978,11 @@ private function _title( $option ) {
 						$_or = "{$this->tableNames['page']}.page_title {$comparisonType}" . $this->DB->addQuotes( $title );
 					}
 				}
+
 				$ors[] = $_or;
 			}
 		}
+
 		$where = '(' . implode( ' OR ', $ors ) . ')';
 		$this->addWhere( $where );
 	}
@@ -1990,12 +1990,11 @@ private function _title( $option ) {
 	/**
 	 * Set SQL for 'nottitle' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _nottitle( $option ) {
 		$ors = [];
+
 		foreach ( $option as $comparisonType => $titles ) {
 			foreach ( $titles as $title ) {
 				if ( $this->parameters->getParameter( 'openreferences' ) ) {
@@ -2011,9 +2010,11 @@ private function _nottitle( $option ) {
 						$_or = "{$this->tableNames['page']}.page_title {$comparisonType}" . $this->DB->addQuotes( $title );
 					}
 				}
+
 				$ors[] = $_or;
 			}
 		}
+
 		$where = 'NOT (' . implode( ' OR ', $ors ) . ')';
 		$this->addWhere( $where );
 	}
@@ -2021,15 +2022,14 @@ private function _nottitle( $option ) {
 	/**
 	 * Set SQL for 'titlegt' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _titlegt( $option ) {
 		$where = '(';
+
 		if ( substr( $option, 0, 2 ) == '=_' ) {
 			if ( $this->parameters->getParameter( 'openreferences' ) ) {
-				$where .= 'pl_title >= ' . $this->DB->addQuotes( substr( $sTitleGE, 2 ) );
+				$where .= 'pl_title >= ' . $this->DB->addQuotes( substr( $option, 2 ) );
 			} else {
 				$where .= $this->tableNames['page'] . '.page_title >= ' . $this->DB->addQuotes( substr( $option, 2 ) );
 			}
@@ -2040,6 +2040,7 @@ private function _titlegt( $option ) {
 				$where .= $this->tableNames['page'] . '.page_title > ' . $this->DB->addQuotes( $option );
 			}
 		}
+
 		$where .= ')';
 		$this->addWhere( $where );
 	}
@@ -2047,12 +2048,11 @@ private function _titlegt( $option ) {
 	/**
 	 * Set SQL for 'titlelt' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _titlelt( $option ) {
 		$where = '(';
+
 		if ( substr( $option, 0, 2 ) == '=_' ) {
 			if ( $this->parameters->getParameter( 'openreferences' ) ) {
 				$where .= 'pl_title <= ' . $this->DB->addQuotes( substr( $option, 2 ) );
@@ -2066,6 +2066,7 @@ private function _titlelt( $option ) {
 				$where .= $this->tableNames['page'] . '.page_title < ' . $this->DB->addQuotes( $option );
 			}
 		}
+
 		$where .= ')';
 		$this->addWhere( $where );
 	}
@@ -2073,18 +2074,18 @@ private function _titlelt( $option ) {
 	/**
 	 * Set SQL for 'usedby' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _usedby( $option ) {
 		if ( $this->parameters->getParameter( 'openreferences' ) ) {
 			$ors = [];
+
 			foreach ( $option as $linkGroup ) {
 				foreach ( $linkGroup as $link ) {
 					$ors[] = 'tpl_from = ' . intval( $link->getArticleID() );
 				}
 			}
+
 			$where = '(' . implode( ' OR ', $ors ) . ')';
 		} else {
 			$this->addTable( 'templatelinks', 'tpl' );
@@ -2093,38 +2094,43 @@ private function _usedby( $option ) {
 			$where = $this->tableNames['page'] . '.page_namespace = tpl.tl_namespace AND ' .
 					 $this->tableNames['page'] . '.page_title = tpl.tl_title AND tplsrc.page_id = tpl.tl_from AND ';
 			$ors = [];
+
 			foreach ( $option as $linkGroup ) {
 				foreach ( $linkGroup as $link ) {
 					$ors[] = 'tpl.tl_from = ' . intval( $link->getArticleID() );
 				}
 			}
+
 			$where .= '(' . implode( ' OR ', $ors ) . ')';
 		}
+
 		$this->addWhere( $where );
 	}
 
 	/**
 	 * Set SQL for 'uses' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _uses( $option ) {
 		$this->addTable( 'templatelinks', 'tl' );
 		$where = $this->tableNames['page'] . '.page_id=tl.tl_from AND (';
 		$ors = [];
+
 		foreach ( $option as $linkGroup ) {
 			foreach ( $linkGroup as $link ) {
 				$_or = '(tl.tl_namespace=' . intval( $link->getNamespace() );
+
 				if ( $this->parameters->getParameter( 'ignorecase' ) ) {
 					$_or .= " AND LOWER(CAST(tl.tl_title AS char))=LOWER(" . $this->DB->addQuotes( $link->getDbKey() ) . '))';
 				} else {
 					$_or .= " AND tl.tl_title=" . $this->DB->addQuotes( $link->getDbKey() ) . ')';
 				}
+
 				$ors[] = $_or;
 			}
 		}
+
 		$where .= implode( ' OR ', $ors ) . ')';
 		$this->addWhere( $where );
 	}
@@ -2132,17 +2138,17 @@ private function _uses( $option ) {
 	/**
 	 * Set SQL for 'notuses' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _notuses( $option ) {
 		if ( count( $option ) > 0 ) {
 			$where = $this->tableNames['page'] . '.page_id NOT IN (SELECT ' . $this->tableNames['templatelinks'] . '.tl_from FROM ' . $this->tableNames['templatelinks'] . ' WHERE (';
 			$ors = [];
+
 			foreach ( $option as $linkGroup ) {
 				foreach ( $linkGroup as $link ) {
 					$_or = '(' . $this->tableNames['templatelinks'] . '.tl_namespace=' . intval( $link->getNamespace() );
+
 					if ( $this->parameters->getParameter( 'ignorecase' ) ) {
 						$_or .= ' AND LOWER(CAST(' . $this->tableNames['templatelinks'] . '.tl_title AS char))=LOWER(' . $this->DB->addQuotes( $link->getDbKey() ) . '))';
 					} else {
@@ -2151,8 +2157,10 @@ private function _notuses( $option ) {
 					$ors[] = $_or;
 				}
 			}
+
 			$where .= implode( ' OR ', $ors ) . '))';
 		}
-		$this->addWhere( $where );
+
+		$this->addWhere( $where ?? '' );
 	}
 }
diff --git a/includes/RevisionJoinBuilder.php b/includes/RevisionJoinBuilder.php
new file mode 100644
index 00000000..972b1075
--- /dev/null
+++ b/includes/RevisionJoinBuilder.php
@@ -0,0 +1,123 @@
+<?php
+
+namespace DPL;
+
+use ActorMigration;
+use CommentStore;
+use Wikimedia\Rdbms\IDatabase;
+
+class RevisionJoinBuilder {
+	/** @var IDatabase */
+	private $dbr;
+
+	/** @var ActorMigration */
+	private $actorMigration;
+
+	/** @var CommentStore */
+	private $commentStore;
+
+	/**
+	 * List of fields to select from the first revision of the article, keyed by alias.
+	 * @var string[]
+	 */
+	private $firstRevisionFields = [];
+
+	/**
+	 * List of fields to select from the last revision of the article, keyed by alias.
+	 * @var string[]
+	 */
+	private $lastRevisionFields = [];
+
+	public function __construct(
+		IDatabase $dbr,
+		ActorMigration $actorMigration,
+		CommentStore $commentStore
+	) {
+		$this->dbr = $dbr;
+		$this->actorMigration = $actorMigration;
+		$this->commentStore = $commentStore;
+	}
+
+	public function addFieldsFromFirst( array $fields ): void {
+		$this->firstRevisionFields += $fields;
+	}
+
+	public function addFieldsFromLast( array $fields ): void {
+		$this->lastRevisionFields += $fields;
+	}
+
+	public function getQueryInfo(): array {
+		$queryInfo = [
+			'fields' => [],
+			'tables' => [],
+			'joins' => [],
+		];
+
+		return array_merge_recursive(
+			$queryInfo,
+			$this->addRevisionQueryInfo(
+				'latest_rev',
+				$this->lastRevisionFields,
+				[ 'rev_id=page_latest' ]
+			),
+			$this->addRevisionQueryInfo(
+				'first_rev',
+				$this->firstRevisionFields,
+				[
+					// @phan-suppress-next-line PhanPluginMixedKeyNoKey
+					'rev_page=page_id',
+					'rev_parent_id' => 0,
+				]
+			)
+		);
+	}
+
+	private function addRevisionQueryInfo(
+		string $tableAlias,
+		array $fieldsByAlias,
+		array $joinConds
+	): array {
+		if ( !$fieldsByAlias ) {
+			return [];
+		}
+
+		$fieldsByAlias += [ 'rev_id', 'rev_page', 'rev_parent_id' ];
+
+		$actorQuery = $this->actorMigration->getJoin( 'rev_user' );
+		$commentQuery = $this->commentStore->getJoin( 'rev_comment' );
+
+		// Ensure we correctly fetch aliased fields such as rev_user
+		// from the revision_actor_temp table if it is active.
+		$actorFields = array_keys( $actorQuery['fields'] );
+		$revFields = array_diff( $fieldsByAlias, $actorFields );
+
+		// Since multiple instances of the revision and associated actor tables may be used per
+		// query, join on the derived result of an aliased subquery to avoid naming conflicts.
+		$revQuery = $this->dbr->buildSelectSubquery(
+			[ $tableAlias => 'revision' ] + $actorQuery['tables'] + $commentQuery['tables'],
+			$actorQuery['fields'] + $commentQuery['fields'] + array_values( $revFields ),
+			[],
+			__METHOD__,
+			[],
+			$actorQuery['joins'] + $commentQuery['joins']
+		);
+
+		$fieldsWithPrefix = [];
+		$quotedTableAlias = $this->dbr->addIdentifierQuotes( $tableAlias );
+
+		foreach ( $fieldsByAlias as $alias => $revFieldName ) {
+			$quotedRevField = $this->dbr->addIdentifierQuotes( $revFieldName );
+			$fieldsWithPrefix[$alias] = "$quotedTableAlias.$quotedRevField";
+		}
+
+		return [
+			'fields' => $fieldsWithPrefix,
+			'tables' => [
+				$tableAlias => $revQuery
+			],
+			'joins' => [
+				$tableAlias => [ 'JOIN', $joinConds ]
+			]
+		];
+	}
+}
diff --git a/includes/UpdateArticle.php b/includes/UpdateArticle.php
index 5b0e45b4..812402f0 100644
--- a/includes/UpdateArticle.php
+++ b/includes/UpdateArticle.php
@@ -1,20 +1,20 @@
 <?php
-/**
- * DynamicPageList3
- * DPL UpdateArticle Class
- *
- * @license		GPL-2.0-or-later
- * @package		DynamicPageList3
- *
- */
 
 namespace DPL;
 
+use Article;
+use CommentStoreComment;
+use MediaWiki\MediaWikiServices;
+use MediaWiki\Revision\SlotRecord;
+use ReadOnlyError;
+use RequestContext;
+use Title;
+
 class UpdateArticle {
 	/**
 	 * this fucntion hast three tasks (depending on $exec):
 	 * (1) show an edit dialogue for template fields (exec = edit)
-	 * (2) set template parameters to  values specified in the query (exec=set)v
+	 * (2) set template parameters to values specified in the query (exec=set)v
 	 * (2) preview the source code including any changes of these parameters made in the edit form or with other changes (exec=preview)
 	 * (3) save the article with the changed value set or with other changes (exec=save)
 	 * "other changes" means that a regexp can be applied to the source text or arbitrary text can be
@@ -23,71 +23,75 @@ class UpdateArticle {
 	public static function updateArticleByRule( $title, $text, $rulesText ) {
 		// we use ; as command delimiter; \; stands for a semicolon
 		// \n is translated to a real linefeed
-		$rulesText       = str_replace( ";", '°', $rulesText );
-		$rulesText       = str_replace( '\°', ';', $rulesText );
-		$rulesText       = str_replace( "\\n", "\n", $rulesText );
-		$rules           = explode( '°', $rulesText );
-		$exec            = 'edit';
-		$replaceThis     = '';
-		$replacement     = '';
-		$after           = '';
-		$insertionAfter  = '';
-		$before          = '';
+		$rulesText = str_replace( ";", '°', $rulesText );
+		$rulesText = str_replace( '\°', ';', $rulesText );
+		$rulesText = str_replace( "\\n", "\n", $rulesText );
+		$rules = explode( '°', $rulesText );
+		$exec = 'edit';
+		$replaceThis = '';
+		$replacement = '';
+		$after = '';
+		$insertionAfter = '';
+		$before = '';
 		$insertionBefore = '';
-		$template        = '';
-		$parameter       = [];
-		$value           = [];
-		$afterparm       = [];
-		$format          = [];
-		$preview         = [];
-		$save            = [];
-		$tooltip         = [];
-		$optional        = [];
-
-		$lastCmd         = '';
-		$message         = '';
-		$summary         = '';
-		$editForm        = false;
-		$action          = '';
-		$hidden          = [];
-		$legendPage      = '';
+		$template = '';
+		$parameter = [];
+		$value = [];
+		$afterparm = [];
+		$format = [];
+		$preview = [];
+		$save = [];
+		$tooltip = [];
+		$optional = [];
+
+		$lastCmd = '';
+		$message = '';
+		$summary = '';
+		$editForm = false;
+		$action = '';
+		$hidden = [];
+		$legendPage = '';
 		$instructionPage = '';
-		$table           = '';
-		$fieldFormat     = '';
+		$table = '';
+		$fieldFormat = '';
 
-		// $message .= 'updaterules=<pre><nowiki>';
 		$nr = -1;
 		foreach ( $rules as $rule ) {
 			if ( preg_match( '/^\s*#/', $rule ) > 0 ) {
-				continue; // # is comment symbol
+				continue;
 			}
 
-			$rule = preg_replace( '/^[\s]*/', '', $rule ); // strip leading white space
-			$cmd  = preg_split( "/ +/", $rule, 2 );
+			$rule = preg_replace( '/^[\s]*/', '', $rule );
+			$cmd = preg_split( "/ +/", $rule, 2 );
+
 			if ( count( $cmd ) > 1 ) {
 				$arg = $cmd[1];
 			} else {
 				$arg = '';
 			}
+
 			$cmd[0] = trim( $cmd[0] );
 
-			// after ... insert ...     ,   before ... insert ...
+			// after ... insert ..., before ... insert ...
 			if ( $cmd[0] == 'before' ) {
-				$before  = $arg;
+				$before = $arg;
 				$lastCmd = 'B';
 			}
 			if ( $cmd[0] == 'after' ) {
-				$after   = $arg;
+				$after = $arg;
 				$lastCmd = 'A';
 			}
+
 			if ( $cmd[0] == 'insert' && $lastCmd != '' ) {
 				if ( $lastCmd == 'A' ) {
 					$insertionAfter = $arg;
 				}
+
 				if ( $lastCmd == 'B' ) {
 					$insertionBefore = $arg;
 				}
 			}
+
 			if ( $cmd[0] == 'template' ) {
 				$template = $arg;
 			}
@@ -99,39 +103,49 @@ public static function updateArticleByRule( $title, $text, $rulesText ) {
 					$afterparm[$nr] = [
 						$parameter[$nr - 1]
 					];
-					$n              = $nr - 1;
+
+					$n = $nr - 1;
 					while ( $n > 0 && array_key_exists( $n, $optional ) ) {
 						$n--;
 						$afterparm[$nr][] = $parameter[$n];
 					}
 				}
 			}
+
 			if ( $cmd[0] == 'value' ) {
 				$value[$nr] = $arg;
 			}
+
 			if ( $cmd[0] == 'format' ) {
 				$format[$nr] = $arg;
 			}
+
 			if ( $cmd[0] == 'tooltip' ) {
 				$tooltip[$nr] = $arg;
 			}
+
 			if ( $cmd[0] == 'optional' ) {
 				$optional[$nr] = true;
 			}
+
 			if ( $cmd[0] == 'afterparm' ) {
 				$afterparm[$nr] = [
 					$arg
 				];
 			}
+
 			if ( $cmd[0] == 'legend' ) {
 				$legendPage = $arg;
 			}
+
 			if ( $cmd[0] == 'instruction' ) {
 				$instructionPage = $arg;
 			}
+
 			if ( $cmd[0] == 'table' ) {
 				$table = $arg;
 			}
+
 			if ( $cmd[0] == 'field' ) {
 				$fieldFormat = $arg;
 			}
@@ -139,6 +153,7 @@ public static function updateArticleByRule( $title, $text, $rulesText ) {
 			if ( $cmd[0] == 'replace' ) {
 				$replaceThis = $arg;
 			}
+
 			if ( $cmd[0] == 'by' ) {
 				$replacement = $arg;
 			}
@@ -146,15 +161,19 @@ public static function updateArticleByRule( $title, $text, $rulesText ) {
 			if ( $cmd[0] == 'editform' ) {
 				$editForm = $arg;
 			}
+
 			if ( $cmd[0] == 'action' ) {
 				$action = $arg;
 			}
+
 			if ( $cmd[0] == 'hidden' ) {
 				$hidden[] = $arg;
 			}
+
 			if ( $cmd[0] == 'preview' ) {
 				$preview[] = $arg;
 			}
+
 			if ( $cmd[0] == 'save' ) {
 				$save[] = $arg;
 			}
@@ -162,6 +181,7 @@ public static function updateArticleByRule( $title, $text, $rulesText ) {
 			if ( $cmd[0] == 'summary' ) {
 				$summary = $arg;
 			}
+
 			if ( $cmd[0] == 'exec' ) {
 				$exec = $arg; // desired action (set or edit or preview)
 			}
@@ -172,16 +192,16 @@ public static function updateArticleByRule( $title, $text, $rulesText ) {
 			if ( $replaceThis != '' ) {
 				$summary .= "\n replace $replaceThis\n by $replacement";
 			}
+
 			if ( $before != '' ) {
-				$summary .= "\n before  $before\n insertionBefore";
+				$summary .= "\n before $before\n insertionBefore";
 			}
+
 			if ( $after != '' ) {
-				$summary .= "\n after   $after\n insertionAfter";
+				$summary .= "\n after $after\n insertionAfter";
 			}
 		}
 
-		// $message.= '</nowiki></pre>';
-
 		// perform changes to the wiki source text =======================================
 
 		if ( $replaceThis != '' ) {
@@ -198,86 +218,109 @@ public static function updateArticleByRule( $title, $text, $rulesText ) {
 
 		// deal with template parameters =================================================
 
-		global $wgRequest, $wgUser;
+		global $wgRequest;
 
-		if ( $template != '' ) {
+		$user = RequestContext::getMain()->getUser();
 
+		if ( $template != '' ) {
 			if ( $exec == 'edit' ) {
-				$tpv        = self::getTemplateParmValues( $text, $template );
+				$tpv = self::getTemplateParmValues( $text, $template );
 				$legendText = '';
+
 				if ( $legendPage != '' ) {
 					$legendTitle = '';
-					global $wgParser, $wgUser;
-					$parser = clone $wgParser;
+
+					$parser = clone MediaWikiServices::getInstance()->getParser();
+
 					LST::text( $parser, $legendPage, $legendTitle, $legendText );
 					$legendText = preg_replace( '/^.*?\<section\s+begin\s*=\s*legend\s*\/\>/s', '', $legendText );
 					$legendText = preg_replace( '/\<section\s+end\s*=\s*legend\s*\/\>.*/s', '', $legendText );
 				}
+
 				$instructionText = '';
-				$instructions    = [];
+				$instructions = [];
+
 				if ( $instructionPage != '' ) {
 					$instructionTitle = '';
-					global $wgParser, $wgUser;
-					$parser = clone $wgParser;
+
+					$parser = clone MediaWikiServices::getInstance()->getParser();
+
 					LST::text( $parser, $instructionPage, $instructionTitle, $instructionText );
 					$instructions = self::getTemplateParmValues( $instructionText, 'Template field' );
 				}
+
 				// construct an edit form containing all template invocations
 				$form = "<html><form method=post action=\"$action\" $editForm>\n";
+
 				foreach ( $tpv as $call => $tplValues ) {
 					$form .= "<table $table>\n";
 					foreach ( $parameter as $nr => $parm ) {
 						// try to extract legend from the docs of the template
 						$myToolTip = '';
+
 						if ( array_key_exists( $nr, $tooltip ) ) {
 							$myToolTip = $tooltip[$nr];
 						}
+
 						$myInstruction = '';
-						$myType        = '';
+						$myType = '';
+
 						foreach ( $instructions as $instruct ) {
 							if ( array_key_exists( 'field', $instruct ) && $instruct['field'] == $parm ) {
 								if ( array_key_exists( 'doc', $instruct ) ) {
 									$myInstruction = $instruct['doc'];
 								}
+
 								if ( array_key_exists( 'type', $instruct ) ) {
 									$myType = $instruct['type'];
 								}
 								break;
 							}
 						}
+
 						$myFormat = '';
 						if ( array_key_exists( $nr, $format ) ) {
 							$myFormat = $format[$nr];
 						}
+
 						$myOptional = array_key_exists( $nr, $optional );
 						if ( $legendText != '' && $myToolTip == '' ) {
 							$myToolTip = preg_replace( '/^.*\<section\s+begin\s*=\s*' . preg_quote( $parm, '/' ) . '\s*\/\>/s', '', $legendText );
+
 							if ( strlen( $myToolTip ) == strlen( $legendText ) ) {
 								$myToolTip = '';
 							} else {
 								$myToolTip = preg_replace( '/\<section\s+end\s*=\s*' . preg_quote( $parm, '/' ) . '\s*\/\>.*/s', '', $myToolTip );
 							}
 						}
+
 						$myValue = '';
 						if ( array_key_exists( $parm, $tpv[$call] ) ) {
 							$myValue = $tpv[$call][$parm];
 						}
+
 						$form .= self::editTemplateCall( $text, $template, $call, $parm, $myType, $myValue, $myFormat, $myToolTip, $myInstruction, $myOptional, $fieldFormat );
 					}
+
 					$form .= "</table>\n<br/><br/>";
 				}
+
 				foreach ( $hidden as $hide ) {
 					$form .= "<input type='hidden' " . $hide . " />";
 				}
-				$form .= "<input type='hidden' name='wpEditToken' value='{$wgUser->getEditToken()}'/>";
+
+				$form .= "<input type='hidden' name='wpEditToken' value='{$user->getEditToken()}'/>";
 				foreach ( $preview as $prev ) {
 					$form .= "<input type='submit' " . $prev . " /> ";
 				}
+
 				$form .= "</form></html>\n";
+
 				return $form;
 			} elseif ( $exec == 'set' || $exec == 'preview' ) {
 				// loop over all invocations and parameters, this could be improved to enhance performance
 				$matchCount = 10;
+
 				for ( $call = 0; $call < 10; $call++ ) {
 					foreach ( $parameter as $nr => $parm ) {
 						// set parameters to values specified in the dpl source or get them from the http request
@@ -289,33 +332,41 @@ public static function updateArticleByRule( $title, $text, $rulesText ) {
 							}
 							$myValue = $wgRequest->getVal( urlencode( $call . '_' . $parm ), '' );
 						}
-						$myOptional  = array_key_exists( $nr, $optional );
+
+						$myOptional = array_key_exists( $nr, $optional );
 						$myAfterParm = [];
+
 						if ( array_key_exists( $nr, $afterparm ) ) {
 							$myAfterParm = $afterparm[$nr];
 						}
-						$text = self::updateTemplateCall( $matchCount, $text, $template, $call, $parm, $myValue, $myAfterParm, $myOptional );
+
+						$text = self::updateTemplateCall( $matchCount, $text, $template, $call, $parm, $myValue ?? '', $myAfterParm, $myOptional );
 					}
+
 					if ( $exec == 'set' ) {
-						break; // values taken from dpl text only populate the first invocation
+						break;
 					}
 				}
 			}
 		}
 
 		if ( $exec == 'set' ) {
-			return self::updateArticle( $title, $text, $summary );
+			return self::doUpdateArticle( $title, $text, $summary );
 		} elseif ( $exec == 'preview' ) {
 			global $wgScriptPath, $wgRequest;
-			$titleX   = \Title::newFromText( $title );
-			$articleX = new \Article( $titleX );
-			$form     = '<html>
+
+			$titleX = Title::newFromText( $title );
+			$articleX = new Article( $titleX );
+
+			$userOptionsLookup = MediaWikiServices::getInstance()->getUserOptionsLookup();
+
+			$form = '<html>
 	<form id="editform" name="editform" method="post" action="' . $wgScriptPath . '/index.php?title=' . urlencode( $title ) . '&action=submit" enctype="multipart/form-data">
 		<input type="hidden" value="" name="wpSection" />
 		<input type="hidden" value="' . wfTimestampNow() . '" name="wpStarttime" />
-		<input type="hidden" value="' . $articleX->getTimestamp() . '" name="wpEdittime" />
+		<input type="hidden" value="' . $articleX->getPage()->getTimestamp() . '" name="wpEdittime" />
 		<input type="hidden" value="" name="wpScrolltop" id="wpScrolltop" />
-		<textarea tabindex="1" accesskey="," name="wpTextbox1" id="wpTextbox1" rows="' . $wgUser->getIntOption( 'rows' ) . '" cols="' . $wgUser->getIntOption( 'cols' ) . '" >' . htmlspecialchars( $text ) . '</textarea>
+		<textarea tabindex="1" accesskey="," name="wpTextbox1" id="wpTextbox1" rows="' . $userOptionsLookup->getIntOption( $user, 'rows' ) . '" cols="' . $userOptionsLookup->getIntOption( $user, 'cols' ) . '" >' . htmlspecialchars( $text ) . '</textarea>
 		<input type="hidden" name="wpSummary value="' . $summary . '" id="wpSummary" />
 		<input name="wpAutoSummary" type="hidden" value="" />
 		<input id="wpSave" name="wpSave" type="submit" value="Save page" accesskey="s" title="Save your changes [s]" />
@@ -324,27 +375,44 @@ public static function updateArticleByRule( $title, $text, $rulesText ) {
 </html>';
 			return $form;
 		}
+
 		return "exec must be one of the following: edit, preview, set";
 	}
 
-	private static function updateArticle( $title, $text, $summary ) {
-		global $wgUser, $wgRequest, $wgOut;
+	private static function doUpdateArticle( $title, $text, $summary ) {
+		global $wgRequest, $wgOut;
+
+		$user = RequestContext::getMain()->getUser();
 
-		if ( !$wgUser->matchEditToken( $wgRequest->getVal( 'wpEditToken' ) ) ) {
+		if ( !$user->matchEditToken( $wgRequest->getVal( 'wpEditToken' ) ) ) {
 			$wgOut->addWikiMsg( 'sessionfailure' );
+
 			return 'session failure';
 		}
 
-		$titleX = \Title::newFromText( $title );
-		$permission_errors = $titleX->getUserPermissionsErrors( 'edit', $wgUser );
+		$titleX = Title::newFromText( $title );
+		$permission_errors = MediaWikiServices::getInstance()->getPermissionManager()->getPermissionErrors( 'edit', $user, $titleX );
+
 		if ( count( $permission_errors ) == 0 ) {
-			$articleX = \WikiPage::factory( $titleX );
-			$articleXContent = \ContentHandler::makeContent( $text, $titleX );
-			$articleX->doEditContent( $articleXContent, $summary, EDIT_UPDATE | EDIT_DEFER_UPDATES | EDIT_AUTOSUMMARY );
-			$wgOut->redirect( $titleX->getFullUrl( $articleX->isRedirect() ? 'redirect=no' : '' ) );
+			$wikiPageFactory = MediaWikiServices::getInstance()->getWikiPageFactory();
+
+			$page = $wikiPageFactory->newFromTitle( $titleX );
+			$updater = $page->newPageUpdater( $user );
+			$content = $page->getContentHandler()->makeContent( $text, $titleX );
+			$updater->setContent( SlotRecord::MAIN, $content );
+			$comment = CommentStoreComment::newUnsavedComment( $summary );
+
+			$updater->saveRevision(
+				$comment,
+				EDIT_UPDATE | EDIT_DEFER_UPDATES | EDIT_AUTOSUMMARY
+			);
+
+			$wgOut->redirect( $titleX->getFullUrl( $page->isRedirect() ? 'redirect=no' : '' ) );
+
 			return '';
 		} else {
 			$wgOut->showPermissionsErrorPage( $permission_errors );
+
 			return 'permission error';
 		}
 	}
@@ -352,19 +420,24 @@ private static function updateArticle( $title, $text, $summary ) {
 	private static function editTemplateCall( $text, $template, $call, $parameter, $type, $value, $format, $legend, $instruction, $optional, $fieldFormat ) {
 		$matches = [];
 		$nlCount = preg_match_all( '/\n/', $value, $matches );
+
 		if ( $nlCount > 0 ) {
 			$rows = $nlCount + 1;
 		} else {
 			$rows = floor( strlen( $value ) / 50 ) + 1;
 		}
+
 		if ( preg_match( '/rows\s*=/', $format ) <= 0 ) {
 			$format .= " rows=$rows";
 		}
+
 		$cols = 50;
 		if ( preg_match( '/cols\s*=/', $format ) <= 0 ) {
 			$format .= " cols=$cols";
 		}
+
 		$textArea = "<textarea name=\"" . urlencode( $call . '_' . $parameter ) . "\" $format/>" . htmlspecialchars( $value ) . "</textarea>";
+
 		return str_replace( '%NAME%', htmlspecialchars( str_replace( '_', ' ', $parameter ) ), str_replace( '%TYPE%', $type, str_replace( '%INPUT%', $textArea, str_replace( '%LEGEND%', "</html>" . htmlspecialchars( $legend ) . "<html>", str_replace( '%INSTRUCTION%', "</html>" . htmlspecialchars( $instruction ) . "<html>", $fieldFormat ) ) ) ) );
 	}
 
@@ -372,39 +445,44 @@ private static function editTemplateCall( $text, $template, $call, $parameter, $
 	 * return an array of template invocations; each element is an associative array of parameter and value
 	 */
 	private static function getTemplateParmValues( $text, $template ) {
-		$matches   = [];
+		$matches = [];
 		$noMatches = preg_match_all( '/\{\{\s*' . preg_quote( $template, '/' ) . '\s*[|}]/i', $text, $matches, PREG_OFFSET_CAPTURE );
+
 		if ( $noMatches <= 0 ) {
 			return '';
 		}
+
 		$textLen = strlen( $text );
-		$tval    = []; // the result array of template values
-		$call    = -1; // index for tval
+		$tval = [];
+		$call = -1;
 
 		foreach ( $matches as $matchA ) {
 			foreach ( $matchA as $matchB ) {
-				$match         = $matchB[0];
-				$start         = $matchB[1];
+				$match = $matchB[0];
+				$start = $matchB[1];
 				$tval[++$call] = [];
-				$nr            = 0; // number of parameter if no name given
-				$parmValue     = '';
-				$parmName      = '';
-				$parm          = '';
+				$nr = 0;
+				$parmValue = '';
+				$parmName = '';
+				$parm = '';
 
 				if ( $match[strlen( $match ) - 1] == '}' ) {
-					break; // template was called without parameters, continue with next invocation
+					break;
 				}
 
 				// search to the end of the template call
 				$cbrackets = 2;
+
 				for ( $i = $start + strlen( $match ); $i < $textLen; $i++ ) {
 					$c = $text[$i];
 					if ( $c == '{' || $c == '[' ) {
-						$cbrackets++; // we count both types of brackets
+						$cbrackets++;
 					}
+
 					if ( $c == '}' || $c == ']' ) {
 						$cbrackets--;
 					}
+
 					if ( ( $cbrackets == 2 && $c == '|' ) || ( $cbrackets == 1 && $c == '}' ) ) {
 						// parameter (name or value) found
 						if ( $parmName == '' ) {
@@ -412,9 +490,11 @@ private static function getTemplateParmValues( $text, $template ) {
 						} else {
 							$tval[$call][$parmName] = trim( $parmValue );
 						}
-						$parmName  = '';
+
+						$parmName = '';
 						$parmValue = '';
-						$parm      = '';
+						$parm = '';
+
 						continue;
 					} else {
 						if ( $parmName == '' ) {
@@ -425,13 +505,15 @@ private static function getTemplateParmValues( $text, $template ) {
 							$parmValue .= $c;
 						}
 					}
+
 					$parm .= $c;
 					if ( $cbrackets == 0 ) {
-						break; // end of parameter list
+						break;
 					}
 				}
 			}
 		}
+
 		return $tval;
 	}
 
@@ -444,46 +526,54 @@ private static function updateTemplateCall( &$matchCount, $text, $template, $cal
 			return $text;
 		}
 
-		$matches   = [];
+		$matches = [];
 		$noMatches = preg_match_all( '/\{\{\s*' . preg_quote( $template, '/' ) . '\s*[|}]/i', $text, $matches, PREG_OFFSET_CAPTURE );
+
 		if ( $noMatches <= 0 ) {
 			return $text;
 		}
-		$beginSubst  = -1;
-		$endSubst    = -1;
+
+		$beginSubst = -1;
+		$endSubst = -1;
 		$posInsertAt = 0;
-		$apNrLast    = 1000; // last (optional) predecessor
+		$apNrLast = 1000;
 
 		foreach ( $matches as $matchA ) {
 			$matchCount = count( $matchA );
+
 			foreach ( $matchA as $occurence => $matchB ) {
 				if ( $occurence < $call ) {
 					continue;
 				}
+
 				$match = $matchB[0];
 				$start = $matchB[1];
 
 				if ( $match[strlen( $match ) - 1] == '}' ) {
 					// template was called without parameters, add new parameter and value
 					// append parameter and value
-					$beginSubst   = $i;
-					$endSubst     = $i;
+					$beginSubst = 0;
+					$endSubst = 0;
 					$substitution = "|$parameter = $value";
 					break;
 				} else {
 					// there is already a list of parameters; we search to the end of the template call
 					$cbrackets = 2;
-					$parm      = '';
-					$pos       = $start + strlen( $match ) - 1;
-					$textLen   = strlen( $text );
+					$parm = '';
+					$pos = $start + strlen( $match ) - 1;
+					$textLen = strlen( $text );
+
 					for ( $i = $pos + 1; $i < $textLen; $i++ ) {
 						$c = $text[$i];
+
 						if ( $c == '{' || $c == '[' ) {
 							$cbrackets++; // we count both types of brackets
 						}
+
 						if ( $c == '}' || $c == ']' ) {
 							$cbrackets--;
 						}
+
 						if ( ( $cbrackets == 2 && $c == '|' ) || ( $cbrackets == 1 && $c == '}' ) ) {
 							// parameter (name / value) found
 
@@ -491,12 +581,15 @@ private static function updateTemplateCall( &$matchCount, $text, $template, $cal
 							if ( count( $token ) == 2 ) {
 								// we need a pair of name / value
 								$parmName = trim( $token[0] );
+
 								if ( $parmName == $parameter ) {
 									// we found the parameter, now replace the current value
 									$parmValue = trim( $token[1] );
+
 									if ( $parmValue == $value ) {
 										break; // no need to change when values are identical
 									}
+
 									// keep spaces;
 									if ( $parmValue == '' ) {
 										if ( strlen( $token[1] ) > 0 && $token[1][strlen( $token[1] ) - 1] == "\n" ) {
@@ -507,15 +600,16 @@ private static function updateTemplateCall( &$matchCount, $text, $template, $cal
 									} else {
 										$substitution = str_replace( $parmValue, $value, $token[1] );
 									}
+
 									$beginSubst = $pos + strlen( $token[0] ) + 2;
-									$endSubst   = $i;
+									$endSubst = $i;
 									break;
 								} else {
 									foreach ( $afterParm as $apNr => $ap ) {
 										// store position for insertion
 										if ( $parmName == $ap && $apNr < $apNrLast ) {
 											$posInsertAt = $i;
-											$apNrLast    = $apNr;
+											$apNrLast = $apNr;
 											break;
 										}
 									}
@@ -529,20 +623,23 @@ private static function updateTemplateCall( &$matchCount, $text, $template, $cal
 								} else {
 									$beginSubst = $i;
 								}
+
 								$substitution = "|$parameter = $value";
 								if ( $text[$beginSubst - 1] == "\n" ) {
 									--$beginSubst;
 									$substitution = "\n" . $substitution;
 								}
+
 								$endSubst = $beginSubst;
 								break;
 							}
 
-							$pos  = $i;
+							$pos = $i;
 							$parm = '';
 						} else {
 							$parm .= $c;
 						}
+
 						if ( $cbrackets == 0 ) {
 							break;
 						}
@@ -557,11 +654,11 @@ private static function updateTemplateCall( &$matchCount, $text, $template, $cal
 			return $text;
 		}
 
-		return substr( $text, 0, $beginSubst ) . $substitution . substr( $text, $endSubst );
+		return substr( $text, 0, $beginSubst ) . ( $substitution ?? '' ) . substr( $text, $endSubst );
 	}
 
-	public function deleteArticleByRule( $title, $text, $rulesText ) {
-		global $wgUser, $wgOut;
+	public static function deleteArticleByRule( $title, $text, $rulesText ) {
+		global $wgOut;
 
 		// return "deletion of articles by DPL is disabled.";
 
@@ -570,23 +667,25 @@ public function deleteArticleByRule( $title, $text, $rulesText ) {
 		$rulesText = str_replace( ";", '°', $rulesText );
 		$rulesText = str_replace( '\°', ';', $rulesText );
 		$rulesText = str_replace( "\\n", "\n", $rulesText );
-		$rules     = explode( '°', $rulesText );
-		$exec      = false;
-		$message   = '';
-		$reason    = '';
+		$rules = explode( '°', $rulesText );
+		$exec = false;
+		$message = '';
+		$reason = '';
 
 		foreach ( $rules as $rule ) {
 			if ( preg_match( '/^\s*#/', $rule ) > 0 ) {
 				continue; // # is comment symbol
 			}
 
-			$rule = preg_replace( '/^[\s]*/', '', $rule ); // strip leading white space
-			$cmd  = preg_split( "/ +/", $rule, 2 );
+			$rule = preg_replace( '/^[\s]*/', '', $rule );
+			$cmd = preg_split( "/ +/", $rule, 2 );
+
 			if ( count( $cmd ) > 1 ) {
 				$arg = $cmd[1];
 			} else {
 				$arg = '';
 			}
+
 			$cmd[0] = trim( $cmd[0] );
 
 			if ( $cmd[0] == 'reason' ) {
@@ -598,26 +697,33 @@ public function deleteArticleByRule( $title, $text, $rulesText ) {
 				$exec = true;
 			}
 		}
+
 		$reason .= "\nbulk delete by DPL query";
 
-		$titleX = \Title::newFromText( $title );
+		$titleX = Title::newFromText( $title );
+
 		if ( $exec ) {
+			$user = RequestContext::getMain()->getUser();
+
 			# Check permissions
-			$permission_errors = $titleX->getUserPermissionsErrors( 'delete', $wgUser );
+			$permission_errors = MediaWikiServices::getInstance()->getPermissionManager()->getPermissionErrors( 'delete', $user, $titleX );
+			$isReadOnly = MediaWikiServices::getInstance()->getReadOnlyMode()->isReadOnly();
+
 			if ( count( $permission_errors ) > 0 ) {
 				$wgOut->showPermissionsErrorPage( $permission_errors );
 				return 'permission error';
-			} elseif ( wfReadOnly() ) {
-				$wgOut->readOnlyPage();
-				return 'DPL: read only mode';
+			} elseif ( $isReadOnly ) {
+				throw new ReadOnlyError;
 			} else {
-				$articleX = new \Article( $titleX );
+				$articleX = new Article( $titleX );
 				$articleX->doDelete( $reason );
 			}
 		} else {
 			$message .= "set 'exec yes' to delete &#160; &#160; <big>'''$title'''</big>\n";
 		}
-		$message .= "<pre><nowiki>\n{$text}</nowiki></pre>"; // <pre><nowiki>\n"; // .$text."\n</nowiki></pre>\n";
+
+		$message .= "<pre><nowiki>\n{$text}</nowiki></pre>"; // <pre><nowiki>\n";
+
 		return $message;
 	}
 }
diff --git a/includes/UserQueryBuilder.php b/includes/UserQueryBuilder.php
new file mode 100644
index 00000000..b0e19c78
--- /dev/null
+++ b/includes/UserQueryBuilder.php
@@ -0,0 +1,161 @@
+<?php
+
+namespace DPL;
+
+use ActorMigration;
+use MediaWiki\MediaWikiServices;
+use MediaWiki\User\UserFactory;
+use MediaWiki\User\UserIdentity;
+use Wikimedia\Rdbms\IDatabase;
+
+class UserQueryBuilder {
+	/** @var IDatabase */
+	private $dbr;
+
+	/** @var ActorMigration */
+	private $actorMigration;
+
+	/** @var UserIdentity|array */
+	private $modifiedByConstraints = [];
+
+	/** @var UserIdentity|array */
+	private $notModifiedByConstraints = [];
+
+	/** @var UserIdentity|array */
+	private $notCreatedByConstraints = [];
+
+	/** @var UserIdentity|array */
+	private $notLastModifiedByConstraints = [];
+
+	/** @var UserIdentity|null */
+	private $createdByConstraint;
+
+	/** @var UserIdentity|null */
+	private $lastModifiedByConstraint;
+
+	public function __construct( IDatabase $dbr, ActorMigration $actorMigration ) {
+		$this->dbr = $dbr;
+		$this->actorMigration = $actorMigration;
+	}
+
+	public function addModifiedByConstraint( string $userName ): void {
+		$this->modifiedByConstraints[] = $this->getUserForQuery( $userName );
+	}
+
+	public function addNotModifiedByConstraint( string $userName ): void {
+		$this->notModifiedByConstraints[] = $this->getUserForQuery( $userName );
+	}
+
+	public function addCreatedByConstraint( string $userName ): void {
+		$this->createdByConstraint = $this->getUserForQuery( $userName );
+	}
+
+	public function addNotCreatedByConstraint( string $userName ): void {
+		$this->notCreatedByConstraints[] = $this->getUserForQuery( $userName );
+	}
+
+	public function addLastModifiedByConstraint( string $userName ): void {
+		$this->lastModifiedByConstraint = $this->getUserForQuery( $userName );
+	}
+
+	public function addNotLastModifiedByConstraint( string $userName ): void {
+		$this->notLastModifiedByConstraints[] = $this->getUserForQuery( $userName );
+	}
+
+	/**
+	 * Combine the constraints into a single condition suitable for inclusion in a WHERE clause.
+	 * @return string
+	 */
+	public function getWhere(): string {
+		$conds = [];
+
+		$modifiedByQuery = $this->getSubqueryForConstraint( $this->modifiedByConstraints );
+		if ( $modifiedByQuery ) {
+			$conds[] = "page_id IN $modifiedByQuery";
+		}
+
+		$notModifiedByQuery = $this->getSubqueryForConstraint( $this->notModifiedByConstraints );
+		if ( $notModifiedByQuery ) {
+			$conds[] = "NOT EXISTS $notModifiedByQuery";
+		}
+
+		$lastModifiedByQuery = $this->getSubqueryForConstraint(
+			[ $this->lastModifiedByConstraint ],
+			$this->notLastModifiedByConstraints,
+			'rev_id'
+		);
+		if ( $lastModifiedByQuery ) {
+			$conds[] = "page_latest IN $lastModifiedByQuery";
+		}
+
+		$createdByQuery = $this->getSubqueryForConstraint(
+			[ $this->createdByConstraint ],
+			$this->notCreatedByConstraints,
+			'rev_page',
+			[ 'rev_parent_id' => 0 ]
+		);
+		if ( $createdByQuery ) {
+			$conds[] = "page_id IN $createdByQuery";
+		}
+
+		return $this->dbr->makeList( $conds, IDatabase::LIST_AND );
+	}
+
+	private function getUserForQuery( string $userName ): ?UserIdentity {
+		$userFactory = MediaWikiServices::getInstance()->getUserFactory();
+
+		return $userFactory->newFromName( $userName, UserFactory::RIGOR_NONE ) ?: null;
+	}
+
+	/**
+	 * Construct a subquery for filtering revisions based on given user-specific criteria.
+	 * @param UserIdentity[] $constraints -users to include in the result set
+	 * @param UserIdentity[] $notConstraints - users to exclude from the result set
+	 * @param string $selectField - field name to select from the revision table
+	 * @param array $conds - additional query conditions
+	 * @return string|null - the subquery, or null if no constraints were given
+	 */
+	private function getSubqueryForConstraint(
+		array $constraints,
+		array $notConstraints = [],
+		string $selectField = 'rev_page',
+		array $conds = []
+	): ?string {
+		$constraints = array_filter( $constraints );
+		$notConstraints = array_filter( $notConstraints );
+		if ( !$constraints && !$notConstraints ) {
+			return null;
+		}
+
+		$constraintActorQuery = $this->actorMigration->getWhere(
+			$this->dbr,
+			'rev_user',
+			$constraints
+		);
+
+		$notConstraintActorQuery = $this->actorMigration->getWhere(
+			$this->dbr,
+			'rev_user',
+			$notConstraints
+		);
+
+		if ( $constraints ) {
+			$conds[] = $constraintActorQuery['conds'];
+		}
+
+		if ( $notConstraints ) {
+			$conds[] = "NOT ({$notConstraintActorQuery['conds']})";
+		}
+
+		$conds[] = 'rev_page=page_id';
+
+		return (string)$this->dbr->buildSelectSubquery(
+			[ 'revision' ] + $constraintActorQuery['tables'] + $notConstraintActorQuery['tables'],
+			[ $selectField ],
+			$conds,
+			__METHOD__,
+			[],
+			(array)$constraintActorQuery['joins'] + (array)$notConstraintActorQuery['joins']
+		);
+	}
+}
diff --git a/includes/Variables.php b/includes/Variables.php
index f20375ea..1b0ab7ff 100644
--- a/includes/Variables.php
+++ b/includes/Variables.php
@@ -1,13 +1,5 @@
 <?php
-/**
- * DynamicPageList3
- * DPL Variables Class
- *
- * @author		IlyaHaykinson, Unendlich, Dangerville, Algorithmix, Theaitetos, Alexia E. Smith
- * @license		GPL-2.0-or-later
- * @package		DynamicPageList3
- *
- */
+
 namespace DPL;
 
 class Variables {
@@ -29,33 +21,41 @@ class Variables {
 	// if the first parameter is empty it will be ignored {{#vardefine:|a|b}} is the same as {{#vardefine:a|b}}
 	public static function setVar( $arg ) {
 		$numargs = count( $arg );
+
 		if ( $numargs >= 3 && $arg[2] == '' ) {
 			$start = 3;
 		} else {
 			$start = 2;
 		}
+
 		for ( $i = $start; $i < $numargs; $i++ ) {
 			$var = $arg[$i];
+
 			if ( ++$i <= $numargs - 1 ) {
 				self::$memoryVar[$var] = $arg[$i];
 			} else {
 				self::$memoryVar[$var] = '';
 			}
 		}
+
 		return '';
 	}
 
 	public static function setVarDefault( $arg ) {
 		$numargs = count( $arg );
+
 		if ( $numargs > 3 ) {
 			$value = $arg[3];
 		} else {
 			return '';
 		}
+
 		$var = $arg[2];
+
 		if ( !array_key_exists( $var, self::$memoryVar ) || self::$memoryVar[$var] == '' ) {
 			self::$memoryVar[$var] = $value;
 		}
+
 		return '';
 	}
 
@@ -63,74 +63,95 @@ public static function getVar( $var ) {
 		if ( array_key_exists( $var, self::$memoryVar ) ) {
 			return self::$memoryVar[$var];
 		}
+
 		return '';
 	}
 
 	public static function setArray( $arg ) {
 		$numargs = count( $arg );
+
 		if ( $numargs < 5 ) {
 			return '';
 		}
-		$var       = trim( $arg[2] );
-		$value     = $arg[3];
+
+		$var = trim( $arg[2] );
+		$value = $arg[3];
 		$delimiter = $arg[4];
+
 		if ( $var == '' ) {
 			return '';
 		}
+
 		if ( $value == '' ) {
 			self::$memoryArray[$var] = [];
 			return;
 		}
+
 		if ( $delimiter == '' ) {
 			self::$memoryArray[$var] = [
 				$value
 			];
+
 			return;
 		}
-		if ( 0 !== strpos( $delimiter, '/' ) || ( strlen( $delimiter ) - 1 ) !== strrpos( $delimiter, '/' ) ) {
+
+		if ( strpos( $delimiter, '/' ) !== 0 || ( strlen( $delimiter ) - 1 ) !== strrpos( $delimiter, '/' ) ) {
 			$delimiter = '/\s*' . $delimiter . '\s*/';
 		}
+
 		self::$memoryArray[$var] = preg_split( $delimiter, $value );
+
 		return "value={$value}, delimiter={$delimiter}," . count( self::$memoryArray[$var] );
 	}
 
 	public static function dumpArray( $arg ) {
 		$numargs = count( $arg );
+
 		if ( $numargs < 3 ) {
 			return '';
 		}
-		$var  = trim( $arg[2] );
+
+		$var = trim( $arg[2] );
 		$text = " array {$var} = {";
-		$n    = 0;
+		$n = 0;
+
 		if ( array_key_exists( $var, self::$memoryArray ) ) {
 			foreach ( self::$memoryArray[$var] as $value ) {
 				if ( $n++ > 0 ) {
 					$text .= ', ';
 				}
+
 				$text .= "{$value}";
 			}
 		}
+
 		return $text . "}\n";
 	}
 
 	public static function printArray( $var, $delimiter, $search, $subject ) {
 		$var = trim( $var );
+
 		if ( $var == '' ) {
 			return '';
 		}
+
 		if ( !array_key_exists( $var, self::$memoryArray ) ) {
 			return '';
 		}
-		$values          = self::$memoryArray[$var];
+
+		$values = self::$memoryArray[$var];
 		$rendered_values = [];
+
 		foreach ( $values as $v ) {
 			$temp_result_value = str_replace( $search, $v, $subject );
 			$rendered_values[] = $temp_result_value;
 		}
+
 		return [
+			// @phan-suppress-next-line PhanPluginMixedKeyNoKey
 			implode( $delimiter, $rendered_values ),
-			'noparse'	=> false,
-			'isHTML'	=> false
+			'noparse' => false,
+			'isHTML' => false
 		];
 	}
 }
diff --git a/includes/heading/DefinitionHeading.php b/includes/heading/DefinitionHeading.php
index 167fa6de..a10b8cd4 100644
--- a/includes/heading/DefinitionHeading.php
+++ b/includes/heading/DefinitionHeading.php
@@ -1,12 +1,4 @@
 <?php
-/**
- * DynamicPageList3
- * DPL DefinitionHeading Class
- *
- * @license		GPL-2.0-or-later
- * @package		DynamicPageList3
- *
- */
 
 namespace DPL\Heading;
 
@@ -74,21 +66,22 @@ class DefinitionHeading extends Heading {
 	/**
 	 * Format a heading group.
 	 *
-	 * @access	public
-	 * @param	integer	Article start index for this heading.
-	 * @param	integer	Article count for this heading.
-	 * @param	string	Heading link/text display.
-	 * @param	array	List of \DPL\Article.
-	 * @param	object	List of \DPL\Lister\Lister
-	 * @return	string	Heading HTML
+	 * @param int $headingStart
+	 * @param int $headingCount
+	 * @param string $headingLink
+	 * @param array $articles
+	 * @param Lister $lister
+	 * @return string
 	 */
 	public function formatItem( $headingStart, $headingCount, $headingLink, $articles, Lister $lister ) {
 		$item = '';
 
 		$item .= $this->headListStart . $headingLink;
+
 		if ( $this->showHeadingCount ) {
 			$item .= $this->articleCountMessage( $headingCount );
 		}
+
 		$item .= $this->headListEnd;
 		$item .= $this->getItemStart() . $lister->formatList( $articles, $headingStart, $headingCount ) . $this->getItemEnd();
 
diff --git a/includes/heading/Heading.php b/includes/heading/Heading.php
index 8ece3015..512a4dfd 100644
--- a/includes/heading/Heading.php
+++ b/includes/heading/Heading.php
@@ -1,29 +1,23 @@
 <?php
-/**
- * DynamicPageList3
- * DPL List Class
- *
- * @license		GPL-2.0-or-later
- * @package		DynamicPageList3
- *
- */
+
 namespace DPL\Heading;
 
 use DPL\Article;
 use DPL\Lister\Lister;
 use DPL\Parameters;
+use Sanitizer;
 
 class Heading {
 	/**
 	 * Listing style for this class.
 	 *
-	 * @var constant
+	 * @var int|null
 	 */
 	public $style = null;
 
 	/**
 	 * List(Section) Start
-	 * Use %s for attribute placement.  Example: <div%s>
+	 * Use %s for attribute placement. Example: <div%s>
 	 *
 	 * @var string
 	 */
@@ -38,7 +32,7 @@ class Heading {
 
 	/**
 	 * Item Start
-	 * Use %s for attribute placement.  Example: <div%s>
+	 * Use %s for attribute placement. Example: <div%s>
 	 *
 	 * @var string
 	 */
@@ -54,14 +48,14 @@ class Heading {
 	/**
 	 * Extra list HTML attributes.
 	 *
-	 * @var array
+	 * @var string
 	 */
 	public $listAttributes = '';
 
 	/**
 	 * Extra item HTML attributes.
 	 *
-	 * @var array
+	 * @var string
 	 */
 	public $itemAttributes = '';
 
@@ -73,18 +67,14 @@ class Heading {
 	protected $showHeadingCount = false;
 
 	/**
-	 * \DPL\Parameters
+	 * Parameters
 	 *
-	 * @var object
+	 * @var Parameters
 	 */
-	protected $parameters = null;
+	protected $parameters;
 
 	/**
-	 * Main Constructor
-	 *
-	 * @access	public
-	 * @param	object	\DPL\Parameters
-	 * @return	void
+	 * @param Parameters $parameters
 	 */
 	public function __construct( Parameters $parameters ) {
 		$this->setListAttributes( $parameters->getParameter( 'hlistattr' ) );
@@ -96,17 +86,16 @@ public function __construct( Parameters $parameters ) {
 	/**
 	 * Get a new List subclass based on user selection.
 	 *
-	 * @access	public
-	 * @param	string	Heading style.
-	 * @param	object	\DPL\Parameters
-	 * @param	object	MediaWiki \Parser
-	 * @return	mixed	Heading subclass or null for a bad style.
+	 * @param string $style
+	 * @param Parameters $parameters
+	 * @return mixed
 	 */
-	public static function newFromStyle( $style, \DPL\Parameters $parameters ) {
+	public static function newFromStyle( $style, Parameters $parameters ) {
 		$style = strtolower( $style );
+
 		switch ( $style ) {
 			case 'definition':
-				$class = 'DefinitionHeading';
+				$class = DefinitionHeading::class;
 				break;
 			case 'h1':
 			case 'h2':
@@ -115,28 +104,25 @@ public static function newFromStyle( $style, \DPL\Parameters $parameters ) {
 			case 'h5':
 			case 'h6':
 			case 'header':
-				$class = 'TieredHeading';
+				$class = TieredHeading::class;
 				break;
 			case 'ordered':
-				$class = 'OrderedHeading';
+				$class = OrderedHeading::class;
 				break;
 			case 'unordered':
-				$class = 'UnorderedHeading';
+				$class = UnorderedHeading::class;
 				break;
 			default:
 				return null;
-				break;
 		}
-		$class = '\DPL\Heading\\' . $class;
 
 		return new $class( $parameters );
 	}
 
 	/**
-	 * Get the \DPL\Parameters object this object was constructed with.
+	 * Get the Parameters object this object was constructed with.
 	 *
-	 * @access	public
-	 * @return	object	\DPL\Parameters
+	 * @return Parameters
 	 */
 	public function getParameters() {
 		return $this->parameters;
@@ -145,31 +131,25 @@ public function getParameters() {
 	/**
 	 * Set extra list attributes.
 	 *
-	 * @access	public
-	 * @param	string	Tag soup attributes, example: this="that" thing="no"
-	 * @return	void
+	 * @param string $attributes
 	 */
 	public function setListAttributes( $attributes ) {
-		$this->listAttributes = \Sanitizer::fixTagAttributes( $attributes, 'ul' );
+		$this->listAttributes = Sanitizer::fixTagAttributes( $attributes, 'ul' );
 	}
 
 	/**
 	 * Set extra item attributes.
 	 *
-	 * @access	public
-	 * @param	string	Tag soup attributes, example: this="that" thing="no"
-	 * @return	void
+	 * @param string $attributes
 	 */
 	public function setItemAttributes( $attributes ) {
-		$this->itemAttributes = \Sanitizer::fixTagAttributes( $attributes, 'li' );
+		$this->itemAttributes = Sanitizer::fixTagAttributes( $attributes, 'li' );
 	}
 
 	/**
 	 * Set if the article count per heading should be shown.
 	 *
-	 * @access	public
-	 * @param	boolean	[Optional] Show Heading Count
-	 * @return	void
+	 * @param bool $show
 	 */
 	public function setShowHeadingCount( $show = false ) {
 		$this->showHeadingCount = boolval( $show );
@@ -178,8 +158,7 @@ public function setShowHeadingCount( $show = false ) {
 	/**
 	 * Return the list style.
 	 *
-	 * @access	public
-	 * @return	integer	List style constant.
+	 * @return int
 	 */
 	public function getStyle() {
 		return $this->style;
@@ -188,10 +167,9 @@ public function getStyle() {
 	/**
 	 * Format a list of articles into all lists with headings as needed.
 	 *
-	 * @access	public
-	 * @param	array	List of \DPL\Article
-	 * @param	object	List of \DPL\Lister\Lister
-	 * @return	string	Formatted list.
+	 * @param array $articles
+	 * @param Lister $lister
+	 * @return string
 	 */
 	public function format( $articles, Lister $lister ) {
 		$columns = $this->getParameters()->getParameter( 'columns' );
@@ -204,46 +182,57 @@ public function format( $articles, Lister $lister ) {
 
 		$headings = Article::getHeadings();
 		$output = '';
+
 		if ( !empty( $headings ) ) {
 			if ( $columns != 1 || $rows != 1 ) {
-				$hspace = 2; // the extra space for headings
+				$hspace = 2;
+
 				// repeat outer tags for each of the specified columns / rows in the output
 				// we assume that a heading roughly takes the space of two articles
 				$count = count( $articles ) + $hspace * count( $headings );
+
 				if ( $columns != 1 ) {
 					$iGroup = $columns;
 				} else {
 					$iGroup = $rows;
 				}
+
 				$nsize = floor( $count / $iGroup );
-				$rest  = $count - ( floor( $nsize ) * floor( $iGroup ) );
+				$rest = $count - ( floor( $nsize ) * floor( $iGroup ) );
+
 				if ( $rest > 0 ) {
 					$nsize += 1;
 				}
+
 				$output .= "{|" . $rowColFormat . "\n|\n";
+
 				if ( $nsize < $hspace + 1 ) {
-					$nsize = $hspace + 1; // correction for result sets with one entry
+					$nsize = $hspace + 1;
 				}
+
 				$output .= $this->getListStart();
 				$nstart = 0;
-				$greml  = $nsize; // remaining lines in current group
-				$g      = 0;
+				$greml = $nsize;
+				$g = 0;
 				$offset = 0;
 				foreach ( $headings as $headingCount ) {
 					$headingStart = $nstart - $offset;
 					$headingLink = $articles[$headingStart]->mParentHLink;
 					$output .= $this->getItemStart() . $headingLink . $this->getItemEnd();
+
 					if ( $this->showHeadingCount ) {
 						$output .= $this->articleCountMessage( $headingCount );
 					}
+
 					$offset += $hspace;
 					$nstart += $hspace;
 					$portion = $headingCount;
 					$greml -= $hspace;
 					$listOutput = '';
+
 					do {
 						$greml -= $portion;
-						// $output .= "nsize=$nsize, portion=$portion, greml=$greml";
+
 						if ( $greml > 0 ) {
 							$output .= $lister->formatList( $articles, $nstart - $offset, $portion );
 							$nstart += $portion;
@@ -253,85 +242,104 @@ public function format( $articles, Lister $lister ) {
 							$output .= $lister->formatList( $articles, $nstart - $offset, $portion + $greml );
 							$nstart += ( $portion + $greml );
 							$portion = ( -$greml );
+
 							if ( $columns != 1 ) {
 								$output .= "\n|valign=top|\n";
 							} else {
 								$output .= "\n|-\n|\n";
 							}
+
 							++$g;
-							// if ($rest != 0 && $g==$rest) $nsize -= 1;
+
 							if ( $nstart + $nsize > $count ) {
 								$nsize = $count - $nstart;
 							}
+
 							$greml = $nsize;
+
 							if ( $greml <= 0 ) {
 								break;
 							}
 						}
 					} while ( $portion > 0 );
+
 					$output .= $this->getItemEnd();
 				}
+
 				$output .= $this->listEnd;
 				$output .= "\n|}\n";
 			} else {
 				$output .= $this->getListStart();
 				$headingStart = 0;
+
 				foreach ( $headings as $headingCount ) {
 					$headingLink = $articles[$headingStart]->mParentHLink;
 					$output .= $this->formatItem( $headingStart, $headingCount, $headingLink, $articles, $lister );
 					$headingStart += $headingCount;
 				}
+
 				$output .= $this->listEnd;
 			}
 		} elseif ( $columns != 1 || $rows != 1 ) {
 			// repeat outer tags for each of the specified columns / rows in the output
 			$nstart = 0;
-			$count  = count( $articles );
+			$count = count( $articles );
+
 			if ( $columns != 1 ) {
 				$iGroup = $columns;
 			} else {
 				$iGroup = $rows;
 			}
+
 			$nsize = floor( $count / $iGroup );
-			$rest  = $count - ( floor( $nsize ) * floor( $iGroup ) );
+			$rest = $count - ( floor( $nsize ) * floor( $iGroup ) );
+
 			if ( $rest > 0 ) {
 				$nsize += 1;
 			}
+
 			$output .= "{|" . $rowColFormat . "\n|\n";
+
 			for ( $g = 0; $g < $iGroup; $g++ ) {
-				$output .= $lister->formatList( $articles, $nstart, $nsize );
+				$output .= $lister->formatList( $articles, $nstart, (int)$nsize );
+
 				if ( $columns != 1 ) {
 					$output .= "\n|valign=top|\n";
 				} else {
 					$output .= "\n|-\n|\n";
 				}
-				$nstart = $nstart + $nsize;
-				// if ($rest != 0 && $g+1==$rest) $nsize -= 1;
+
+				$nstart += $nsize;
+
 				if ( $nstart + $nsize > $count ) {
 					$nsize = $count - $nstart;
 				}
 			}
+
 			$output .= "\n|}\n";
 		} elseif ( $rowSize > 0 ) {
 			// repeat row header after n lines of output
 			$nstart = 0;
-			$nsize  = $rowSize;
-			$count  = count( $articles );
+			$nsize = $rowSize;
+			$count = count( $articles );
 			$output .= '{|' . $rowColFormat . "\n|\n";
+
 			do {
 				if ( $nstart + $nsize > $count ) {
 					$nsize = $count - $nstart;
 				}
-				$output .= $lister->formatList( $articles, $nstart, $nsize );
+
+				$output .= $lister->formatList( $articles, $nstart, (int)$nsize );
 				$output .= "\n|-\n|\n";
-				$nstart = $nstart + $nsize;
+				$nstart += $nsize;
 				if ( $nstart >= $count ) {
 					break;
 				}
 			} while ( true );
+
 			$output .= "\n|}\n";
 		} else {
-			//Even though the headingmode is not none there were no headings, but still results.  Output them anyway.
+			// Even though the headingmode is not none there were no headings, but still results. Output them anyway.
 			$output .= $lister->formatList( $articles, 0, count( $articles ) );
 		}
 
@@ -341,21 +349,22 @@ public function format( $articles, Lister $lister ) {
 	/**
 	 * Format a heading group.
 	 *
-	 * @access	public
-	 * @param	integer	Article start index for this heading.
-	 * @param	integer	Article count for this heading.
-	 * @param	string	Heading link/text display.
-	 * @param	array	List of \DPL\Article.
-	 * @param	object	List of \DPL\Lister\Lister
-	 * @return	string	Heading HTML
+	 * @param int $headingStart
+	 * @param int $headingCount
+	 * @param string $headingLink
+	 * @param array $articles
+	 * @param Lister $lister
+	 * @return string
 	 */
 	public function formatItem( $headingStart, $headingCount, $headingLink, $articles, Lister $lister ) {
 		$item = '';
 
 		$item .= $this->getItemStart() . $headingLink;
+
 		if ( $this->showHeadingCount ) {
 			$item .= $this->articleCountMessage( $headingCount );
 		}
+
 		$item .= $lister->formatList( $articles, $headingStart, $headingCount );
 		$item .= $this->getItemEnd();
 
@@ -365,8 +374,7 @@ public function formatItem( $headingStart, $headingCount, $headingLink, $article
 	/**
 	 * Return $this->listStart with attributes replaced.
 	 *
-	 * @access	public
-	 * @return	string	List Start
+	 * @return string
 	 */
 	public function getListStart() {
 		return sprintf( $this->listStart, $this->listAttributes );
@@ -375,8 +383,7 @@ public function getListStart() {
 	/**
 	 * Return $this->itemStart with attributes replaced.
 	 *
-	 * @access	public
-	 * @return	string	Item Start
+	 * @return string
 	 */
 	public function getItemStart() {
 		return sprintf( $this->itemStart, $this->itemAttributes );
@@ -385,8 +392,7 @@ public function getItemStart() {
 	/**
 	 * Return $this->itemEnd with attributes replaced.
 	 *
-	 * @access	public
-	 * @return	string	Item End
+	 * @return string
 	 */
 	public function getItemEnd() {
 		return $this->itemEnd;
@@ -395,17 +401,18 @@ public function getItemEnd() {
 	/**
 	 * Get the article count message appropriate for this list.
 	 *
-	 * @access	public
-	 * @param	integer	Count
-	 * @return	string	Message
+	 * @param int $count
+	 * @return string
 	 */
 	protected function articleCountMessage( $count ) {
 		$orderMethods = $this->getParameters()->getParameter( 'ordermethods' );
+
 		if ( isset( $orderMethods[0] ) && $orderMethods[0] === 'category' ) {
 			$message = 'categoryarticlecount';
 		} else {
 			$message = 'dpl_articlecount';
 		}
+
 		return '<p>' . wfMessage( $message, $count )->escaped() . '</p>';
 	}
 }
diff --git a/includes/heading/OrderedHeading.php b/includes/heading/OrderedHeading.php
index a2bd94fe..b8bd2106 100644
--- a/includes/heading/OrderedHeading.php
+++ b/includes/heading/OrderedHeading.php
@@ -1,12 +1,4 @@
 <?php
-/**
- * DynamicPageList3
- * DPL OrderedHeading Class
- *
- * @license		GPL-2.0-or-later
- * @package		DynamicPageList3
- *
- */
 
 namespace DPL\Heading;
 
diff --git a/includes/heading/TieredHeading.php b/includes/heading/TieredHeading.php
index 04d42565..02c90b8e 100644
--- a/includes/heading/TieredHeading.php
+++ b/includes/heading/TieredHeading.php
@@ -1,12 +1,4 @@
 <?php
-/**
- * DynamicPageList3
- * DPL TieredHeading Class
- *
- * @license		GPL-2.0-or-later
- * @package		DynamicPageList3
- *
- */
 
 namespace DPL\Heading;
 
@@ -50,35 +42,33 @@ class TieredHeading extends Heading {
 	private $tierLevel = 'eader';
 
 	/**
-	 * Main Constructor
-	 *
-	 * @access	public
-	 * @param	object	\DPL\Parameters
-	 * @return	void
+	 * @param Parameters $parameters
 	 */
 	public function __construct( Parameters $parameters ) {
 		parent::__construct( $parameters );
+
 		$this->tierLevel = substr( $parameters->getParameter( 'headingmode' ), 1 );
 	}
 
 	/**
 	 * Format a heading group.
 	 *
-	 * @access	public
-	 * @param	integer	Article start index for this heading.
-	 * @param	integer	Article count for this heading.
-	 * @param	string	Heading link/text display.
-	 * @param	array	List of \DPL\Article.
-	 * @param	object	List of \DPL\Lister\Lister
-	 * @return	string	Heading HTML
+	 * @param int $headingStart
+	 * @param int $headingCount
+	 * @param string $headingLink
+	 * @param array $articles
+	 * @param Lister $lister
+	 * @return string
 	 */
 	public function formatItem( $headingStart, $headingCount, $headingLink, $articles, Lister $lister ) {
 		$item = '';
 
 		$item .= $this->getItemStart() . $headingLink;
+
 		if ( $this->showHeadingCount ) {
 			$item .= $this->articleCountMessage( $headingCount );
 		}
+
 		$item .= $this->getItemEnd();
 		$item .= $lister->formatList( $articles, $headingStart, $headingCount );
 
@@ -88,8 +78,7 @@ public function formatItem( $headingStart, $headingCount, $headingLink, $article
 	/**
 	 * Return $this->listStart with attributes replaced.
 	 *
-	 * @access	public
-	 * @return	string	List Start
+	 * @return string
 	 */
 	public function getListStart() {
 		return sprintf( $this->listStart, $this->listAttributes );
@@ -98,8 +87,7 @@ public function getListStart() {
 	/**
 	 * Return $this->itemStart with attributes replaced.
 	 *
-	 * @access	public
-	 * @return	string	Item Start
+	 * @return string
 	 */
 	public function getItemStart() {
 		return sprintf( $this->itemStart, $this->itemAttributes, $this->tierLevel );
@@ -108,8 +96,7 @@ public function getItemStart() {
 	/**
 	 * Return $this->itemEnd with attributes replaced.
 	 *
-	 * @access	public
-	 * @return	string	Item End
+	 * @return string
 	 */
 	public function getItemEnd() {
 		return sprintf( $this->itemEnd, $this->itemAttributes, $this->tierLevel );
diff --git a/includes/heading/UnorderedHeading.php b/includes/heading/UnorderedHeading.php
index 9e56b263..9b3ae7e2 100644
--- a/includes/heading/UnorderedHeading.php
+++ b/includes/heading/UnorderedHeading.php
@@ -1,12 +1,4 @@
 <?php
-/**
- * DynamicPageList3
- * DPL UnorderedHeading Class
- *
- * @license		GPL-2.0-or-later
- * @package		DynamicPageList3
- *
- */
 
 namespace DPL\Heading;
 
diff --git a/includes/lister/CategoryList.php b/includes/lister/CategoryList.php
index b1262da3..6c0c045b 100644
--- a/includes/lister/CategoryList.php
+++ b/includes/lister/CategoryList.php
@@ -1,15 +1,8 @@
 <?php
-/**
- * DynamicPageList3
- * DPL CategoryList Class
- *
- * @license		GPL-2.0-or-later
- * @package		DynamicPageList3
- *
- */
 
 namespace DPL\Lister;
 
+use CategoryViewer;
 use DPL\Article;
 use DPL\Config;
 
@@ -17,45 +10,49 @@ class CategoryList extends Lister {
 	/**
 	 * Listing style for this class.
 	 *
-	 * @var constant
+	 * @var int
 	 */
 	public $style = parent::LIST_CATEGORY;
 
 	/**
 	 * Format the list of articles.
 	 *
-	 * @access	public
-	 * @param	array	List of \DPL\Article
-	 * @param	integer	Start position of the array to process.
-	 * @param	integer	Total objects from the array to process.
-	 * @return	string	Formatted list.
+	 * @param array $articles
+	 * @param int $start
+	 * @param int $count
+	 * @return string Formatted list.
 	 */
 	public function formatList( $articles, $start, $count ) {
+		$articleLinks = [];
+		$articleStartChars = [];
+
 		$filteredCount = 0;
+
 		for ( $i = $start; $i < $start + $count; $i++ ) {
 			$articleLinks[] = $articles[$i]->mLink;
 			$articleStartChars[] = $articles[$i]->mStartChar;
-			$filteredCount = $filteredCount + 1;
+
+			$filteredCount++;
 		}
 
 		$this->rowCount = $filteredCount;
 
 		if ( count( $articleLinks ) > Config::getSetting( 'categoryStyleListCutoff' ) ) {
-			return "__NOTOC____NOEDITSECTION__" . \CategoryViewer::columnList( $articleLinks, $articleStartChars );
+			return "__NOTOC____NOEDITSECTION__" . CategoryViewer::columnList( $articleLinks, $articleStartChars );
 		} elseif ( count( $articleLinks ) > 0 ) {
 			// for short lists of articles in categories.
-			return "__NOTOC____NOEDITSECTION__" . \CategoryViewer::shortList( $articleLinks, $articleStartChars );
+			return "__NOTOC____NOEDITSECTION__" . CategoryViewer::shortList( $articleLinks, $articleStartChars );
 		}
+
 		return '';
 	}
 
 	/**
 	 * Format a single item.
 	 *
-	 * @access	public
-	 * @param	object	DPL\Article
-	 * @param	string	[Optional] Page text to include.
-	 * @return	string	Item HTML
+	 * @param Article $article
+	 * @param string|null $pageText
+	 * @return string
 	 */
 	public function formatItem( Article $article, $pageText = null ) {
 		return '';
diff --git a/includes/lister/DefinitionList.php b/includes/lister/DefinitionList.php
index 42e1975f..f194a4a5 100644
--- a/includes/lister/DefinitionList.php
+++ b/includes/lister/DefinitionList.php
@@ -1,12 +1,4 @@
 <?php
-/**
- * DynamicPageList3
- * DPL DefinitionList Class
- *
- * @license		GPL-2.0-or-later
- * @package		DynamicPageList3
- *
- */
 
 namespace DPL\Lister;
 
@@ -14,7 +6,7 @@ class DefinitionList extends Lister {
 	/**
 	 * Listing style for this class.
 	 *
-	 * @var constant
+	 * @var int
 	 */
 	public $style = parent::LIST_DEFINITION;
 
diff --git a/includes/lister/GalleryList.php b/includes/lister/GalleryList.php
index 0271469a..afc7de1f 100644
--- a/includes/lister/GalleryList.php
+++ b/includes/lister/GalleryList.php
@@ -1,12 +1,4 @@
 <?php
-/**
- * DynamicPageList3
- * DPL GalleryList Class
- *
- * @license		GPL-2.0-or-later
- * @package		DynamicPageList3
- *
- */
 
 namespace DPL\Lister;
 
@@ -16,7 +8,7 @@ class GalleryList extends Lister {
 	/**
 	 * Listing style for this class.
 	 *
-	 * @var constant
+	 * @var int
 	 */
 	public $style = parent::LIST_GALLERY;
 
@@ -46,21 +38,20 @@ class GalleryList extends Lister {
 	 *
 	 * @var string
 	 */
-	public $itemEnd = "|";
+	public $itemEnd = '|';
 
 	/**
 	 * Format an item.
 	 *
-	 * @access	public
-	 * @param	object	DPL\Article
-	 * @param	string	[Optional] Page text to include.include.
-	 * @return	string	Item HTML
+	 * @param Article $article
+	 * @param string|null $pageText
+	 * @return string
 	 */
 	public function formatItem( Article $article, $pageText = null ) {
 		$item = $article->mTitle;
 
 		if ( $pageText !== null ) {
-			//Include parsed/processed wiki markup content after each item before the closing tag.
+			// Include parsed/processed wiki markup content after each item before the closing tag.
 			$item .= $pageText;
 		}
 
diff --git a/includes/lister/InlineList.php b/includes/lister/InlineList.php
index d2b5e75a..08c24238 100644
--- a/includes/lister/InlineList.php
+++ b/includes/lister/InlineList.php
@@ -1,20 +1,15 @@
 <?php
-/**
- * DynamicPageList3
- * DPL InlineList Class
- *
- * @license		GPL-2.0-or-later
- * @package		DynamicPageList3
- *
- */
 
 namespace DPL\Lister;
 
+use DPL\Parameters;
+use Parser;
+
 class InlineList extends Lister {
 	/**
 	 * Listing style for this class.
 	 *
-	 * @var constant
+	 * @var int
 	 */
 	public $style = parent::LIST_INLINE;
 
@@ -68,24 +63,20 @@ class InlineList extends Lister {
 	protected $textSeparator = '';
 
 	/**
-	 * Main Constructor
-	 *
-	 * @access	public
-	 * @param	object	\DPL\Parameters
-	 * @param	object	MediaWiki \Parser
-	 * @return	void
+	 * @param Parameters $parameters
+	 * @param Parser $parser
 	 */
-	public function __construct( \DPL\Parameters $parameters, \Parser $parser ) {
+	public function __construct( Parameters $parameters, Parser $parser ) {
 		parent::__construct( $parameters, $parser );
+
 		$this->textSeparator = $parameters->getParameter( 'inlinetext' );
 	}
 
 	/**
 	 * Join together items after being processed by formatItem().
 	 *
-	 * @access	public
-	 * @param	array	Items as formatted by formatItem().
-	 * @return	string	Imploded items.
+	 * @param array $items
+	 * @return string
 	 */
 	protected function implodeItems( $items ) {
 		return implode( $this->textSeparator, $items );
diff --git a/includes/lister/Lister.php b/includes/lister/Lister.php
index 8c02b2c2..4063886a 100644
--- a/includes/lister/Lister.php
+++ b/includes/lister/Lister.php
@@ -1,40 +1,43 @@
 <?php
-/**
- * DynamicPageList3
- * DPL List Class
- *
- * @license		GPL-2.0-or-later
- * @package		DynamicPageList3
- *
- */
 
 namespace DPL\Lister;
 
 use DPL\Article;
 use DPL\LST;
+use DPL\Parameters;
 use DPL\UpdateArticle;
 use MediaWiki\MediaWikiServices;
+use Parser;
+use Sanitizer;
+use Title;
 
 class Lister {
-	const LIST_DEFINITION = 1;
-	const LIST_GALLERY = 2;
-	const LIST_HEADING = 3;
-	const LIST_INLINE = 4;
-	const LIST_ORDERED = 5;
-	const LIST_UNORDERED = 6;
-	const LIST_CATEGORY = 7;
-	const LIST_USERFORMAT = 8;
+	public const LIST_DEFINITION = 1;
+
+	public const LIST_GALLERY = 2;
+
+	public const LIST_HEADING = 3;
+
+	public const LIST_INLINE = 4;
+
+	public const LIST_ORDERED = 5;
+
+	public const LIST_UNORDERED = 6;
+
+	public const LIST_CATEGORY = 7;
+
+	public const LIST_USERFORMAT = 8;
 
 	/**
 	 * Listing style for this class.
 	 *
-	 * @var constant
+	 * @var int|null
 	 */
 	public $style = null;
 
 	/**
 	 * Heading List Start
-	 * Use %s for attribute placement.  Example: <div%s>
+	 * Use %s for attribute placement. Example: <div%s>
 	 *
 	 * @var string
 	 */
@@ -49,7 +52,7 @@ class Lister {
 
 	/**
 	 * Heading List Start
-	 * Use %s for attribute placement.  Example: <div%s>
+	 * Use %s for attribute placement. Example: <div%s>
 	 *
 	 * @var string
 	 */
@@ -64,7 +67,7 @@ class Lister {
 
 	/**
 	 * List(Section) Start
-	 * Use %s for attribute placement.  Example: <div%s>
+	 * Use %s for attribute placement. Example: <div%s>
 	 *
 	 * @var string
 	 */
@@ -79,7 +82,7 @@ class Lister {
 
 	/**
 	 * Item Start
-	 * Use %s for attribute placement.  Example: <div%s>
+	 * Use %s for attribute placement. Example: <div%s>
 	 *
 	 * @var string
 	 */
@@ -95,28 +98,28 @@ class Lister {
 	/**
 	 * Extra head list HTML attributes.
 	 *
-	 * @var array
+	 * @var string
 	 */
 	public $headListAttributes = '';
 
 	/**
 	 * Extra head item HTML attributes.
 	 *
-	 * @var array
+	 * @var string
 	 */
 	public $headItemAttributes = '';
 
 	/**
 	 * Extra list HTML attributes.
 	 *
-	 * @var array
+	 * @var string
 	 */
 	public $listAttributes = '';
 
 	/**
 	 * Extra item HTML attributes.
 	 *
-	 * @var array
+	 * @var string
 	 */
 	public $itemAttributes = '';
 
@@ -151,14 +154,19 @@ class Lister {
 	/**
 	 * Index of the table column to sort by.
 	 *
-	 * @var int
+	 * @var int|null
 	 */
 	protected $tableSortColumn = null;
 
+	/**
+	 * @var string|null
+	 */
+	protected $tableSortMethod = null;
+
 	/**
 	 * Maximum title length.
 	 *
-	 * @var int
+	 * @var int|null
 	 */
 	protected $titleMaxLength = null;
 
@@ -186,7 +194,7 @@ class Lister {
 	/**
 	 * Maximum length before truncated included wiki text.
 	 *
-	 * @var int
+	 * @var int|null
 	 */
 	protected $includePageMaxLength = null;
 
@@ -195,21 +203,21 @@ class Lister {
 	 *
 	 * @var array
 	 */
-	protected $pageTextMatch = null;
+	protected $pageTextMatch;
 
 	/**
 	 * Array of regex text matches for page transclusion. (includematch)
 	 *
 	 * @var array
 	 */
-	protected $pageTextMatchRegex = null;
+	protected $pageTextMatchRegex;
 
 	/**
 	 * Array of not regex text matches for page transclusion. (includenotmatch)
 	 *
 	 * @var array
 	 */
-	protected $pageTextMatchNotRegex = null;
+	protected $pageTextMatchNotRegex;
 
 	/**
 	 * Parsed wiki text into HTML before running include/includematch/includenotmatch.
@@ -226,28 +234,24 @@ class Lister {
 	public $rowCount = 0;
 
 	/**
-	 * \DPL\Parameters
+	 * Parameters
 	 *
-	 * @var object
+	 * @var Parameters
 	 */
-	protected $parameters = null;
+	protected $parameters;
 
 	/**
 	 * Parser
 	 *
-	 * @var object
+	 * @var Parser
 	 */
-	protected $parser = null;
+	protected $parser;
 
 	/**
-	 * Main Constructor
-	 *
-	 * @access	public
-	 * @param	object	\DPL\Parameters
-	 * @param	object	MediaWiki \Parser
-	 * @return	void
+	 * @param Parameters $parameters
+	 * @param Parser $parser
 	 */
-	public function __construct( \DPL\Parameters $parameters, \Parser $parser ) {
+	public function __construct( Parameters $parameters, Parser $parser ) {
 		$this->setHeadListAttributes( $parameters->getParameter( 'hlistattr' ) );
 		$this->setHeadItemAttributes( $parameters->getParameter( 'hitemattr' ) );
 		$this->setListAttributes( $parameters->getParameter( 'listattr' ) );
@@ -256,7 +260,7 @@ public function __construct( \DPL\Parameters $parameters, \Parser $parser ) {
 		$this->setTemplateSuffix( $parameters->getParameter( 'defaulttemplatesuffix' ) );
 		$this->setTrimIncluded( $parameters->getParameter( 'includetrim' ) );
 		$this->setTableSortColumn( $parameters->getParameter( 'tablesortcol' ) );
-		$this->setTableSortMethod($parameters->getParameter('tablesortmethod'));
+		$this->setTableSortMethod( $parameters->getParameter( 'tablesortmethod' ) );
 		$this->setTitleMaxLength( $parameters->getParameter( 'titlemaxlen' ) );
 		$this->setEscapeLinks( $parameters->getParameter( 'escapelinks' ) );
 		$this->setSectionSeparators( $parameters->getParameter( 'secseparators' ) );
@@ -274,51 +278,49 @@ public function __construct( \DPL\Parameters $parameters, \Parser $parser ) {
 	/**
 	 * Get a new List subclass based on user selection.
 	 *
-	 * @access	public
-	 * @param	string	List style.
-	 * @param	object	\DPL\Parameters
-	 * @param	object	MediaWiki \Parser
-	 * @return	object	Lister subclass.
+	 * @param string $style
+	 * @param Parameters $parameters
+	 * @param Parser $parser
+	 * @return mixed
 	 */
-	public static function newFromStyle( $style, \DPL\Parameters $parameters, \Parser $parser ) {
+	public static function newFromStyle( $style, Parameters $parameters, Parser $parser ) {
 		$style = strtolower( $style );
+
 		switch ( $style ) {
 			case 'category':
-				$class = 'CategoryList';
+				$class = CategoryList::class;
 				break;
 			case 'definition':
-				$class = 'DefinitionList';
+				$class = DefinitionList::class;
 				break;
 			case 'gallery':
-				$class = 'GalleryList';
+				$class = GalleryList::class;
 				break;
 			case 'inline':
-				$class = 'InlineList';
+				$class = InlineList::class;
 				break;
 			case 'ordered':
-				$class = 'OrderedList';
+				$class = OrderedList::class;
 				break;
 			case 'subpage':
-				$class = 'SubPageList';
+				$class = SubPageList::class;
 				break;
 			default:
 			case 'unordered':
-				$class = 'UnorderedList';
+				$class = UnorderedList::class;
 				break;
 			case 'userformat':
-				$class = 'UserFormatList';
+				$class = UserFormatList::class;
 				break;
 		}
-		$class = '\DPL\Lister\\' . $class;
 
 		return new $class( $parameters, $parser );
 	}
 
 	/**
-	 * Get the \DPL\Parameters object this object was constructed with.
+	 * Get the Parameters object this object was constructed with.
 	 *
-	 * @access	public
-	 * @return	object	\DPL\Parameters
+	 * @return Parameters
 	 */
 	public function getParameters() {
 		return $this->parameters;
@@ -327,53 +329,43 @@ public function getParameters() {
 	/**
 	 * Set extra list attributes for header wraps.
 	 *
-	 * @access	public
-	 * @param	string	Tag soup attributes, example: this="that" thing="no"
-	 * @return	void
+	 * @param string $attributes
 	 */
 	public function setHeadListAttributes( $attributes ) {
-		$this->headListAttributes = \Sanitizer::fixTagAttributes( $attributes, 'ul' );
+		$this->headListAttributes = Sanitizer::fixTagAttributes( $attributes, 'ul' );
 	}
 
 	/**
 	 * Set extra item attributes for header items.
 	 *
-	 * @access	public
-	 * @param	string	Tag soup attributes, example: this="that" thing="no"
-	 * @return	void
+	 * @param string $attributes
 	 */
 	public function setHeadItemAttributes( $attributes ) {
-		$this->headItemAttributes = \Sanitizer::fixTagAttributes( $attributes, 'li' );
+		$this->headItemAttributes = Sanitizer::fixTagAttributes( $attributes, 'li' );
 	}
 
 	/**
 	 * Set extra list attributes.
 	 *
-	 * @access	public
-	 * @param	string	Tag soup attributes, example: this="that" thing="no"
-	 * @return	void
+	 * @param string $attributes
 	 */
 	public function setListAttributes( $attributes ) {
-		$this->listAttributes = \Sanitizer::fixTagAttributes( $attributes, 'ul' );
+		$this->listAttributes = Sanitizer::fixTagAttributes( $attributes, 'ul' );
 	}
 
 	/**
 	 * Set extra item attributes.
 	 *
-	 * @access	public
-	 * @param	string	Tag soup attributes, example: this="that" thing="no"
-	 * @return	void
+	 * @param string $attributes
 	 */
 	public function setItemAttributes( $attributes ) {
-		$this->itemAttributes = \Sanitizer::fixTagAttributes( $attributes, 'li' );
+		$this->itemAttributes = Sanitizer::fixTagAttributes( $attributes, 'li' );
 	}
 
 	/**
 	 * Set the count of items to trigger a section as dominant.
 	 *
-	 * @access	public
-	 * @param	integer	Count
-	 * @return	void
+	 * @param int $count
 	 */
 	public function setDominantSectionCount( $count = -1 ) {
 		$this->dominantSectionCount = intval( $count );
@@ -382,8 +374,7 @@ public function setDominantSectionCount( $count = -1 ) {
 	/**
 	 * Get the count of items to trigger a section as dominant.
 	 *
-	 * @access	public
-	 * @return	integer	Count
+	 * @return int
 	 */
 	public function getDominantSectionCount() {
 		return $this->dominantSectionCount;
@@ -392,8 +383,7 @@ public function getDominantSectionCount() {
 	/**
 	 * Return the list style.
 	 *
-	 * @access	public
-	 * @return	integer	List style constant.
+	 * @return int
 	 */
 	public function getStyle() {
 		return $this->style;
@@ -402,9 +392,7 @@ public function getStyle() {
 	/**
 	 * Set the template suffix for whatever the hell uses it.
 	 *
-	 * @access	public
-	 * @param	string	Template Suffix
-	 * @return	void
+	 * @param string $suffix
 	 */
 	public function setTemplateSuffix( $suffix = '.default' ) {
 		$this->templateSuffix = $suffix;
@@ -413,8 +401,7 @@ public function setTemplateSuffix( $suffix = '.default' ) {
 	/**
 	 * Get the template suffix for whatever the hell uses it.
 	 *
-	 * @access	public
-	 * @return	string
+	 * @return string
 	 */
 	public function getTemplateSuffix() {
 		return $this->templateSuffix;
@@ -423,9 +410,7 @@ public function getTemplateSuffix() {
 	/**
 	 * Set if included wiki text should be trimmed.
 	 *
-	 * @access	public
-	 * @param	boolean	[Optional] Trim
-	 * @return	void
+	 * @param bool $trim
 	 */
 	public function setTrimIncluded( $trim = false ) {
 		$this->trimIncluded = boolval( $trim );
@@ -434,8 +419,7 @@ public function setTrimIncluded( $trim = false ) {
 	/**
 	 * Get if included wiki text should be trimmed.
 	 *
-	 * @access	public
-	 * @return	boolean	Trim
+	 * @return bool
 	 */
 	public function getTrimIncluded() {
 		return $this->trimIncluded;
@@ -445,9 +429,7 @@ public function getTrimIncluded() {
 	 * Set if links should be escaped?
 	 * @todo The naming of this parameter is weird and I am not sure what it does.
 	 *
-	 * @access	public
-	 * @param	boolean	[Optional] Escape
-	 * @return	void
+	 * @param bool $escape
 	 */
 	public function setEscapeLinks( $escape = true ) {
 		$this->escapeLinks = boolval( $escape );
@@ -456,8 +438,7 @@ public function setEscapeLinks( $escape = true ) {
 	/**
 	 * Get if links should be escaped.
 	 *
-	 * @access	public
-	 * @return	boolean	Escape
+	 * @return bool
 	 */
 	public function getEscapeLinks() {
 		return $this->escapeLinks;
@@ -466,9 +447,7 @@ public function getEscapeLinks() {
 	/**
 	 * Set the index of the table column to sort by.
 	 *
-	 * @access	public
-	 * @param	mixed	[Optional] Integer index or null to disable.
-	 * @return	void
+	 * @param int|null $index
 	 */
 	public function setTableSortColumn( $index = null ) {
 		$this->tableSortColumn = $index === null ? null : intval( $index );
@@ -477,8 +456,7 @@ public function setTableSortColumn( $index = null ) {
 	/**
 	 * Get the index of the table column to sort by.
 	 *
-	 * @access	public
-	 * @return	mixed	Integer index or null to disable.
+	 * @return int|null
 	 */
 	public function getTableSortColumn() {
 		return $this->tableSortColumn;
@@ -487,19 +465,16 @@ public function getTableSortColumn() {
 	/**
 	 * Set the algorithm for table sorting
 	 *
-	 * @access	public
-	 * @param	string	Algorithm name
-	 * @return	void
+	 * @param string|null $method
 	 */
-	public function setTableSortMethod($method = null) {
+	public function setTableSortMethod( $method = null ) {
 		$this->tableSortMethod = $method === null ? 'standard' : $method;
 	}
 
 	/**
 	 * Get the algorithm for table sorting
 	 *
-	 * @access	public
-	 * @return	string	Algorithm name
+	 * @return string
 	 */
 	public function getTableSortMethod() {
 		return $this->tableSortMethod;
@@ -508,9 +483,7 @@ public function getTableSortMethod() {
 	/**
 	 * Set the maximum title length for display.
 	 *
-	 * @access	public
-	 * @param	mixed	[Optional] Integer length or null to disable.
-	 * @return	void
+	 * @param int|null $length
 	 */
 	public function setTitleMaxLength( $length = null ) {
 		$this->titleMaxLength = $length === null ? null : intval( $length );
@@ -519,8 +492,7 @@ public function setTitleMaxLength( $length = null ) {
 	/**
 	 * Get the maximum title length for display.
 	 *
-	 * @access	public
-	 * @return	mixed	Integer length or null to disable.
+	 * @return int|null
 	 */
 	public function getTitleMaxLength() {
 		return $this->titleMaxLength;
@@ -529,31 +501,25 @@ public function getTitleMaxLength() {
 	/**
 	 * Set the separators that separate sections of matched page text.
 	 *
-	 * @access	public
-	 * @param	array	[Optional] Array of section separators.
-	 * @return	void
+	 * @param ?array $separators
 	 */
 	public function setSectionSeparators( ?array $separators ) {
-		$this->sectionSeparators = (array)$separators ?? [];
+		$this->sectionSeparators = $separators ?? [];
 	}
 
 	/**
 	 * Set the separators that separate related sections of matched page text.
 	 *
-	 * @access	public
-	 * @param	array	[Optional] Array of section separators.
-	 * @return	void
+	 * @param ?array $separators
 	 */
 	public function setMultiSectionSeparators( ?array $separators ) {
-		$this->multiSectionSeparators = (array)$separators ?? [];
+		$this->multiSectionSeparators = $separators ?? [];
 	}
 
 	/**
 	 * Set if wiki text should be included in output.
 	 *
-	 * @access	public
-	 * @param	boolean	[Optional] Parse
-	 * @return	void
+	 * @param bool $include
 	 */
 	public function setIncludePageText( $include = false ) {
 		$this->includePageText = boolval( $include );
@@ -562,9 +528,7 @@ public function setIncludePageText( $include = false ) {
 	/**
 	 * Set the maximum included page text length before truncating.
 	 *
-	 * @access	public
-	 * @param	mixed	[Optional] Integer length or null to disable.
-	 * @return	void
+	 * @param int|null $length
 	 */
 	public function setIncludePageMaxLength( $length = null ) {
 		$this->includePageMaxLength = $length === null ? null : intval( $length );
@@ -573,42 +537,34 @@ public function setIncludePageMaxLength( $length = null ) {
 	/**
 	 * Set the plain string text matching for page transclusion.
 	 *
-	 * @access	public
-	 * @param	array	[Optional] Array of plain string matches.
-	 * @return	void
+	 * @param array	$pageTextMatch
 	 */
 	public function setPageTextMatch( array $pageTextMatch = [] ) {
-		$this->pageTextMatch = (array)$pageTextMatch;
+		$this->pageTextMatch = $pageTextMatch;
 	}
 
 	/**
 	 * Set the regex text matching for page transclusion.
 	 *
-	 * @access	public
-	 * @param	array	[Optional] Array of regexes.
-	 * @return	void
+	 * @param array	$pageTextMatchRegex
 	 */
 	public function setPageTextMatchRegex( array $pageTextMatchRegex = [] ) {
-		$this->pageTextMatchRegex = (array)$pageTextMatchRegex;
+		$this->pageTextMatchRegex = $pageTextMatchRegex;
 	}
 
 	/**
 	 * Set the not regex text matching for page transclusion.
 	 *
-	 * @access	public
-	 * @param	array	[Optional] Array of regexes.
-	 * @return	void
+	 * @param array	$pageTextMatchNotRegex
 	 */
 	public function setPageTextMatchNotRegex( array $pageTextMatchNotRegex = [] ) {
-		$this->pageTextMatchNotRegex = (array)$pageTextMatchNotRegex;
+		$this->pageTextMatchNotRegex = $pageTextMatchNotRegex;
 	}
 
 	/**
 	 * Set if included wiki text should be parsed before being matched against.
 	 *
-	 * @access	public
-	 * @param	boolean	[Optional] Parse
-	 * @return	void
+	 * @param bool $parse
 	 */
 	public function setIncludePageParsed( $parse = false ) {
 		$this->includePageParsed = boolval( $parse );
@@ -617,9 +573,8 @@ public function setIncludePageParsed( $parse = false ) {
 	/**
 	 * Shortcut to format all articles into a single formatted list.
 	 *
-	 * @access	public
-	 * @param	array	List of \DPL\Article
-	 * @return	string	Formatted list.
+	 * @param array $articles
+	 * @return string
 	 */
 	public function format( $articles ) {
 		return $this->formatList( $articles, 0, count( $articles ) );
@@ -628,17 +583,18 @@ public function format( $articles ) {
 	/**
 	 * Format a list of articles into a singular list.
 	 *
-	 * @access	public
-	 * @param	array	List of \DPL\Article
-	 * @param	integer	Start position of the array to process.
-	 * @param	integer	Total objects from the array to process.
-	 * @return	string	Formatted list.
+	 * @param array $articles
+	 * @param int $start
+	 * @param int $count
+	 * @return string
 	 */
 	public function formatList( $articles, $start, $count ) {
 		$filteredCount = 0;
 		$items = [];
+
 		for ( $i = $start; $i < $start + $count; $i++ ) {
 			$article = $articles[$i];
+
 			if ( empty( $article ) || empty( $article->mTitle ) ) {
 				continue;
 			}
@@ -663,20 +619,19 @@ public function formatList( $articles, $start, $count ) {
 	/**
 	 * Format a single item.
 	 *
-	 * @access	public
-	 * @param	object	DPL\Article
-	 * @param	string	[Optional] Page text to include.
-	 * @return	string	Item HTML
+	 * @param Article $article
+	 * @param string|null $pageText
+	 * @return string
 	 */
 	public function formatItem( Article $article, $pageText = null ) {
 		global $wgLang;
 
 		$item = '';
 
-		// DPL Article, not MediaWiki.
 		$date = $article->getDate();
 		if ( $date !== null ) {
 			$item .= $date . ' ';
+
 			if ( $article->mRevision !== null ) {
 				$item .= '[{{fullurl:' . $article->mTitle . '|oldid=' . $article->mRevision . '}} ' . htmlspecialchars( $article->mTitle ) . ']';
 			} else {
@@ -701,6 +656,7 @@ public function formatItem( Article $article, $pageText = null ) {
 
 		if ( $article->mUserLink !== null ) {
 			$item .= ' . . [[User:' . $article->mUser . '|' . $article->mUser . ']]';
+
 			if ( $article->mComment != '' ) {
 				$item .= ' { ' . $article->mComment . ' }';
 			}
@@ -719,7 +675,7 @@ public function formatItem( Article $article, $pageText = null ) {
 		}
 
 		if ( $pageText !== null ) {
-			//Include parsed/processed wiki markup content after each item before the closing tag.
+			// Include parsed/processed wiki markup content after each item before the closing tag.
 			$item .= $pageText;
 		}
 
@@ -733,8 +689,7 @@ public function formatItem( Article $article, $pageText = null ) {
 	/**
 	 * Return $this->headListStart with attributes replaced.
 	 *
-	 * @access	public
-	 * @return	string	Head List Start
+	 * @return string
 	 */
 	public function getHeadListStart() {
 		return sprintf( $this->headListStart, $this->headListAttributes );
@@ -743,8 +698,7 @@ public function getHeadListStart() {
 	/**
 	 * Return $this->headItemStart with attributes replaced.
 	 *
-	 * @access	public
-	 * @return	string	Head Item Start
+	 * @return string
 	 */
 	public function getHeadItemStart() {
 		return sprintf( $this->headItemStart, $this->headItemAttributes );
@@ -753,8 +707,7 @@ public function getHeadItemStart() {
 	/**
 	 * Return $this->headItemStart with attributes replaced.
 	 *
-	 * @access	public
-	 * @return	string	Head Item End
+	 * @return string
 	 */
 	public function getHeadItemEnd() {
 		return $this->headItemEnd;
@@ -763,8 +716,7 @@ public function getHeadItemEnd() {
 	/**
 	 * Return $this->listStart with attributes replaced.
 	 *
-	 * @access	public
-	 * @return	string	List Start
+	 * @return string
 	 */
 	public function getListStart() {
 		return sprintf( $this->listStart, $this->listAttributes );
@@ -773,8 +725,7 @@ public function getListStart() {
 	/**
 	 * Return $this->itemStart with attributes replaced.
 	 *
-	 * @access	public
-	 * @return	string	Item Start
+	 * @return string
 	 */
 	public function getItemStart() {
 		return sprintf( $this->itemStart, $this->itemAttributes );
@@ -783,8 +734,7 @@ public function getItemStart() {
 	/**
 	 * Return $this->itemEnd with attributes replaced.
 	 *
-	 * @access	public
-	 * @return	string	Item End
+	 * @return string
 	 */
 	public function getItemEnd() {
 		return $this->itemEnd;
@@ -793,9 +743,8 @@ public function getItemEnd() {
 	/**
 	 * Join together items after being processed by formatItem().
 	 *
-	 * @protected
-	 * @param	array	Items as formatted by formatItem().
-	 * @return	string	Imploded items.
+	 * @param array $items
+	 * @return string
 	 */
 	protected function implodeItems( $items ) {
 		return implode( '', $items );
@@ -804,10 +753,9 @@ protected function implodeItems( $items ) {
 	/**
 	 * Replace user tag parameters.
 	 *
-	 * @protected
-	 * @param	string	Text to perform replacements on.
-	 * @param	object	\DPL\Article
-	 * @return	string	Text with replacements performed.
+	 * @param string $tag
+	 * @param Article $article
+	 * @return string
 	 */
 	protected function replaceTagParameters( $tag, Article $article ) {
 		$contLang = MediaWikiServices::getInstance()->getContentLanguage();
@@ -827,7 +775,7 @@ protected function replaceTagParameters( $tag, Article $article ) {
 		}
 
 		$tag = str_replace( '%PAGE%', $pagename, $tag );
-		$tag = str_replace( '%PAGEID%', $article->mID, $tag );
+		$tag = str_replace( '%PAGEID%', (string)$article->mID, $tag );
 		$tag = str_replace( '%NAMESPACE%', $namespaces[$article->mNamespace], $tag );
 		$tag = str_replace( '%IMAGE%', $imageUrl, $tag );
 		$tag = str_replace( '%EXTERNALLINK%', $article->mExternalLink, $tag );
@@ -835,23 +783,26 @@ protected function replaceTagParameters( $tag, Article $article ) {
 
 		$title = $article->mTitle->getText();
 		$replaceInTitle = $this->getParameters()->getParameter( 'replaceintitle' );
+
 		if ( is_array( $replaceInTitle ) && count( $replaceInTitle ) === 2 ) {
 			$title = preg_replace( $replaceInTitle[0], $replaceInTitle[1], $title );
 		}
+
 		$titleMaxLength = $this->getTitleMaxLength();
 		if ( $titleMaxLength !== null && ( strlen( $title ) > $titleMaxLength ) ) {
 			$title = substr( $title, 0, $titleMaxLength ) . '...';
 		}
+
 		$tag = str_replace( '%TITLE%', $title, $tag );
 
-		$tag = str_replace( '%COUNT%', $article->mCounter, $tag );
-		$tag = str_replace( '%COUNTFS%', floor( log( $article->mCounter ) * 0.7 ), $tag );
-		$tag = str_replace( '%COUNTFS2%', floor( sqrt( log( $article->mCounter ) ) ), $tag );
-		$tag = str_replace( '%SIZE%', $article->mSize, $tag );
-		$tag = str_replace( '%SIZEFS%', floor( sqrt( log( $article->mSize ) ) * 2.5 - 5 ), $tag );
+		$tag = str_replace( '%COUNT%', (string)$article->mCounter, $tag );
+		$tag = str_replace( '%COUNTFS%', (string)( floor( log( $article->mCounter ) * 0.7 ) ), $tag );
+		$tag = str_replace( '%COUNTFS2%', (string)( floor( sqrt( log( $article->mCounter ) ) ) ), $tag );
+		$tag = str_replace( '%SIZE%', (string)$article->mSize, $tag );
+		$tag = str_replace( '%SIZEFS%', (string)( floor( sqrt( log( $article->mSize ) ) * 2.5 - 5 ) ), $tag );
 		$tag = str_replace( '%DATE%', $article->getDate(), $tag );
-		$tag = str_replace( '%REVISION%', $article->mRevision, $tag );
-		$tag = str_replace( '%CONTRIBUTION%', $article->mContribution, $tag );
+		$tag = str_replace( '%REVISION%', (string)$article->mRevision, $tag );
+		$tag = str_replace( '%CONTRIBUTION%', (string)$article->mContribution, $tag );
 		$tag = str_replace( '%CONTRIB%', $article->mContrib, $tag );
 		$tag = str_replace( '%CONTRIBUTOR%', $article->mContributor, $tag );
 		$tag = str_replace( '%USER%', $article->mUser, $tag );
@@ -863,6 +814,7 @@ protected function replaceTagParameters( $tag, Article $article ) {
 				$tag = str_replace( '%PAGESEL%', $namespaces[$article->mSelNamespace] . ':' . str_replace( '_', ' ', $article->mSelTitle ), $tag );
 			}
 		}
+
 		$tag = str_replace( '%IMAGESEL%', str_replace( '_', ' ', $article->mImageSelTitle ), $tag );
 
 		$tag = $this->replaceTagCategory( $tag, $article );
@@ -873,10 +825,9 @@ protected function replaceTagParameters( $tag, Article $article ) {
 	/**
 	 * Replace user tag parameters for categories.
 	 *
-	 * @protected
-	 * @param	string	Text to perform replacements on.
-	 * @param	object	\DPL\Article
-	 * @return	string	Text with replacements performed.
+	 * @param string $tag
+	 * @param Article $article
+	 * @return string
 	 */
 	protected function replaceTagCategory( $tag, Article $article ) {
 		if ( !empty( $article->mCategoryLinks ) ) {
@@ -895,66 +846,63 @@ protected function replaceTagCategory( $tag, Article $article ) {
 	/**
 	 * Replace the %NR%(current article sequence number) in text.
 	 *
-	 * @protected
-	 * @param	string	Text to perform replacements on.
-	 * @param	integer	The current article sequence number (starting from 1).
-	 * @return	string	Text with replacements performed.
+	 * @param string $tag
+	 * @param int $nr
+	 * @return string
 	 */
 	protected function replaceTagCount( $tag, $nr ) {
-		return str_replace( '%NR%', $nr, $tag );
+		return str_replace( '%NR%', (string)$nr, $tag );
 	}
 
-	//
-
 	/**
 	 * Format one single item of an entry in the output list (i.e. one occurence of one item from the include parameter).
-	 * @todo I am not exactly sure how this function differs from replaceTagParameters().  It has something to do with table row formatting.  --Alexia
 	 *
-	 * @private
-	 * @param	array	String pieces to perform replacements on.
-	 * @param	mixed	Index of the table row position.
-	 * @param	object	\DPL\Article
-	 * @return	void
+	 * @param array &$pieces
+	 * @param mixed $s Index of the table row position.
+	 * @param Article $article
 	 */
 	private function replaceTagTableRow( &$pieces, $s, Article $article ) {
 		$tableFormat = $this->getParameters()->getParameter( 'tablerow' );
 		$firstCall = true;
+
 		foreach ( $pieces as $key => $val ) {
 			if ( isset( $tableFormat[$s] ) ) {
 				if ( $s == 0 || $firstCall ) {
 					$pieces[$key] = str_replace( '%%', $val, $tableFormat[$s] );
 				} else {
 					$n = strpos( $tableFormat[$s], '|' );
+
 					if ( $n === false || !( strpos( substr( $tableFormat[$s], 0, $n ), '{' ) === false ) || !( strpos( substr( $tableFormat[$s], 0, $n ), '[' ) === false ) ) {
 						$pieces[$key] = str_replace( '%%', $val, $tableFormat[$s] );
 					} else {
 						$pieces[$key] = str_replace( '%%', $val, substr( $tableFormat[$s], $n + 1 ) );
 					}
 				}
+
 				$pieces[$key] = str_replace( '%IMAGE%', $this->parseImageUrlWithPath( $val ), $pieces[$key] );
 				$pieces[$key] = str_replace( '%PAGE%', $article->mTitle->getPrefixedText(), $pieces[$key] );
 
 				$pieces[$key] = $this->replaceTagCategory( $pieces[$key], $article );
 			}
+
 			$firstCall = false;
 		}
 	}
 
 	/**
-	 * Format one single template argument of one occurence of one item from the include parameter.  This is called via a backlink from LST::includeTemplate().
-	 * @todo Again, another poorly documented function with vague functionality.  --Alexia
+	 * Format one single template argument of one occurence of one item from the include parameter. This is called via a backlink from LST::includeTemplate().
 	 *
-	 * @access	public
-	 * @param	string	Argument to parse and replace.
-	 * @param	mixed	Index of the table row position.
-	 * @param	mixed	Other part of the index of the table row position?
-	 * @param	boolean	Is this the first time this function was called in this context?
-	 * @param	integer	Maximum text length allowed.
-	 * @param	object	\DPL\Article
-	 * @return	strig	Formatted text.
+	 * @param string $arg
+	 * @param mixed	$s Index of the table row position.
+	 * @param mixed $argNr Other part of the index of the table row position?
+	 * @param bool $firstCall
+	 * @param int $maxLength
+	 * @param Article $article
+	 * @return string
 	 */
 	public function formatTemplateArg( $arg, $s, $argNr, $firstCall, $maxLength, Article $article ) {
 		$tableFormat = $this->getParameters()->getParameter( 'tablerow' );
+
 		// we could try to format fields differently within the first call of a template
 		// currently we do not make such a difference
 
@@ -962,22 +910,28 @@ public function formatTemplateArg( $arg, $s, $argNr, $firstCall, $maxLength, Art
 		// a start of a new row (wiki table syntax)
 		if ( array_key_exists( "$s.$argNr", $tableFormat ) ) {
 			$n = -1;
+
 			if ( $s >= 1 && $argNr == 0 && !$firstCall ) {
 				$n = strpos( $tableFormat["$s.$argNr"], '|' );
 				if ( $n === false || !( strpos( substr( $tableFormat["$s.$argNr"], 0, $n ), '{' ) === false ) || !( strpos( substr( $tableFormat["$s.$argNr"], 0, $n ), '[' ) === false ) ) {
 					$n = -1;
 				}
 			}
+
 			$result = str_replace( '%%', $arg, substr( $tableFormat["$s.$argNr"], $n + 1 ) );
 			$result = str_replace( '%PAGE%', $article->mTitle->getPrefixedText(), $result );
-			$result = str_replace( '%IMAGE%', $this->parseImageUrlWithPath( $arg ), $result ); //@TODO: This just blindly passes the argument through hoping it is an image.  --Alexia
+
+			// @TODO: This just blindly passes the argument through hoping it is an image.
+			$result = str_replace( '%IMAGE%', $this->parseImageUrlWithPath( $arg ), $result );
 			$result = $this->cutAt( $maxLength, $result );
+
 			if ( strlen( $result ) > 0 && $result[0] == '-' ) {
 				return ' ' . $result;
 			} else {
 				return $result;
 			}
 		}
+
 		$result = $this->cutAt( $maxLength, $arg );
 		if ( strlen( $result ) > 0 && $result[0] == '-' ) {
 			return ' ' . $result;
@@ -992,50 +946,55 @@ public function formatTemplateArg( $arg, $s, $argNr, $firstCall, $maxLength, Art
 	 * ... it is balanced in terms of braces, brackets and tags
 	 * ... can be used as content of a wikitable field without spoiling the whole surrounding wikitext structure
 	 *
-	 * @private
-	 * @param  $lim     limit of character count for the result
-	 * @param  $text    the wikitext to be truncated
-	 * @return the truncated text; note that in some cases it may be slightly longer than the given limit
-	 *         if the text is alread shorter than the limit or if the limit is negative, the text
-	 *         will be returned without any checks for balance of tags
+	 * @param int $lim
+	 * @param string $text
+	 *
+	 * @return string the truncated text; note that in some cases it may be slightly longer than the given limit
+	 * if the text is alread shorter than the limit or if the limit is negative, the text
+	 * will be returned without any checks for balance of tags
 	 */
 	private function cutAt( $lim, $text ) {
 		if ( $lim < 0 ) {
 			return $text;
 		}
+
 		return LST::limitTranscludedText( $text, $lim );
 	}
 
 	/**
 	 * Prepends an image name with its hash path.
 	 *
-	 * @protected
-	 * @param 	mixed	\DPL\Article or string image name of the image (may start with Image: or File:).
-	 * @return	string	Image URL
+	 * @param Article|string $article
+	 * @return string
 	 */
 	protected function parseImageUrlWithPath( $article ) {
+		$repoGroup = MediaWikiServices::getInstance()->getRepoGroup();
+
 		$imageUrl = '';
-		if ( $article instanceof \DPL\Article ) {
+		if ( $article instanceof Article ) {
 			if ( $article->mNamespace == NS_FILE ) {
 				// calculate URL for existing images
-				// $img = Image::newFromName($article->mTitle->getText());
-				$img = wfFindFile( \Title::makeTitle( NS_FILE, $article->mTitle->getText() ) );
+				// $img = Image::newFromName( $article->mTitle->getText() );
+
+				$img = $repoGroup->findFile( Title::makeTitle( NS_FILE, $article->mTitle->getText() ) );
 				if ( $img && $img->exists() ) {
 					$imageUrl = $img->getURL();
 				} else {
-					$fileTitle = \Title::makeTitleSafe( NS_FILE, $article->mTitle->getDBKey() );
-					$imageUrl = \RepoGroup::singleton()->getLocalRepo()->newFile( $fileTitle )->getPath();
+					$fileTitle = Title::makeTitleSafe( NS_FILE, $article->mTitle->getDBKey() );
+					$imageUrl = $repoGroup->getLocalRepo()->newFile( $fileTitle )->getPath();
 				}
 			}
 		} else {
-			$title = \Title::newfromText( 'File:' . $article );
+			$title = Title::newfromText( 'File:' . $article );
+
 			if ( $title !== null ) {
-				$fileTitle   = \Title::makeTitleSafe( 6, $title->getDBKey() );
-				$imageUrl = \RepoGroup::singleton()->getLocalRepo()->newFile( $fileTitle )->getPath();
+				$fileTitle = Title::makeTitleSafe( 6, $title->getDBKey() );
+
+				$imageUrl = $repoGroup->getLocalRepo()->newFile( $fileTitle )->getPath();
 			}
 		}
 
-		//@TODO: Check this preg_replace.  Probably only works for stock file repositories.  --Alexia
+		// @TODO: Check this preg_replace. Probably only works for stock file repositories.
 		$imageUrl = preg_replace( '~^.*images/(.*)~', '\1', $imageUrl );
 
 		return $imageUrl;
@@ -1044,36 +1003,43 @@ protected function parseImageUrlWithPath( $article ) {
 	/**
 	 * Transclude a page contents.
 	 *
-	 * @access	public
-	 * @param	object	\DPL\Article
-	 * @param	integer	Filtered Article Count
-	 * @return	string	Page Text
+	 * @param Article $article
+	 * @param int &$filteredCount
+	 * @return string
 	 */
 	public function transcludePage( Article $article, &$filteredCount ) {
 		$matchFailed = false;
+		$septag = [];
+
 		if ( empty( $this->pageTextMatch ) || $this->pageTextMatch[0] == '*' ) { // include whole article
 			$title = $article->mTitle->getPrefixedText();
+
 			if ( $this->getStyle() == self::LIST_USERFORMAT ) {
 				$pageText = '';
 			} else {
 				$pageText = '<br/>';
 			}
-			$text = $this->parser->fetchTemplate( \Title::newFromText( $title ) );
-			if ( ( count( $this->pageTextMatchRegex ) <= 0 || $this->pageTextMatchRegex[0] == '' || !preg_match( $this->pageTextMatchRegex[0], $text ) == false ) && ( count( $this->pageTextMatchNotRegex ) <= 0 || $this->pageTextMatchNotRegex[0] == '' || preg_match( $this->pageTextMatchNotRegex[0], $text ) == false ) ) {
+
+			$text = $this->parser->fetchTemplateAndTitle( Title::newFromText( $title ) )[0];
+			if ( ( count( $this->pageTextMatchRegex ) <= 0 || $this->pageTextMatchRegex[0] == '' || !( !preg_match( $this->pageTextMatchRegex[0], $text ) ) ) && ( count( $this->pageTextMatchNotRegex ) <= 0 || $this->pageTextMatchNotRegex[0] == '' || preg_match( $this->pageTextMatchNotRegex[0], $text ) == false ) ) {
 				if ( $this->includePageMaxLength > 0 && ( strlen( $text ) > $this->includePageMaxLength ) ) {
 					$text = LST::limitTranscludedText( $text, $this->includePageMaxLength, ' [[' . $title . '|..→]]' );
 				}
-				$filteredCount = $filteredCount + 1;
+
+				$filteredCount++;
 
 				// update article if include=* and updaterules are given
 				$updateRules = $this->getParameters()->getParameter( 'updaterules' );
 				$deleteRules = $this->getParameters()->getParameter( 'deleterules' );
+
 				if ( !empty( $updateRules ) ) {
 					$ruleOutput = UpdateArticle::updateArticleByRule( $title, $text, $updateRules );
+
 					// append update message to output
 					$pageText .= $ruleOutput;
 				} elseif ( !empty( $deleteRules ) ) {
 					$ruleOutput = UpdateArticle::deleteArticleByRule( $title, $text, $deleteRules );
+
 					// append delete message to output
 					$pageText .= $ruleOutput;
 				} else {
@@ -1083,6 +1049,7 @@ public function transcludePage( Article $article, &$filteredCount ) {
 						$pieces = [
 							0 => $text
 						];
+
 						$this->replaceTagTableRow( $pieces, 0, $article );
 						$pageText .= $pieces[0];
 					} else {
@@ -1094,17 +1061,20 @@ public function transcludePage( Article $article, &$filteredCount ) {
 			}
 		} else {
 			// identify section pieces
-			$secPiece       = [];
+			$secPiece = [];
 			$dominantPieces = false;
+
 			// ONE section can be marked as "dominant"; if this section contains multiple entries
 			// we will create a separate output row for each value of the dominant section
 			// the values of all other columns will be repeated
 
 			foreach ( $this->pageTextMatch as $s => $sSecLabel ) {
 				$sSecLabel = trim( $sSecLabel );
+
 				if ( $sSecLabel == '' ) {
 					break;
 				}
+
 				// if sections are identified by number we have a % at the beginning
 				if ( $sSecLabel[0] == '%' ) {
 					$sSecLabel = '#' . $sSecLabel;
@@ -1117,29 +1087,36 @@ public function transcludePage( Article $article, &$filteredCount ) {
 					$secPieces = [
 						''
 					];
+
 					$this->replaceTagTableRow( $secPieces, $s, $article );
 				} elseif ( $sSecLabel[0] != '{' ) {
-					$limpos      = strpos( $sSecLabel, '[' );
-					$cutLink     = 'default';
+					$limpos = strpos( $sSecLabel, '[' );
+					$cutLink = 'default';
 					$skipPattern = [];
+
 					if ( $limpos > 0 && $sSecLabel[strlen( $sSecLabel ) - 1] == ']' ) {
 						// regular expressions which define a skip pattern may precede the text
 						$fmtSec = explode( '~', substr( $sSecLabel, $limpos + 1, strlen( $sSecLabel ) - $limpos - 2 ) );
 						$sSecLabel = substr( $sSecLabel, 0, $limpos );
-						$cutInfo = explode( " ", $fmtSec[count( $fmtSec ) - 1], 2 );
+						$cutInfo = explode( ' ', $fmtSec[count( $fmtSec ) - 1], 2 );
 						$maxLength = intval( $cutInfo[0] );
+
 						if ( array_key_exists( '1', $cutInfo ) ) {
 							$cutLink = $cutInfo[1];
 						}
+
 						foreach ( $fmtSec as $skipKey => $skipPat ) {
 							if ( $skipKey == count( $fmtSec ) - 1 ) {
 								continue;
 							}
+
 							$skipPattern[] = $skipPat;
 						}
 					}
+
 					if ( $maxLength < 0 ) {
-						$maxLength = -1; // without valid limit include whole section
+						// without valid limit include whole section
+						$maxLength = -1;
 					}
 				}
 
@@ -1149,6 +1126,7 @@ public function transcludePage( Article $article, &$filteredCount ) {
 				} else {
 					$mustMatch = '';
 				}
+
 				if ( is_array( $this->pageTextMatchNotRegex ) && count( $this->pageTextMatchNotRegex ) > $s && !empty( $this->pageTextMatchNotRegex[$s] ) ) {
 					$mustNotMatch = $this->pageTextMatchNotRegex[$s];
 				} else {
@@ -1156,23 +1134,30 @@ public function transcludePage( Article $article, &$filteredCount ) {
 				}
 
 				// if chapters are selected by number, text or regexp we get the heading from LST::includeHeading
+				$sectionHeading = [];
 				$sectionHeading[0] = '';
+
 				if ( $sSecLabel == '-' ) {
 					$secPiece[$s] = $secPieces[0];
 				} elseif ( $sSecLabel[0] == '#' || $sSecLabel[0] == '@' ) {
 					$sectionHeading[0] = substr( $sSecLabel, 1 );
+
 					// Uses LST::includeHeading() from LabeledSectionTransclusion extension to include headings from the page
-					$secPieces = LST::includeHeading( $this->parser, $article->mTitle->getPrefixedText(), substr( $sSecLabel, 1 ), '', $sectionHeading, false, $maxLength, $cutLink, $this->getTrimIncluded(), $skipPattern );
+					$secPieces = LST::includeHeading( $this->parser, $article->mTitle->getPrefixedText(), substr( $sSecLabel, 1 ), '', $sectionHeading, false, $maxLength, $cutLink ?? 'default', $this->getTrimIncluded(), $skipPattern ?? [] );
+
 					if ( $mustMatch != '' || $mustNotMatch != '' ) {
 						$secPiecesTmp = $secPieces;
-						$offset       = 0;
+						$offset = 0;
+
 						foreach ( $secPiecesTmp as $nr => $onePiece ) {
 							if ( ( $mustMatch != '' && preg_match( $mustMatch, $onePiece ) == false ) || ( $mustNotMatch != '' && preg_match( $mustNotMatch, $onePiece ) != false ) ) {
 								array_splice( $secPieces, $nr - $offset, 1 );
+
 								$offset++;
 							}
 						}
 					}
+
 					// if maxlen was 0 we suppress all output; note that for matching we used the full text
 					if ( $maxLength == 0 ) {
 						$secPieces = [
@@ -1189,18 +1174,22 @@ public function transcludePage( Article $article, &$filteredCount ) {
 						}
 						break;
 					}
+
 					$secPiece[$s] = $secPieces[0];
 					for ( $sp = 1; $sp < count( $secPieces ); $sp++ ) {
 						if ( isset( $this->multiSectionSeparators[$s] ) ) {
-							$secPiece[$s] .= str_replace( '%SECTION%', $sectionHeading[$sp], $this->replaceTagCount( $this->multiSectionSeparators[$s], $filteredCount ) );
+							$secPiece[$s] .= str_replace( '%SECTION%', $sectionHeading[$sp] ?? '', $this->replaceTagCount( $this->multiSectionSeparators[$s], $filteredCount ) );
 						}
+
 						$secPiece[$s] .= $secPieces[$sp];
 					}
+
 					if ( $this->getDominantSectionCount() >= 0 && $s == $this->getDominantSectionCount() && count( $secPieces ) > 1 ) {
 						$dominantPieces = $secPieces;
 					}
+
 					if ( ( $mustMatch != '' || $mustNotMatch != '' ) && count( $secPieces ) <= 0 ) {
-						$matchFailed = true; // NOTHING MATCHED
+						$matchFailed = true;
 						break;
 					}
 
@@ -1209,28 +1198,34 @@ public function transcludePage( Article $article, &$filteredCount ) {
 					// primary syntax {template}suffix
 					$template1 = trim( substr( $sSecLabel, 1, strpos( $sSecLabel, '}' ) - 1 ) );
 					$template2 = trim( str_replace( '}', '', substr( $sSecLabel, 1 ) ) );
+
 					// alternate syntax: {template|surrogate}
 					if ( $template2 == $template1 && strpos( $template1, '|' ) > 0 ) {
 						$template1 = preg_replace( '/\|.*/', '', $template1 );
 						$template2 = preg_replace( '/^.+\|/', '', $template2 );
 					}
-					//Why the hell was defaultTemplateSuffix be passed all over the place for just fucking here?  --Alexia
-					$secPieces    = LST::includeTemplate( $this->parser, $this, $s, $article, $template1, $template2, $template2 . $this->getTemplateSuffix(), $mustMatch, $mustNotMatch, $this->includePageParsed, implode( ', ', $article->mCategoryLinks ) );
+
+					// Why was defaultTemplateSuffix passed all over the place for just here?
+					$secPieces = LST::includeTemplate( $this->parser, $this, $s, $article, $template1, $template2, $template2 . $this->getTemplateSuffix(), $mustMatch, $mustNotMatch, $this->includePageParsed, implode( ', ', $article->mCategoryLinks ) );
 					$secPiece[$s] = implode( isset( $this->multiSectionSeparators[$s] ) ? $this->replaceTagCount( $this->multiSectionSeparators[$s], $filteredCount ) : '', $secPieces );
+
 					if ( $this->getDominantSectionCount() >= 0 && $s == $this->getDominantSectionCount() && count( $secPieces ) > 1 ) {
 						$dominantPieces = $secPieces;
 					}
+
 					if ( ( $mustMatch != '' || $mustNotMatch != '' ) && count( $secPieces ) <= 1 && $secPieces[0] == '' ) {
-						$matchFailed = true; // NOTHING MATCHED
+						$matchFailed = true;
 						break;
 					}
 				} else {
 					// Uses LST::includeSection() from LabeledSectionTransclusion extension to include labeled sections from the page
-					$secPieces    = LST::includeSection( $this->parser, $article->mTitle->getPrefixedText(), $sSecLabel, '', false, $this->getTrimIncluded(), $skipPattern );
+					$secPieces = LST::includeSection( $this->parser, $article->mTitle->getPrefixedText(), $sSecLabel, '', false, $this->getTrimIncluded(), $skipPattern ?? [] );
 					$secPiece[$s] = implode( isset( $this->multiSectionSeparators[$s] ) ? $this->replaceTagCount( $this->multiSectionSeparators[$s], $filteredCount ) : '', $secPieces );
+
 					if ( $this->getDominantSectionCount() >= 0 && $s == $this->getDominantSectionCount() && count( $secPieces ) > 1 ) {
 						$dominantPieces = $secPieces;
 					}
+
 					if ( ( $mustMatch != '' && preg_match( $mustMatch, $secPiece[$s] ) == false ) || ( $mustNotMatch != '' && preg_match( $mustNotMatch, $secPiece[$s] ) != false ) ) {
 						$matchFailed = true;
 						break;
@@ -1246,6 +1241,7 @@ public function transcludePage( Article $article, &$filteredCount ) {
 				} else {
 					$septag[$s * 2] = '';
 				}
+
 				if ( isset( $this->sectionSeparators[$s * 2 + 1] ) ) {
 					$septag[$s * 2 + 1] = str_replace( '%SECTION%', $sectionHeading[0], $this->replaceTagCount( $this->sectionSeparators[$s * 2 + 1], $filteredCount ) );
 				} else {
@@ -1257,10 +1253,12 @@ public function transcludePage( Article $article, &$filteredCount ) {
 			if ( $matchFailed ) {
 				return '';
 			}
-			$filteredCount = $filteredCount + 1;
+
+			$filteredCount++;
 
 			// assemble parts with separators
 			$pageText = '';
+
 			if ( $dominantPieces != false ) {
 				foreach ( $dominantPieces as $dominantPiece ) {
 					foreach ( $secPiece as $s => $piece ) {
@@ -1277,17 +1275,17 @@ public function transcludePage( Article $article, &$filteredCount ) {
 				}
 			}
 		}
+
 		return $pageText;
 	}
 
 	/**
 	 * Wrap seciton pieces with start and end tags.
 	 *
-	 * @protected
-	 * @param	string	Piece to be wrapped.
-	 * @param	string	Text to prepend.
-	 * @param	string	Text to append.
-	 * @return	string	Wrapped text.
+	 * @param string $piece
+	 * @param string $start
+	 * @param string $end
+	 * @return string
 	 */
 	protected function joinSectionTagPieces( $piece, $start, $end ) {
 		return $start . $piece . $end;
@@ -1296,8 +1294,7 @@ protected function joinSectionTagPieces( $piece, $start, $end ) {
 	/**
 	 * Get the count of listed items after formatting, transcluding, and such.
 	 *
-	 * @access	public
-	 * @return	integer	Row Count
+	 * @return int
 	 */
 	public function getRowCount() {
 		return $this->rowCount;
diff --git a/includes/lister/OrderedList.php b/includes/lister/OrderedList.php
index aba636e3..d1de1ae0 100644
--- a/includes/lister/OrderedList.php
+++ b/includes/lister/OrderedList.php
@@ -1,12 +1,4 @@
 <?php
-/**
- * DynamicPageList3
- * DPL OrderedList Class
- *
- * @license		GPL-2.0-or-later
- * @package		DynamicPageList3
- *
- */
 
 namespace DPL\Lister;
 
@@ -14,7 +6,7 @@ class OrderedList extends UnorderedList {
 	/**
 	 * Listing style for this class.
 	 *
-	 * @var constant
+	 * @var int
 	 */
 	public $style = parent::LIST_ORDERED;
 
@@ -42,31 +34,30 @@ class OrderedList extends UnorderedList {
 	/**
 	 * Format the list of articles.
 	 *
-	 * @access	public
-	 * @param	array	List of \DPL\Article
-	 * @param	integer	Start position of the array to process.
-	 * @param	integer	Total objects from the array to process.
-	 * @return	string	Formatted list.
+	 * @param array $articles
+	 * @param int $start
+	 * @param int $count
+	 * @return string
 	 */
 	public function formatList( $articles, $start, $count ) {
 		$this->offsetCount = $count;
+
 		return parent::formatList( $articles, $start, $count );
 	}
 
 	/**
 	 * Return $this->listStart with attributes replaced.
 	 *
-	 * @access	public
-	 * @return	string	List Start
+	 * @return string
 	 */
 	public function getListStart() {
 		// increase start value of ordered lists at multi-column output
-		//The offset that comes from the URL parameter is zero based, but has to be +1'ed for display.
+		// The offset that comes from the URL parameter is zero based, but has to be +1'ed for display.
 		$offset = $this->getParameters()->getParameter( 'offset' ) + 1;
 
 		if ( $offset != 0 ) {
-			//@TODO: So this adds the total count of articles to the offset.  I have not found a case where this does not mess up the displayed count.  I am commenting this out for now.
-			//$offset += $this->offsetCount;
+			// @TODO: So this adds the total count of articles to the offset. I have not found a case where this does not mess up the displayed count. I am commenting this out for now.
+			// $offset += $this->offsetCount;
 		}
 
 		return sprintf( $this->listStart, $this->listAttributes . ' start="' . $offset . '"' );
diff --git a/includes/lister/SubPageList.php b/includes/lister/SubPageList.php
index b42e8c09..574acb21 100644
--- a/includes/lister/SubPageList.php
+++ b/includes/lister/SubPageList.php
@@ -1,12 +1,4 @@
 <?php
-/**
- * DynamicPageList3
- * DPL SubPageList Class
- *
- * @license		GPL-2.0-or-later
- * @package		DynamicPageList3
- *
- */
 
 namespace DPL\Lister;
 
@@ -14,7 +6,7 @@ class SubPageList extends UnorderedList {
 	/**
 	 * Listing style for this class.
 	 *
-	 * @var constant
+	 * @var int
 	 */
 	public $style = parent::LIST_UNORDERED;
 
@@ -49,17 +41,18 @@ class SubPageList extends UnorderedList {
 	/**
 	 * Format a list of articles into a singular list.
 	 *
-	 * @access	public
-	 * @param	array	List of \DPL\Article
-	 * @param	integer	Start position of the array to process.
-	 * @param	integer	Total objects from the array to process.
-	 * @return	string	Formatted list.
+	 * @param array $articles
+	 * @param int $start
+	 * @param int $count
+	 * @return string
 	 */
 	public function formatList( $articles, $start, $count ) {
 		$filteredCount = 0;
 		$items = [];
+
 		for ( $i = $start; $i < $start + $count; $i++ ) {
 			$article = $articles[$i];
+
 			if ( empty( $article ) || empty( $article->mTitle ) ) {
 				continue;
 			}
@@ -84,22 +77,26 @@ public function formatList( $articles, $start, $count ) {
 	/**
 	 * Nest items down to the proper level.
 	 *
-	 * @private
-	 * @param	array	Part levels to nest down to.
-	 * @param	array	Items holder to nest the item into.
-	 * @param	string	Formatted Item
-	 * @return	array	Nest Items
+	 * @param array &$parts
+	 * @param array $items
+	 * @param string $item
+	 * @return array
 	 */
 	private function nestItem( &$parts, $items, $item ) {
 		$firstPart = reset( $parts );
+
 		if ( count( $parts ) > 1 ) {
 			array_shift( $parts );
+
 			if ( !isset( $items[$firstPart] ) ) {
 				$items[$firstPart] = [];
 			}
+
 			$items[$firstPart] = $this->nestItem( $parts, $items[$firstPart], $item );
+
 			return $items;
 		}
+
 		$items[$firstPart][] = $item;
 
 		return $items;
@@ -108,21 +105,23 @@ private function nestItem( &$parts, $items, $item ) {
 	/**
 	 * Join together items after being processed by formatItem().
 	 *
-	 * @protected
-	 * @param	array	Items as formatted by formatItem().
-	 * @return	string	Imploded items.
+	 * @param array $items
+	 * @return string
 	 */
 	protected function implodeItems( $items ) {
 		$list = '';
+
 		foreach ( $items as $key => $item ) {
 			if ( is_string( $item ) ) {
 				$list .= $item;
 				continue;
 			}
+
 			if ( is_array( $item ) ) {
 				$list .= $this->getItemStart() . $key . $this->getListStart() . $this->implodeItems( $item ) . $this->listEnd . $this->getItemEnd();
 			}
 		}
+
 		return $list;
 	}
 }
diff --git a/includes/lister/UnorderedList.php b/includes/lister/UnorderedList.php
index 0c7c6e43..05d850fe 100644
--- a/includes/lister/UnorderedList.php
+++ b/includes/lister/UnorderedList.php
@@ -1,12 +1,4 @@
 <?php
-/**
- * DynamicPageList3
- * DPL UnorderedList Class
- *
- * @license		GPL-2.0-or-later
- * @package		DynamicPageList3
- *
- */
 
 namespace DPL\Lister;
 
@@ -14,7 +6,7 @@ class UnorderedList extends Lister {
 	/**
 	 * Listing style for this class.
 	 *
-	 * @var constant
+	 * @var int
 	 */
 	public $style = parent::LIST_UNORDERED;
 
diff --git a/includes/lister/UserFormatList.php b/includes/lister/UserFormatList.php
index 7aa8faff..7f379c92 100644
--- a/includes/lister/UserFormatList.php
+++ b/includes/lister/UserFormatList.php
@@ -1,22 +1,16 @@
 <?php
-/**
- * DynamicPageList3
- * DPL UserFormatList Class
- *
- * @license		GPL-2.0-or-later
- * @package		DynamicPageList3
- *
- */
 
 namespace DPL\Lister;
 
 use DPL\Article;
+use DPL\Parameters;
+use Parser;
 
 class UserFormatList extends Lister {
 	/**
 	 * Listing style for this class.
 	 *
-	 * @var constant
+	 * @var int
 	 */
 	public $style = parent::LIST_USERFORMAT;
 
@@ -28,26 +22,27 @@ class UserFormatList extends Lister {
 	protected $textSeparator = '';
 
 	/**
-	 * Main Constructor
-	 *
-	 * @access	public
-	 * @param	object	\DPL\Parameters
-	 * @param	object	MediaWiki \Parser
-	 * @return	void
+	 * @param Parameters $parameters
+	 * @param Parser $parser
 	 */
-	public function __construct( \DPL\Parameters $parameters, \Parser $parser ) {
+	public function __construct( Parameters $parameters, Parser $parser ) {
 		parent::__construct( $parameters, $parser );
+
 		$this->textSeparator = $parameters->getParameter( 'inlinetext' );
 		$listSeparators = $parameters->getParameter( 'listseparators' );
+
 		if ( isset( $listSeparators[0] ) ) {
 			$this->listStart = $listSeparators[0];
 		}
+
 		if ( isset( $listSeparators[1] ) ) {
 			$this->itemStart = $listSeparators[1];
 		}
+
 		if ( isset( $listSeparators[2] ) ) {
 			$this->itemEnd = $listSeparators[2];
 		}
+
 		if ( isset( $listSeparators[3] ) ) {
 			$this->listEnd = $listSeparators[3];
 		}
@@ -56,17 +51,18 @@ public function __construct( \DPL\Parameters $parameters, \Parser $parser ) {
 	/**
 	 * Format the list of articles.
 	 *
-	 * @access	public
-	 * @param	array	List of \DPL\Article
-	 * @param	integer	Start position of the array to process.
-	 * @param	integer	Total objects from the array to process.
-	 * @return	string	Formatted list.
+	 * @param array $articles
+	 * @param int $start
+	 * @param int $count
+	 * @return string
 	 */
 	public function formatList( $articles, $start, $count ) {
 		$filteredCount = 0;
 		$items = [];
+
 		for ( $i = $start; $i < $start + $count; $i++ ) {
 			$article = $articles[$i];
+
 			if ( empty( $article ) || empty( $article->mTitle ) ) {
 				continue;
 			}
@@ -86,13 +82,16 @@ public function formatList( $articles, $start, $count ) {
 		$this->rowCount = $filteredCount;
 
 		// if requested we sort the table by the contents of a given column
-		$sortColumn	= $this->getTableSortColumn();
+		$sortColumn = $this->getTableSortColumn();
 		if ( $sortColumn != 0 ) {
 			$rowsKey = [];
+
 			foreach ( $items as $index => $item ) {
 				$item = trim( $item );
+
 				if ( strpos( $item, '|-' ) === 0 ) {
 					$item = explode( '|-', $item, 2 );
+
 					if ( count( $item ) == 2 ) {
 						$item = $item[1];
 					} else {
@@ -100,25 +99,33 @@ public function formatList( $articles, $start, $count ) {
 						continue;
 					}
 				}
+
 				if ( strlen( $item ) > 0 ) {
 					$word = explode( "\n|", $item );
+
 					if ( isset( $word[0] ) && empty( $word[0] ) ) {
 						array_shift( $word );
 					}
+
 					if ( isset( $word[abs( $sortColumn ) - 1] ) ) {
 						$test = trim( $word[abs( $sortColumn ) - 1] );
+
 						if ( strpos( $test, '|' ) > 0 ) {
 							$test = trim( explode( '|', $test )[1] );
 						}
+
 						$rowsKey[$index] = $test;
 					}
 				}
 			}
-			$this->sort($rowsKey, $sortColumn);
+
+			$this->sort( $rowsKey, $sortColumn );
 			$newItems = [];
+
 			foreach ( $rowsKey as $index => $val ) {
 				$newItems[] = $items[$index];
 			}
+
 			$items = $newItems;
 		}
 
@@ -128,36 +135,34 @@ public function formatList( $articles, $start, $count ) {
 	/**
 	 * Sort the data of a table column in place. Preserves array keys.
 	 *
-	 * @access	public
-	 * @param	array	Table column data
-	 * @param	int		Index of the column to sort
-	 * @return	void
+	 * @param array	&$rowsKey
+	 * @param int $sortColumn
 	 */
-	protected function sort(&$rowsKey, $sortColumn) {
+	protected function sort( &$rowsKey, $sortColumn ) {
 		$sortMethod = $this->getTableSortMethod();
-	
-		if ($sortColumn < 0) {
-			switch ($sortMethod) {
+
+		if ( $sortColumn < 0 ) {
+			switch ( $sortMethod ) {
 				case 'natural':
 					// Reverse natsort()
-                    uasort($rowsKey, function($first, $second) {
-                    	return strnatcmp($second, $first);
-					});
+					uasort( $rowsKey, static function ( $first, $second ) {
+						return strnatcmp( $second, $first );
+					} );
 					break;
 				case 'standard':
 				default:
-					arsort($rowsKey);
+					arsort( $rowsKey );
 					break;
 			}
 		} else {
-			switch ($sortMethod) {
+			switch ( $sortMethod ) {
 				case 'natural':
-				natsort($rowsKey);
-				break;
-			case 'standard':
-			default:
-				asort($rowsKey);
-				break;
+					natsort( $rowsKey );
+					break;
+				case 'standard':
+				default:
+					asort( $rowsKey );
+					break;
 			}
 		}
 	}
@@ -165,16 +170,15 @@ protected function sort(&$rowsKey, $sortColumn) {
 	/**
 	 * Format a single item.
 	 *
-	 * @access	public
-	 * @param	object	DPL\Article
-	 * @param	string	[Optional] Page text to include.
-	 * @return	string	Item HTML
+	 * @param Article $article
+	 * @param string|null $pageText
+	 * @return string
 	 */
 	public function formatItem( Article $article, $pageText = null ) {
 		$item = '';
 
 		if ( $pageText !== null ) {
-			//Include parsed/processed wiki markup content after each item before the closing tag.
+			// Include parsed/processed wiki markup content after each item before the closing tag.
 			$item .= $pageText;
 		}
 
@@ -188,8 +192,7 @@ public function formatItem( Article $article, $pageText = null ) {
 	/**
 	 * Return $this->itemStart with attributes replaced.
 	 *
-	 * @access	public
-	 * @return	string	Item Start
+	 * @return string
 	 */
 	public function getItemStart() {
 		return $this->replaceTagCount( $this->itemStart, $this->getRowCount() );
@@ -198,8 +201,7 @@ public function getItemStart() {
 	/**
 	 * Return $this->itemEnd with attributes replaced.
 	 *
-	 * @access	public
-	 * @return	string	Item End
+	 * @return string
 	 */
 	public function getItemEnd() {
 		return $this->replaceTagCount( $this->itemEnd, $this->getRowCount() );
@@ -208,9 +210,8 @@ public function getItemEnd() {
 	/**
 	 * Join together items after being processed by formatItem().
 	 *
-	 * @access	public
-	 * @param	array	Items as formatted by formatItem().
-	 * @return	string	Imploded items.
+	 * @param array $items
+	 * @return string
 	 */
 	protected function implodeItems( $items ) {
 		return implode( $this->textSeparator, $items );
diff --git a/maintenance/createTemplate.php b/maintenance/createTemplate.php
index f4f30268..edde9cb3 100644
--- a/maintenance/createTemplate.php
+++ b/maintenance/createTemplate.php
@@ -1,21 +1,13 @@
 <?php
-/**
- * DynamicPageList3
- * CreateTemplate
- *
- * @license GPL-2.0-or-later
- * @package DynamicPageList3
- *
- */
 
 namespace DPL\Maintenance;
 
 use CommentStoreComment;
 use LoggedUpdateMaintenance;
+use MediaWiki\MediaWikiServices;
 use MediaWiki\Revision\SlotRecord;
 use Title;
 use User;
-use WikiPage;
 
 $IP = getenv( 'MW_INSTALL_PATH' );
 if ( $IP === false ) {
@@ -31,6 +23,7 @@ class CreateTemplate extends LoggedUpdateMaintenance {
 
 	public function __construct() {
 		parent::__construct();
+
 		$this->addDescription( 'Handle inserting DPL\'s necessary template for content inclusion.' );
 	}
 
@@ -62,11 +55,14 @@ protected function doDBUpdates() {
 
 		// Make sure template does not already exist
 		if ( !$title->exists() ) {
-			$wikipage = WikiPage::factory( $title );
-			$updater = $wikipage->newPageUpdater( User::newSystemUser( 'DynamicPageList3 extension' ) );
-			$content = $wikipage->getContentHandler()->makeContent( '<noinclude>This page was automatically created.  It serves as an anchor page for all \'\'\'[[Special:WhatLinksHere/Template:Extension_DPL|invocations]]\'\'\' of [https://www.mediawiki.org/wiki/Special:MyLanguage/Extension:DynamicPageList3 Extension:DynamicPageList3].</noinclude>', $title );
+			$wikiPageFactory = MediaWikiServices::getInstance()->getWikiPageFactory();
+
+			$page = $wikiPageFactory->newFromTitle( $title );
+			$updater = $page->newPageUpdater( User::newSystemUser( 'DynamicPageList3 extension' ) );
+			$content = $page->getContentHandler()->makeContent( '<noinclude>This page was automatically created. It serves as an anchor page for all \'\'\'[[Special:WhatLinksHere/Template:Extension_DPL|invocations]]\'\'\' of [https://www.mediawiki.org/wiki/Special:MyLanguage/Extension:DynamicPageList3 Extension:DynamicPageList3].</noinclude>', $title );
 			$updater->setContent( SlotRecord::MAIN, $content );
 			$comment = CommentStoreComment::newUnsavedComment( 'Autogenerated DPL\'s necessary template for content inclusion' );
+
 			$updater->saveRevision(
 				$comment,
 				EDIT_NEW | EDIT_FORCE_BOT
diff --git a/tests/phpunit/DPLIntegrationTestCase.php b/tests/phpunit/DPLIntegrationTestCase.php
new file mode 100644
index 00000000..e8a49d61
--- /dev/null
+++ b/tests/phpunit/DPLIntegrationTestCase.php
@@ -0,0 +1,158 @@
+<?php
+
+namespace DPL;
+
+use DOMDocument;
+use DOMXPath;
+use ImportStreamSource;
+use MediaWiki\Auth\AuthManager;
+use MediaWiki\MediaWikiServices;
+use MediaWiki\User\UserFactory;
+use MediaWikiTestCase;
+use ParserOptions;
+use RequestContext;
+use Title;
+use User;
+use WikiImporter;
+
+abstract class DPLIntegrationTestCase extends MediaWikiTestCase {
+	/**
+	 * Guard condition to ensure we only import seed data once per test suite run.
+	 * @var bool
+	 */
+	private static $wasSeedDataImported = false;
+
+	public function addDBData() {
+		if ( self::$wasSeedDataImported ) {
+			return;
+		}
+
+		$seedDataPath = __DIR__ . '/../seed-data.xml';
+		$this->seedTestUsers( $seedDataPath );
+		$importer = $this->getWikiImporter( $seedDataPath );
+		$importer->disableStatisticsUpdate();
+		// Ensure we actually create local user accounts in the DB
+		$importer->setUsernamePrefix( '', true );
+		$importer->doImport();
+
+		self::$wasSeedDataImported = true;
+	}
+
+	/**
+	 * Import test accounts from seed data so that DPL queries can refer to them.
+	 * @param string $seedDataPath - path to seed data to be loaded
+	 */
+	private function seedTestUsers( string $seedDataPath ): void {
+		$doc = new DOMDocument();
+		$doc->preserveWhiteSpace = false;
+		$doc->load( $seedDataPath );
+
+		$xpath = new DOMXPath( $doc );
+		$xpath->registerNamespace( 'mw', 'http://www.mediawiki.org/xml/export-0.11/' );
+
+		$userNodes = $xpath->query( '//mw:mediawiki/mw:page/mw:revision/mw:contributor/mw:username' );
+		$usersByName = [];
+
+		$authManager = $this->getAuthManager();
+
+		foreach ( $userNodes as $node ) {
+			$userName = $node->nodeValue;
+
+			// Already created
+			if ( isset( $usersByName[$userName] ) ) {
+				continue;
+			}
+
+			$usersByName[$userName] = true;
+			$user = $this->newUserFromName( $userName );
+
+			if ( !$user || $user->idForName() !== 0 ) {
+				return; // sanity
+			}
+
+			$status = $authManager->autoCreateUser(
+				$user,
+				$authManager::AUTOCREATE_SOURCE_MAINT,
+				false
+			);
+
+			if ( !$status->isOK() ) {
+				return;
+			}
+		}
+	}
+
+	private function getWikiImporter( string $seedDataPath ): WikiImporter {
+		$seedDataFile = fopen( $seedDataPath, 'rt' );
+		$source = new ImportStreamSource( $seedDataFile );
+		$services = MediaWikiServices::getInstance();
+
+		if ( $services->hasService( 'WikiImporterFactory' ) ) {
+			return $services->getWikiImporterFactory()->getWikiImporter( $source );
+		}
+
+		// MW 1.36
+		return new WikiImporter( $source, $services->getMainConfig() );
+	}
+
+	private function getAuthManager(): AuthManager {
+		$services = MediaWikiServices::getInstance();
+
+		return $services->getAuthManager();
+	}
+
+	private function newUserFromName( string $name ): ?User {
+		$services = MediaWikiServices::getInstance();
+
+		return $services->getUserFactory()->newFromName( $name, UserFactory::RIGOR_CREATABLE );
+	}
+
+	/**
+	 * Convenience function to return the list of page titles matching a DPL query
+	 * @param array $params - DPL invocation parameters
+	 * @return string[]
+	 */
+	protected function getDPLQueryResults( array $params, string $format = '%PAGE%' ): array {
+		$params += [
+			// Use a custom format for executing the query to allow easily extracting results
+			'format' => "<div id=\"dpl-test-query\">,$format,|,</div>"
+		];
+
+		$html = $this->runDPLQuery( $params );
+		$doc = new DOMDocument();
+		$doc->loadHTML( $html );
+		$queryResults = $doc->getElementById( 'dpl-test-query' );
+		if ( $queryResults ) {
+			return explode( "|", rtrim( $queryResults->textContent, "|" ) );
+		}
+
+		return [];
+	}
+
+	/**
+	 * Build and execute a DPL invocation using the given parameters and return the HTML output.
+	 * @param array $params
+	 * @return string
+	 */
+	protected function runDPLQuery( array $params ): string {
+		$invocation = '<dpl>';
+
+		foreach ( $params as $paramName => $values ) {
+			$values = (array)$values; // multi-value parameters
+			foreach ( $values as $value ) {
+				$invocation .= "$paramName=$value\n";
+			}
+		}
+
+		$invocation .= '</dpl>';
+
+		$parser = MediaWikiServices::getInstance()->getParser();
+		$title = Title::makeTitle( NS_MAIN, 'DPLQueryTest' );
+		$parserOptions = ParserOptions::newCanonical(
+			RequestContext::getMain()
+		);
+		$parserOutput = $parser->parse( $invocation, $title, $parserOptions );
+
+		return $parserOutput->getText();
+	}
+}
diff --git a/tests/phpunit/DPLQueryIntegrationTest.php b/tests/phpunit/DPLQueryIntegrationTest.php
new file mode 100644
index 00000000..dcd78536
--- /dev/null
+++ b/tests/phpunit/DPLQueryIntegrationTest.php
@@ -0,0 +1,350 @@
+<?php
+
+namespace DPL;
+
+/**
+ * @group DynamicPageList3
+ * @group Database
+ */
+class DPLQueryIntegrationTest extends DPLIntegrationTestCase {
+
+	public function testFindPagesInCategory(): void {
+		$this->assertArrayEquals(
+			[ 'DPLTestArticle 1', 'DPLTestArticle 2', 'DPLTestArticle 3', 'DPLTestArticleMultipleCategories' ],
+			$this->getDPLQueryResults( [ 'category' => 'DPLTestCategory' ] ),
+			true
+		);
+	}
+
+	public function testFindPagesInCategoryWithOrderAndLimit(): void {
+		$this->assertArrayEquals(
+			[ 'DPLTestArticleMultipleCategories', 'DPLTestArticle 3', ],
+			$this->getDPLQueryResults( [
+				'category' => 'DPLTestCategory',
+				'ordermethod' => 'sortkey',
+				'order' => 'descending',
+				'count' => '2'
+			] ),
+			true
+		);
+	}
+
+	public function testFindPagesNotInCategory(): void {
+		$results = $this->getDPLQueryResults( [
+			'namespace' => '', // NS_MAIN
+			'notcategory' => 'DPLTestCategory'
+		] );
+
+		$this->assertContains( 'DPLTestArticleNoCategory', $results );
+		foreach ( [ 'DPLTestArticle 1', 'DPLTestArticle 2', 'DPLTestArticle 3' ] as $pageInCat ) {
+			$this->assertNotContains( $pageInCat, $results );
+		}
+	}
+
+	public function testFindPagesNotInCategoryByPrefix(): void {
+		$results = $this->getDPLQueryResults( [
+			'namespace' => '', // NS_MAIN
+			'titlematch' => 'DPLTest%',
+			'notcategory' => 'DPLTestCategory'
+		] );
+
+		$this->assertArrayEquals(
+			[ 'DPLTestArticleNoCategory', 'DPLTestArticleOtherCategoryWithInfobox' ],
+			$results,
+			true
+		);
+	}
+
+	public function testFindPagesByPrefix(): void {
+		$results = $this->getDPLQueryResults( [
+			'namespace' => '', // NS_MAIN
+			'titlematch' => 'DPLTest%',
+		] );
+
+		$this->assertNotEmpty( $results );
+
+		foreach ( $results as $result ) {
+			$this->assertStringStartsWith( 'DPLTest', $result );
+		}
+	}
+
+	public function testFindPagesInCategoryIntersection(): void {
+		$this->assertArrayEquals(
+			[ 'DPLTestArticleMultipleCategories' ],
+			$this->getDPLQueryResults( [
+				'category' => [ 'DPLTestCategory', 'DPLTestOtherCategory' ]
+			] ),
+			true
+		);
+	}
+
+	public function testFindPagesUsingTemplate(): void {
+		$this->assertArrayEquals(
+			[ 'DPLTestArticle 1', 'DPLTestArticleOtherCategoryWithInfobox' ],
+			$this->getDPLQueryResults( [
+				'uses' => 'Template:DPLInfobox'
+			] ),
+			true
+		);
+	}
+
+	public function testFindPagesInCategoryUsingTemplate(): void {
+		$this->assertArrayEquals(
+			[ 'DPLTestArticleOtherCategoryWithInfobox' ],
+			$this->getDPLQueryResults( [
+				'category' => 'DPLTestOtherCategory',
+				'uses' => 'Template:DPLInfobox'
+			] ),
+			true
+		);
+	}
+
+	public function testFindPagesNotInCategoryUsingTemplate(): void {
+		$this->assertArrayEquals(
+			[ 'DPLTestArticle 1' ],
+			$this->getDPLQueryResults( [
+				'notcategory' => 'DPLTestOtherCategory',
+				'uses' => 'Template:DPLInfobox'
+			] ),
+			true
+		);
+	}
+
+	public function testFindTemplatesUsedByPage(): void {
+		$this->assertArrayEquals(
+			[ 'Template:DPLInfobox' ],
+			$this->getDPLQueryResults( [
+				'usedby' => 'DPLTestArticleOtherCategoryWithInfobox'
+			] ),
+			true
+		);
+	}
+
+	public function testFindPagesByTitleRegexpInNamespace(): void {
+		$this->assertArrayEquals(
+			[ 'DPLTestArticle 1', 'DPLTestArticle 2' ],
+			$this->getDPLQueryResults( [
+				'namespace' => '', // NS_MAIN
+				'titleregexp' => 'DPLTestArticle [12]'
+			] )
+		);
+	}
+
+	public function testFindPagesBeforeTitleInCategory(): void {
+		$this->assertArrayEquals(
+			[ 'DPLTestArticle 1', 'DPLTestArticle 2' ],
+			$this->getDPLQueryResults( [
+				'category' => 'DPLTestCategory',
+				'titlelt' => 'DPLTestArticle 3',
+				'count' => '2'
+			] )
+		);
+	}
+
+	public function testFindPagesInCategoryWithMaxRevisionLimit(): void {
+		$this->assertArrayEquals(
+			[ 'DPLTestArticle 2', 'DPLTestArticleMultipleCategories' ],
+			$this->getDPLQueryResults( [
+				'category' => 'DPLTestCategory',
+				'maxrevisions' => '1',
+			] ),
+			true
+		);
+	}
+
+	public function testFindPagesInCategoryWithMinRevisionLimit(): void {
+		$this->assertArrayEquals(
+			[ 'DPLTestArticle 1', 'DPLTestArticle 3' ],
+			$this->getDPLQueryResults( [
+				'category' => 'DPLTestCategory',
+				'minrevisions' => '2',
+			] ),
+			true
+		);
+	}
+
+	public function testFindPagesByCategoryMin(): void {
+		$this->assertArrayEquals(
+			[ 'DPLTestArticleMultipleCategories' ],
+			$this->getDPLQueryResults( [
+				'category' => 'DPLTestCategory',
+				'categoriesminmax' => '2',
+			] ),
+			true
+		);
+	}
+
+	public function testFindPagesByCategoryMinMax(): void {
+		$this->assertArrayEquals(
+			[ 'DPLTestArticle 1', 'DPLTestArticle 2', 'DPLTestArticle 3' ],
+			$this->getDPLQueryResults( [
+				'category' => 'DPLTestCategory',
+				'categoriesminmax' => '1,1',
+			] ),
+			true
+		);
+	}
+
+	public function testFindPagesNotModifiedByUserInCategory(): void {
+		$this->assertArrayEquals(
+			[ 'DPLTestArticle 2', 'DPLTestArticle 3', 'DPLTestArticleMultipleCategories' ],
+			$this->getDPLQueryResults( [
+				'category' => 'DPLTestCategory',
+				'notmodifiedby' => 'DPLTestUser',
+			] ),
+			true
+		);
+	}
+
+	public function testFindPagesCreatedByUserInCategory(): void {
+		$this->assertArrayEquals(
+			[ 'DPLTestArticleOtherCategoryWithInfobox' ],
+			$this->getDPLQueryResults( [
+				'category' => 'DPLTestOtherCategory',
+				'createdby' => 'DPLTestSystemUser',
+			] ),
+			true
+		);
+	}
+
+	public function testFindPagesLastModifiedByUserInCategory(): void {
+		$this->assertArrayEquals(
+			[ 'DPLTestArticle 1' ],
+			$this->getDPLQueryResults( [
+				'category' => 'DPLTestCategory',
+				'lastmodifiedby' => 'DPLTestUser',
+			] ),
+			true
+		);
+	}
+
+	public function testFindPagesNotLastModifiedByUserInCategory(): void {
+		$this->assertArrayEquals(
+			[ 'DPLTestArticle 2', 'DPLTestArticle 3', 'DPLTestArticleMultipleCategories' ],
+			$this->getDPLQueryResults( [
+				'category' => 'DPLTestCategory',
+				'notlastmodifiedby' => 'DPLTestUser',
+			] ),
+			true
+		);
+	}
+
+	public function testFindPagesEverModifiedByUserInCategory(): void {
+		$this->assertArrayEquals(
+			[ 'DPLTestArticle 1', 'DPLTestArticle 2', 'DPLTestArticle 3', 'DPLTestArticleMultipleCategories' ],
+			$this->getDPLQueryResults( [
+				'category' => 'DPLTestCategory',
+				'modifiedby' => 'DPLTestAdmin',
+			] ),
+			true
+		);
+	}
+
+	public function testFindPagesNotCreatedByUserInCategory(): void {
+		$this->assertArrayEquals(
+			[ 'DPLTestArticleMultipleCategories' ],
+			$this->getDPLQueryResults( [
+				'category' => 'DPLTestOtherCategory',
+				'notcreatedby' => 'DPLTestSystemUser',
+			] ),
+			true
+		);
+	}
+
+	public function testFindPagesViaUserFilterCombinations(): void {
+		$this->assertArrayEquals(
+			[ 'DPLUncategorizedPage' ],
+			$this->getDPLQueryResults( [
+				'modifiedby' => 'DPLTestUser',
+				'notcreatedby' => 'DPLTestAdmin',
+				'notlastmodifiedby' => 'DPLTestUser',
+			] ),
+			true
+		);
+	}
+
+	public function testFindPagesInCategoryOrderedByLastEdit(): void {
+		$results = $this->getDPLQueryResults( [
+			'category' => 'DPLTestCategory',
+			'ordermethod' => 'lastedit',
+			'order' => 'descending',
+		] );
+
+		$this->assertArrayEquals(
+			[
+				'DPLTestArticle 3',
+				'DPLTestArticle 2',
+				'DPLTestArticleMultipleCategories',
+				'DPLTestArticle 1',
+			],
+			$results,
+			true
+		);
+	}
+
+	public function testFindPagesInCategoryOrderedByFirstEdit(): void {
+		$results = $this->getDPLQueryResults( [
+			'category' => 'DPLTestCategory',
+			'ordermethod' => 'firstedit',
+			'order' => 'descending',
+		] );
+
+		$this->assertArrayEquals(
+			[
+				'DPLTestArticle 2',
+				'DPLTestArticleMultipleCategories',
+				'DPLTestArticle 1',
+				'DPLTestArticle 3',
+			],
+			$results,
+			true
+		);
+	}
+
+	public function testOrderByLastEditAndUser(): void {
+		$results = $this->getDPLQueryResults( [
+			'category' => 'DPLTestCategory',
+			'ordermethod' => 'lastedit,user',
+			'order' => 'descending',
+			'adduser' => 'true',
+			'createdby' => 'DPLTestAdmin'
+		], '%PAGE% %USER%' );
+
+		$this->assertEquals( [
+			'DPLTestArticle 3 DPLTestAdmin',
+			'DPLTestArticle 2 DPLTestAdmin',
+			'DPLTestArticleMultipleCategories DPLTestAdmin',
+			'DPLTestArticle 1 DPLTestUser',
+		], $results );
+	}
+
+	public function testGetPageAuthors(): void {
+		$results = $this->getDPLQueryResults( [
+			'category' => 'DPLTestCategory',
+			'addauthor' => 'true',
+			'order' => 'ascending',
+			'ordermethod' => 'title'
+		], '%PAGE% %USER%' );
+
+		$this->assertEquals( [
+			'DPLTestArticle 1 DPLTestAdmin',
+			'DPLTestArticle 2 DPLTestAdmin',
+			'DPLTestArticle 3 DPLTestAdmin',
+			'DPLTestArticleMultipleCategories DPLTestAdmin',
+		], $results );
+	}
+
+	public function testGetLastEditorsByPage(): void {
+		$results = $this->getDPLQueryResults( [
+			'category' => 'DPLTestCategory',
+			'addlasteditor' => 'true'
+		], '%PAGE% %USER%' );
+
+		$this->assertEquals( [
+			'DPLTestArticle 1 DPLTestUser',
+			'DPLTestArticle 2 DPLTestAdmin',
+			'DPLTestArticle 3 DPLTestAdmin',
+			'DPLTestArticleMultipleCategories DPLTestAdmin',
+		], $results );
+	}
+}
diff --git a/tests/seed-data.xml b/tests/seed-data.xml
new file mode 100644
index 00000000..58198584
--- /dev/null
+++ b/tests/seed-data.xml
@@ -0,0 +1,267 @@
+<mediawiki xmlns="http://www.mediawiki.org/xml/export-0.11/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.mediawiki.org/xml/export-0.11/ http://www.mediawiki.org/xml/export-0.11.xsd" version="0.11" xml:lang="en">
+	<siteinfo>
+		<sitename>MediaWiki</sitename>
+		<dbname>mwdev</dbname>
+		<base>http://localhost:8080/wiki/Main_Page</base>
+		<generator>MediaWiki 1.37.0-alpha</generator>
+		<case>first-letter</case>
+		<namespaces>
+			<namespace key="-2" case="first-letter">Media</namespace>
+			<namespace key="-1" case="first-letter">Special</namespace>
+			<namespace key="0" case="first-letter" />
+			<namespace key="1" case="first-letter">Talk</namespace>
+			<namespace key="2" case="first-letter">User</namespace>
+			<namespace key="3" case="first-letter">User talk</namespace>
+			<namespace key="4" case="first-letter">Project</namespace>
+			<namespace key="5" case="first-letter">Project talk</namespace>
+			<namespace key="6" case="first-letter">File</namespace>
+			<namespace key="7" case="first-letter">File talk</namespace>
+			<namespace key="8" case="first-letter">MediaWiki</namespace>
+			<namespace key="9" case="first-letter">MediaWiki talk</namespace>
+			<namespace key="10" case="first-letter">Template</namespace>
+			<namespace key="11" case="first-letter">Template talk</namespace>
+			<namespace key="12" case="first-letter">Help</namespace>
+			<namespace key="13" case="first-letter">Help talk</namespace>
+			<namespace key="14" case="first-letter">Category</namespace>
+			<namespace key="15" case="first-letter">Category talk</namespace>
+		</namespaces>
+	</siteinfo>
+	<page>
+		<title>Template:DPLInfobox</title>
+		<ns>10</ns>
+		<id>13</id>
+		<revision>
+			<id>13</id>
+			<timestamp>2017-09-07T10:45:24Z</timestamp>
+			<contributor>
+				<username>DPLTestSystemUser</username>
+			</contributor>
+			<comment>Test template</comment>
+			<origin>13</origin>
+			<model>wikitext</model>
+			<format>text/x-wiki</format>
+			<text xml:space="preserve" bytes="13">Test template</text>
+			<sha1 />
+		</revision>
+	</page>
+	<page>
+		<title>Category:DPLTestCategory</title>
+		<ns>14</ns>
+		<id>14</id>
+		<revision>
+			<id>17</id>
+			<timestamp>2021-09-02T14:42:11Z</timestamp>
+			<contributor>
+				<username>DPLTestAdmin</username>
+				<id>1</id>
+			</contributor>
+			<comment>Created page with "DPL Test category"</comment>
+			<origin>17</origin>
+			<model>wikitext</model>
+			<format>text/x-wiki</format>
+			<text bytes="17" sha1="7fvwcsar4s6wpu5l22vedd9yaek5js6" xml:space="preserve">DPL Test category</text>
+			<sha1>7fvwcsar4s6wpu5l22vedd9yaek5js6</sha1>
+		</revision>
+	</page>
+	<page>
+		<title>DPLTestArticle 1</title>
+		<ns>0</ns>
+		<id>15</id>
+		<revision>
+			<id>18</id>
+			<timestamp>2021-09-02T14:43:05Z</timestamp>
+			<contributor>
+				<username>DPLTestAdmin</username>
+				<id>1</id>
+			</contributor>
+			<comment>Initial page version</comment>
+			<origin>18</origin>
+			<model>wikitext</model>
+			<format>text/x-wiki</format>
+			<text xml:space="preserve">Donec non dolor ipsum.
+[[Category:DPLTestCategory]]</text>
+			<sha1 />
+		</revision>
+		<revision>
+			<id>19</id>
+			<parentid>18</parentid>
+			<timestamp>2021-09-02T14:43:16Z</timestamp>
+			<contributor>
+				<username>DPLTestUser</username>
+				<id>2</id>
+			</contributor>
+			<comment>Edited version</comment>
+			<origin>19</origin>
+			<model>wikitext</model>
+			<format>text/x-wiki</format>
+			<text xml:space="preserve">Sed mollis dignissim [[DPLTestArticle 2]] purus, auctor faucibus [[DPLTestArticleNoCategory]] purus tincidunt at. {{DPLInfobox}}
+[[Category:DPLTestCategory]]</text>
+			<sha1 />
+		</revision>
+	</page>
+	<page>
+		<title>DPLTestArticle 2</title>
+		<ns>0</ns>
+		<id>16</id>
+		<revision>
+			<id>20</id>
+			<timestamp>2021-09-02T14:44:02Z</timestamp>
+			<contributor>
+				<username>DPLTestAdmin</username>
+				<id>1</id>
+			</contributor>
+			<comment>Initial page version</comment>
+			<origin>20</origin>
+			<model>wikitext</model>
+			<format>text/x-wiki</format>
+			<text bytes="72" sha1="gykofop7mtvar8ajsyppok80uy6fiti" xml:space="preserve">Sed dapibus enim ac quam pharetra suscipit.
+[[Category:DPLTestCategory]]</text>
+			<sha1>gykofop7mtvar8ajsyppok80uy6fiti</sha1>
+		</revision>
+	</page>
+	<page>
+		<title>DPLTestArticle 3</title>
+		<ns>0</ns>
+		<id>17</id>
+		<revision>
+			<id>21</id>
+			<timestamp>2019-08-12T00:11:23Z</timestamp>
+			<contributor>
+				<username>DPLTestAdmin</username>
+				<id>1</id>
+			</contributor>
+			<comment>Initial page version</comment>
+			<origin>21</origin>
+			<model>wikitext</model>
+			<format>text/x-wiki</format>
+			<text bytes="95" sha1="og8hxtaxjfid8cinjh7nq5g2zxv0cdj" xml:space="preserve">Vestibulum a ante aliquet, vestibulum risus vitae, imperdiet sem.
+[[Category:DPLTestCategory]]</text>
+			<sha1>og8hxtaxjfid8cinjh7nq5g2zxv0cdj</sha1>
+		</revision>
+		<revision>
+			<id>22</id>
+			<parentid>21</parentid>
+			<timestamp>2021-09-02T14:44:47Z</timestamp>
+			<contributor>
+				<username>DPLTestAdmin</username>
+				<id>1</id>
+			</contributor>
+			<comment>Edited version</comment>
+			<origin>22</origin>
+			<model>wikitext</model>
+			<format>text/x-wiki</format>
+			<text bytes="73" sha1="9caafrpllg2n9zyk52h0ov4bajyxjpj" xml:space="preserve"> Duis vel dapibus tellus, eu vehicula metus.
+[[Category:DPLTestCategory]]</text>
+			<sha1>9caafrpllg2n9zyk52h0ov4bajyxjpj</sha1>
+		</revision>
+	</page>
+	<page>
+		<title>DPLTestArticleNoCategory</title>
+		<ns>0</ns>
+		<id>18</id>
+		<revision>
+			<id>23</id>
+			<timestamp>2021-09-03T00:12:20Z</timestamp>
+			<contributor>
+				<username>DPLTestUser</username>
+				<id>2</id>
+			</contributor>
+			<comment>Create test page without category</comment>
+			<origin>23</origin>
+			<model>wikitext</model>
+			<format>text/x-wiki</format>
+			<text bytes="40" xml:space="preserve">Urbem praeclaram statui, mea moenia vidi</text>
+			<sha1 />
+		</revision>
+	</page>
+	<page>
+		<title>Category:DPLTestOtherCategory</title>
+		<ns>14</ns>
+		<id>24</id>
+		<revision>
+			<id>24</id>
+			<timestamp>2021-09-02T14:42:11Z</timestamp>
+			<contributor>
+				<username>DPLTestAdmin</username>
+				<id>1</id>
+			</contributor>
+			<comment>Created page with "DPL Test category"</comment>
+			<origin>24</origin>
+			<model>wikitext</model>
+			<format>text/x-wiki</format>
+			<text bytes="18" xml:space="preserve">DPL other category</text>
+			<sha1 />
+		</revision>
+	</page>
+	<page>
+		<title>DPLTestArticleMultipleCategories</title>
+		<ns>0</ns>
+		<id>25</id>
+		<revision>
+			<id>25</id>
+			<timestamp>2021-09-02T14:44:01Z</timestamp>
+			<contributor>
+				<username>DPLTestAdmin</username>
+				<id>1</id>
+			</contributor>
+			<comment>Page with multiple categories</comment>
+			<origin>25</origin>
+			<model>wikitext</model>
+			<format>text/x-wiki</format>
+			<text bytes="117" xml:space="preserve">Quo usque tandem abutere, Catilina, patientia nostra?!
+[[Category:DPLTestOtherCategory]]
+[[Category:DPLTestCategory]]</text>
+			<sha1 />
+		</revision>
+	</page>
+	<page>
+		<title>DPLTestArticleOtherCategoryWithInfobox</title>
+		<ns>0</ns>
+		<id>26</id>
+		<revision>
+			<id>26</id>
+			<timestamp>2021-09-02T14:44:01Z</timestamp>
+			<contributor>
+				<username>DPLTestSystemUser</username>
+			</contributor>
+			<comment>Page with infobox</comment>
+			<origin>25</origin>
+			<model>wikitext</model>
+			<format>text/x-wiki</format>
+			<text xml:space="preserve">{{DPLInfobox}} some content
+[[Category:DPLTestOtherCategory]]]</text>
+			<sha1 />
+		</revision>
+	</page>
+	<page>
+		<title>DPLUncategorizedPage</title>
+		<ns>0</ns>
+		<id>27</id>
+		<revision>
+			<id>27</id>
+			<timestamp>2021-09-04T03:01:00Z</timestamp>
+			<contributor>
+				<username>DPLTestSystemUser</username>
+			</contributor>
+			<comment>Create test uncategorized page</comment>
+			<origin>27</origin>
+			<model>wikitext</model>
+			<format>text/x-wiki</format>
+			<text xml:space="preserve">Uncategorized test page</text>
+			<sha1 />
+		</revision>
+		<revision>
+			<id>28</id>
+			<timestamp>2021-09-04T03:01:00Z</timestamp>
+			<contributor>
+				<username>DPLTestUser</username>
+			</contributor>
+			<comment>Page edited</comment>
+			<origin>27</origin>
+			<model>wikitext</model>
+			<format>text/x-wiki</format>
+			<text xml:space="preserve">Uncategorized test page edit</text>
+			<sha1 />
+		</revision>
+	</page>
+</mediawiki>
