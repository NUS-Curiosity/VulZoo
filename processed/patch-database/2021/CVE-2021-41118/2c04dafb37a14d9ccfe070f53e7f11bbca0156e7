diff --git a/.gitattributes b/.gitattributes
new file mode 100644
index 00000000..3cbfe7d8
--- /dev/null
+++ b/.gitattributes
@@ -0,0 +1 @@
+dependencies linguist-language=yaml
diff --git a/.github/dependabot.yml b/.github/dependabot.yml
new file mode 100644
index 00000000..a83a73d4
--- /dev/null
+++ b/.github/dependabot.yml
@@ -0,0 +1,10 @@
+version: 2
+updates:
+  - package-ecosystem: "github-actions"
+    directory: "/"
+    schedule:
+      interval: "daily"
+  - package-ecosystem: "composer"
+    directory: "/"
+    schedule:
+      interval: "daily"
diff --git a/.github/workflows/dependencies b/.github/workflows/dependencies
new file mode 100644
index 00000000..333045ab
--- /dev/null
+++ b/.github/workflows/dependencies
@@ -0,0 +1,3 @@
+Variables:
+  branch: auto
+  repo: auto
diff --git a/.github/workflows/mediawiki-tests.yml b/.github/workflows/mediawiki-tests.yml
new file mode 100644
index 00000000..b5278cfb
--- /dev/null
+++ b/.github/workflows/mediawiki-tests.yml
@@ -0,0 +1,433 @@
+name: Quibble and Phan
+
+on:
+  push:
+    branches: [ master ]
+  pull_request:
+    branches: [ master ]
+
+jobs:
+  test:
+    name: "${{ matrix.mw }} | PHP ${{ matrix.php }} (${{ matrix.stage }})"
+
+    strategy:
+      matrix:
+        include:
+          # Latest stable MediaWiki - PHP 7.3 (phan)
+          - mw: 'REL1_36'
+            php: 7.3
+            php-docker: 73
+            experimental: false
+            stage: phan
+
+          # Latest stable MediaWiki - PHP 7.4 (phan)
+          - mw: 'REL1_36'
+            php: 7.4
+            php-docker: 74
+            experimental: false
+            stage: phan
+
+          # Latest MediaWiki release branch - PHP 7.3 (phan)
+          - mw: 'REL1_37'
+            php: 7.3
+            php-docker: 73
+            experimental: true
+            stage: phan
+
+          # Latest MediaWiki release branch - PHP 7.4 (phan)
+          - mw: 'REL1_37'
+            php: 7.4
+            php-docker: 74
+            experimental: true
+            stage: phan
+
+          # Latest MediaWiki master - PHP 7.3 (phan)
+          - mw: 'master'
+            php: 7.3
+            php-docker: 73
+            experimental: true
+            stage: phan
+
+          # Latest MediaWiki master - PHP 7.4 (phan)
+          - mw: 'master'
+            php: 7.4
+            php-docker: 74
+            experimental: true
+            stage: phan
+
+          # Latest stable MediaWiki - PHP 7.3 (coverage)
+          - mw: 'REL1_36'
+            php: 7.3
+            php-docker: 73
+            experimental: false
+            stage: coverage
+
+          # Latest MediaWiki release branch - PHP 7.3 (coverage)
+          - mw: 'REL1_37'
+            php: 7.3
+            php-docker: 73
+            experimental: false
+            stage: coverage
+
+          # Latest MediaWiki master - PHP 7.3 (coverage)
+          - mw: 'master'
+            php: 7.3
+            php-docker: 73
+            experimental: false
+            stage: coverage
+
+          # Latest stable MediaWiki - PHP 7.3 (phpunit-unit)
+          - mw: 'REL1_36'
+            php: 7.3
+            php-docker: 73
+            experimental: false
+            stage: phpunit-unit
+
+          # Latest stable MediaWiki - PHP 7.4 (phpunit-unit)
+          - mw: 'REL1_36'
+            php: 7.4
+            php-docker: 74
+            experimental: false
+            stage: phpunit-unit
+
+          # Latest MediaWiki release branch - PHP 7.3 (phpunit-unit)
+          - mw: 'REL1_37'
+            php: 7.3
+            php-docker: 73
+            experimental: false
+            stage: phpunit-unit
+
+          # Latest MediaWiki release branch - PHP 7.4 (phpunit-unit)
+          - mw: 'REL1_37'
+            php: 7.4
+            php-docker: 74
+            experimental: false
+            stage: phpunit-unit
+
+          # Latest MediaWiki master - PHP 7.3 (phpunit-unit)
+          - mw: 'master'
+            php: 7.3
+            php-docker: 73
+            experimental: false
+            stage: phpunit-unit
+
+          # Latest MediaWiki master - PHP 7.4 (phpunit-unit)
+          - mw: 'master'
+            php: 7.4
+            php-docker: 74
+            experimental: false
+            stage: phpunit-unit
+
+          # Latest stable MediaWiki - PHP 7.3 (phpunit)
+          - mw: 'REL1_36'
+            php: 7.3
+            php-docker: 73
+            experimental: false
+            stage: phpunit
+
+          # Latest stable MediaWiki - PHP 7.4 (phpunit)
+          - mw: 'REL1_36'
+            php: 7.4
+            php-docker: 74
+            experimental: false
+            stage: phpunit
+
+          # Latest MediaWiki release branch - PHP 7.3 (phpunit)
+          - mw: 'REL1_37'
+            php: 7.3
+            php-docker: 73
+            experimental: false
+            stage: phpunit
+
+          # Latest MediaWiki release branch - PHP 7.4 (phpunit)
+          - mw: 'REL1_37'
+            php: 7.4
+            php-docker: 74
+            experimental: false
+            stage: phpunit
+
+          # Latest MediaWiki master - PHP 7.3 (phpunit)
+          - mw: 'master'
+            php: 7.3
+            php-docker: 73
+            experimental: false
+            stage: phpunit
+
+          # Latest MediaWiki master - PHP 7.4 (phpunit)
+          - mw: 'master'
+            php: 7.4
+            php-docker: 74
+            experimental: false
+            stage: phpunit
+
+          # Latest stable MediaWiki - PHP 7.3 (selenium)
+          - mw: 'REL1_36'
+            php: 7.3
+            php-docker: 73
+            experimental: false
+            stage: selenium
+
+          # Latest MediaWiki release branch - PHP 7.3 (selenium)
+          - mw: 'REL1_37'
+            php: 7.3
+            php-docker: 73
+            experimental: false
+            stage: selenium
+
+          # Latest MediaWiki master - PHP 7.3 (selenium)
+          - mw: 'master'
+            php: 7.3
+            php-docker: 73
+            experimental: false
+            stage: selenium
+
+          # Latest stable MediaWiki - PHP 7.3 (qunit)
+          - mw: 'REL1_36'
+            php: 7.3
+            php-docker: 73
+            experimental: false
+            stage: qunit
+
+          # Latest MediaWiki release branch - PHP 7.3 (qunit)
+          - mw: 'REL1_37'
+            php: 7.3
+            php-docker: 73
+            experimental: false
+            stage: qunit
+
+          # Latest MediaWiki master - PHP 7.3 (qunit)
+          - mw: 'master'
+            php: 7.3
+            php-docker: 73
+            experimental: false
+            stage: qunit
+
+          # Latest stable MediaWiki - PHP 7.3 (composer-test)
+          - mw: 'REL1_36'
+            php: 7.3
+            php-docker: 73
+            experimental: false
+            stage: composer-test
+
+    runs-on: ubuntu-latest
+
+    env:
+      DOCKER_REGISTRY: docker-registry.wikimedia.org
+      DOCKER_ORG: releng
+      QUIBBLE_DOCKER_IMAGE: quibble-buster-php${{ matrix.php-docker }}
+      COVERAGE_DOCKER_IMAGE: quibble-buster-php${{ matrix.php-docker }}-coverage
+      PHAN_DOCKER_IMAGE: mediawiki-phan-php${{ matrix.php-docker }}
+
+    steps:
+      - name: Cancel Previous Runs
+        uses: styfle/cancel-workflow-action@0.9.1
+        with:
+          access_token: ${{ github.token }}
+
+      - uses: actions/checkout@v2
+
+      # /home/runner/cache/                               Cache
+      # /home/runner/src/                                 Mediawiki installation
+      # /home/runner/src/extensions/EXTENSION_NAME/       Clone of the extension repository
+      # /home/runner/docker-images/                       Docker images which exported with docker-save command
+      # $GITHUB_WORKSPACE/.github/workflows/dependencies  Necessary dependencies - YAML syntax
+      # $GITHUB_WORKSPACE/.github/workflows/globals.php   Add global configuration options for MediaWiki
+      - name: Set up
+        run: |
+          echo MEDIAWIKI_VERSION="${{ matrix.mw }}" >> $GITHUB_ENV
+
+          if [ "${{ matrix.stage }}" == 'phan' ]; then
+            export DOCKER_IMAGE="${PHAN_DOCKER_IMAGE}"
+          elif [ "${{ matrix.stage }}" == coverage ]; then
+            export DOCKER_IMAGE="${COVERAGE_DOCKER_IMAGE}"
+          else
+            export DOCKER_IMAGE="${QUIBBLE_DOCKER_IMAGE}"
+          fi
+          echo "DOCKER_IMAGE=${DOCKER_IMAGE}" >> $GITHUB_ENV
+
+          # Get the latest docker tag (Ref: https://github.com/thcipriani/dockerregistry)
+          DOCKER_LATEST_TAG="$(curl -sL "https://${DOCKER_REGISTRY}/v2/${DOCKER_ORG}/${DOCKER_IMAGE}/tags/list" |
+            python3 -c 'import json;print("\n".join(json.loads(input())["tags"]))' |
+            grep -v latest | sort -Vr | head -1)"
+          echo "DOCKER_LATEST_TAG=${DOCKER_LATEST_TAG}" >> $GITHUB_ENV
+          if [ "${{ matrix.stage }}" == 'phan' ] || [ "${{ matrix.stage }}" == 'coverage' ]; then
+            echo "QUIBBLE_DOCKER_LATEST_TAG=$(curl -sL "https://${DOCKER_REGISTRY}/v2/${DOCKER_ORG}/${QUIBBLE_DOCKER_IMAGE}/tags/list" |
+              python3 -c 'import json;print("\n".join(json.loads(input())["tags"]))' |
+              grep -v latest | sort -Vr | head -1)" >> $GITHUB_ENV
+          fi
+
+          # Resolve dependencies
+          if [ -e .github/workflows/dependencies ] && [ "${{ matrix.stage }}" == 'phan' ]; then
+            cd .github/workflows
+            curl -sL https://raw.githubusercontent.com/wikimedia/integration-config/master/zuul/parameter_functions.py -o pf.py
+            curl -sL https://raw.githubusercontent.com/Universal-Omega/scripts/master/mediawiki/resolve_dependencies.py -o rd.py
+            echo "DEPENDENCIES=$(python3 rd.py)" >> $GITHUB_ENV
+          fi
+
+      - name: Cache docker image
+        uses: actions/cache@v2
+        with:
+          path: /home/runner/docker-images/${{ env.DOCKER_IMAGE }}
+          key: ${{ env.DOCKER_IMAGE }}:${{ env.DOCKER_LATEST_TAG }}
+
+      - name: Load or pull docker image
+        run: |
+          docker load -i /home/runner/docker-images/"${DOCKER_IMAGE}" || \
+            docker pull "${DOCKER_REGISTRY}/${DOCKER_ORG}/${DOCKER_IMAGE}:${DOCKER_LATEST_TAG}"
+
+      - name: Cache quibble docker image
+        if: ${{ matrix.stage == 'coverage' || matrix.stage == 'phan' }}
+        uses: actions/cache@v2
+        with:
+          path: /home/runner/docker-images/${{ env.QUIBBLE_DOCKER_IMAGE }}
+          key: ${{ env.QUIBBLE_DOCKER_IMAGE }}:${{ env.QUIBBLE_DOCKER_LATEST_TAG }}
+      - name: Load or pull quibble docker image
+        if: ${{ matrix.stage == 'coverage' || matrix.stage == 'phan' }}
+        run: |
+          docker load -i /home/runner/docker-images/"${QUIBBLE_DOCKER_IMAGE}" || \
+            docker pull "${DOCKER_REGISTRY}/${DOCKER_ORG}/${QUIBBLE_DOCKER_IMAGE}:${QUIBBLE_DOCKER_LATEST_TAG}"
+
+      - name: Download MediaWiki and extensions
+        run: |
+          cd /home/runner
+          if [ ! -d src ]; then
+            git clone -b "${MEDIAWIKI_VERSION}" --depth 1 https://gerrit.wikimedia.org/r/mediawiki/core src
+            git clone --recurse-submodules -b "${MEDIAWIKI_VERSION}" --depth 1 https://gerrit.wikimedia.org/r/mediawiki/skins/Vector src/skins/Vector
+            for dep in $DEPENDENCIES; do
+              dependency=$(echo $dep | cut -d'|' -f1)
+              repository=$(echo $dep | cut -sd'|' -f2)
+              branch=$(echo $dep | rev | cut -sd'|' -f1 | rev)
+
+              if [ $repository == $branch ]; then
+                repository=""
+              fi
+
+              git clone --recurse-submodules -b "${branch:-${MEDIAWIKI_VERSION}}" --depth 1 "${repository:-https://gerrit.wikimedia.org/r/${dependency}}" src/"$(echo $dependency | cut -d'/' -f2,3)"
+            done
+          fi
+
+          # REPLACE SETUP.PHP FOR CREATEWIKI DEPENDANT EXTENSIONS ON REL1_36.
+          # FIXES A BUG PRESENT ON REL1_36, WHEN DOING DATABASE STUFF BEFORE THIS WAS DONE, REQUEST INFO WAS ALREADY SET FOR DBLoadBalancerFactory,
+          # RESULTING IN "LogicException: ChronologyProtector already initialized". THIS HACK REMOVES
+          # MediaWikiServices::getInstance()->getDBLoadBalancerFactory()->setRequestInfo(). THIS IS ALREADY FIXED FOR REL1_37 AND LATER.
+          # WITH https://github.com/wikimedia/mediawiki/commit/29827d
+
+          if [ -d src/extensions/CreateWiki ] || [ "${{ github.event.repository.name }}" == 'CreateWiki' ] && [ "${MEDIAWIKI_VERSION}" == 'REL1_36' ]; then
+            curl -sL https://raw.githubusercontent.com/Universal-Omega/scripts/master/mediawiki/hacks/Setup-REL1_36.php > src/includes/Setup.php
+          fi
+
+          if [ -e "$GITHUB_WORKSPACE"/.github/workflows/globals.php ]; then
+            echo 'require_once __DIR__ . "/../extensions/${{ github.event.repository.name }}/.github/workflows/globals.php";' >> src/includes/DevelopmentSettings.php
+          fi
+
+          git -C src/ log -n 1 --format="%H"
+
+      - name: Cache dependencies (composer and npm)
+        uses: actions/cache@v2
+        with:
+          path: /home/runner/cache
+          key: ${{ runner.os }}-${{ env.MEDIAWIKI_VERSION }}-${{ hashFiles('**/*.lock') }}
+
+      - name: Setup PHP Action
+        if: ${{ matrix.stage == 'phan' }}
+        uses: shivammathur/setup-php@v2
+        with:
+          php-version: ${{ matrix.php }}
+          tools: composer:v2
+
+      - name: Composer install
+        if: ${{ matrix.stage == 'phan' }}
+        run: |
+          if [ -e composer.json ]; then
+            composer install --prefer-dist --no-progress --no-interaction
+          fi
+
+      - name: Fix PHPCS violations
+        continue-on-error: true
+        if: ${{ github.event_name == 'pull_request' && matrix.stage == 'composer-test' }}
+        env:
+          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
+        run: |
+          if [ -e composer.json ]; then
+            composer install --prefer-dist --no-progress --no-interaction
+            composer fix
+
+            rm composer.lock
+
+            git config --global user.name "github-actions"
+            git config --global user.email "github-actions@users.noreply.github.com"
+            git remote set-url origin "https://x-access-token:${GITHUB_TOKEN}@github.com/${GITHUB_REPOSITORY}.git"
+            git checkout -b ${GITHUB_HEAD_REF}
+            git add .
+            git commit -am "CI: lint code to MediaWiki standards" -m "Check commit and GitHub actions for more details" || echo "No changes to commit"
+            git pull origin ${GITHUB_HEAD_REF} --rebase
+            git push --set-upstream origin ${GITHUB_HEAD_REF}
+          fi
+
+      - name: Main Test
+        continue-on-error: ${{ matrix.experimental }}
+        run: |
+          cd /home/runner
+          # Move our extension
+          sudo cp -r "${GITHUB_WORKSPACE}" src/extensions/
+          mkdir -p cache cover
+          chmod 777 src cache cover
+          sudo chown -R nobody:nogroup src cache
+          sudo chown $(id -u):$(id -g) src cache
+          # Composer install
+          if [ "${{ matrix.stage }}" == 'phan' ] || [ "${{ matrix.stage }}" == 'coverage' ]; then
+            docker run \
+              -e ZUUL_PROJECT=mediawiki/extensions/"${{ github.event.repository.name }}" \
+              -v "$(pwd)"/cache:/cache \
+              -v "$(pwd)"/src:/workspace/src \
+              "${DOCKER_REGISTRY}/${DOCKER_ORG}/${QUIBBLE_DOCKER_IMAGE}:${QUIBBLE_DOCKER_LATEST_TAG}" \
+              --skip-zuul \
+              --packages-source composer \
+              --skip-install \
+              --skip all \
+              $DEPENDENCIES
+          fi
+
+          if [ "${{ matrix.stage }}" == 'phan' ]; then
+            docker run \
+              -e THING_SUBNAME=extensions/"${{ github.event.repository.name }}" \
+              -v "$(pwd)"/src:/mediawiki \
+              "${DOCKER_REGISTRY}/${DOCKER_ORG}/${DOCKER_IMAGE}:${DOCKER_LATEST_TAG}" \
+              --color
+          elif [ "${{ matrix.stage }}" == 'coverage' ] && [ -d src/extensions/"${{ github.event.repository.name }}"/tests/phpunit ]; then
+            docker run \
+              -e ZUUL_PROJECT=mediawiki/extensions/"${{ github.event.repository.name }}" \
+              -v "$(pwd)"/cache:/cache \
+              -v "$(pwd)"/src:/workspace/src \
+              -v "$(pwd)"/cover:/workspace/cover \
+              "${DOCKER_REGISTRY}/${DOCKER_ORG}/${DOCKER_IMAGE}:${DOCKER_LATEST_TAG}" \
+              --skip-zuul \
+              --skip-deps \
+              -c mwext-phpunit-coverage
+          elif [ "${{ matrix.stage }}" != 'coverage' ]; then
+            docker run \
+              -e ZUUL_PROJECT=mediawiki/extensions/"${{ github.event.repository.name }}" \
+              -v "$(pwd)"/cache:/cache \
+              -v "$(pwd)"/src:/workspace/src \
+              "${DOCKER_REGISTRY}/${DOCKER_ORG}/${DOCKER_IMAGE}:${DOCKER_LATEST_TAG}" \
+              --skip-zuul \
+              --packages-source composer \
+              --run "${{ matrix.stage }}" \
+              $DEPENDENCIES
+            fi
+
+      - name: Upload coverage to Codecov
+        if: ${{ matrix.stage == 'coverage' }}
+        uses: codecov/codecov-action@v2
+        with:
+          directory: /home/runner/cover
+
+      - name: Tear down
+        run: |
+          cd /home/runner
+          sudo rm -rf src/extensions/"${{ github.event.repository.name }}"
+          # See https://doc.wikimedia.org/quibble/index.html#remove-localsettings-php-between-runs
+          rm "$(pwd)"/src/LocalSettings.php || true
+          mkdir -p docker-images
+          docker save -o "$(pwd)/docker-images/${DOCKER_IMAGE}" \
+            "${DOCKER_REGISTRY}/${DOCKER_ORG}/${DOCKER_IMAGE}:${DOCKER_LATEST_TAG}"
diff --git a/.gitignore b/.gitignore
index 6016e6ed..e794f92b 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,10 +1,3 @@
-/node_modules
-/vendor
 /composer.lock
-/.eslintcache
-*.kate-swp
-*~
-.*.swp
-.DS_Store
-.svn
-.idea
+/vendor
+.github/*
diff --git a/.phan/config.php b/.phan/config.php
index ff50366c..2e2aa11d 100644
--- a/.phan/config.php
+++ b/.phan/config.php
@@ -2,39 +2,22 @@
 
 $cfg = require __DIR__ . '/../vendor/mediawiki/mediawiki-phan-config/src/config.php';
 
-$cfg['suppress_issue_types'] = array_merge( $cfg['suppress_issue_types'], [
-	'PhanUndeclaredInterface',
-	'PhanUndeclaredTypeParameter',
-	'PhanUndeclaredClassMethod',
-	'PhanUndeclaredFunction',
-	'PhanUndeclaredConstant',
-	'PhanUndeclaredTypeReturnType',
-	'PhanPossiblyUndeclaredVariable',
-	'PhanTypePossiblyInvalidDimOffset',
-	'PhanTypeInvalidDimOffset',
-	'PhanUndeclaredConstantOfClass',
-	'PhanUndeclaredExtendedClass',
-	'PhanTypeMismatchReturnNullable',
-	'PhanUndeclaredExtendedClass',
-	'PhanUndeclaredMethod',
-	'PhanUndeclaredProperty',
-	'PhanPluginDuplicateAdjacentStatement',
-	'PhanImpossibleCondition',
-	'PhanUndeclaredClassInstanceof',
-	'PhanTypeArraySuspiciousNullable',
-	'PhanParamTooMany',
-	'PhanPluginDuplicateConditionalNullCoalescing',
-	'PhanRedundantCondition',
-	'PhanPluginDuplicateConditionalTernaryDuplication',
-	'PhanTypeMismatchReturnProbablyReal',
-	'PhanUndeclaredVariableDim',
-	'PhanUndeclaredClass',
-	'PhanUnextractableAnnotation',
-	'PhanTypeSuspiciousStringExpression',
-	'PhanImpossibleTypeComparison',
-	'PhanTypeMismatchArgument'
-] );
+$cfg['directory_list'] = array_merge(
+	$cfg['directory_list'], [
+		'../../extensions/Variables',
+	]
+);
 
-$cfg['scalar_implicit_cast'] = true;
+$cfg['exclude_analysis_directory_list'] = array_merge(
+	$cfg['exclude_analysis_directory_list'], [
+		'../../extensions/Variables',
+	]
+);
+
+$cfg['suppress_issue_types'] = [
+	'SecurityCheck-ReDoS',
+	'SecurityCheck-LikelyFalsePositive',
+	'PhanAccessMethodInternal',
+];
 
 return $cfg;
diff --git a/.phpcs.xml b/.phpcs.xml
index f844bc5a..8e445048 100644
--- a/.phpcs.xml
+++ b/.phpcs.xml
@@ -1,16 +1,17 @@
 <?xml version="1.0"?>
 <ruleset>
-    <rule ref="./vendor/mediawiki/mediawiki-codesniffer/MediaWiki">
-		<exclude name="Generic.Files.LineLength" />
+	<file>.</file>
+	<rule ref="./vendor/mediawiki/mediawiki-codesniffer/MediaWiki">
+		<exclude name="Generic.Files.LineLength.TooLong" />
 		<exclude name="MediaWiki.Commenting.FunctionComment" />
-		<exclude name="MediaWiki.NamingConventions.LowerCamelFunctionsName" />
-		<exclude name="MediaWiki.WhiteSpace.SpaceBeforeSingleLineComment" />
+		<exclude name="MediaWiki.Commenting.MissingCovers.MissingCovers" />
+		<exclude name="MediaWiki.NamingConventions.LowerCamelFunctionsName.FunctionName" />
+		<exclude name="MediaWiki.WhiteSpace.SpaceBeforeSingleLineComment.NewLineComment" />
 		<exclude name="PSR2.Methods.MethodDeclaration.Underscore" />
+		<exclude name="MediaWiki.ControlStructures.AssignmentInControlStructures.AssignmentInControlStructures" />
+		<exclude name="PEAR.Functions.ValidDefaultValue.NotAtEnd" />
 	</rule>
-	<rule ref="Generic.NamingConventions.ConstructorName">
-		<severity>3</severity>
-	</rule>
-    <file>.</file>
-    <arg name="extensions" value="php,php5,inc"/>
-    <arg name="encoding" value="UTF-8"/>
+	<arg name="bootstrap" value="./vendor/mediawiki/mediawiki-codesniffer/utils/bootstrap-ci.php"/>
+	<arg name="extensions" value="php"/>
+	<arg name="encoding" value="UTF-8"/>
 </ruleset>
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 0ae24b3c..a22555f0 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -702,3 +702,9 @@ Many thanks to GreenReaper on GitHub for reporting and finding issues with core
 # Version 3.3.5
 * Fix syntax error in extension.json
 * 1.36.0 support
+
+# Version 3.3.6
+* Major code cleanup
+* Numerous bug fixes
+* Now requires MediaWiki 1.36.0 or later
+* 1.37.0 support
diff --git a/COPYING b/COPYING
index d159169d..94a9ed02 100644
--- a/COPYING
+++ b/COPYING
@@ -1,281 +1,622 @@
                     GNU GENERAL PUBLIC LICENSE
-                       Version 2, June 1991
+                       Version 3, 29 June 2007
 
- Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
- 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
  Everyone is permitted to copy and distribute verbatim copies
  of this license document, but changing it is not allowed.
 
                             Preamble
 
-  The licenses for most software are designed to take away your
-freedom to share and change it.  By contrast, the GNU General Public
-License is intended to guarantee your freedom to share and change free
-software--to make sure the software is free for all its users.  This
-General Public License applies to most of the Free Software
-Foundation's software and to any other program whose authors commit to
-using it.  (Some other Free Software Foundation software is covered by
-the GNU Lesser General Public License instead.)  You can apply it to
+  The GNU General Public License is a free, copyleft license for
+software and other kinds of works.
+
+  The licenses for most software and other practical works are designed
+to take away your freedom to share and change the works.  By contrast,
+the GNU General Public License is intended to guarantee your freedom to
+share and change all versions of a program--to make sure it remains free
+software for all its users.  We, the Free Software Foundation, use the
+GNU General Public License for most of our software; it applies also to
+any other work released this way by its authors.  You can apply it to
 your programs, too.
 
   When we speak of free software, we are referring to freedom, not
 price.  Our General Public Licenses are designed to make sure that you
 have the freedom to distribute copies of free software (and charge for
-this service if you wish), that you receive source code or can get it
-if you want it, that you can change the software or use pieces of it
-in new free programs; and that you know you can do these things.
+them if you wish), that you receive source code or can get it if you
+want it, that you can change the software or use pieces of it in new
+free programs, and that you know you can do these things.
 
-  To protect your rights, we need to make restrictions that forbid
-anyone to deny you these rights or to ask you to surrender the rights.
-These restrictions translate to certain responsibilities for you if you
-distribute copies of the software, or if you modify it.
+  To protect your rights, we need to prevent others from denying you
+these rights or asking you to surrender the rights.  Therefore, you have
+certain responsibilities if you distribute copies of the software, or if
+you modify it: responsibilities to respect the freedom of others.
 
   For example, if you distribute copies of such a program, whether
-gratis or for a fee, you must give the recipients all the rights that
-you have.  You must make sure that they, too, receive or can get the
-source code.  And you must show them these terms so they know their
-rights.
-
-  We protect your rights with two steps: (1) copyright the software, and
-(2) offer you this license which gives you legal permission to copy,
-distribute and/or modify the software.
-
-  Also, for each author's protection and ours, we want to make certain
-that everyone understands that there is no warranty for this free
-software.  If the software is modified by someone else and passed on, we
-want its recipients to know that what they have is not the original, so
-that any problems introduced by others will not reflect on the original
-authors' reputations.
-
-  Finally, any free program is threatened constantly by software
-patents.  We wish to avoid the danger that redistributors of a free
-program will individually obtain patent licenses, in effect making the
-program proprietary.  To prevent this, we have made it clear that any
-patent must be licensed for everyone's free use or not licensed at all.
+gratis or for a fee, you must pass on to the recipients the same
+freedoms that you received.  You must make sure that they, too, receive
+or can get the source code.  And you must show them these terms so they
+know their rights.
+
+  Developers that use the GNU GPL protect your rights with two steps:
+(1) assert copyright on the software, and (2) offer you this License
+giving you legal permission to copy, distribute and/or modify it.
+
+  For the developers' and authors' protection, the GPL clearly explains
+that there is no warranty for this free software.  For both users' and
+authors' sake, the GPL requires that modified versions be marked as
+changed, so that their problems will not be attributed erroneously to
+authors of previous versions.
+
+  Some devices are designed to deny users access to install or run
+modified versions of the software inside them, although the manufacturer
+can do so.  This is fundamentally incompatible with the aim of
+protecting users' freedom to change the software.  The systematic
+pattern of such abuse occurs in the area of products for individuals to
+use, which is precisely where it is most unacceptable.  Therefore, we
+have designed this version of the GPL to prohibit the practice for those
+products.  If such problems arise substantially in other domains, we
+stand ready to extend this provision to those domains in future versions
+of the GPL, as needed to protect the freedom of users.
+
+  Finally, every program is threatened constantly by software patents.
+States should not allow patents to restrict development and use of
+software on general-purpose computers, but in those that do, we wish to
+avoid the special danger that patents applied to a free program could
+make it effectively proprietary.  To prevent this, the GPL assures that
+patents cannot be used to render the program non-free.
 
   The precise terms and conditions for copying, distribution and
 modification follow.
 
-                    GNU GENERAL PUBLIC LICENSE
-   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
-
-  0. This License applies to any program or other work which contains
-a notice placed by the copyright holder saying it may be distributed
-under the terms of this General Public License.  The "Program", below,
-refers to any such program or work, and a "work based on the Program"
-means either the Program or any derivative work under copyright law:
-that is to say, a work containing the Program or a portion of it,
-either verbatim or with modifications and/or translated into another
-language.  (Hereinafter, translation is included without limitation in
-the term "modification".)  Each licensee is addressed as "you".
-
-Activities other than copying, distribution and modification are not
-covered by this License; they are outside its scope.  The act of
-running the Program is not restricted, and the output from the Program
-is covered only if its contents constitute a work based on the
-Program (independent of having been made by running the Program).
-Whether that is true depends on what the Program does.
-
-  1. You may copy and distribute verbatim copies of the Program's
-source code as you receive it, in any medium, provided that you
-conspicuously and appropriately publish on each copy an appropriate
-copyright notice and disclaimer of warranty; keep intact all the
-notices that refer to this License and to the absence of any warranty;
-and give any other recipients of the Program a copy of this License
-along with the Program.
-
-You may charge a fee for the physical act of transferring a copy, and
-you may at your option offer warranty protection in exchange for a fee.
-
-  2. You may modify your copy or copies of the Program or any portion
-of it, thus forming a work based on the Program, and copy and
-distribute such modifications or work under the terms of Section 1
-above, provided that you also meet all of these conditions:
-
-    a) You must cause the modified files to carry prominent notices
-    stating that you changed the files and the date of any change.
-
-    b) You must cause any work that you distribute or publish, that in
-    whole or in part contains or is derived from the Program or any
-    part thereof, to be licensed as a whole at no charge to all third
-    parties under the terms of this License.
-
-    c) If the modified program normally reads commands interactively
-    when run, you must cause it, when started running for such
-    interactive use in the most ordinary way, to print or display an
-    announcement including an appropriate copyright notice and a
-    notice that there is no warranty (or else, saying that you provide
-    a warranty) and that users may redistribute the program under
-    these conditions, and telling the user how to view a copy of this
-    License.  (Exception: if the Program itself is interactive but
-    does not normally print such an announcement, your work based on
-    the Program is not required to print an announcement.)
-
-These requirements apply to the modified work as a whole.  If
-identifiable sections of that work are not derived from the Program,
-and can be reasonably considered independent and separate works in
-themselves, then this License, and its terms, do not apply to those
-sections when you distribute them as separate works.  But when you
-distribute the same sections as part of a whole which is a work based
-on the Program, the distribution of the whole must be on the terms of
-this License, whose permissions for other licensees extend to the
-entire whole, and thus to each and every part regardless of who wrote it.
-
-Thus, it is not the intent of this section to claim rights or contest
-your rights to work written entirely by you; rather, the intent is to
-exercise the right to control the distribution of derivative or
-collective works based on the Program.
-
-In addition, mere aggregation of another work not based on the Program
-with the Program (or with a work based on the Program) on a volume of
-a storage or distribution medium does not bring the other work under
-the scope of this License.
-
-  3. You may copy and distribute the Program (or a work based on it,
-under Section 2) in object code or executable form under the terms of
-Sections 1 and 2 above provided that you also do one of the following:
-
-    a) Accompany it with the complete corresponding machine-readable
-    source code, which must be distributed under the terms of Sections
-    1 and 2 above on a medium customarily used for software interchange; or,
-
-    b) Accompany it with a written offer, valid for at least three
-    years, to give any third party, for a charge no more than your
-    cost of physically performing source distribution, a complete
-    machine-readable copy of the corresponding source code, to be
-    distributed under the terms of Sections 1 and 2 above on a medium
-    customarily used for software interchange; or,
-
-    c) Accompany it with the information you received as to the offer
-    to distribute corresponding source code.  (This alternative is
-    allowed only for noncommercial distribution and only if you
-    received the program in object code or executable form with such
-    an offer, in accord with Subsection b above.)
-
-The source code for a work means the preferred form of the work for
-making modifications to it.  For an executable work, complete source
-code means all the source code for all modules it contains, plus any
-associated interface definition files, plus the scripts used to
-control compilation and installation of the executable.  However, as a
-special exception, the source code distributed need not include
-anything that is normally distributed (in either source or binary
-form) with the major components (compiler, kernel, and so on) of the
-operating system on which the executable runs, unless that component
-itself accompanies the executable.
-
-If distribution of executable or object code is made by offering
-access to copy from a designated place, then offering equivalent
-access to copy the source code from the same place counts as
-distribution of the source code, even though third parties are not
-compelled to copy the source along with the object code.
-
-  4. You may not copy, modify, sublicense, or distribute the Program
-except as expressly provided under this License.  Any attempt
-otherwise to copy, modify, sublicense or distribute the Program is
-void, and will automatically terminate your rights under this License.
-However, parties who have received copies, or rights, from you under
-this License will not have their licenses terminated so long as such
-parties remain in full compliance.
-
-  5. You are not required to accept this License, since you have not
-signed it.  However, nothing else grants you permission to modify or
-distribute the Program or its derivative works.  These actions are
-prohibited by law if you do not accept this License.  Therefore, by
-modifying or distributing the Program (or any work based on the
-Program), you indicate your acceptance of this License to do so, and
-all its terms and conditions for copying, distributing or modifying
-the Program or works based on it.
-
-  6. Each time you redistribute the Program (or any work based on the
-Program), the recipient automatically receives a license from the
-original licensor to copy, distribute or modify the Program subject to
-these terms and conditions.  You may not impose any further
-restrictions on the recipients' exercise of the rights granted herein.
-You are not responsible for enforcing compliance by third parties to
+                       TERMS AND CONDITIONS
+
+  0. Definitions.
+
+  "This License" refers to version 3 of the GNU General Public License.
+
+  "Copyright" also means copyright-like laws that apply to other kinds of
+works, such as semiconductor masks.
+
+  "The Program" refers to any copyrightable work licensed under this
+License.  Each licensee is addressed as "you".  "Licensees" and
+"recipients" may be individuals or organizations.
+
+  To "modify" a work means to copy from or adapt all or part of the work
+in a fashion requiring copyright permission, other than the making of an
+exact copy.  The resulting work is called a "modified version" of the
+earlier work or a work "based on" the earlier work.
+
+  A "covered work" means either the unmodified Program or a work based
+on the Program.
+
+  To "propagate" a work means to do anything with it that, without
+permission, would make you directly or secondarily liable for
+infringement under applicable copyright law, except executing it on a
+computer or modifying a private copy.  Propagation includes copying,
+distribution (with or without modification), making available to the
+public, and in some countries other activities as well.
+
+  To "convey" a work means any kind of propagation that enables other
+parties to make or receive copies.  Mere interaction with a user through
+a computer network, with no transfer of a copy, is not conveying.
+
+  An interactive user interface displays "Appropriate Legal Notices"
+to the extent that it includes a convenient and prominently visible
+feature that (1) displays an appropriate copyright notice, and (2)
+tells the user that there is no warranty for the work (except to the
+extent that warranties are provided), that licensees may convey the
+work under this License, and how to view a copy of this License.  If
+the interface presents a list of user commands or options, such as a
+menu, a prominent item in the list meets this criterion.
+
+  1. Source Code.
+
+  The "source code" for a work means the preferred form of the work
+for making modifications to it.  "Object code" means any non-source
+form of a work.
+
+  A "Standard Interface" means an interface that either is an official
+standard defined by a recognized standards body, or, in the case of
+interfaces specified for a particular programming language, one that
+is widely used among developers working in that language.
+
+  The "System Libraries" of an executable work include anything, other
+than the work as a whole, that (a) is included in the normal form of
+packaging a Major Component, but which is not part of that Major
+Component, and (b) serves only to enable use of the work with that
+Major Component, or to implement a Standard Interface for which an
+implementation is available to the public in source code form.  A
+"Major Component", in this context, means a major essential component
+(kernel, window system, and so on) of the specific operating system
+(if any) on which the executable work runs, or a compiler used to
+produce the work, or an object code interpreter used to run it.
+
+  The "Corresponding Source" for a work in object code form means all
+the source code needed to generate, install, and (for an executable
+work) run the object code and to modify the work, including scripts to
+control those activities.  However, it does not include the work's
+System Libraries, or general-purpose tools or generally available free
+programs which are used unmodified in performing those activities but
+which are not part of the work.  For example, Corresponding Source
+includes interface definition files associated with source files for
+the work, and the source code for shared libraries and dynamically
+linked subprograms that the work is specifically designed to require,
+such as by intimate data communication or control flow between those
+subprograms and other parts of the work.
+
+  The Corresponding Source need not include anything that users
+can regenerate automatically from other parts of the Corresponding
+Source.
+
+  The Corresponding Source for a work in source code form is that
+same work.
+
+  2. Basic Permissions.
+
+  All rights granted under this License are granted for the term of
+copyright on the Program, and are irrevocable provided the stated
+conditions are met.  This License explicitly affirms your unlimited
+permission to run the unmodified Program.  The output from running a
+covered work is covered by this License only if the output, given its
+content, constitutes a covered work.  This License acknowledges your
+rights of fair use or other equivalent, as provided by copyright law.
+
+  You may make, run and propagate covered works that you do not
+convey, without conditions so long as your license otherwise remains
+in force.  You may convey covered works to others for the sole purpose
+of having them make modifications exclusively for you, or provide you
+with facilities for running those works, provided that you comply with
+the terms of this License in conveying all material for which you do
+not control copyright.  Those thus making or running the covered works
+for you must do so exclusively on your behalf, under your direction
+and control, on terms that prohibit them from making any copies of
+your copyrighted material outside their relationship with you.
+
+  Conveying under any other circumstances is permitted solely under
+the conditions stated below.  Sublicensing is not allowed; section 10
+makes it unnecessary.
+
+  3. Protecting Users' Legal Rights From Anti-Circumvention Law.
+
+  No covered work shall be deemed part of an effective technological
+measure under any applicable law fulfilling obligations under article
+11 of the WIPO copyright treaty adopted on 20 December 1996, or
+similar laws prohibiting or restricting circumvention of such
+measures.
+
+  When you convey a covered work, you waive any legal power to forbid
+circumvention of technological measures to the extent such circumvention
+is effected by exercising rights under this License with respect to
+the covered work, and you disclaim any intention to limit operation or
+modification of the work as a means of enforcing, against the work's
+users, your or third parties' legal rights to forbid circumvention of
+technological measures.
+
+  4. Conveying Verbatim Copies.
+
+  You may convey verbatim copies of the Program's source code as you
+receive it, in any medium, provided that you conspicuously and
+appropriately publish on each copy an appropriate copyright notice;
+keep intact all notices stating that this License and any
+non-permissive terms added in accord with section 7 apply to the code;
+keep intact all notices of the absence of any warranty; and give all
+recipients a copy of this License along with the Program.
+
+  You may charge any price or no price for each copy that you convey,
+and you may offer support or warranty protection for a fee.
+
+  5. Conveying Modified Source Versions.
+
+  You may convey a work based on the Program, or the modifications to
+produce it from the Program, in the form of source code under the
+terms of section 4, provided that you also meet all of these conditions:
+
+    a) The work must carry prominent notices stating that you modified
+    it, and giving a relevant date.
+
+    b) The work must carry prominent notices stating that it is
+    released under this License and any conditions added under section
+    7.  This requirement modifies the requirement in section 4 to
+    "keep intact all notices".
+
+    c) You must license the entire work, as a whole, under this
+    License to anyone who comes into possession of a copy.  This
+    License will therefore apply, along with any applicable section 7
+    additional terms, to the whole of the work, and all its parts,
+    regardless of how they are packaged.  This License gives no
+    permission to license the work in any other way, but it does not
+    invalidate such permission if you have separately received it.
+
+    d) If the work has interactive user interfaces, each must display
+    Appropriate Legal Notices; however, if the Program has interactive
+    interfaces that do not display Appropriate Legal Notices, your
+    work need not make them do so.
+
+  A compilation of a covered work with other separate and independent
+works, which are not by their nature extensions of the covered work,
+and which are not combined with it such as to form a larger program,
+in or on a volume of a storage or distribution medium, is called an
+"aggregate" if the compilation and its resulting copyright are not
+used to limit the access or legal rights of the compilation's users
+beyond what the individual works permit.  Inclusion of a covered work
+in an aggregate does not cause this License to apply to the other
+parts of the aggregate.
+
+  6. Conveying Non-Source Forms.
+
+  You may convey a covered work in object code form under the terms
+of sections 4 and 5, provided that you also convey the
+machine-readable Corresponding Source under the terms of this License,
+in one of these ways:
+
+    a) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by the
+    Corresponding Source fixed on a durable physical medium
+    customarily used for software interchange.
+
+    b) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by a
+    written offer, valid for at least three years and valid for as
+    long as you offer spare parts or customer support for that product
+    model, to give anyone who possesses the object code either (1) a
+    copy of the Corresponding Source for all the software in the
+    product that is covered by this License, on a durable physical
+    medium customarily used for software interchange, for a price no
+    more than your reasonable cost of physically performing this
+    conveying of source, or (2) access to copy the
+    Corresponding Source from a network server at no charge.
+
+    c) Convey individual copies of the object code with a copy of the
+    written offer to provide the Corresponding Source.  This
+    alternative is allowed only occasionally and noncommercially, and
+    only if you received the object code with such an offer, in accord
+    with subsection 6b.
+
+    d) Convey the object code by offering access from a designated
+    place (gratis or for a charge), and offer equivalent access to the
+    Corresponding Source in the same way through the same place at no
+    further charge.  You need not require recipients to copy the
+    Corresponding Source along with the object code.  If the place to
+    copy the object code is a network server, the Corresponding Source
+    may be on a different server (operated by you or a third party)
+    that supports equivalent copying facilities, provided you maintain
+    clear directions next to the object code saying where to find the
+    Corresponding Source.  Regardless of what server hosts the
+    Corresponding Source, you remain obligated to ensure that it is
+    available for as long as needed to satisfy these requirements.
+
+    e) Convey the object code using peer-to-peer transmission, provided
+    you inform other peers where the object code and Corresponding
+    Source of the work are being offered to the general public at no
+    charge under subsection 6d.
+
+  A separable portion of the object code, whose source code is excluded
+from the Corresponding Source as a System Library, need not be
+included in conveying the object code work.
+
+  A "User Product" is either (1) a "consumer product", which means any
+tangible personal property which is normally used for personal, family,
+or household purposes, or (2) anything designed or sold for incorporation
+into a dwelling.  In determining whether a product is a consumer product,
+doubtful cases shall be resolved in favor of coverage.  For a particular
+product received by a particular user, "normally used" refers to a
+typical or common use of that class of product, regardless of the status
+of the particular user or of the way in which the particular user
+actually uses, or expects or is expected to use, the product.  A product
+is a consumer product regardless of whether the product has substantial
+commercial, industrial or non-consumer uses, unless such uses represent
+the only significant mode of use of the product.
+
+  "Installation Information" for a User Product means any methods,
+procedures, authorization keys, or other information required to install
+and execute modified versions of a covered work in that User Product from
+a modified version of its Corresponding Source.  The information must
+suffice to ensure that the continued functioning of the modified object
+code is in no case prevented or interfered with solely because
+modification has been made.
+
+  If you convey an object code work under this section in, or with, or
+specifically for use in, a User Product, and the conveying occurs as
+part of a transaction in which the right of possession and use of the
+User Product is transferred to the recipient in perpetuity or for a
+fixed term (regardless of how the transaction is characterized), the
+Corresponding Source conveyed under this section must be accompanied
+by the Installation Information.  But this requirement does not apply
+if neither you nor any third party retains the ability to install
+modified object code on the User Product (for example, the work has
+been installed in ROM).
+
+  The requirement to provide Installation Information does not include a
+requirement to continue to provide support service, warranty, or updates
+for a work that has been modified or installed by the recipient, or for
+the User Product in which it has been modified or installed.  Access to a
+network may be denied when the modification itself materially and
+adversely affects the operation of the network or violates the rules and
+protocols for communication across the network.
+
+  Corresponding Source conveyed, and Installation Information provided,
+in accord with this section must be in a format that is publicly
+documented (and with an implementation available to the public in
+source code form), and must require no special password or key for
+unpacking, reading or copying.
+
+  7. Additional Terms.
+
+  "Additional permissions" are terms that supplement the terms of this
+License by making exceptions from one or more of its conditions.
+Additional permissions that are applicable to the entire Program shall
+be treated as though they were included in this License, to the extent
+that they are valid under applicable law.  If additional permissions
+apply only to part of the Program, that part may be used separately
+under those permissions, but the entire Program remains governed by
+this License without regard to the additional permissions.
+
+  When you convey a copy of a covered work, you may at your option
+remove any additional permissions from that copy, or from any part of
+it.  (Additional permissions may be written to require their own
+removal in certain cases when you modify the work.)  You may place
+additional permissions on material, added by you to a covered work,
+for which you have or can give appropriate copyright permission.
+
+  Notwithstanding any other provision of this License, for material you
+add to a covered work, you may (if authorized by the copyright holders of
+that material) supplement the terms of this License with terms:
+
+    a) Disclaiming warranty or limiting liability differently from the
+    terms of sections 15 and 16 of this License; or
+
+    b) Requiring preservation of specified reasonable legal notices or
+    author attributions in that material or in the Appropriate Legal
+    Notices displayed by works containing it; or
+
+    c) Prohibiting misrepresentation of the origin of that material, or
+    requiring that modified versions of such material be marked in
+    reasonable ways as different from the original version; or
+
+    d) Limiting the use for publicity purposes of names of licensors or
+    authors of the material; or
+
+    e) Declining to grant rights under trademark law for use of some
+    trade names, trademarks, or service marks; or
+
+    f) Requiring indemnification of licensors and authors of that
+    material by anyone who conveys the material (or modified versions of
+    it) with contractual assumptions of liability to the recipient, for
+    any liability that these contractual assumptions directly impose on
+    those licensors and authors.
+
+  All other non-permissive additional terms are considered "further
+restrictions" within the meaning of section 10.  If the Program as you
+received it, or any part of it, contains a notice stating that it is
+governed by this License along with a term that is a further
+restriction, you may remove that term.  If a license document contains
+a further restriction but permits relicensing or conveying under this
+License, you may add to a covered work material governed by the terms
+of that license document, provided that the further restriction does
+not survive such relicensing or conveying.
+
+  If you add terms to a covered work in accord with this section, you
+must place, in the relevant source files, a statement of the
+additional terms that apply to those files, or a notice indicating
+where to find the applicable terms.
+
+  Additional terms, permissive or non-permissive, may be stated in the
+form of a separately written license, or stated as exceptions;
+the above requirements apply either way.
+
+  8. Termination.
+
+  You may not propagate or modify a covered work except as expressly
+provided under this License.  Any attempt otherwise to propagate or
+modify it is void, and will automatically terminate your rights under
+this License (including any patent licenses granted under the third
+paragraph of section 11).
+
+  However, if you cease all violation of this License, then your
+license from a particular copyright holder is reinstated (a)
+provisionally, unless and until the copyright holder explicitly and
+finally terminates your license, and (b) permanently, if the copyright
+holder fails to notify you of the violation by some reasonable means
+prior to 60 days after the cessation.
+
+  Moreover, your license from a particular copyright holder is
+reinstated permanently if the copyright holder notifies you of the
+violation by some reasonable means, this is the first time you have
+received notice of violation of this License (for any work) from that
+copyright holder, and you cure the violation prior to 30 days after
+your receipt of the notice.
+
+  Termination of your rights under this section does not terminate the
+licenses of parties who have received copies or rights from you under
+this License.  If your rights have been terminated and not permanently
+reinstated, you do not qualify to receive new licenses for the same
+material under section 10.
+
+  9. Acceptance Not Required for Having Copies.
+
+  You are not required to accept this License in order to receive or
+run a copy of the Program.  Ancillary propagation of a covered work
+occurring solely as a consequence of using peer-to-peer transmission
+to receive a copy likewise does not require acceptance.  However,
+nothing other than this License grants you permission to propagate or
+modify any covered work.  These actions infringe copyright if you do
+not accept this License.  Therefore, by modifying or propagating a
+covered work, you indicate your acceptance of this License to do so.
+
+  10. Automatic Licensing of Downstream Recipients.
+
+  Each time you convey a covered work, the recipient automatically
+receives a license from the original licensors, to run, modify and
+propagate that work, subject to this License.  You are not responsible
+for enforcing compliance by third parties with this License.
+
+  An "entity transaction" is a transaction transferring control of an
+organization, or substantially all assets of one, or subdividing an
+organization, or merging organizations.  If propagation of a covered
+work results from an entity transaction, each party to that
+transaction who receives a copy of the work also receives whatever
+licenses to the work the party's predecessor in interest had or could
+give under the previous paragraph, plus a right to possession of the
+Corresponding Source of the work from the predecessor in interest, if
+the predecessor has it or can get it with reasonable efforts.
+
+  You may not impose any further restrictions on the exercise of the
+rights granted or affirmed under this License.  For example, you may
+not impose a license fee, royalty, or other charge for exercise of
+rights granted under this License, and you may not initiate litigation
+(including a cross-claim or counterclaim in a lawsuit) alleging that
+any patent claim is infringed by making, using, selling, offering for
+sale, or importing the Program or any portion of it.
+
+  11. Patents.
+
+  A "contributor" is a copyright holder who authorizes use under this
+License of the Program or a work on which the Program is based.  The
+work thus licensed is called the contributor's "contributor version".
+
+  A contributor's "essential patent claims" are all patent claims
+owned or controlled by the contributor, whether already acquired or
+hereafter acquired, that would be infringed by some manner, permitted
+by this License, of making, using, or selling its contributor version,
+but do not include claims that would be infringed only as a
+consequence of further modification of the contributor version.  For
+purposes of this definition, "control" includes the right to grant
+patent sublicenses in a manner consistent with the requirements of
 this License.
 
-  7. If, as a consequence of a court judgment or allegation of patent
-infringement or for any other reason (not limited to patent issues),
-conditions are imposed on you (whether by court order, agreement or
+  Each contributor grants you a non-exclusive, worldwide, royalty-free
+patent license under the contributor's essential patent claims, to
+make, use, sell, offer for sale, import and otherwise run, modify and
+propagate the contents of its contributor version.
+
+  In the following three paragraphs, a "patent license" is any express
+agreement or commitment, however denominated, not to enforce a patent
+(such as an express permission to practice a patent or covenant not to
+sue for patent infringement).  To "grant" such a patent license to a
+party means to make such an agreement or commitment not to enforce a
+patent against the party.
+
+  If you convey a covered work, knowingly relying on a patent license,
+and the Corresponding Source of the work is not available for anyone
+to copy, free of charge and under the terms of this License, through a
+publicly available network server or other readily accessible means,
+then you must either (1) cause the Corresponding Source to be so
+available, or (2) arrange to deprive yourself of the benefit of the
+patent license for this particular work, or (3) arrange, in a manner
+consistent with the requirements of this License, to extend the patent
+license to downstream recipients.  "Knowingly relying" means you have
+actual knowledge that, but for the patent license, your conveying the
+covered work in a country, or your recipient's use of the covered work
+in a country, would infringe one or more identifiable patents in that
+country that you have reason to believe are valid.
+
+  If, pursuant to or in connection with a single transaction or
+arrangement, you convey, or propagate by procuring conveyance of, a
+covered work, and grant a patent license to some of the parties
+receiving the covered work authorizing them to use, propagate, modify
+or convey a specific copy of the covered work, then the patent license
+you grant is automatically extended to all recipients of the covered
+work and works based on it.
+
+  A patent license is "discriminatory" if it does not include within
+the scope of its coverage, prohibits the exercise of, or is
+conditioned on the non-exercise of one or more of the rights that are
+specifically granted under this License.  You may not convey a covered
+work if you are a party to an arrangement with a third party that is
+in the business of distributing software, under which you make payment
+to the third party based on the extent of your activity of conveying
+the work, and under which the third party grants, to any of the
+parties who would receive the covered work from you, a discriminatory
+patent license (a) in connection with copies of the covered work
+conveyed by you (or copies made from those copies), or (b) primarily
+for and in connection with specific products or compilations that
+contain the covered work, unless you entered into that arrangement,
+or that patent license was granted, prior to 28 March 2007.
+
+  Nothing in this License shall be construed as excluding or limiting
+any implied license or other defenses to infringement that may
+otherwise be available to you under applicable patent law.
+
+  12. No Surrender of Others' Freedom.
+
+  If conditions are imposed on you (whether by court order, agreement or
 otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot
-distribute so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you
-may not distribute the Program at all.  For example, if a patent
-license would not permit royalty-free redistribution of the Program by
-all those who receive copies directly or indirectly through you, then
-the only way you could satisfy both it and this License would be to
-refrain entirely from distribution of the Program.
-
-If any portion of this section is held invalid or unenforceable under
-any particular circumstance, the balance of the section is intended to
-apply and the section as a whole is intended to apply in other
-circumstances.
-
-It is not the purpose of this section to induce you to infringe any
-patents or other property right claims or to contest validity of any
-such claims; this section has the sole purpose of protecting the
-integrity of the free software distribution system, which is
-implemented by public license practices.  Many people have made
-generous contributions to the wide range of software distributed
-through that system in reliance on consistent application of that
-system; it is up to the author/donor to decide if he or she is willing
-to distribute software through any other system and a licensee cannot
-impose that choice.
-
-This section is intended to make thoroughly clear what is believed to
-be a consequence of the rest of this License.
-
-  8. If the distribution and/or use of the Program is restricted in
-certain countries either by patents or by copyrighted interfaces, the
-original copyright holder who places the Program under this License
-may add an explicit geographical distribution limitation excluding
-those countries, so that distribution is permitted only in or among
-countries not thus excluded.  In such case, this License incorporates
-the limitation as if written in the body of this License.
-
-  9. The Free Software Foundation may publish revised and/or new versions
-of the General Public License from time to time.  Such new versions will
+excuse you from the conditions of this License.  If you cannot convey a
+covered work so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you may
+not convey it at all.  For example, if you agree to terms that obligate you
+to collect a royalty for further conveying from those to whom you convey
+the Program, the only way you could satisfy both those terms and this
+License would be to refrain entirely from conveying the Program.
+
+  13. Use with the GNU Affero General Public License.
+
+  Notwithstanding any other provision of this License, you have
+permission to link or combine any covered work with a work licensed
+under version 3 of the GNU Affero General Public License into a single
+combined work, and to convey the resulting work.  The terms of this
+License will continue to apply to the part which is the covered work,
+but the special requirements of the GNU Affero General Public License,
+section 13, concerning interaction through a network will apply to the
+combination as such.
+
+  14. Revised Versions of this License.
+
+  The Free Software Foundation may publish revised and/or new versions of
+the GNU General Public License from time to time.  Such new versions will
 be similar in spirit to the present version, but may differ in detail to
 address new problems or concerns.
 
-Each version is given a distinguishing version number.  If the Program
-specifies a version number of this License which applies to it and "any
-later version", you have the option of following the terms and conditions
-either of that version or of any later version published by the Free
-Software Foundation.  If the Program does not specify a version number of
-this License, you may choose any version ever published by the Free Software
-Foundation.
-
-  10. If you wish to incorporate parts of the Program into other free
-programs whose distribution conditions are different, write to the author
-to ask for permission.  For software which is copyrighted by the Free
-Software Foundation, write to the Free Software Foundation; we sometimes
-make exceptions for this.  Our decision will be guided by the two goals
-of preserving the free status of all derivatives of our free software and
-of promoting the sharing and reuse of software generally.
-
-                            NO WARRANTY
-
-  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
-FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
-OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
-PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
-OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
-TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
-PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
-REPAIR OR CORRECTION.
-
-  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
-WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
-REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
-INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
-OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
-TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
-YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
-PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGES.
+  Each version is given a distinguishing version number.  If the
+Program specifies that a certain numbered version of the GNU General
+Public License "or any later version" applies to it, you have the
+option of following the terms and conditions either of that numbered
+version or of any later version published by the Free Software
+Foundation.  If the Program does not specify a version number of the
+GNU General Public License, you may choose any version ever published
+by the Free Software Foundation.
+
+  If the Program specifies that a proxy can decide which future
+versions of the GNU General Public License can be used, that proxy's
+public statement of acceptance of a version permanently authorizes you
+to choose that version for the Program.
+
+  Later license versions may give you additional or different
+permissions.  However, no additional obligations are imposed on any
+author or copyright holder as a result of your choosing to follow a
+later version.
+
+  15. Disclaimer of Warranty.
+
+  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
+APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
+HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
+OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
+IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
+ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. Limitation of Liability.
+
+  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
+THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
+GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
+USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
+DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
+PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
+EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
+SUCH DAMAGES.
+
+  17. Interpretation of Sections 15 and 16.
+
+  If the disclaimer of warranty and limitation of liability provided
+above cannot be given local legal effect according to their terms,
+reviewing courts shall apply local law that most closely approximates
+an absolute waiver of all civil liability in connection with the
+Program, unless a warranty or assumption of liability accompanies a
+copy of the Program in return for a fee.
 
                      END OF TERMS AND CONDITIONS
 
@@ -287,15 +628,15 @@ free software which everyone can redistribute and change under these terms.
 
   To do so, attach the following notices to the program.  It is safest
 to attach them to the start of each source file to most effectively
-convey the exclusion of warranty; and each file should have at least
+state the exclusion of warranty; and each file should have at least
 the "copyright" line and a pointer to where the full notice is found.
 
     <one line to give the program's name and a brief idea of what it does.>
     Copyright (C) <year>  <name of author>
 
-    This program is free software; you can redistribute it and/or modify
+    This program is free software: you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
+    the Free Software Foundation, either version 3 of the License, or
     (at your option) any later version.
 
     This program is distributed in the hope that it will be useful,
@@ -303,37 +644,31 @@ the "copyright" line and a pointer to where the full notice is found.
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License along
-    with this program; if not, write to the Free Software Foundation, Inc.,
-    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 Also add information on how to contact you by electronic and paper mail.
 
-If the program is interactive, make it output a short notice like this
-when it starts in an interactive mode:
+  If the program does terminal interaction, make it output a short
+notice like this when it starts in an interactive mode:
 
-    Gnomovision version 69, Copyright (C) year name of author
-    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    <program>  Copyright (C) <year>  <name of author>
+    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
     This is free software, and you are welcome to redistribute it
     under certain conditions; type `show c' for details.
 
 The hypothetical commands `show w' and `show c' should show the appropriate
-parts of the General Public License.  Of course, the commands you use may
-be called something other than `show w' and `show c'; they could even be
-mouse-clicks or menu items--whatever suits your program.
-
-You should also get your employer (if you work as a programmer) or your
-school, if any, to sign a "copyright disclaimer" for the program, if
-necessary.  Here is a sample; alter the names:
-
-  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
-  `Gnomovision' (which makes passes at compilers) written by James Hacker.
-
-  <signature of Ty Coon>, 1 April 1989
-  Ty Coon, President of Vice
-
-This General Public License does not permit incorporating your program into
-proprietary programs.  If your program is a subroutine library, you may
-consider it more useful to permit linking proprietary applications with the
-library.  If this is what you want to do, use the GNU Lesser General
-Public License instead of this License.
+parts of the General Public License.  Of course, your program's commands
+might be different; for a GUI interface, you would use an "about box".
+
+  You should also get your employer (if you work as a programmer) or school,
+if any, to sign a "copyright disclaimer" for the program, if necessary.
+For more information on this, and how to apply and follow the GNU GPL, see
+<http://www.gnu.org/licenses/>.
+
+  The GNU General Public License does not permit incorporating your program
+into proprietary programs.  If your program is a subroutine library, you
+may consider it more useful to permit linking proprietary applications with
+the library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.  But first, please read
+<http://www.gnu.org/philosophy/why-not-lgpl.html>.
diff --git a/README.md b/README.md
index 7fdb82cd..02c185f5 100644
--- a/README.md
+++ b/README.md
@@ -11,7 +11,7 @@ Complex look ups can result in computationally expensive database queries.  Howe
 * Manual and Complete Documentation: [Documentation at Gamepedia Help Wiki](https://help.gamepedia.com/Extension:DPL3/Manual)
 * Source Code: [Source code at Gitlab](https://gitlab.com/hydrawiki/extensions/DynamicPageList)
 * Bugs and Feature Requests: [Issues at Gitlab](https://gitlab.com/hydrawiki/extensions/DynamicPageList/issues)
-* Licensing: DynamicPageList3 is released under [GNU General Public License, version 2](https://opensource.org/licenses/GPL-2.0).
+* Licensing: DynamicPageList3 is released under [GNU General Public License, version 3](https://opensource.org/licenses/GPL-3.0).
 
 
 ## Installation
diff --git a/composer.json b/composer.json
index fae1037b..ed71f5e1 100644
--- a/composer.json
+++ b/composer.json
@@ -3,7 +3,7 @@
 	"type": "mediawiki-extension",
 	"description": "The DynamicPageList3 extension allows creating listsof other articles based on theircategory, namespace, title, referencesortemplate usageandinclude contentsor arguments of template calls of those articles into your page.",
 	"homepage": "https://www.mediawiki.org/wiki/Extension:DynamicPageList3",
-	"license": "GPL-2.0-or-later",
+	"license": "GPL-3.0-or-later",
 	"require": {
 		"composer/installers": ">=1.0.1"
 	},
@@ -12,22 +12,23 @@
 		"optimize-autoloader": true
 	},
 	"require-dev": {
-		"mediawiki/mediawiki-codesniffer": "35.0.0",
-		"mediawiki/mediawiki-phan-config": "0.10.6",
+		"mediawiki/mediawiki-codesniffer": "37.0.0",
+		"mediawiki/mediawiki-phan-config": "0.11.0",
 		"mediawiki/minus-x": "1.1.1",
 		"php-parallel-lint/php-console-highlighter": "0.5.0",
-		"php-parallel-lint/php-parallel-lint": "1.2.0"
+		"php-parallel-lint/php-parallel-lint": "1.3.1"
 	},
 	"scripts": {
-		"test": [
-			"parallel-lint . --exclude vendor --exclude node_modules",
-			"minus-x check .",
-			"phpcs -p -s"
-		],
 		"fix": [
 			"minus-x fix .",
-			"phpcbf"
+			"phpcbf; if [ $? -eq 1 ]; then exit 0; fi"
+		],
+		"test": [
+			"parallel-lint . --exclude node_modules --exclude vendor",
+			"minus-x check .",
+			"@phpcs"
 		],
-		"phan": "phan -d . --long-progress-bar"
+		"phan": "phan -d . --long-progress-bar",
+		"phpcs": "phpcs -sp --cache"
 	}
 }
diff --git a/extension.json b/extension.json
index 8a2f6dad..1a569254 100644
--- a/extension.json
+++ b/extension.json
@@ -1,6 +1,6 @@
 {
 	"name": "DynamicPageList3",
-	"version": "3.3.5",
+	"version": "3.3.6",
 	"author": [
 		"Alexia E. Smith",
 		"[https://meta.miraheze.org/wiki/User:Universal_Omega Universal Omega]",
@@ -8,10 +8,10 @@
 	],
 	"url": "https://www.mediawiki.org/wiki/Extension:DynamicPageList3",
 	"descriptionmsg": "dpl-desc",
-	"license-name": "GPL-2.0-or-later",
+	"license-name": "GPL-3.0-or-later",
 	"type": "parserhook",
 	"requires": {
-		"MediaWiki": ">= 1.35.0"
+		"MediaWiki": ">= 1.36.0"
 	},
 	"GroupPermissions": {
 		"sysop": {
@@ -29,7 +29,7 @@
 		]
 	},
 	"ExtensionMessagesFiles": {
-		"DynamicPageListMagic": "DynamicPageList.i18n.magic.php"
+		"DynamicPageListMagic": "includes/DynamicPageListMagic.php"
 	},
 	"AutoloadClasses": {
 		"DPL\\Article": "includes/Article.php",
@@ -57,14 +57,17 @@
 		"DPL\\Query": "includes/Query.php",
 		"DPL\\UpdateArticle": "includes/UpdateArticle.php",
 		"DPL\\Variables": "includes/Variables.php",
-		"DynamicPageListHooks": "DynamicPageListHooks.php"
+		"DPL\\RevisionJoinBuilder": "includes/RevisionJoinBuilder.php",
+		"DPL\\UserQueryBuilder": "includes/UserQueryBuilder.php",
+		"DPL\\DynamicPageListHooks": "includes/DynamicPageListHooks.php",
+		"DPL\\DPLIntegrationTestCase": "tests/phpunit/DPLIntegrationTestCase.php"
 	},
 	"Hooks": {
 		"ParserFirstCallInit": [
-			"DynamicPageListHooks::onParserFirstCallInit"
+			"DPL\\DynamicPageListHooks::onParserFirstCallInit"
 		],
 		"LoadExtensionSchemaUpdates": [
-			"DynamicPageListHooks::onLoadExtensionSchemaUpdates"
+			"DPL\\DynamicPageListHooks::onLoadExtensionSchemaUpdates"
 		]
 	},
 	"config": {
@@ -95,6 +98,5 @@
 		"dplchapter-parserfunc-tracking-category",
 		"dplmatrix-parserfunc-tracking-category"
 	],
-	"callback": "DynamicPageListHooks::onRegistration",
 	"manifest_version": 1
 }
diff --git a/i18n/af.json b/i18n/af.json
deleted file mode 100644
index ebdf6d31..00000000
--- a/i18n/af.json
+++ /dev/null
@@ -1,10 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Naudefj"
-        ]
-    },
-    "intersection_toomanycats": "Fout: Te veel kategorie!",
-    "intersection_toofewcats": "Fout: Te min kategorie!",
-    "intersection_noresults": "Fout: Geen resultate!"
-}
\ No newline at end of file
diff --git a/i18n/an.json b/i18n/an.json
deleted file mode 100644
index 7fe2fe06..00000000
--- a/i18n/an.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Juanpabl"
-        ]
-    },
-    "intersection-desc": "Preduz una lista d'os elementos ms rezients que bi ha en una categora u a unin de barios categoras",
-    "intersection_toomanycats": "Error: Masiadas categoras!",
-    "intersection_toofewcats": "Error: numero insufizient de categoras!",
-    "intersection_noresults": "Error: No bi ha garra resultau!",
-    "intersection_noincludecats": "Error: Ha d'encluyir  lo menos una categora u endicar un espazio de nombres!"
-}
\ No newline at end of file
diff --git a/i18n/ar.json b/i18n/ar.json
deleted file mode 100644
index 3f4b0815..00000000
--- a/i18n/ar.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Meno25"
-        ]
-    },
-    "intersection-desc": "           ",
-    "intersection_toomanycats": ":   !",
-    "intersection_toofewcats": ":   !",
-    "intersection_noresults": ":  !",
-    "intersection_noincludecats": ":          !"
-}
\ No newline at end of file
diff --git a/i18n/arz.json b/i18n/arz.json
deleted file mode 100644
index c8edb502..00000000
--- a/i18n/arz.json
+++ /dev/null
@@ -1,13 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Meno25",
-            "Ramsis II"
-        ]
-    },
-    "intersection-desc": "       ,    ",
-    "intersection_toomanycats": ":  !",
-    "intersection_toofewcats": ":  !",
-    "intersection_noresults": ": !",
-    "intersection_noincludecats": ":         !"
-}
\ No newline at end of file
diff --git a/i18n/ast.json b/i18n/ast.json
deleted file mode 100644
index d8fb3a39..00000000
--- a/i18n/ast.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Esbardu"
-        ]
-    },
-    "intersection-desc": "Amuesa una llista de los elementos ms recin que tenga una categora o una xuntanza de varies categores",
-    "intersection_toomanycats": "Error: Demasiaes categores!",
-    "intersection_toofewcats": "Error: Demasiaes poques categores!",
-    "intersection_noresults": "Error: Nun hai resultaos!",
-    "intersection_noincludecats": "Error: Necesites amiestar a lo menos una categora, o especificar un espaciu de nomes!"
-}
\ No newline at end of file
diff --git a/i18n/bcc.json b/i18n/bcc.json
deleted file mode 100644
index b649694f..00000000
--- a/i18n/bcc.json
+++ /dev/null
@@ -1,11 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Mostafadaneshvar"
-        ]
-    },
-    "intersection_toomanycats": "DynamicPageList:   !",
-    "intersection_toofewcats": "DynamicPageList:    !",
-    "intersection_noresults": "DynamicPageList:   ",
-    "intersection_noincludecats": "  :             !"
-}
\ No newline at end of file
diff --git a/i18n/be-tarask.json b/i18n/be-tarask.json
deleted file mode 100644
index 03a089df..00000000
--- a/i18n/be-tarask.json
+++ /dev/null
@@ -1,13 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "EugeneZelenko",
-            "Jim-by"
-        ]
-    },
-    "intersection-desc": "         '  ",
-    "intersection_toomanycats": ":  !",
-    "intersection_toofewcats": ":   !",
-    "intersection_noresults": ":  !",
-    "intersection_noincludecats": ":           !"
-}
\ No newline at end of file
diff --git a/i18n/bg.json b/i18n/bg.json
deleted file mode 100644
index 41f1898c..00000000
--- a/i18n/bg.json
+++ /dev/null
@@ -1,13 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "DCLXVI",
-            "Spiritia"
-        ]
-    },
-    "intersection-desc": "   -         ",
-    "intersection_toomanycats": "Error:   !",
-    "intersection_toofewcats": "Error:   !",
-    "intersection_noresults": "Error:  !",
-    "intersection_noincludecats": "Error:              !"
-}
\ No newline at end of file
diff --git a/i18n/bn.json b/i18n/bn.json
deleted file mode 100644
index c09714c3..00000000
--- a/i18n/bn.json
+++ /dev/null
@@ -1,11 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Bellayet"
-        ]
-    },
-    "intersection_toomanycats": "Error:   !",
-    "intersection_toofewcats": "Error:   !",
-    "intersection_noresults": "Error:  !",
-    "intersection_noincludecats": ":     ,     !"
-}
\ No newline at end of file
diff --git a/i18n/br.json b/i18n/br.json
deleted file mode 100644
index 77c8e4d3..00000000
--- a/i18n/br.json
+++ /dev/null
@@ -1,10 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Fulup"
-        ]
-    },
-    "intersection_toomanycats": "Error: Re a rummado !",
-    "intersection_toofewcats": "Error: Re nebeut a rummado !",
-    "intersection_noresults": "Error: Disoc'h ebet !"
-}
\ No newline at end of file
diff --git a/i18n/bs.json b/i18n/bs.json
deleted file mode 100644
index f0f2a2bb..00000000
--- a/i18n/bs.json
+++ /dev/null
@@ -1,13 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "CERminator",
-            "Seha"
-        ]
-    },
-    "intersection-desc": "Izbacuje listu najeih taaka koje se nalaze u kategoriji ili u sekciji nekoliko kategorija.",
-    "intersection_toomanycats": "Greka: Previe kategorija!",
-    "intersection_toofewcats": "Greka: Premalo kategorija!",
-    "intersection_noresults": "Greka: Nema rezultata!",
-    "intersection_noincludecats": "Greka: Potrebno je da ukljuite najmanje jednu kategoriju ili odredite imenski prostor!"
-}
\ No newline at end of file
diff --git a/i18n/ca.json b/i18n/ca.json
deleted file mode 100644
index 256e6bb5..00000000
--- a/i18n/ca.json
+++ /dev/null
@@ -1,13 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Paucabot",
-            "SMP"
-        ]
-    },
-    "intersection-desc": "Genera una llista d'elements recents en una categoria o en la intersecci de diverses.",
-    "intersection_toomanycats": "Error: Massa categories!",
-    "intersection_toofewcats": "Error: Massa poques categories!",
-    "intersection_noresults": "Error: Cap resultat!",
-    "intersection_noincludecats": "Error: Heu d'incloure almenys una categoria o especificar un espai de noms!"
-}
\ No newline at end of file
diff --git a/i18n/cs.json b/i18n/cs.json
deleted file mode 100644
index 97aa5ee3..00000000
--- a/i18n/cs.json
+++ /dev/null
@@ -1,13 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Li-sung",
-            "Matj Grabovsk"
-        ]
-    },
-    "intersection-desc": "Vype seznam nejnovjch poloek v kategorii nebo sjednot nkolik kategori",
-    "intersection_toomanycats": "Error: Pli mnoho kategori!",
-    "intersection_toofewcats": "Error: Mlo kategori!",
-    "intersection_noresults": "Error: dn vsledky!",
-    "intersection_noincludecats": "Error: Muste zahrnout alespo jednu kategorii nebo urit jmenn prostor!"
-}
\ No newline at end of file
diff --git a/i18n/de.json b/i18n/de.json
deleted file mode 100644
index 89514d29..00000000
--- a/i18n/de.json
+++ /dev/null
@@ -1,49 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Gero Scholz",
-            "MarkusRost"
-        ]
-    },
-    "intersection-desc": "Ausgabe einer Liste der aktuellsten Eintrge in einer Kategorie, oder der Schnittmenge mehrerer Kategorien",
-    "intersection_toomanycats": "Fehler: Zu viele Kategorien!",
-    "intersection_toofewcats": "Fehler: Zu wenige Kategorien!",
-    "intersection_noresults": "Fehler: Kein Ergebnis!",
-    "intersection_noincludecats": "Fehler: Es muss mindestens eine Kategorie eingebunden werden oder ein Namensraum angegeben sein!",
-    "dpl_log_1": "Fehler: bei $1 Parameter: $2! Hilfe:  <code>$1= <i>(leer)</i> (Hauptnamensraum)$3</code>.",
-    "dpl_log_2": "Fehler: bei $1 Parameter: $2! Hilfe:  <code>$1= <i>vollstndiger Seitenname</i></code>.",
-    "dpl_log_3": "Fehler: Zu viele Kategorien! Maximum: $1.",
-    "dpl_log_4": "Fehler: Zu wenige Kategorien! Minimum: $1.",
-    "dpl_log_5": "Fehler: Keine Auswahlkriterien angegeben! Mindestens einer der folgenden Parameter ist erforderlich: category, namespace, titlematch, linksto, uses, createdby, modifiedby, lastmodifiedby oder die not-Varianten davon.",
-    "dpl_log_6": "Fehler: Sie mssen mindestens eine Kategorie angeben, wenn Sie addfirstcategorydate=true oder ordermethod=categoryadd benutzen.",
-    "dpl_log_7": "Fehler: Wenn Sie mehr als eine Kategorie angeben, knnen Sie addfirstcategorydate=true oder ordermethod=categoryadd nicht benutzen.",
-    "dpl_log_8": "Fehler: Es ist nur eine einzige Art der Datumsangabe gleichzeitig mglich.",
-    "dpl_log_9": "Fehler: Der Parameter $1 muss in Verbindung mit ordermethod=[ $2 ] benutzt werden.",
-    "dpl_log_10": "Fehler: Die Indexangabe bei dominantsection muss zwischen 1 und  der Anzahl der Argumente von includepage liegen ($0 in diesem Fall).",
-    "dpl_log_11": "Fehler: Kann keine logischen Operationen an nicht kategorisierten Seiten ausfhren (z.&nbsp;B. mit dem category Parameter) weil die $0-Ansicht nicht in der Datenbank vorhanden ist!",
-    "dpl_log_12": "Fehler: Die Angabe von openreferences ist nicht vereinbar mit anderen angegegeben Optionen. Entferne die anderen Optionen oder openreferences. Details dazu stehen im DPL-Manual.",
-    "dpl_log_13": "Warnung: Der unbekannte Parameter $1 wurde ignoriert. Hilfe: Verfgbare Parameter: <code>$2</code>.",
-    "dpl_log_14": "Warnung: berspringe die ungltige Option $2 fr den Parameter $1.",
-    "dpl_log_15": "Warnung: Falscher $1-Parameter: $2! Standardwert wird verwendet: $3 (unbegrenzt). Hilfe: <code>$1= <i>(leer)</i> (unbegrenzt) | n</code>, wobei <code>n</code> eine positive Ganzzahl sein muss.",
-    "dpl_log_16": "Warnung: Keine Ergebnisse.",
-    "dpl_log_17": "Warnung: Add* Parameter (adduser, addeditdate, usw.) und includepage haben keinen Effekt in Verbindung mit mode=category. Es kann nur der Seitentitel und Namensraum angezeigt werden.",
-    "dpl_log_18": "Warnung: headingmode=$1 hat keinen Effekt, wenn ordermethod sich auf eine einzelne Komponente bezieht. Es wird $2 verwendet. Hilfe: Sie knnen not-$1 headingmode Werte in Verbindung mit ordermethod fr mehrfache Komponenten verwenden. Die erste Konponente wird fr Gruppen verwendet. Z.&nbsp;B. ordermethod=category,<i>comp</i> (<i>comp</i> ist eine andere Komponente) fr Kategorie-Gruppen.",
-    "dpl_log_19": "Warnung: debug=$1 steht nicht an erster Stelle in der DPL-Anweisung. Die Einstellung wird erst wirksam, nachdem die vorausgehenden Parameter geprft und verarbeitet sind.",
-    "dpl_log_20": "Warnung: Endlosschleife beim Einbinden von Inhalten der Seite $0.",
-    "dpl_log_21": "Datenbank-Abfrage: <code>$0</code>",
-    "dpl_log_22": "Warnung: Keine Parameter-Option angegeben fr $1. (= fehlt)",
-    "dpl_articlecount": "Diese Gruppe enthlt {{PLURAL:$1|einen|$1}} Artikel.",
-    "action-dpl_param_update_rules": "um den Parameter updaterules zu nutzen",
-    "action-dpl_param_delete_rules": "um den Parameter deleterules zu nutzen",
-    "dpl_query_error": "Die DPL-Erweiterung (Version $1) produzierte ein SQL-Statement, was zu einem Datenbank-Fehler fhrte.<br/>Der Grund knnte ein interner Fehler von DPL sein oder ein Fehler deinerseits; besonders beim Nutzen von Parametern wie categoryregexp oder titleregexp.  Die Verwendung von non-greedy *? matching patterns werden nicht untersttzt.<br/>Fehlermeldung:<br/><code>$2</code>",
-    "dpl-tag-tracking-category": "Seiten, die DynamicPageList parser tag nutzen",
-    "dpl-intersection-tracking-category": "Seiten, die DynamicPageList Intersection parser tag nutzen",
-    "dpl-parserfunc-tracking-category": "Seiten, die DynamicPageList parser function nutzen",
-    "dplnum-parserfunc-tracking-category": "Seiten, die DynamicPageList dplnum parser function nutzen",
-    "dplvar-parserfunc-tracking-category": "Seiten, die DynamicPageList dplvar parser function nutzen",
-    "dplreplace-parserfunc-tracking-category": "Seiten, die DynamicPageList dplreplace parser function nutzen",
-    "dplchapter-parserfunc-tracking-category": "Seiten, die DynamicPageList dplchapter parser function nutzen",
-    "dplmatrix-parserfunc-tracking-category": "Seiten, die DynamicPageList dplmatrix parser function nutzen",
-    "right-dpl_param_delete_rules": "Massenlschungen von Seiten, die DPL nutzen",
-    "right-dpl_param_update_rules": "Massennderungen von Seiten, die DPL nutzen"
-}
\ No newline at end of file
diff --git a/i18n/dsb.json b/i18n/dsb.json
deleted file mode 100644
index 13cd527f..00000000
--- a/i18n/dsb.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Michawiki"
-        ]
-    },
-    "intersection-desc": "Wudawa lisina nejaktualnjejych zapiskow w kategoriji abo zgromadneje mogosi nkotarych kategorijow",
-    "intersection_toomanycats": "Zmlka: Pewjele kategorijow!",
-    "intersection_toofewcats": "Zmlka: Pemao kategorijow!",
-    "intersection_noresults": "Zmlka: edne wusldki!",
-    "intersection_noincludecats": "Zmlka: Musy nanejmjenjej jadnu kategoriju zapgnu abo mjenjowy rum pda!"
-}
\ No newline at end of file
diff --git a/i18n/el.json b/i18n/el.json
deleted file mode 100644
index 9aca7805..00000000
--- a/i18n/el.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Dead3y3"
-        ]
-    },
-    "intersection-desc": "             ,     ",
-    "intersection_toomanycats": ":   !",
-    "intersection_toofewcats": ":   !",
-    "intersection_noresults": ":   !",
-    "intersection_noincludecats": ":      ,      !"
-}
\ No newline at end of file
diff --git a/i18n/en.json b/i18n/en.json
index 31c03ccf..26a94fb0 100644
--- a/i18n/en.json
+++ b/i18n/en.json
@@ -1,50 +1,51 @@
 {
-    "@metadata": {
-        "authors": [
-            "m:User:Dangerman <cyril.dangerville@gmail.com>"
-        ]
-    },
-    "intersection-desc": "Outputs a bulleted list of the most recent items residing in a category, or an intersection of several categories",
-    "intersection_toomanycats": "Error: Too many categories!",
-    "intersection_toofewcats": "Error: Too few categories!",
-    "intersection_noresults": "Error: No results!",
-    "intersection_noincludecats": "Error: You need to include at least one category, or specify a namespace!",
-    "dpl-desc": "A highly flexible report generator for MediaWikis",
-    "dpl_log_1": "Error: Wrong '$1' parameter: '$2'! Help:  <code>$1= <i>empty string</i> (Main)$3</code>.",
-    "dpl_log_2": "Error: Wrong '$1' parameter: '$2'! Help:  <code>$1= <i>full pagename</i></code>.",
-    "dpl_log_3": "Error: Too many categories! Maximum: $1. Help: increase <code>$wgDplSettings['maxCategoryCount']</code> to specify more categories or set <code>$wgDplSettings['allowUnlimitedCategories'] = true;</code> for no limitation. (Set the variable in the wiki's <code>LocalSettings.php</code> configuration file.)",
-    "dpl_log_4": "Error: Too few categories! Minimum: $1. Help: decrease <code>$wgDplSettings['minCategoryCount']</code> to specify fewer categories. (Set the variable in the wiki's <code>LocalSettings.php</code> configuration file.)",
-    "dpl_log_5": "Error: No selection criteria found! You must use at least one of the following parameters: category, namespace, titlematch, linksto, uses, createdby, modifiedby, lastmodifiedby, or their 'not' variants",
-    "dpl_log_6": "Error: At least one category must be chosen if to use 'addfirstcategorydate=true' or 'ordermethod=categoryadd'.",
-    "dpl_log_7": "Error: If you include more than one category, you cannot use 'addfirstcategorydate=true' or 'ordermethod=categoryadd'.",
-    "dpl_log_8": "Error: Only one date type can be added at a time.",
-    "dpl_log_9": "Error: The paramater '$1' must be used with 'ordermethod=[ $2 ]'",
-    "dpl_log_10": "Error: the index for the dominant section must be between 1 and the number of arguments of includepage ($0 in this case)",
-    "dpl_log_11": "Error: Cannot perform logical operations on the Uncategorized pages (f.e. with the 'category' parameter) because the $0 view does not exist on the database! Help: have the database administrator execute this query: <code>$1</code>.",
-    "dpl_log_12": "Error: specifying \"openreferences\" is incompatible with another option specified.  Please remove that other option or \"openreferences\".  See the manual for details.",
-    "dpl_log_13": "Warning: Unknown parameter '$1' was ignored. Help: available parameters: <code>$2</code>.",
-    "dpl_log_14": "Warning: Skipping bad option '$2' for parameter '$1'.",
-    "dpl_log_15": "Warning: Wrong '$1' parameter: '$2'! Using default: '$3' (no limit). Help: <code>$1= <i>empty string</i> (no limit) | n</code>, with <code>n</code> a positive integer.",
-    "dpl_log_16": "Warning: No results.",
-    "dpl_log_17": "Warning: Add* parameters ('adduser', 'addeditdate', etc.)' and 'includepage' have no effect with 'mode=category'. Only the page namespace/title can be viewed in this mode.",
-    "dpl_log_18": "Warning: 'headingmode=$1' has no effect with 'ordermethod' on a single component. Using: '$2'. Help: you can use not-$2 'headingmode' values with 'ordermethod' on multiple components. The first component is used for headings. E.g. 'ordermethod=category,<i>comp</i>' (<i>comp</i> is another component) for category headings.",
-    "dpl_log_19": "Warning: 'debug=$1' is not in first position in the DPL element. The new debug settings are not applied before all previous parameters have been parsed and checked.",
-    "dpl_log_20": "Warning: An infinite transclusion loop is created by page '$0'.",
-    "dpl_log_21": "Query: <code>$0</code>",
-    "dpl_log_22": "Warning: No parameter option supplied for '$1'. (Missing '=')",
-    "dpl_articlecount": "There {{PLURAL:$1|is one article|are $1 articles}} in this heading.",
-    "dpl_description": "A flexible report generator for MediaWiki. See [http://semeb.com/dpldemo] for the manual and examples",
-    "action-dpl_param_update_rules": "to use the parameter 'updaterules'",
-    "action-dpl_param_delete_rules": "to use the parameter 'deleterules'",
-    "dpl_query_error": "The DPL extension (version $1) produced a SQL statement which led to a Database error.<br/>The reason may be an internal error of DPL or an error which you made; especially when using parameters like 'categoryregexp' or 'titleregexp'.  Usage of non-greedy *? matching patterns are not supported.<br/>Error message was:<br/><tt>$2</tt>",
-    "dpl-tag-tracking-category": "Pages using DynamicPageList parser tag",
-    "dpl-intersection-tracking-category": "Pages using DynamicPageList Intersection parser tag",
-    "dpl-parserfunc-tracking-category": "Pages using DynamicPageList parser function",
-    "dplnum-parserfunc-tracking-category": "Pages using DynamicPageList dplnum parser function",
-    "dplvar-parserfunc-tracking-category": "Pages using DynamicPageList dplvar parser function",
-    "dplreplace-parserfunc-tracking-category": "Pages using DynamicPageList dplreplace parser function",
-    "dplchapter-parserfunc-tracking-category": "Pages using DynamicPageList dplchapter parser function",
-    "dplmatrix-parserfunc-tracking-category": "Pages using DynamicPageList dplmatrix parser function",
-    "right-dpl_param_delete_rules": "Mass deletion of pages using DPL",
-    "right-dpl_param_update_rules": "Mass update of pages using DPL"
-}
\ No newline at end of file
+	"@metadata": {
+		"authors": [
+			"Dangerman",
+			"Universal Omega"
+		]
+	},
+	"intersection-desc": "Outputs a bulleted list of the most recent items residing in a category, or an intersection of several categories",
+	"intersection_toomanycats": "Error: Too many categories!",
+	"intersection_toofewcats": "Error: Too few categories!",
+	"intersection_noresults": "Error: No results!",
+	"intersection_noincludecats": "Error: You need to include at least one category, or specify a namespace!",
+	"dpl-desc": "A highly flexible report generator for MediaWikis",
+	"dpl_log_1": "Error: Wrong '$1' parameter: '$2'! Help: <code>$1= <i>empty string</i> (Main)$3</code>.",
+	"dpl_log_2": "Error: Wrong '$1' parameter: '$2'! Help: <code>$1= <i>full pagename</i></code>.",
+	"dpl_log_3": "Error: Too many categories! Maximum: $1. Help: increase <code>$wgDplSettings['maxCategoryCount']</code> to specify more categories or set <code>$wgDplSettings['allowUnlimitedCategories'] = true;</code> for no limitation. (Set the variable in the wiki's <code>LocalSettings.php</code> configuration file.)",
+	"dpl_log_4": "Error: Too few categories! Minimum: $1. Help: decrease <code>$wgDplSettings['minCategoryCount']</code> to specify fewer categories. (Set the variable in the wiki's <code>LocalSettings.php</code> configuration file.)",
+	"dpl_log_5": "Error: No selection criteria found! You must use at least one of the following parameters: category, namespace, titlematch, linksto, uses, createdby, modifiedby, lastmodifiedby, or their 'not' variants",
+	"dpl_log_6": "Error: At least one category must be chosen if to use 'addfirstcategorydate=true' or 'ordermethod=categoryadd'.",
+	"dpl_log_7": "Error: If you include more than one category, you cannot use 'addfirstcategorydate=true' or 'ordermethod=categoryadd'.",
+	"dpl_log_8": "Error: Only one date type can be added at a time.",
+	"dpl_log_9": "Error: The paramater '$1' must be used with 'ordermethod=[ $2 ]'",
+	"dpl_log_10": "Error: the index for the dominant section must be between 1 and the number of arguments of includepage ($0 in this case)",
+	"dpl_log_11": "Error: Cannot perform logical operations on the Uncategorized pages (f.e. with the 'category' parameter) because the $0 view does not exist on the database! Help: have the database administrator execute this query: <code>$1</code>.",
+	"dpl_log_12": "Error: specifying \"openreferences\" is incompatible with another option specified. Please remove that other option or \"openreferences\". See the manual for details.",
+	"dpl_log_13": "Warning: Unknown parameter '$1' was ignored. Help: available parameters: <code>$2</code>.",
+	"dpl_log_14": "Warning: Skipping bad option '$2' for parameter '$1'.",
+	"dpl_log_15": "Warning: Wrong '$1' parameter: '$2'! Using default: '$3' (no limit). Help: <code>$1= <i>empty string</i> (no limit) | n</code>, with <code>n</code> a positive integer.",
+	"dpl_log_16": "Warning: No results.",
+	"dpl_log_17": "Warning: Add* parameters ('adduser', 'addeditdate', etc.)' and 'includepage' have no effect with 'mode=category'. Only the page namespace/title can be viewed in this mode.",
+	"dpl_log_18": "Warning: 'headingmode=$1' has no effect with 'ordermethod' on a single component. Using: '$2'. Help: you can use not-$2 'headingmode' values with 'ordermethod' on multiple components. The first component is used for headings. E.g. 'ordermethod=category,<i>comp</i>' (<i>comp</i> is another component) for category headings.",
+	"dpl_log_19": "Warning: 'debug=$1' is not in first position in the DPL element. The new debug settings are not applied before all previous parameters have been parsed and checked.",
+	"dpl_log_20": "Warning: An infinite transclusion loop is created by page '$0'.",
+	"dpl_log_21": "Query: <code>$0</code>",
+	"dpl_log_22": "Warning: No parameter option supplied for '$1'. (Missing '=')",
+	"dpl_articlecount": "There {{PLURAL:$1|is one article|are $1 articles}} in this heading.",
+	"dpl_description": "A flexible report generator for MediaWiki. See [http://semeb.com/dpldemo] for the manual and examples",
+	"action-dpl_param_update_rules": "to use the parameter 'updaterules'",
+	"action-dpl_param_delete_rules": "to use the parameter 'deleterules'",
+	"dpl_query_error": "The DPL extension (version $1) produced a SQL statement which led to a Database error.<br/>The reason may be an internal error of DPL or an error which you made; especially when using parameters like 'categoryregexp' or 'titleregexp'. Usage of non-greedy *? matching patterns are not supported.<br/>Error message was:<br/><tt>$2</tt>",
+	"dpl-tag-tracking-category": "Pages using DynamicPageList parser tag",
+	"dpl-intersection-tracking-category": "Pages using DynamicPageList Intersection parser tag",
+	"dpl-parserfunc-tracking-category": "Pages using DynamicPageList parser function",
+	"dplnum-parserfunc-tracking-category": "Pages using DynamicPageList dplnum parser function",
+	"dplvar-parserfunc-tracking-category": "Pages using DynamicPageList dplvar parser function",
+	"dplreplace-parserfunc-tracking-category": "Pages using DynamicPageList dplreplace parser function",
+	"dplchapter-parserfunc-tracking-category": "Pages using DynamicPageList dplchapter parser function",
+	"dplmatrix-parserfunc-tracking-category": "Pages using DynamicPageList dplmatrix parser function",
+	"right-dpl_param_delete_rules": "Mass deletion of pages using DPL",
+	"right-dpl_param_update_rules": "Mass update of pages using DPL"
+}
diff --git a/i18n/eo.json b/i18n/eo.json
deleted file mode 100644
index ff80baa8..00000000
--- a/i18n/eo.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Yekrats"
-        ]
-    },
-    "intersection-desc": "Eligas bulpunktitan liston de la plej lastaj kategorianoj, a unuigo de pluraj kategorioj",
-    "intersection_toomanycats": "Eraro: Tro da kategorioj!",
-    "intersection_toofewcats": "Error: Tro malmultaj da kategorioj!",
-    "intersection_noresults": "Error: Neniom da rezultoj!",
-    "intersection_noincludecats": "Error: Vi devas inkluzivi almena unu kategorion, a specifigu nomspacon!"
-}
\ No newline at end of file
diff --git a/i18n/es.json b/i18n/es.json
deleted file mode 100644
index b0d59238..00000000
--- a/i18n/es.json
+++ /dev/null
@@ -1,14 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Aleator",
-            "Remember the dot",
-            "Sanbec"
-        ]
-    },
-    "intersection-desc": "Devuelve una lista de los elementos ms recientes que estn en una categora o en una interseccin de varias categoras",
-    "intersection_toomanycats": "Error: Demasiadas categoras!",
-    "intersection_toofewcats": "Error: Muy pocas categoras!",
-    "intersection_noresults": "Error: Sin resultados!",
-    "intersection_noincludecats": "Error: Necesita incluir al menos una categora, o especificar un espacio de nombres!"
-}
\ No newline at end of file
diff --git a/i18n/eu.json b/i18n/eu.json
deleted file mode 100644
index 1fb9c77e..00000000
--- a/i18n/eu.json
+++ /dev/null
@@ -1,11 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "An13sa"
-        ]
-    },
-    "intersection_toomanycats": "Errorea: Kategoria gehiegi!",
-    "intersection_toofewcats": "Errorea: Kategoria gutxiegi!",
-    "intersection_noresults": "Errorea: Emaitzarik ez!",
-    "intersection_noincludecats": "Errorea: Gutxienez kategoria bat gehitu edo izen bat zehaztu behar duzu!"
-}
\ No newline at end of file
diff --git a/i18n/fa.json b/i18n/fa.json
deleted file mode 100644
index 417748a1..00000000
--- a/i18n/fa.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Huji"
-        ]
-    },
-    "intersection-desc": "                 ",
-    "intersection_toomanycats": "DynamicPageList:    !",
-    "intersection_toofewcats": "DynamicPageList:    !",
-    "intersection_noresults": "DynamicPageList:   !",
-    "intersection_noincludecats": "DynamicPageList:               !"
-}
\ No newline at end of file
diff --git a/i18n/fi.json b/i18n/fi.json
deleted file mode 100644
index ef5cf1f5..00000000
--- a/i18n/fi.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Nike"
-        ]
-    },
-    "intersection-desc": "Tulostaa listan luokassa tai useamman luokan yhdisteess olevista sivuista.",
-    "intersection_toomanycats": "Error: Liian monta luokkaa.",
-    "intersection_toofewcats": "Error: Liian vhn luokkia.",
-    "intersection_noresults": "Error: Ei tuloksia.",
-    "intersection_noincludecats": "Error: Lis vhintn yksi luokka tai mrit nimiavaruus."
-}
\ No newline at end of file
diff --git a/i18n/fr.json b/i18n/fr.json
deleted file mode 100644
index 87f31d29..00000000
--- a/i18n/fr.json
+++ /dev/null
@@ -1,36 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Grondin",
-            "Urhixidur",
-            "Verdy p"
-        ]
-    },
-    "intersection-desc": "Affiche une liste,  puces, des articles les plus rcents dans une catgorie, ou  partir dune combinaison de plusieurs catgories.",
-    "intersection_toomanycats": "DynamicPageList : trop de catgories !",
-    "intersection_toofewcats": "DynamicPageList : pas assez de catgories !",
-    "intersection_noresults": "DynamicPageList : aucun rsultat !",
-    "intersection_noincludecats": "Error : vous devez inclure au moins une catgorie, ou prciser un nom despace !",
-    "dpl_log_1": "ERREUR : Mauvais paramtre '$0' : '$1'! Aide :  <code>$0= <i>chane vide</i> (Principal)$3</code>. (Les quivalents avec des mots magiques sont aussi autoriss.)",
-    "dpl_log_2": "ERREUR : Mauvais paramtre '$0' : '$1'! Aide :  <code>$0= <i>Nom complet de la page</i></code>. (Les mots magiques sont autoriss.)",
-    "dpl_log_3": "ERREUR : Trop de catgories ! Maximum : $0. Aide : accrotre <code>DynamicPageListHooks::$maxCategoryCount</code> pour autoriser plus de catgories ou rgler <code>DynamicPageListHooks::$allowUnlimitedCategories=true</code> pour aucune limite. ( rgler dans <code>LocalSettings.php</code>, aprs avoir inclus <code>DynamicPageList.php</code>.)",
-    "dpl_log_4": "ERREUR : Pas assez de catgories ! Minimum : $0. Aide : dcrotre <code>DynamicPageListHooks::$minCategoryCount</code> pour autoriser moins de catgories. ( rgler dans <code>LocalSettings.php</code> de prfrence, aprs avoir inclus <code>DynamicPageList.php</code>.)",
-    "dpl_log_5": "ERROR: No selection criteria found! You must use at least one of the following parameters: category, namespace, titlematch, linksto, uses, createdby, modifiedby, lastmodifiedby, or their 'not' variants",
-    "dpl_log_6": "ERREUR : Vous devez inclure au moins une catgorie si vous voulez utiliser 'addfirstcategorydate=true' ou 'ordermethod=categoryadd' !",
-    "dpl_log_7": "ERREUR : Si vous incluez plus dune catgorie, vous ne pouvez pas utiliser 'addfirstcategorydate=true' ou 'ordermethod=categoryadd' !",
-    "dpl_log_8": "ERREUR : Vous ne pouvez pas utiliser plus dun type de date  la fois !",
-    "dpl_log_9": "ERREUR : Vous ne pouvez utiliser '$0' quavec 'ordermethod=[...,]$1' !",
-    "dpl_log_10": "ERROR: the index for the dominant section must be between 1 and the number of arguments of includepage ($0 in this case)",
-    "dpl_log_11": "ERREUR : Ne peut pas effectuer doprations logiques sur les pages sans catgories (avec la paramtre 'category') car la vue $0 nexiste pas dans la base de donnes ! Aide : demander  un administrateur de la base de donnes d'effectuer : <code>$1</code>.",
-    "dpl_log_12": "ERROR: specifying \"openreferences\" is incompatible with some other option you specified. See the manual for details.",
-    "dpl_log_13": "AVERTISSEMENT : Le paramtre inconnu '$1' est ignor. Aide : paramtres disponibles : <code>$2</code>.",
-    "dpl_log_14": "AVERTISSEMENT : Mauvais paramtre '$0' : '$1'! Utilisation de la valeur par dfaut : '$2'. Aide : <code>$0= $3</code>.",
-    "dpl_log_15": "AVERTISSEMENT : Mauvais paramtre '$0' : '$1'! Utilisattion de la valeur par dfaut : '$2' (aucune limite). Aide : <code>$0= <i>chane vide</i> (aucune limite) | n</code>, avec <code>n</code> un entier positif.",
-    "dpl_log_16": "AVERTISSEMENT : Aucun rsultat !",
-    "dpl_log_17": "AVERTISSEMENT : Les paramtres Add* ('adduser', 'addeditdate', etc.)' et 'includepage' nont aucun effet avec 'mode=category'. Seuls lespace de nom et le titre de la page peuvent tre vus dans ce mode..",
-    "dpl_log_18": "AVERTISSEMENT : 'headingmode=$0' n'a aucun effet avec 'ordermethod' sur une simple composante. Utiliser : '$1'. Aide : vous pouvez utiliser not-$1  sur les valeurs de 'headingmode' avec 'ordermethod' sur plusieurs composantes.  La premire composante est utilise pour les en-ttes. Exemple : 'ordermethod=category,<i>comp</i>' (<i>comp</i> est une autre composante) pour les en-ttes de catgorie.",
-    "dpl_log_19": "AVERTISSEMENT : 'debug=$0' nest pas en premire position dans llment DPL. Les nouveaux rglages de dbogage ne seront appliqus quaprs que les paramtres prcdents aient t vrifis.",
-    "dpl_log_20": "AVERTISSEMENT : Une boucle dinclusion infinie est cre par la page '$0'.",
-    "dpl_log_21": "REQUTE : <code>$0</code>",
-    "dpl_articlecount": "Il y a {{PLURAL:$1|un article|$1 articles}} dans cette section."
-}
\ No newline at end of file
diff --git a/i18n/frp.json b/i18n/frp.json
deleted file mode 100644
index 117d18d9..00000000
--- a/i18n/frp.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "ChrisPtDe"
-        ]
-    },
-    "intersection-desc": "Afiche una lista de puges des articllos los ples novls dens una catgorie, ou ben ds una combinson de plusiors catgories.",
-    "intersection_toomanycats": "Error : trop de catgories !",
-    "intersection_toofewcats": "Error : pas prod de catgories !",
-    "intersection_noresults": "Error : nion rsultat !",
-    "intersection_noincludecats": "Error : vos avd fta dencllure u muens yona catgorie, ou ben de spcefiar un spo de nom !"
-}
\ No newline at end of file
diff --git a/i18n/gl.json b/i18n/gl.json
deleted file mode 100644
index cd6f16ea..00000000
--- a/i18n/gl.json
+++ /dev/null
@@ -1,13 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Tolio",
-            "Xos"
-        ]
-    },
-    "intersection-desc": "Devolve unha lista punteada dos elementos mis recentes que estn nunha categora ou nunha unin de varias categoras",
-    "intersection_toomanycats": "Erro: demasiadas categoras!",
-    "intersection_toofewcats": "Erro: moi poucas categoras!",
-    "intersection_noresults": "Erro: ningn resultado!",
-    "intersection_noincludecats": "Erro: ten que inclur unha categora polo menos ou especificar un espazo de nomes!"
-}
\ No newline at end of file
diff --git a/i18n/grc.json b/i18n/grc.json
deleted file mode 100644
index 0e7d17d4..00000000
--- a/i18n/grc.json
+++ /dev/null
@@ -1,9 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Omnipaedista"
-        ]
-    },
-    "intersection_noresults": ":  ",
-    "intersection_noincludecats": ":      ,    !"
-}
\ No newline at end of file
diff --git a/i18n/gsw.json b/i18n/gsw.json
deleted file mode 100644
index 84177999..00000000
--- a/i18n/gsw.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Als-Holder"
-        ]
-    },
-    "intersection-desc": "Usgabe vun ere Lischt vu dr aktullschte Yytrg in ere Kategorii, oder vu dr Schnittmngi vu mehrere Kategorie",
-    "intersection_toomanycats": "Fhler: Zvyyl Kategorie!",
-    "intersection_toofewcats": "Fhler: Zwenig Kategorie!",
-    "intersection_noresults": "Fhler: Kei Ergebnis!",
-    "intersection_noincludecats": "Fhler: S muess zmindescht ei Kategorii yybunde wre oder gib e Namensruum aa!"
-}
\ No newline at end of file
diff --git a/i18n/he.json b/i18n/he.json
deleted file mode 100644
index 498e188e..00000000
--- a/i18n/he.json
+++ /dev/null
@@ -1,34 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Rotem Liss"
-        ]
-    },
-    "intersection-desc": "       ,   ",
-    "intersection_toomanycats": "DynamicPageList:   !",
-    "intersection_toofewcats": "DynamicPageList:   !",
-    "intersection_noresults": "DynamicPageList:  !",
-    "intersection_noincludecats": "DynamicPageList:     ,    !",
-    "dpl_log_1": ":  '$0' : '$1'! : <code>$0= <i> </i> ()$3</code>. (       .)",
-    "dpl_log_2": ":  '$0' : '$1'! : <code>$0= <i>  </i></code>. (   .)",
-    "dpl_log_3": ":   ! : $0. :   <code>DynamicPageListHooks::$maxCategoryCount</code>       <code>DynamicPageListHooks::$allowUnlimitedCategories=true</code>    . (    <code>LocalSettings.php</code>,   <code>DynamicPageList.php</code>.)",
-    "dpl_log_4": ":   ! : $0. :   <code>DynamicPageListHooks::$minCategoryCount</code>    . (    <code>LocalSettings.php</code>,   <code>DynamicPageList.php</code>.)",
-    "dpl_log_5": "ERROR: No selection criteria found! You must use at least one of the following parameters: category, namespace, titlematch, linksto, uses, createdby, modifiedby, lastmodifiedby, or their 'not' variants",
-    "dpl_log_6": ":         'addfirstcategorydate=true'  'ordermethod=categoryadd'!",
-    "dpl_log_7": ":      ,    'addfirstcategorydate=true'  'ordermethod=categoryadd'!",
-    "dpl_log_8": ":          !",
-    "dpl_log_9": "?????: ????????? ?????? ??'$0' ?? 'ordermethod=[...,]$1' ????!",
-    "dpl_log_10": "ERROR: the index for the dominant section must be between 1 and the number of arguments of includepage ($0 in this case)",
-    "dpl_log_11": ":          (,   '')   $0    ! :       : <code>$1</code>.",
-    "dpl_log_12": "ERROR: specifying \"openreferences\" is incompatible with some other option you specified. See the manual for details.",
-    "dpl_log_13": ":      '$1'. :  : <code>$2</code>.",
-    "dpl_log_14": ":  '$0' : '$1'!   : '$2'. : <code>$0= $3</code>.",
-    "dpl_log_15": ":  '$0' : '$1'!   : '$2' ( ). : <code>$0= <i> </i> ( ) | n</code>,  <code>n</code>   .",
-    "dpl_log_16": "?????: ??? ??????!",
-    "dpl_log_17": ": *  ('adduser', 'addeditdate' )  'includepage'    'mode=category'.          .",
-    "dpl_log_18": ": 'headingmode=$0'    'ordermethod'   .  : '$1'. :     'headingmode'  $1  'ordermethod'   .    . , 'ordermethod=category,<i>comp</i>' (<i>comp</i>   )  .",
-    "dpl_log_19": ": 'debug=$0w      DPL.            .",
-    "dpl_log_20": ":      '$0'.",
-    "dpl_log_21": ": <code>$0</code>",
-    "dpl_articlecount": "{{PLURAL:$1| $1 |  }}   ."
-}
\ No newline at end of file
diff --git a/i18n/hi.json b/i18n/hi.json
deleted file mode 100644
index b465e1a0..00000000
--- a/i18n/hi.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Kaustubh"
-        ]
-    },
-    "intersection-desc": "       ",
-    "intersection_toomanycats": "Error:   !",
-    "intersection_toofewcats": "Error:   !",
-    "intersection_noresults": "Error:  !",
-    "intersection_noincludecats": "Error:         !"
-}
\ No newline at end of file
diff --git a/i18n/hr.json b/i18n/hr.json
deleted file mode 100644
index 97242d77..00000000
--- a/i18n/hr.json
+++ /dev/null
@@ -1,13 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Dalibor Bosits",
-            "Dnik"
-        ]
-    },
-    "intersection-desc": "Omoguava popis najnovijih stranica ili datoteka iz kategorije, ili presjeka nekoliko kategorija",
-    "intersection_toomanycats": "Error: Previe kategorija!",
-    "intersection_toofewcats": "Error: Premalo kategorija!",
-    "intersection_noresults": "Error: Nema rezultata!",
-    "intersection_noincludecats": "Error: Morate ukljuiti bar jednu kategoriju, ili odabrati imenski prostor!"
-}
\ No newline at end of file
diff --git a/i18n/hsb.json b/i18n/hsb.json
deleted file mode 100644
index 877a893d..00000000
--- a/i18n/hsb.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Michawiki"
-        ]
-    },
-    "intersection-desc": "Wudae lisiny najaktualniich zapiskow w jednej kategoriji abo w skupinje kategorijow",
-    "intersection_toomanycats": "Error: Pewjele kategorijow!",
-    "intersection_toofewcats": "Error: Pemao kategorijow!",
-    "intersection_noresults": "Error: ane wusldki!",
-    "intersection_noincludecats": "Error: Dyrbi znajmjea kednu kategoriju zapije abo mjenowy rum poda!"
-}
\ No newline at end of file
diff --git a/i18n/hu.json b/i18n/hu.json
deleted file mode 100644
index 3c0491fc..00000000
--- a/i18n/hu.json
+++ /dev/null
@@ -1,14 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Dani",
-            "Gondnok",
-            "KossuthRad"
-        ]
-    },
-    "intersection-desc": "Megjelenti egy adott kategriban, vagy kategrik unijban lv legjabb szcikkek listjt",
-    "intersection_toomanycats": "Hiba: Tl sok kategria!",
-    "intersection_toofewcats": "Hiba: Tl kevs kategria!",
-    "intersection_noresults": "Hiba: Nincs eredmny!",
-    "intersection_noincludecats": "Hiba: Legalbb egy listzand kategrit meg kell adnod, vagy pedig egy nvteret!"
-}
\ No newline at end of file
diff --git a/i18n/ia.json b/i18n/ia.json
deleted file mode 100644
index 61016131..00000000
--- a/i18n/ia.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "McDutchie"
-        ]
-    },
-    "intersection-desc": "Face un lista a punctos del elementos le plus recente in un categoria, o un union de plure categorias",
-    "intersection_toomanycats": "Error: Troppo de categorias!",
-    "intersection_toofewcats": "Error: Non bastante categorias!",
-    "intersection_noresults": "Error: Nulle resultatos!",
-    "intersection_noincludecats": "Error: Tu debe includer al minus un categoria, o specificar un spatio de nomines!"
-}
\ No newline at end of file
diff --git a/i18n/id.json b/i18n/id.json
deleted file mode 100644
index de3b97da..00000000
--- a/i18n/id.json
+++ /dev/null
@@ -1,34 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "IvanLanin"
-        ]
-    },
-    "intersection-desc": "Menghasilkan suatu daftar item terbaru pada suatu kategori atau gabungan beberapa kategori",
-    "intersection_toomanycats": "DynamicPageList: Terlalu banyak kategori!",
-    "intersection_toofewcats": "DynamicPageList: Terlalu sedikit kategori!",
-    "intersection_noresults": "DynamicPageList: Tak ada hasil yang sesuai!",
-    "intersection_noincludecats": "DynamicPageList: Anda perlu mencantumkan paling tidak satu kategori, atau menyebutkan satu ruang nama!",
-    "dpl_log_1": "KESALAHAN: Parameter '$0' salah: '$1'! Bantuan: <code>$0= <i>string kosong</i> (Utama)$3</code>. (Ekivalen kata kunci juga diizinkan.)",
-    "dpl_log_2": "KESALAHAN: Parameter '$0' salah: '$1'! Bantuan:  <code>$0= <i>nama lengkap halaman</i></code>. (Kata kunci diizinkan.)",
-    "dpl_log_3": "KESALAHAN: Kategori terlalu banyak! Maksimum: $0. Bantuan: perbesar <code>DynamicPageListHooks::$maxCategoryCount</code> untuk memberikan lebih banyak kategori atau atur  <code>DynamicPageListHooks::$allowUnlimitedCategories=true</code> untuk menghapus batasan. (Atur variabel tersebut di <code>LocalSettings.php</code>, setelah mencantumkan <code>DynamicPageList.php</code>.)",
-    "dpl_log_4": "KESALAHAN: Kategori terlalu sedikit! Minimum: $0. Bantuan: kurangi <code>DynamicPageListHooks::$minCategoryCount</code> untuk mengurangi kategori. (Atur variabel tersebut di <code>LocalSettings.php</code>, setelah mencantumkan <code>DynamicPageList.php</code>.)",
-    "dpl_log_5": "ERROR: No selection criteria found! You must use at least one of the following parameters: category, namespace, titlematch, linksto, uses, createdby, modifiedby, lastmodifiedby, or their 'not' variants",
-    "dpl_log_6": "KESALAHAN: Anda harus memberikan paling tidak satu kategori jika menggunakan 'addfirstcategorydate=true' atau 'ordermethod=categoryadd'!",
-    "dpl_log_7": "KESALAHAN: Jika Anda memberikan lebih dari satu kategori, Anda tidak dapat menggunakan 'addfirstcategorydate=true' atau 'ordermethod=categoryadd'!",
-    "dpl_log_8": "KESALAHAN: Anda tidak dapat memberikan lebih dari satu jenis tanggal dalam satu waktu!",
-    "dpl_log_9": "KESALAHAN: Anda dapat menggunakan '$0' hanya dengan 'ordermethod=[...,]$1'!",
-    "dpl_log_10": "ERROR: the index for the dominant section must be between 1 and the number of arguments of includepage ($0 in this case)",
-    "dpl_log_11": "KESALAHAN: Tidak dapat melakukan operasi logika pada halaman yang tak terkategori (misalnya dengan parameter 'kategori') karena view $0 tidak ada di basis data! Bantuan: mintalah admin basis data untuk menjalankan kueri berikut: <code>$1</code>.",
-    "dpl_log_12": "ERROR: specifying \"openreferences\" is incompatible with some other option you specified. See the manual for details.",
-    "dpl_log_13": "KESALAHAN: Paramater yang tak dikenal '$1' diabaikan. Bantuan: parameter yang tersedia: <code>$2</code>.",
-    "dpl_log_14": "KESALAHAN: Parameter '$0' salah: '$1'! Menggunakan konfigurasi baku: '$2'. Bantuan: <code>$0= $3</code>.",
-    "dpl_log_15": "KESALAHAN: Parameter '$0' salah: '$1'! Menggunakan konfigurasi baku: '$2' (tanpa limitasi). Bantuan: <code>$0= <i>string kosong</i> (tanpa limitasi) | n</code>, dengan <code>n</code> suatu bilangan positif.",
-    "dpl_log_16": "KESALAHAN: Hasil tak ditemukan!",
-    "dpl_log_17": "KESALAHAN: Menambahkan * parameter ('adduser', 'addeditdate', dll.)' dan 'includepage' tidak berpengaruh pada 'mode=category'. Hanya ruang nama/judul halaman yang dapat ditampilkan dengan mode ini.",
-    "dpl_log_18": "KESALAHAN: 'headingmode=$0' tidak berpengaruh dengan 'ordermethod' pada suatu komponen tunggal. Menggunakan: '$1'. Bantuan: Anda dapat menggunakan nilai not-$1 'headingmode' dengan 'ordermethod' terhadap beberapa komponen. Komponen pertama digunakan sebagai judul. Misalnya 'ordermethod=category,<i>comp</i>' (<i>comp</i> adalah komponen lain) untuk judul kategori.",
-    "dpl_log_19": "KESALAHAN: 'debug=$0' tidak pada posisi pertama pada elemen DPL. Aturan debug tidak diterapkan sebelum semua variabel sebelumnya telah diparsing dan dicek.",
-    "dpl_log_20": "KESALAHAN: Suatu lingkaran transklusi tak hingga ditimbulkan oleh halaman '$0'.",
-    "dpl_log_21": "KUERI: <code>$0</code>",
-    "dpl_articlecount": "Terdapat {{PLURAL:$1|artikel|artikel}} dalam judul ini."
-}
\ No newline at end of file
diff --git a/i18n/io.json b/i18n/io.json
deleted file mode 100644
index 3e4352af..00000000
--- a/i18n/io.json
+++ /dev/null
@@ -1,11 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Malafaya"
-        ]
-    },
-    "intersection_toomanycats": "Eroro: Tro multa kategorii!",
-    "intersection_toofewcats": "Eroro: Tro poka kategorii!",
-    "intersection_noresults": "Eroro: Nula rezultaji!",
-    "intersection_noincludecats": "Eroro: Vu mustas inkluzar adminime un kategorio, o specigez nomaro!"
-}
\ No newline at end of file
diff --git a/i18n/it.json b/i18n/it.json
deleted file mode 100644
index 69214b11..00000000
--- a/i18n/it.json
+++ /dev/null
@@ -1,34 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "BrokenArrow",
-            "Darth Kule"
-        ]
-    },
-    "intersection-desc": "Visualizza un elenco puntato con gli elementi pi recenti inseriti in una categoria o nell'unione di pi categorie",
-    "intersection_toomanycats": "Errore: Numero di categorie eccessivo.",
-    "intersection_toofewcats": "Errore: Numero di categorie insufficiente.",
-    "intersection_noresults": "Errore: Nessun risultato.",
-    "intersection_noincludecats": "Errore:  necessario includere almeno una categoria oppure specificare un namespace.",
-    "dpl_log_1": "ERRORE nel parametro '$0': '$1'. Suggerimento:  <code>$0= <i>stringa vuota</i> (Principale)$3</code>.",
-    "dpl_log_2": "ERRORE nel parametro '$0': '$1'. Suggerimento:  <code>$0= <i>nome completo della pagina</i></code>.",
-    "dpl_log_3": "ERRORE: Categorie sovrabbondanti (massimo $0). Suggerimento: aumentare il valore di <code>DynamicPageListHooks::$maxCategoryCount</code> per indicare un numero maggiore di categorie, oppure impostare <code>DynamicPageListHooks::$allowUnlimitedCategories=true</code> per non avere alcun limite. (Impostare le variabili nel file <code>LocalSettings.php</code>, dopo l'inclusione di <code>DynamicPageList.php</code>.)",
-    "dpl_log_4": "ERRORE: Categorie insufficienti (minimo $0). Suggerimento: diminuire il valore di <code>DynamicPageListHooks::$minCategoryCount</code> per indicare un numero minore di categorie. (Impostare la variabile nel file <code>LocalSettings.php</code>, dopo l'inclusione di <code>DynamicPageList.php</code>.)",
-    "dpl_log_5": "ERROR: No selection criteria found! You must use at least one of the following parameters: category, namespace, titlematch, linksto, uses, createdby, modifiedby, lastmodifiedby, or their 'not' variants",
-    "dpl_log_6": "ERRORE: L'uso dei parametri 'addfirstcategorydate=true' e 'ordermethod=categoryadd' richiede l'inserimento di una o pi categorie.",
-    "dpl_log_7": "ERRORE: L'inserimento di pi categorie impedisce l'uso dei parametri 'addfirstcategorydate=true' e 'ordermethod=categoryadd'.",
-    "dpl_log_8": "ERRORE: Non  consentito l'uso contemporaneo di pi tipi di data.",
-    "dpl_log_9": "ERRORE: L'uso del parametro '$0'  consentito unicamente con 'ordermethod=[...,]$1'.",
-    "dpl_log_10": "ERROR: the index for the dominant section must be between 1 and the number of arguments of includepage ($0 in this case)",
-    "dpl_log_11": "ERRORE: Impossibile effettuare operazioni logiche sulle pagine prive di categoria (ad es. con il parametro 'category') in quanto il database non contiene la vista $0. Suggerimento: chiedere all'amministratore del database di eseguire la seguente query: <code>$1</code>.",
-    "dpl_log_12": "ERROR: specifying \"openreferences\" is incompatible with some other option you specified. See the manual for details.",
-    "dpl_log_13": "ATTENZIONE: Il parametro non riconosciuto '$1'  stato ignorato. Suggerimento: i parametri disponibili sono: <code>$2</code>.",
-    "dpl_log_14": "ATTENZIONE: Errore nel parametro '$0': '$1'.  stato usato il valore predefinito '$2'. Suggerimento: <code>$0= $3</code>.",
-    "dpl_log_15": "ATTENZIONE: errore nel parametro '$0': '$1'.  stato usato il valore predefinito '$2' (nessun limite). Suggerimento: <code>$0= <i>stringa vuota</i> (nessun limite) | n</code>, con <code>n</code> intero positivo.",
-    "dpl_log_16": "ATTENZIONE: Nessun risultato.",
-    "dpl_log_17": "ATTENZIONE: I parametri add* ('adduser', 'addeditdate', ecc.)' non hanno alcun effetto quando  specificato 'mode=category'. In tale modalit vengono visualizzati unicamente il namespace e il titolo della pagina.",
-    "dpl_log_18": "ATTENZIONE: Il parametro 'headingmode=$0' non ha alcun effetto quando  specificato 'ordermethod' su un solo componente. Verr utilizzato il valore '$1'. Suggerimento:  posibile utilizzare i valori diversi da $1 per il parametro 'headingmode' nel caso di 'ordermethod' su pi componenti. Il primo componente viene usato per generare i titoli di sezione. Ad es. 'ordermethod=category,<i>comp</i>' (dove <i>comp</i>  un altro componente) per avere titoli di sezione basati sulla categoria.",
-    "dpl_log_19": "ATTENZIONE: Il parametro 'debug=$0' non  il primo elemento della sezione DPL. Le nuove impostazioni di debug non verranno applicate prima di aver completato il parsing e la verifica di tutti i parametri che lo precedono.",
-    "dpl_log_21": "QUERY: <code>$0</code>",
-    "dpl_articlecount": "Questa sezione contiene {{PLURAL:$1|una voce|$1 voci}}."
-}
\ No newline at end of file
diff --git a/i18n/ja.json b/i18n/ja.json
deleted file mode 100644
index 7ff0d92b..00000000
--- a/i18n/ja.json
+++ /dev/null
@@ -1,13 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Fryed-peach",
-            "JtFuruhata"
-        ]
-    },
-    "intersection-desc": "",
-    "intersection_toomanycats": ": ",
-    "intersection_toofewcats": ": ",
-    "intersection_noresults": ": ",
-    "intersection_noincludecats": ": 1"
-}
\ No newline at end of file
diff --git a/i18n/jut.json b/i18n/jut.json
deleted file mode 100644
index fcfefc77..00000000
--- a/i18n/jut.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Huslke"
-        ]
-    },
-    "intersection-desc": "Outputs en bulleted liste der senestste itemer rsidende i en klynge, ller  unje der severl klynger",
-    "intersection_toomanycats": "Error: verfl klynger!",
-    "intersection_toofewcats": "Error: verwneg klynger!",
-    "intersection_noresults": "Error: Ekke rsultter!",
-    "intersection_noincludecats": "Error: Du ndst til inkludr til mendst en klynge, ller spsifir en navnerum!"
-}
\ No newline at end of file
diff --git a/i18n/jv.json b/i18n/jv.json
deleted file mode 100644
index d5550319..00000000
--- a/i18n/jv.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Meursault2004"
-        ]
-    },
-    "intersection-desc": "Ngasilak sawijining daftar item paling anyar ing sawijining kategori utawa gabungan sawetara kategori",
-    "intersection_toomanycats": "Error: Kakhan kategori!",
-    "intersection_toofewcats": "Error: Kesithikan kategori!",
-    "intersection_noresults": "Error: Ora ana pituwas (kasil)!",
-    "intersection_noincludecats": "Error: Panjenengan perlu minimal mnhi kategori sawiji, utawa spsifikasi bilik nama sawiji!"
-}
\ No newline at end of file
diff --git a/i18n/km.json b/i18n/km.json
deleted file mode 100644
index c4cfbd5b..00000000
--- a/i18n/km.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Chhorran",
-            "Thearith"
-        ]
-    },
-    "intersection_toomanycats": " !",
-    "intersection_toofewcats": " !",
-    "intersection_noresults": " !",
-    "intersection_noincludecats": "   !"
-}
\ No newline at end of file
diff --git a/i18n/ko.json b/i18n/ko.json
deleted file mode 100644
index 2744c068..00000000
--- a/i18n/ko.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Kwj2772",
-            "Yknok29"
-        ]
-    },
-    "intersection_toomanycats": ":   !",
-    "intersection_toofewcats": ":   !",
-    "intersection_noresults": ":  !",
-    "intersection_noincludecats": ":         !"
-}
\ No newline at end of file
diff --git a/i18n/ksh.json b/i18n/ksh.json
deleted file mode 100644
index 0d4bc455..00000000
--- a/i18n/ksh.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Purodha"
-        ]
-    },
-    "intersection-desc": "Zeij_en Li met de neuste Enndrsch en en Saachjrupp, udder de neuste Enndrsch, die en alle Jruppe uss_enem Knubbel fun Saachjrupp dren sin.",
-    "intersection_toomanycats": "<i lang=\"en\">DynamicPageList</i> ht ene Fler jefonge: Dat sinn_er zo vill Saachjroppe!",
-    "intersection_toofewcats": "<i lang=\"en\">DynamicPageList</i> ht ene Fler jefonge: Dat sin ze winnisch Saachjruppe!",
-    "intersection_noresults": "<i lang=\"en\">DynamicPageList</i> ht ene Fler jefonge: Do kohm nix bei erus!",
-    "intersection_noincludecats": "<i lang=\"en\">DynamicPageList</i> ht ene Fler jefonge: Mer bruch winnischdens ein Saachjrupp. Sns jivv e Appachtemang aan!"
-}
\ No newline at end of file
diff --git a/i18n/lb.json b/i18n/lb.json
deleted file mode 100644
index df887610..00000000
--- a/i18n/lb.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Robby"
-        ]
-    },
-    "intersection-desc": "Generiert eng Lscht mat de rezentesten Androungen an eng Kategorie, oder an eng Intersektioun vu mi Kategorien",
-    "intersection_toomanycats": "Dynamesch Site-Lscht: Zevill Kategorien!",
-    "intersection_toofewcats": "Dynamesch Site-Lscht: Ze wineg Kategorien!",
-    "intersection_noresults": "Dynamesch Site-Lscht: Kee Resultat!",
-    "intersection_noincludecats": "Dynamesch Site-Lscht: Dir musst mindestens eng Kategorie abannen, oder de Nummraum uginn!"
-}
\ No newline at end of file
diff --git a/i18n/li.json b/i18n/li.json
deleted file mode 100644
index ffb07ec0..00000000
--- a/i18n/li.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Matthias"
-        ]
-    },
-    "intersection-desc": "Geeft als uitvoer een ongenummerde lijst met de meest recent toegevoegde items in een categorie, of een combinatie van categorie",
-    "intersection_toomanycats": "Error: Te veel categorie!",
-    "intersection_toofewcats": "Error: Te weinig categorie!",
-    "intersection_noresults": "Error: Gein resultate!",
-    "intersection_noincludecats": "Error: U moet tenminste een categorie of een naamruimte opgeve!"
-}
\ No newline at end of file
diff --git a/i18n/lt.json b/i18n/lt.json
deleted file mode 100644
index 10bbfcf3..00000000
--- a/i18n/lt.json
+++ /dev/null
@@ -1,11 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Matasg"
-        ]
-    },
-    "intersection_toomanycats": "Error: Per daug kategorij!",
-    "intersection_toofewcats": "Error: Per maai kategorij!",
-    "intersection_noresults": "Error: Nra rezultat!",
-    "intersection_noincludecats": "Error: Jums reikia traukti bent vien kategorij, arba nurodyti vard srit!"
-}
\ No newline at end of file
diff --git a/i18n/lv.json b/i18n/lv.json
deleted file mode 100644
index 5c33cedc..00000000
--- a/i18n/lv.json
+++ /dev/null
@@ -1,9 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Xil"
-        ]
-    },
-    "intersection_toomanycats": "Kda: prk daudz kategoriju!",
-    "intersection_toofewcats": "Kda: prk maz kategoriju!"
-}
\ No newline at end of file
diff --git a/i18n/mg.json b/i18n/mg.json
deleted file mode 100644
index 89773ec0..00000000
--- a/i18n/mg.json
+++ /dev/null
@@ -1,8 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Jagwar"
-        ]
-    },
-    "intersection_toomanycats": "DynamicPageList : Be laotra ny sokajy"
-}
\ No newline at end of file
diff --git a/i18n/ml.json b/i18n/ml.json
deleted file mode 100644
index dbc45b1e..00000000
--- a/i18n/ml.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Shijualex"
-        ]
-    },
-    "intersection-desc": "      ,       .",
-    "intersection_toomanycats": "Error:  !",
-    "intersection_toofewcats": "Error:   !",
-    "intersection_noresults": "Error:  !",
-    "intersection_noincludecats": "Error:          !"
-}
\ No newline at end of file
diff --git a/i18n/mr.json b/i18n/mr.json
deleted file mode 100644
index f1956082..00000000
--- a/i18n/mr.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Kaustubh"
-        ]
-    },
-    "intersection-desc": "      .",
-    "intersection_toomanycats": "Error:   !",
-    "intersection_toofewcats": "Error:   !",
-    "intersection_noresults": "Error:  !",
-    "intersection_noincludecats": "Error:        !"
-}
\ No newline at end of file
diff --git a/i18n/ms.json b/i18n/ms.json
deleted file mode 100644
index 5de2fcc4..00000000
--- a/i18n/ms.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Aviator"
-        ]
-    },
-    "intersection-desc": "Mengoutput senarai item terkini dalam sesebuah kategori atau kesatuan beberapa buah kategori",
-    "intersection_toomanycats": "Error: Kategori terlalu banyak!",
-    "intersection_toofewcats": "Error: Kategori terlalu sedikit!",
-    "intersection_noresults": "Error: Tiada hasil!",
-    "intersection_noincludecats": "Error: Anda hendaklah memasukkan sekurang-kurangnya sebuah kategori atau menyatakan sebuah ruang nama!"
-}
\ No newline at end of file
diff --git a/i18n/nb.json b/i18n/nb.json
deleted file mode 100644
index 08d085a1..00000000
--- a/i18n/nb.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Jon Harald Sby"
-        ]
-    },
-    "intersection-desc": "Gir en punktliste over de nyeste elementene i en kategori, eller elementer som er felles i flere kategorier",
-    "intersection_toomanycats": "Dynamisk sideliste: For mange kategorier!",
-    "intersection_toofewcats": "Dynamisk sidelist: For f kategorier!",
-    "intersection_noresults": "Dynamisk sideliste: Ingen resultater!",
-    "intersection_noincludecats": "Dynamisk sideliste: Du m inkludere minst n kategori, eller oppgi et navnerom!"
-}
\ No newline at end of file
diff --git a/i18n/nds.json b/i18n/nds.json
deleted file mode 100644
index 384c1d3c..00000000
--- a/i18n/nds.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Slomox"
-        ]
-    },
-    "intersection-desc": "Wiest en List mit de aktuellsten Indrg in en Kategorie, oder de Snittmengd vun mehr Kategorien",
-    "intersection_toomanycats": "Fehler: Toveel Kategorien!",
-    "intersection_toofewcats": "Fehler: To wenig Kategorien!",
-    "intersection_noresults": "Fehler: Nix funnen!",
-    "intersection_noincludecats": "Fehler: Dor mutt opminnst een Kategorie angeven warrn! ODer geev en Naamruum an."
-}
\ No newline at end of file
diff --git a/i18n/nl.json b/i18n/nl.json
deleted file mode 100644
index 0c3a2882..00000000
--- a/i18n/nl.json
+++ /dev/null
@@ -1,30 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "SPQRobin",
-            "Siebrand"
-        ]
-    },
-    "intersection-desc": "Geeft als uitvoer een ongenummerde lijst met de meest recent toegevoegde items in een categorie, of een combinatie van categorien",
-    "intersection_toomanycats": "Fout: Te veel categorien!",
-    "intersection_toofewcats": "Fout: Te weinig categorien!",
-    "intersection_noresults": "Fout: Geen resultaten!",
-    "intersection_noincludecats": "Fout: U moet tenminste een categorie of een naamruimte opgeven!",
-    "dpl_log_1": "FOUT: Verkeerde parameter '$0': '$1'! Hulp:  <code>$0= <i>lege string</i> (Main)$3</code>.",
-    "dpl_log_2": "FOUT: Te veel categorin! Maximum: $0. Hulp: verhoog <code>DynamicPageListHooks::$maxCategoryCount</code> om meer categorien op te kunnen geven of stel geen limiet in met <code>DynamicPageListHooks::$allowUnlimitedCategories=true</code>. (Neem deze variabele op in <code>LocalSettings.php</code>, na het toevoegen van <code>DynamicPageList.php</code>.)",
-    "dpl_log_3": "FOUT: Te weinig categorien! Minimum: $0. Hulp: verlaag <code>DynamicPageListHooks::$minCategoryCount</code> om minder categorien aan te hoeven geven. (Stel de variabele bij voorkeur in via <code>LocalSettings.php</code>, na het toevoegen van <code>DynamicPageList.php</code>.)",
-    "dpl_log_4": "ERROR: No selection criteria found! You must use at least one of the following parameters: category, namespace, titlematch, linksto, uses, createdby, modifiedby, lastmodifiedby, or their 'not' variants",
-    "dpl_log_5": "FOUT: U dient tenminste n categorie op te nemen als u 'addfirstcategorydate=true' of 'ordermethod=categoryadd' wilt gebruiken!",
-    "dpl_log_6": "FOUT: Als u meer dan n categorie opneemt, kunt u 'addfirstcategorydate=true' of 'ordermethod=categoryadd' niet gebruiken!",
-    "dpl_log_8": "FOUT: U kunt niet meer dan n type of datum tegelijk gebruiken!",
-    "dpl_log_9": "FOUT: U kunt '$0' alleen met 'ordermethod=[...,]$1' gebruiken!",
-    "dpl_log_10": "ERROR: the index for the dominant section must be between 1 and the number of arguments of includepage ($0 in this case)",
-    "dpl_log_12": "ERROR: specifying \"openreferences\" is incompatible with some other option you specified. See the manual for details.",
-    "dpl_log_14": "WAARSCHUWING: Verkeerde parameter '$0': '$1'! Nu wordt de standaard gebruikt: '$2'. Hulp: <code>$0= $3</code>.",
-    "dpl_log_16": "WAARSCHUWING: Geen resultaten!",
-    "dpl_log_17": "WAARSCHUWING: Add* parameters ('adduser', 'addeditdate', etc.)' heeft geen effect bij 'mode=category'. Alleen de paginanaamruimte/titel is in deze modus te bekijken.",
-    "dpl_log_18": "WAARSCHUWING: 'headingmode=$0' heeft geen effect met 'ordermethod' op een enkele component. Nu wordt gebruikt: '$1'. Hulp: u kunt een niet-$1 'headingmode'-waarde gebruiken met 'ordermethod' op meerdere componenten. De eerste component wordt gebruikt als kop. Bijvoorbeeld 'ordermethod=category,<i>comp</i>' (<i>comp</i> is een ander component) voor categoriekoppen.",
-    "dpl_log_19": "WAARSCHUWING: 'debug=$0' is niet de eerste positie in het DPL-element. De nieuwe debuginstellingen zijn niet toegepast voor alle voorgaande parameters zijn verwerkt en gecontroleerd.",
-    "dpl_log_21": "QUERY: <code>$0</code>",
-    "dpl_articlecount": "Er {{PLURAL:$1|is n pagina|zijn $1 pagina's}} onder deze kop."
-}
\ No newline at end of file
diff --git a/i18n/nn.json b/i18n/nn.json
deleted file mode 100644
index 21a40b39..00000000
--- a/i18n/nn.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Harald Khan"
-        ]
-    },
-    "intersection-desc": "Gjev ei punktlista over dei nyaste elementa i ein kategori, eller element som er felles i fleire kategoriar",
-    "intersection_toomanycats": "Feil: For mange kategoriar!",
-    "intersection_toofewcats": "Feil: For f kategoriar!",
-    "intersection_noresults": "Feil: Ingen resultat!",
-    "intersection_noincludecats": "Feil: Du m inkludera minst in kategori, eller oppgje eit namnerom!"
-}
\ No newline at end of file
diff --git a/i18n/oc.json b/i18n/oc.json
deleted file mode 100644
index 0883b46e..00000000
--- a/i18n/oc.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Cedric31"
-        ]
-    },
-    "intersection-desc": "Aficha una lista, amb de piuses, dels articles mai recents dins una categoria, o a partir duna combinason de mantuna categoria.",
-    "intersection_toomanycats": "Error : Trp de categorias !",
-    "intersection_toofewcats": "Error : Pas pro de categorias !",
-    "intersection_noresults": "Error : Pas cap de resultat !",
-    "intersection_noincludecats": "Error : avtz besonh dinclure almens una categoria, o de precisar un nom despaci !"
-}
\ No newline at end of file
diff --git a/i18n/os.json b/i18n/os.json
deleted file mode 100644
index ea3c3223..00000000
--- a/i18n/os.json
+++ /dev/null
@@ -1,8 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Amikeco"
-        ]
-    },
-    "intersection_toomanycats": ":   !"
-}
\ No newline at end of file
diff --git a/i18n/pl.json b/i18n/pl.json
deleted file mode 100644
index 2fe97126..00000000
--- a/i18n/pl.json
+++ /dev/null
@@ -1,52 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Sp5uhe",
-            "Rail",
-            "Frisk"
-        ]
-    },
-    "intersection-desc": "Zwraca list wypunktowan najnowszych elementw w kategorii lub grupie kilku kategorii",
-    "intersection_toomanycats": "Bd  zbyt wiele kategorii!",
-    "intersection_toofewcats": "Bd  zbyt mao kategorii!",
-    "intersection_noresults": "Bd  brak wynikw!",
-    "intersection_noincludecats": "Bd  musisz zaczy co najmniej jedn kategori lub okreli przestrze nazw!",
-    "dpl-desc": "Wysoce elastyczny generator raportw w MediaWiki",
-    "dpl_log_1": "Bd  Bdny parametr $1: $2! Pomoc: <code>$1= <i>empty string</i> (Main)$3</code>.",
-    "dpl_log_2": "Bd  Bdny parametr $1: $2! Pomoc: <code>$1= <i>full pagename</i></code>.",
-    "dpl_log_3": "Bd  zbyt wiele kategorii! Maksymalnie $1. Pomoc: zwiksz warto <code>$wgDplSettings['maxCategoryCount']</code> aby okreli wicej kategorii lub ustaw <code>$wgDplSettings['allowUnlimitedCategories'] = true;</code> w celu wyczeniu limitu (ustaw zmienn w pliku konfiguracyjnym <code>LocalSettings.php</code> wiki).",
-    "dpl_log_4": "Bd  zbyt mao kategorii! Minimalnie $1. Pomoc: zmniejsz warto decrease <code>$wgDplSettings['minCategoryCount']</code> aby okreli mniej kategorii (ustaw zmienn w pliku konfiguracyjnym <code>LocalSettings.php</code> wiki).",
-    "dpl_log_5": "Bd  nie odnaleziono kryteriw wyboru! Musisz uy przynajmniej jednego z poniszych parametrw: category, namespace, titlematch, linksto, uses, createdby, modifiedby, lastmodifiedby lub ich wariantw not.",
-    "dpl_log_6": "Bd  musisz wybra przynajmniej jedn kategori aby uy addfirstcategorydate=true lub ordermethod=categoryadd.",
-    "dpl_log_7": "Bd  nie moesz uy addfirstcategorydate=true lub ordermethod=categoryadd jeli podasz wicej ni jedn kategori.",
-    "dpl_log_8": "Bd  mona doda tylko jeden typ daty na raz.",
-    "dpl_log_9": "Bd  parametr $1 musi by uywany wraz z ordermethod=[ $2 ].",
-    "dpl_log_10": "Bd  indeksem dominujcej sekcji musi by liczba pomidzy 1 a liczb argumentw parametru includepage ($0 w tym przypadku).",
-    "dpl_log_11": "Bd  nie mona wykonywa logicznych operacji na nieskategoryzowanych stronach (np. z parametrem category), poniewa podgld $0 nie istnieje w bazie danych! Pomoc: administrator bazy danych musi wykona to zapytanie: <code>$1</code>.",
-    "dpl_log_12": "Bd  podawanie parametru openreferences jest niekompatybilne z inn podan opcj. Usu prosz t inn opcj lub openreferences. Zobacz poradnik aby dowiedzie si wicej.",
-    "dpl_log_13": "Ostrzeenie  nieznany parametr $1 zosta zignorowany. Pomoc: dostpne parametry  <code>$2</code>.",
-    "dpl_log_14": "Ostrzeenie  pominito z opcj $2 dla parametru $1.",
-    "dpl_log_15": "Ostrzeenie  zy parametr $1: $2! Uyto domylnego  $3 (brak limitu). Pomoc: <code>$1= <i>empty string</i> (no limit) | n</code> z <code>n</code> jako liczb dodatni.",
-    "dpl_log_16": "Ostrzeenie  brak wynikw.",
-    "dpl_log_17": "Ostrzeenie  podane parametry (adduser, addeditdate, itd.) oraz includepage nie przynios zamierzonego efektu wraz z mode=category. W tym trybie wida tylko tytu oraz przestrze nazw strony.",
-    "dpl_log_18": "Ostrzeenie  headingmode=$1 nie przyniesie zamierzonego efektu z ordermethod na pojedynczym komponencie. Uyto $2. Pomoc: moesz uy wartoci innych ni $2 dla headingmode na wielu komponentach. Pierwszy komponent jest uywany w nagwkach. Np. ordermethod=category,<i>comp</i> (gdzie <i>comp</i> jest kolejnym komponentem) dla nagwkw kategorii.",
-    "dpl_log_19": "Ostrzeenie  debug=$1 nie jest w pierwszej pozycji w elemencie DPL. Nowe ustawienia debugowania nie s aplikowane przed sprawdzeniem i sparsowaniem wszystkich poprzednich parametrw.",
-    "dpl_log_20": "Ostrzeenie  strona $0 tworzy nieskoczon ptl transkluzji.",
-    "dpl_log_21": "Zapytanie  <code>$0</code>",
-    "dpl_log_22": "Ostrzeenie  nie podano opcji parametru dla $1 (brakujcy znak =).",
-    "dpl_articlecount": "W tym nagwku {{PLURAL:$1|znajduje si jeden artyku|znajduj si $1 artykuy|znajduje si $1 artykuw}}.",
-    "dpl_description": "Wysoce elastyczny generator raportw w MediaWiki. Zobacz http://semeb.com/dpldemo po poradnik i przykady",
-    "action-dpl_param_update_rules": "uywania parametru updaterules",
-    "action-dpl_param_delete_rules": "uywania parametru deleterules",
-    "dpl_query_error": "Rozszerzenie DPL (wersja $1) wyprodukowao wyraenie SQL ktre doprowadzio do bdu bazy danych.<br />Powodem moe by wewntrzny bd DPL lub problem spowodowany przez Ciebie; szczeglnie podczas uywania takich parametrw jak categoryregexp lub titleregexp. Uywanie wzorcw dopasowywania takich jak *? nie jest wspierane.<br />Komunikat bdu:<br /><code>$2</code>",
-    "dpl-tag-tracking-category": "Strony uywajce znacznika parsera DynamicPageList",
-    "dpl-intersection-tracking-category": "Strony uywajce znacznika parsera DynamicPageList Intersection",
-    "dpl-parserfunc-tracking-category": "Strony uywajce funkcji parsera DynamicPageList",
-    "dplnum-parserfunc-tracking-category": "Strony uywajce funkcji parsera DynamicPageList dplnum",
-    "dplvar-parserfunc-tracking-category": "Strony uywajce funkcji parsera DynamicPageList dplvar",
-    "dplreplace-parserfunc-tracking-category": "Strony uywajce funkcji parsera DynamicPageList dplreplace",
-    "dplchapter-parserfunc-tracking-category": "Strony uywajce funkcji parsera DynamicPageList dplchapter",
-    "dplmatrix-parserfunc-tracking-category": "Strony uywajce funkcji parsera DynamicPageList dplmatrix",
-    "right-dpl_param_delete_rules": "Masowe usuwanie stron uywajcych DPL",
-    "right-dpl_param_update_rules": "Masowe aktualizowanie stron uywajcych DPL"
-}
\ No newline at end of file
diff --git a/i18n/pt-br.json b/i18n/pt-br.json
deleted file mode 100644
index 35d7cc76..00000000
--- a/i18n/pt-br.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Eduardo.mps"
-        ]
-    },
-    "intersection-desc": "Exibe uma lista pontuada dos itens mais recentes presentes numa categoria, ou uma interseco de vrias categorias",
-    "intersection_toomanycats": "Erro: Categorias demais!",
-    "intersection_toofewcats": "Erro: Poucas categorias!",
-    "intersection_noresults": "Erro: Sem resultados!",
-    "intersection_noincludecats": "Erro:  necessrio incluir no mnimo uma categoria ou especificar um espao nominal!"
-}
\ No newline at end of file
diff --git a/i18n/pt.json b/i18n/pt.json
deleted file mode 100644
index 448157d6..00000000
--- a/i18n/pt.json
+++ /dev/null
@@ -1,13 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "555",
-            "Malafaya"
-        ]
-    },
-    "intersection-desc": "constri uma lista pontuada dos itens mais recentes presentes numa categoria, ou uma unio de vrias categorias",
-    "intersection_toomanycats": "Error: Categorias em excesso!",
-    "intersection_toofewcats": "Error: Poucas categorias!",
-    "intersection_noresults": "Error: Sem resultados!",
-    "intersection_noincludecats": "Error:  necessrio incluir no mnimo uma categoria ou especificar um espao nominal!"
-}
\ No newline at end of file
diff --git a/i18n/qqq.json b/i18n/qqq.json
deleted file mode 100644
index 1072c302..00000000
--- a/i18n/qqq.json
+++ /dev/null
@@ -1,8 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Purodha"
-        ]
-    },
-    "intersection-desc": "{{desc}}"
-}
\ No newline at end of file
diff --git a/i18n/ro.json b/i18n/ro.json
deleted file mode 100644
index 456097f2..00000000
--- a/i18n/ro.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Mihai"
-        ]
-    },
-    "intersection-desc": "ntoarce o lista celor mai receni itemi care fac parte dintr-o categorie, sau intersecia a mai multor categorii",
-    "intersection_toomanycats": "Eroare: Prea multe categorii!",
-    "intersection_toofewcats": "Eroare: Prea puine categorii!",
-    "intersection_noresults": "Eroare: Niciun rezultat!",
-    "intersection_noincludecats": "Eroare: Trebuie s incluzi cel puin o categorie, sau s specifici un spaiu de nume!"
-}
\ No newline at end of file
diff --git a/i18n/roa-tara.json b/i18n/roa-tara.json
deleted file mode 100644
index 0705f462..00000000
--- a/i18n/roa-tara.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Joetaras"
-        ]
-    },
-    "intersection-desc": "Fa ass 'na liste cu le palle de le urteme urteme artichele ca stonne jndr' 'na categorije, o 'n'interseziona de cchi categorije",
-    "intersection_toomanycats": "Errore: Troppe categorije!",
-    "intersection_toofewcats": "Errore: Troppe picche categorije!",
-    "intersection_noresults": "Errore: Nisciune resultete!",
-    "intersection_noincludecats": "Errore: Tu  abbesogne de 'ngludere ninde ninde 'na categorije, o specific 'nu namespace!"
-}
\ No newline at end of file
diff --git a/i18n/ru.json b/i18n/ru.json
deleted file mode 100644
index 87d7b436..00000000
--- a/i18n/ru.json
+++ /dev/null
@@ -1,31 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            " "
-        ]
-    },
-    "intersection-desc": "           ",
-    "intersection_toomanycats": "Error:   !",
-    "intersection_toofewcats": "Error:   !",
-    "intersection_noresults": "Error:  !",
-    "intersection_noincludecats": "Error:           !",
-    "dpl_log_1": ":  $0-: $1! :  <code>$0= <i> </i> ()$3</code>.",
-    "dpl_log_3": ":   ! : $0. :  <code>DynamicPageListHooks::$maxCategoryCount</code>       <code>DynamicPageListHooks::$allowUnlimitedCategories=true</code>   . (   <code>LocalSettings.php</code>,   <code>DynamicPageList.php</code>.)",
-    "dpl_log_4": ":   ! : $0. :  <code>DynamicPageListHooks::$minCategoryCount</code>    . (   <code>LocalSettings.php</code>,   <code>DynamicPageList.php</code>.)",
-    "dpl_log_5": "ERROR: No selection criteria found! You must use at least one of the following parameters: category, namespace, titlematch, linksto, uses, createdby, modifiedby, lastmodifiedby, or their 'not' variants",
-    "dpl_log_6": ":       ,     addfirstcategorydate=true  ordermethod=categoryadd!",
-    "dpl_log_7": ":      ,      addfirstcategorydate=true  ordermethod=categoryadd!",
-    "dpl_log_8": ":          !",
-    "dpl_log_9": ":    $0   ordermethod=[...,]$1!",
-    "dpl_log_10": "ERROR: the index for the dominant section must be between 1 and the number of arguments of includepage ($0 in this case)",
-    "dpl_log_12": "ERROR: specifying \"openreferences\" is incompatible with some other option you specified. See the manual for details.",
-    "dpl_log_13": ":   $1 . :  : <code>$2</code>.",
-    "dpl_log_14": ":   $0: $1!    : $2. : <code>$0= $3</code>.",
-    "dpl_log_15": ":   $0: $1!    : $2 ( ). : <code>$0= <i> </i> ( ) | n</code>,  <code>n</code>    .",
-    "dpl_log_16": ":  !",
-    "dpl_log_17": ": *  (adduser, addeditdate,  .)    mode=category.          .",
-    "dpl_log_18": ": headingmode=$0    ordermethod   . : $1. :   e -$1 headingmode   ordermethod   .     . , ordermethod=category,<i>comp</i> (<i>comp</i>   )   .",
-    "dpl_log_19": ": debug=$0       DPL-.               .",
-    "dpl_log_21": ": <code>$0</code>",
-    "dpl_articlecount": "   $1 {{PLURAL:$1|||}}."
-}
\ No newline at end of file
diff --git a/i18n/sah.json b/i18n/sah.json
deleted file mode 100644
index b3502530..00000000
--- a/i18n/sah.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "HalanTul"
-        ]
-    },
-    "intersection-desc": "       ()   ",
-    "intersection_toomanycats": "Error:   !",
-    "intersection_toofewcats": "Error:   ",
-    "intersection_noresults": "Error:  !",
-    "intersection_noincludecats": "Error:      ( ) !"
-}
\ No newline at end of file
diff --git a/i18n/sk.json b/i18n/sk.json
deleted file mode 100644
index 5ec03387..00000000
--- a/i18n/sk.json
+++ /dev/null
@@ -1,33 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Helix84"
-        ]
-    },
-    "intersection-desc": "Vype zoznam najnovch poloiek v kategrii alebo zjednoten niekokch kategri",
-    "intersection_toomanycats": "Error: Prli vea kategri!",
-    "intersection_toofewcats": "Error: Prli mlo kategri!",
-    "intersection_noresults": "Error: iadne vsledky!",
-    "intersection_noincludecats": "Error: Muste uvies aspo jednu kategriu alebo menn priestor!",
-    "dpl_log_1": "CHYBA: nesprvny parameter '$0': '$1'! Pomocnk <code>$0= <i>przdny retazec</i> (Hlavn)$3<code>.",
-    "dpl_log_2": "CHYBA: Zl parameter '$0': '$1'! Pomocnk <code>$0= <i>pln nzov strnky</i></code>.",
-    "dpl_log_3": "CHYBA: Prli vela kategri! Maximum: $0. Pomocnk: zvcite <code>DynamicPageListHooks::$maxCategoryCount</code>, aby ste mohli pecifikovat viac kategri alebo nastavte <code>DynamicPageListHooks::$allowUnlimitedCategories=true</code> pre vypnutie limitu. (Premenn nastatavte v <code>LocalSettings.php</code>, potom ako bol includovan <code>DynamicPageList.php</code>.)",
-    "dpl_log_4": "CHYBA: Prli mlo kategri! Minimum: $0. Pomocnk: znte <code>DynamicPageListHooks::$minCategoryCount</code>, aby ste mohli pecifikovat menej kategri. (Premenn nastavte najlepie v <code>LocalSettings.php</code> potom, ako v nom bol includovan <code>DynamicPageList.php</code>.)",
-    "dpl_log_5": "ERROR: No selection criteria found! You must use at least one of the following parameters: category, namespace, titlematch, linksto, uses, createdby, modifiedby, lastmodifiedby, or their 'not' variants",
-    "dpl_log_6": "CHYBA: Muste uviest aspon jednu kategriu ak chcete pouit 'addfirstcategorydate=true' alebo 'ordermethod=categoryadd'!",
-    "dpl_log_7": "CHYBA: Ak zahrniete viac ako jednu kategriu, nemete pouit 'addfirstcategorydate=true' alebo 'ordermethod=categoryadd'!",
-    "dpl_log_8": "CHYBA: Nemete naraz pridat viac ako jeden typ dtumu!",
-    "dpl_log_9": "CHYBA: '$0' mete pouit iba s 'ordermethod=[...,]$1'!",
-    "dpl_log_10": "ERROR: the index for the dominant section must be between 1 and the number of arguments of includepage ($0 in this case)",
-    "dpl_log_11": "CHYBA: Nie je momon vykonvat logick opercie na nekategorizovanch kategrich (napr. s parametrom 'Kategria') lebo neexistuje na databzu pohlad $0! Pomocnk: nech admin databzy vykon tento dotaz: <code>$1</code>.",
-    "dpl_log_12": "ERROR: specifying \"openreferences\" is incompatible with some other option you specified. See the manual for details.",
-    "dpl_log_13": "VAROVANIE: Neznmy parameter '$1' ignorovan. Pomocnk: dostupn parametre: <code>$2</code>.",
-    "dpl_log_14": "VAROVANIE: Nesprvny '$0' parameter: '$1'! Pouvam tandardn '$2'. Pomocnk: <code>$0= $3</code>.",
-    "dpl_log_15": "VAROVANIE: Nesprvny parameter  '$0': '$1'! Pouvam tandardn: '$2' (bez obmedzenia). Pomocnk: <code>$0= <i>przdny retazec</i> (bez obmedzenia) | n</code>, s kladnm celm cslom <code>n</code>.",
-    "dpl_log_16": "VAROVANIE: No results!",
-    "dpl_log_17": "VAROVANIE: Parametre Add* ('adduser', 'addeditdate', atd' nepracuj s mode=category'. V tomto reime je mon prehliadat iba menn priestor/titulok strnky.",
-    "dpl_log_18": "VAROVANIE: 'headingmode=$0' nepracuje s 'ordermethod' na jednom komponente. Pouitie: '$1'. Pomocnk: mete pouit not-$1 hodnoty 'headingmode' s 'ordermethod' na viacer komponenty. Prv komponent sa pouva na nadpisy. Napr. 'ordermethod=category,<i>comp</i>' (<i>comp</i> je in komponent) pre nadpisy kategri.",
-    "dpl_log_19": "VAROVANIE: 'debug=$0' nie je na prvej pozcii v prvku DPL. Nov ladiacie nastavenia nebud pout skr ne bud parsovan a skontrolovan vetky predchdzajce.",
-    "dpl_log_21": "DOTAZ: <code>$0</code>",
-    "dpl_articlecount": "V tomto nadpise {{PLURAL:$1|je jeden clnok|s $1 clnky|je $1 clnkov}}."
-}
\ No newline at end of file
diff --git a/i18n/sr-ec.json b/i18n/sr-ec.json
deleted file mode 100644
index 1f22fb46..00000000
--- a/i18n/sr-ec.json
+++ /dev/null
@@ -1,34 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Millosh"
-        ]
-    },
-    "intersection-desc": "          .",
-    "intersection_toomanycats": ":  !",
-    "intersection_toofewcats": ": !",
-    "intersection_noresults": ":  !",
-    "intersection_noincludecats": ":          !",
-    "dpl_log_1": ":  '$0' : '$1'! :  <code>$0= <i> </i> ()$3</code>. (      .)",
-    "dpl_log_2": ":  '$0' : '$1'! :  <code>$0= <i>  </i></code>. (   .)",
-    "dpl_log_3": ":  !  : $0. :  <code>DynamicPageListHooks::$maxCategoryCount</code>        <code>DynamicPageListHooks::$allowUnlimitedCategories=true</code>   . (   <code>LocalSettings.php</code>,   <code>DynamicPageList.php</code>.)",
-    "dpl_log_4": ":  !  : $0. :  <code>DynamicPageListHooks::$minCategoryCount</code>     . (   <code>LocalSettings.php</code>,   <code>DynamicPageList.php</code>.)",
-    "dpl_log_5": "ERROR: No selection criteria found! You must use at least one of the following parameters: category, namespace, titlematch, linksto, uses, createdby, modifiedby, lastmodifiedby, or their 'not' variants",
-    "dpl_log_6": ":          'addfirstcategorydate=true'  'ordermethod=categoryadd'!",
-    "dpl_log_7": ":      ,    'addfirstcategorydate=true'  'ordermethod=categoryadd'!",
-    "dpl_log_8": ":        !",
-    "dpl_log_9": ":   '$0'  'ordermethod=[...,]$1' !",
-    "dpl_log_10": ":       (.  'category' )   $0      ! :      : <code>$1</code>.",
-    "dpl_log_11": "ERROR: Cannot perform logical operations on the Uncategorized pages (f.e. with the 'category' parameter) because the $0 view does not exist on the database! Help: have the database administrator execute this query: <code>$1</code>.",
-    "dpl_log_12": "ERROR: specifying \"openreferences\" is incompatible with some other option you specified. See the manual for details.",
-    "dpl_log_13": ":   '$1'  . :   : <code>$2</code>.",
-    "dpl_log_14": ":  '$0' : '$1'!   : '$2'. : <code>$0= $3</code>.",
-    "dpl_log_15": ":  '$0' : '$1'!   : '$2' ( ). : <code>$0= <i> </i> ( ) | n</code>,  <code>n</code>   .",
-    "dpl_log_16": ":  !",
-    "dpl_log_17": ": *  ('adduser', 'addeditdate', .)'  'includepage'    'mode=category'.   /        .",
-    "dpl_log_18": ": 'headingmode=$0'    'ordermethod'   .  : '$1'. :   -$1 'headingmode'  'ordermethod'   .      . . 'ordermethod=category,<i></i>' (<i></i>   )   .",
-    "dpl_log_29": ": 'debug=$0'      DPL .           ",
-    "dpl_log_20": ":    '$0'.",
-    "dpl_log_21": ": <code>$0</code>",
-    "dpl_articlecount": "      {{PLURAL:$1| |$1 |$1 }}."
-}
\ No newline at end of file
diff --git a/i18n/sr-el.json b/i18n/sr-el.json
deleted file mode 100644
index bc98e3d8..00000000
--- a/i18n/sr-el.json
+++ /dev/null
@@ -1,29 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Millosh"
-        ]
-    },
-    "dpl_log_1": "GREKA: Pogrean '$0' parametar: '$1'! Pomo:  <code>$0= <i>pogrean string</i> (Glavno)$3</code>. (Ekvivalenti sa maginim reima su takoe dozvoljeni.)",
-    "dpl_log_2": "GREKA: Pogrean '$0' parametar: '$1'! Pomo:  <code>$0= <i>puno ime stranice</i></code>. (Magine rei su dozvoljene.)",
-    "dpl_log_3": "GREKA: Previe kategorija! Maksimum je: $0. Pomo: poveajte <code>DynamicPageListHooks::$maxCategoryCount</code> kako biste postavili vie kategorija ili promenite <code>DynamicPageListHooks::$allowUnlimitedCategories=true</code> za bez granica. (Podesite varijablu u <code>LocalSettings.php</code>, nakon ukljuivanja <code>DynamicPageList.php</code>.)",
-    "dpl_log_4": "GREKA: Premalo kategorija! Minimum je: $0. Pomo: poveajte <code>DynamicPageListHooks::$minCategoryCount</code> kako biste postavili manje kategorija. (Podesite varijablu u <code>LocalSettings.php</code>, nakon ukljuivanja <code>DynamicPageList.php</code>.)",
-    "dpl_log_5": "ERROR: No selection criteria found! You must use at least one of the following parameters: category, namespace, titlematch, linksto, uses, createdby, modifiedby, lastmodifiedby, or their 'not' variants",
-    "dpl_log_6": "GREKA: Morate ukljuiti bar jednu kategoriju ukoliko elite da koristite 'addfirstcategorydate=true' ili 'ordermethod=categoryadd'!",
-    "dpl_log_7": "GREKA: Ukoliko ukljuujete vie od jedne kategorije, ne moete koristiti 'addfirstcategorydate=true' ili 'ordermethod=categoryadd'!",
-    "dpl_log_8": "GREKA: Ne moete dodati vie od jednog tipa datuma!",
-    "dpl_log_9": "GREKA: Moete koristiti '$0' sa 'ordermethod=[...,]$1' iskljuivo!",
-    "dpl_log_10": "ERROR: the index for the dominant section must be between 1 and the number of arguments of includepage ($0 in this case)",
-    "dpl_log_11": "GREKA: Nemogue izvriti operaciju na nekategorizovanim stranicama (npr. sa 'category' parametrom) zato to $0 pregled ne postoji u bazi podataka! Pomo: neka administrator baze izvri ovaj upit: <code>$1</code>.",
-    "dpl_log_12": "ERROR: specifying \"openreferences\" is incompatible with some other option you specified. See the manual for details.",
-    "dpl_log_13": "PANJA: Nepoznat parametar '$1' je ignorisan. Pomo: dostupni parametri su: <code>$2</code>.",
-    "dpl_log_14": "PANJA: Pogrean '$0' parametar: '$1'! Koristi se osnovni: '$2'. Pomo: <code>$0= $3</code>.",
-    "dpl_log_15": "PANJA: Pogrean '$0' parametar: '$1'! Koristi se osnovni: '$2' (bez granice). Pomo: <code>$0= <i>prazan string</i> (bez granice) | n</code>, s <code>n</code> je pozitivan integer.",
-    "dpl_log_16": "PANJA: Nema rezultata!",
-    "dpl_log_17": "PANJA: Dodavanje* parametara ('adduser', 'addeditdate', itd.)' i 'includepage' nema efekta sa 'mode=category'. Iskljuivo ime stranice/imenski prostor mogu da se vide u ovom modu.",
-    "dpl_log_18": "PANJA: 'headingmode=$0' nema efekta sa 'ordermethod' na jednoj komponenti. Koristi se: '$1'. Pomo: ne morate koristiti-$1 'headingmode' podatke 'ordermethod' na vie komponenti. Prva komponenta se koristi za naslov. Npr. 'ordermethod=category,<i>komponenta</i>' (<i>komponenta</i> je druga komponenta) za naslove kategorija.",
-    "dpl_log_19": "PANJA: 'debug=$0' nije na prvom mestu u DPL elementu. Nova debag podeavanja nisu primenjena pre svih parametara koji su provereni",
-    "dpl_log_20": "PANJA: Beskonana petljasa stranice '$0'.",
-    "dpl_log_21": "UPIT: <code>$0</code>",
-    "dpl_articlecount": "U ovom naslovu se trenutno nalazi {{PLURAL:$1|jedan lanak|$1 lanka|$1 lanaka}}"
-}
\ No newline at end of file
diff --git a/i18n/sr.json b/i18n/sr.json
deleted file mode 100644
index 1f22fb46..00000000
--- a/i18n/sr.json
+++ /dev/null
@@ -1,34 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Millosh"
-        ]
-    },
-    "intersection-desc": "          .",
-    "intersection_toomanycats": ":  !",
-    "intersection_toofewcats": ": !",
-    "intersection_noresults": ":  !",
-    "intersection_noincludecats": ":          !",
-    "dpl_log_1": ":  '$0' : '$1'! :  <code>$0= <i> </i> ()$3</code>. (      .)",
-    "dpl_log_2": ":  '$0' : '$1'! :  <code>$0= <i>  </i></code>. (   .)",
-    "dpl_log_3": ":  !  : $0. :  <code>DynamicPageListHooks::$maxCategoryCount</code>        <code>DynamicPageListHooks::$allowUnlimitedCategories=true</code>   . (   <code>LocalSettings.php</code>,   <code>DynamicPageList.php</code>.)",
-    "dpl_log_4": ":  !  : $0. :  <code>DynamicPageListHooks::$minCategoryCount</code>     . (   <code>LocalSettings.php</code>,   <code>DynamicPageList.php</code>.)",
-    "dpl_log_5": "ERROR: No selection criteria found! You must use at least one of the following parameters: category, namespace, titlematch, linksto, uses, createdby, modifiedby, lastmodifiedby, or their 'not' variants",
-    "dpl_log_6": ":          'addfirstcategorydate=true'  'ordermethod=categoryadd'!",
-    "dpl_log_7": ":      ,    'addfirstcategorydate=true'  'ordermethod=categoryadd'!",
-    "dpl_log_8": ":        !",
-    "dpl_log_9": ":   '$0'  'ordermethod=[...,]$1' !",
-    "dpl_log_10": ":       (.  'category' )   $0      ! :      : <code>$1</code>.",
-    "dpl_log_11": "ERROR: Cannot perform logical operations on the Uncategorized pages (f.e. with the 'category' parameter) because the $0 view does not exist on the database! Help: have the database administrator execute this query: <code>$1</code>.",
-    "dpl_log_12": "ERROR: specifying \"openreferences\" is incompatible with some other option you specified. See the manual for details.",
-    "dpl_log_13": ":   '$1'  . :   : <code>$2</code>.",
-    "dpl_log_14": ":  '$0' : '$1'!   : '$2'. : <code>$0= $3</code>.",
-    "dpl_log_15": ":  '$0' : '$1'!   : '$2' ( ). : <code>$0= <i> </i> ( ) | n</code>,  <code>n</code>   .",
-    "dpl_log_16": ":  !",
-    "dpl_log_17": ": *  ('adduser', 'addeditdate', .)'  'includepage'    'mode=category'.   /        .",
-    "dpl_log_18": ": 'headingmode=$0'    'ordermethod'   .  : '$1'. :   -$1 'headingmode'  'ordermethod'   .      . . 'ordermethod=category,<i></i>' (<i></i>   )   .",
-    "dpl_log_29": ": 'debug=$0'      DPL .           ",
-    "dpl_log_20": ":    '$0'.",
-    "dpl_log_21": ": <code>$0</code>",
-    "dpl_articlecount": "      {{PLURAL:$1| |$1 |$1 }}."
-}
\ No newline at end of file
diff --git a/i18n/stq.json b/i18n/stq.json
deleted file mode 100644
index 1c1e6eae..00000000
--- a/i18n/stq.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Pyt"
-        ]
-    },
-    "intersection-desc": "Uutgoawe fon ne Lieste fon do aktulste Iendraage in ne Kategorie, of n Truchsnit fon moorere Kategorien.",
-    "intersection_toomanycats": "Error: Toufuul Kategorien!",
-    "intersection_toofewcats": "Error: Toumin Kategorien!",
-    "intersection_noresults": "Error: Neen Resultoat!",
-    "intersection_noincludecats": "Error: Der mout mindestens een Kategorie ienbuunen weese of reek n Noomensruum oun!"
-}
\ No newline at end of file
diff --git a/i18n/sv.json b/i18n/sv.json
deleted file mode 100644
index 98e320b4..00000000
--- a/i18n/sv.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Lejonel"
-        ]
-    },
-    "intersection-desc": "Skapar punktlistor ver de nyaste sidorna i en eller flera kategorier",
-    "intersection_toomanycats": "Fel: Fr mnga kategorier!",
-    "intersection_toofewcats": "Fel: Fr f kategorier!",
-    "intersection_noresults": "Fel: Inga resultat!",
-    "intersection_noincludecats": "Fel: Du mste inkludera minst en kategori eller ange en namnrymd!"
-}
\ No newline at end of file
diff --git a/i18n/te.json b/i18n/te.json
deleted file mode 100644
index 6fff4b9b..00000000
--- a/i18n/te.json
+++ /dev/null
@@ -1,11 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Veeven"
-        ]
-    },
-    "intersection_toomanycats": "Error:   !",
-    "intersection_toofewcats": "Error:   !",
-    "intersection_noresults": "Error:  !",
-    "intersection_noincludecats": "Error:     ,   &zwnj; !"
-}
\ No newline at end of file
diff --git a/i18n/tg-cyrl.json b/i18n/tg-cyrl.json
deleted file mode 100644
index 1a4c59e1..00000000
--- a/i18n/tg-cyrl.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Ibrahim"
-        ]
-    },
-    "intersection-desc": "       ,          ",
-    "intersection_toomanycats": "Error:    !",
-    "intersection_toofewcats": "Error:    !",
-    "intersection_noresults": "Error:   !",
-    "intersection_noincludecats": "Error:        ,      !"
-}
\ No newline at end of file
diff --git a/i18n/tl.json b/i18n/tl.json
deleted file mode 100644
index 735806e7..00000000
--- a/i18n/tl.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "AnakngAraw"
-        ]
-    },
-    "intersection-desc": "Naglalabas ng isang tinuldukang talaan ng pinakakamakailang mga bagay-bagay na naninirahan sa loob ng isang kaurian, o isang pinagsangahang daanan ng ilang mga kaurian",
-    "intersection_toomanycats": "Kamalian: Napakaraming mga kaurian!",
-    "intersection_toofewcats": "Kamalian: Napakakaunti ng mga kaurian!",
-    "intersection_noresults": "Kaurian: Walang mga kinalabasan/resulta!",
-    "intersection_noincludecats": "Kamalian: Kinakailangan mong magsama ng kahit na isang kaurian, o tumukoy ng isang espasyo ng pangalan!"
-}
\ No newline at end of file
diff --git a/i18n/tr.json b/i18n/tr.json
deleted file mode 100644
index f92fc081..00000000
--- a/i18n/tr.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Joseph"
-        ]
-    },
-    "intersection-desc": "Bir kategoride, yada birok kategorinin kesiiminde bulunan en son elerin, madde iaretli listesini retir",
-    "intersection_toomanycats": "Hata: ok fazla kategori!",
-    "intersection_toofewcats": "Hata: ok az kategori!",
-    "intersection_noresults": "Hata: Sonu yok!",
-    "intersection_noincludecats": "Hata: En az bir kategori eklemeli, ya da bir ad alan belirtmelisiniz!"
-}
\ No newline at end of file
diff --git a/i18n/uk.json b/i18n/uk.json
deleted file mode 100644
index d704fff0..00000000
--- a/i18n/uk.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Ahonc"
-        ]
-    },
-    "intersection-desc": "         '  ",
-    "intersection_toomanycats": "Error:   !",
-    "intersection_toofewcats": "Error:   !",
-    "intersection_noresults": "Error:  !",
-    "intersection_noincludecats": "Error:           !"
-}
\ No newline at end of file
diff --git a/i18n/vec.json b/i18n/vec.json
deleted file mode 100644
index 7eff1d24..00000000
--- a/i18n/vec.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Candalua"
-        ]
-    },
-    "intersection-desc": "Mostra un elenco puntato coi elementi piass reenti inseri in te na categoria o ne l'union de pi categorie",
-    "intersection_toomanycats": "Error: Ghe xe massa categorie!",
-    "intersection_toofewcats": "Error: Ghe xe massa pche categorie!",
-    "intersection_noresults": "Error: Nissun risultato!",
-    "intersection_noincludecats": "Error: Te gh da incldar almanco na categoria opure specificar un namespace."
-}
\ No newline at end of file
diff --git a/i18n/vep.json b/i18n/vep.json
deleted file mode 100644
index a578f904..00000000
--- a/i18n/vep.json
+++ /dev/null
@@ -1,10 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            " "
-        ]
-    },
-    "intersection_toomanycats": "Error: jahk kategorijoid!",
-    "intersection_toofewcats": "Error: Vhhk kategorijoid!",
-    "intersection_noresults": "Error: Ei ole rezul'tatoid!"
-}
\ No newline at end of file
diff --git a/i18n/vi.json b/i18n/vi.json
deleted file mode 100644
index de9f25eb..00000000
--- a/i18n/vi.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Minh Nguyen"
-        ]
-    },
-    "intersection-desc": "Cho ra danh sch nhng khon gn y nht c xp vo mt th loi hay hp ca hn mt th loi",
-    "intersection_toomanycats": "Error: Nhiu th loi qu!",
-    "intersection_toofewcats": "Error: t th loi qu!",
-    "intersection_noresults": "Error: Khng tm thy trang no!",
-    "intersection_noincludecats": "Error: Cn phi bao gm t nht mt th loi hay nh r mt khng gian tn!"
-}
\ No newline at end of file
diff --git a/i18n/vo.json b/i18n/vo.json
deleted file mode 100644
index e4bc55ff..00000000
--- a/i18n/vo.json
+++ /dev/null
@@ -1,11 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Smeira"
-        ]
-    },
-    "intersection_toomanycats": "Error: Klads tu mdiks!",
-    "intersection_toofewcats": "Error: Klads tu nemdiks!",
-    "intersection_noresults": "Error: Seks nonik!",
-    "intersection_noincludecats": "Error: Nedol vln kladi pu bali, u nemaspadi!"
-}
\ No newline at end of file
diff --git a/i18n/yue.json b/i18n/yue.json
deleted file mode 100644
index dc65190c..00000000
--- a/i18n/yue.json
+++ /dev/null
@@ -1,32 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Shinjiman"
-        ]
-    },
-    "intersection-desc": "",
-    "intersection_toomanycats": "DynamicPageList: !",
-    "intersection_toofewcats": "DynamicPageList: !",
-    "intersection_noresults": "DynamicPageList: !",
-    "intersection_noincludecats": "DynamicPageList: !",
-    "dpl-desc": "MediaWiki",
-    "dpl_log_1": ":  '$0' : '$1'! :  <code>$0= <i></i> ()$3</code>",
-    "dpl_log_3": ": ! : $0 :  <code>DynamicPageListHooks::$maxCategoryCount</code>  <code>DynamicPageListHooks::$allowUnlimitedCategories=true</code>  ( <code>DynamicPageList.php</code><code>LocalSettings.php</code>)",
-    "dpl_log_4": ": ! : $0. :  <code>DynamicPageListHooks::$minCategoryCount</code>  ( <code>DynamicPageList.php</code><code>LocalSettings.php</code>)",
-    "dpl_log_5": "ERROR: No selection criteria found! You must use at least one of the following parameters: category, namespace, titlematch, linksto, uses, createdby, modifiedby, lastmodifiedby, or their 'not' variants",
-    "dpl_log_6": ":  'addfirstcategorydate=true'  'ordermethod=categoryadd' !",
-    "dpl_log_7": ":  'addfirstcategorydate=true'  'ordermethod=categoryadd'!",
-    "dpl_log_8": ": !",
-    "dpl_log_9": ":  'ordermethod=[...,]$1'  '$0' !",
-    "dpl_log_10": "ERROR: the index for the dominant section must be between 1 and the number of arguments of includepage ($0 in this case)",
-    "dpl_log_12": "ERROR: specifying \"openreferences\" is incompatible with some other option you specified. See the manual for details.",
-    "dpl_log_13": ":  '$1'  : : <code>$2</code>",
-    "dpl_log_14": ":  '$0' : '$1'! : '$2' : <code>$0= $3</code>",
-    "dpl_log_15": ":  '$0' : '$1'! : '$2' () : <code>$0= <i></i> () | n</code>, <code>n</code>",
-    "dpl_log_16": ": !",
-    "dpl_log_17": ": *  ('adduser', 'addeditdate', )'  'mode=category' ",
-    "dpl_log_18": ":  'ordermethod'  'headingmode=$0'  : '$1' : $1 'headingmode'  'ordermethod'  'ordermethod=category,<i>comp</i>' (<i>comp</i>) ",
-    "dpl_log_19": ": 'debug=$0' DPL",
-    "dpl_log_21": ": <code>$0</code>",
-    "dpl_articlecount": "$1"
-}
\ No newline at end of file
diff --git a/i18n/zh-hans.json b/i18n/zh-hans.json
deleted file mode 100644
index 52577456..00000000
--- a/i18n/zh-hans.json
+++ /dev/null
@@ -1,32 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Shinjiman"
-        ]
-    },
-    "intersection-desc": "",
-    "intersection_toomanycats": "DynamicPageList: !",
-    "intersection_toofewcats": "DynamicPageList: !",
-    "intersection_noresults": "DynamicPageList: !",
-    "intersection_noincludecats": "DynamicPageList: !",
-    "dpl-desc": "MediaWiki",
-    "dpl_log_1": ":  '$0' : '$1'! :  <code>$0= <i></i> ()$3</code>",
-    "dpl_log_3": ": ! : $0 :  <code>DynamicPageListHooks::$maxCategoryCount</code>  <code>DynamicPageListHooks::$allowUnlimitedCategories=true</code>  ( <code>DynamicPageList.php</code><code>LocalSettings.php</code>)",
-    "dpl_log_4": ": ! : $0 :  <code>DynamicPageListHooks::$minCategoryCount</code>  ( <code>DynamicPageList.php</code><code>LocalSettings.php</code>)",
-    "dpl_log_5": "ERROR: No selection criteria found! You must use at least one of the following parameters: category, namespace, titlematch, linksto, uses, createdby, modifiedby, lastmodifiedby, or their 'not' variants",
-    "dpl_log_6": ":  'addfirstcategorydate=true'  'ordermethod=categoryadd' !",
-    "dpl_log_7": ":  'addfirstcategorydate=true'  'ordermethod=categoryadd'!",
-    "dpl_log_8": ": !",
-    "dpl_log_9": ":  'ordermethod=[...,]$1'  '$0' !",
-    "dpl_log_10": "ERROR: the index for the dominant section must be between 1 and the number of arguments of includepage ($0 in this case)",
-    "dpl_log_12": "ERROR: specifying \"openreferences\" is incompatible with some other option you specified. See the manual for details.",
-    "dpl_log_13": ":  '$1'  : : <code>$2</code>",
-    "dpl_log_14": ":  '$0' : '$1'! : '$2' : <code>$0= $3</code>",
-    "dpl_log_15": ":  '$0' : '$1'! : '$2' () : <code>$0= <i></i> () | n</code>, <code>n</code>",
-    "dpl_log_16": ": !",
-    "dpl_log_17": ": *  ('adduser', 'addeditdate', )'  'mode=category' ",
-    "dpl_log_18": ":  'ordermethod'  'headingmode=$0'  : '$1' : $1 'headingmode'  'ordermethod'  'ordermethod=category,<i>comp</i>' (<i>comp</i>) ",
-    "dpl_log_19": ": 'debug=$0' DPL",
-    "dpl_log_21": ": <code>$0</code>",
-    "dpl_articlecount": "$1"
-}
\ No newline at end of file
diff --git a/i18n/zh-hant.json b/i18n/zh-hant.json
deleted file mode 100644
index 53d638c5..00000000
--- a/i18n/zh-hant.json
+++ /dev/null
@@ -1,32 +0,0 @@
-{
-    "@metadata": {
-        "authors": [
-            "Shinjiman"
-        ]
-    },
-    "intersection-desc": "",
-    "intersection_toomanycats": "DynamicPageList: !",
-    "intersection_toofewcats": "DynamicPageList: !",
-    "intersection_noresults": "DynamicPageList: !",
-    "intersection_noincludecats": "DynamicPageList: !",
-    "dpl-desc": "MediaWiki",
-    "dpl_log_1": ":  '$0' : '$1'! :  <code>$0= <i></i> ()$3</code>",
-    "dpl_log_3": ": ! : $0 :  <code>DynamicPageListHooks::$maxCategoryCount</code>  <code>DynamicPageListHooks::$allowUnlimitedCategories=true</code>  ( <code>DynamicPageList.php</code><code>LocalSettings.php</code>)",
-    "dpl_log_4": ": ! : $0 :  <code>DynamicPageListHooks::$minCategoryCount</code>  ( <code>DynamicPageList.php</code><code>LocalSettings.php</code>)",
-    "dpl_log_5": "ERROR: No selection criteria found! You must use at least one of the following parameters: category, namespace, titlematch, linksto, uses, createdby, modifiedby, lastmodifiedby, or their 'not' variants",
-    "dpl_log_6": ":  'addfirstcategorydate=true'  'ordermethod=categoryadd' !",
-    "dpl_log_7": ":  'addfirstcategorydate=true'  'ordermethod=categoryadd'!",
-    "dpl_log_8": ": !",
-    "dpl_log_9": ":  'ordermethod=[...,]$1'  '$0' !",
-    "dpl_log_10": "ERROR: the index for the dominant section must be between 1 and the number of arguments of includepage ($0 in this case)",
-    "dpl_log_12": "ERROR: specifying \"openreferences\" is incompatible with some other option you specified. See the manual for details.",
-    "dpl_log_13": ":  '$1'  : : <code>$2</code>",
-    "dpl_log_14": ":  '$0' : '$1'! : '$2' : <code>$0= $3</code>",
-    "dpl_log_15": ":  '$0' : '$1'! : '$2' () : <code>$0= <i></i> () | n</code>, <code>n</code>",
-    "dpl_log_16": ": !",
-    "dpl_log_17": ": *  ('adduser', 'addeditdate', )'  'mode=category' ",
-    "dpl_log_18": ":  'ordermethod'  'headingmode=$0'  : '$1' : $1 'headingmode'  'ordermethod'  'ordermethod=category,<i>comp</i>' (<i>comp</i>) ",
-    "dpl_log_19": ": 'debug=$0' DPL",
-    "dpl_log_21": ": <code>$0</code>",
-    "dpl_articlecount": "$1"
-}
\ No newline at end of file
diff --git a/includes/Article.php b/includes/Article.php
index 8f591813..f4241ec2 100644
--- a/includes/Article.php
+++ b/includes/Article.php
@@ -1,31 +1,22 @@
 <?php
-/**
- * DynamicPageList3
- * DPL Article Class
- *
- * @author		IlyaHaykinson, Unendlich, Dangerville, Algorithmix, Theaitetos, Alexia E. Smith, Universal Omega
- * @license		GPL-2.0-or-later
- * @package		DynamicPageList3
- *
- */
 
 namespace DPL;
 
 use MediaWiki\MediaWikiServices;
-use User;
+use Title;
 
 class Article {
 	/**
 	 * Title
 	 *
-	 * @var object
+	 * @var Title
 	 */
-	public $mTitle = null;
+	public $mTitle;
 
 	/**
 	 * Namespace ID
 	 *
-	 * @var string
+	 * @var int
 	 */
 	public $mNamespace = -1;
 
@@ -46,7 +37,7 @@ class Article {
 	/**
 	 * Selected namespace ID of initial page.
 	 *
-	 * @var string
+	 * @var int
 	 */
 	public $mSelNamespace = -1;
 
@@ -116,7 +107,7 @@ class Article {
 	/**
 	 * Timestamp depending on the user's request (can be first/last edit, page_touched, ...)
 	 *
-	 * @var string
+	 * @var string|int
 	 */
 	public $mDate = null;
 
@@ -184,52 +175,46 @@ class Article {
 	private static $headings = [];
 
 	/**
-	 * Main Constructor
-	 *
-	 * @access	public
-	 * @param	string	Title
-	 * @param	integer	Namespace
-	 * @return	void
+	 * @param Title $title
+	 * @param int $namespace
 	 */
-	public function __construct( $title, $namespace ) {
-		$this->mTitle     = $title;
+	public function __construct( Title $title, $namespace ) {
+		$this->mTitle = $title;
 		$this->mNamespace = $namespace;
 	}
 
 	/**
 	 * Initialize a new instance from a database row.
 	 *
-	 * @access	public
-	 * @param	array	Database Row
-	 * @param	object	\DPL\Parameters Object
-	 * @param	object	Mediawiki Title Object
-	 * @param	integer	Page Namespace ID
-	 * @param	string	Page Title as Selected from Query
-	 * @return	object	\DPL\Article Object
+	 * @param array	$row
+	 * @param Parameters $parameters
+	 * @param Title	$title
+	 * @param int $pageNamespace
+	 * @param string $pageTitle
+	 * @return Article
 	 */
-	public static function newFromRow( $row, Parameters $parameters, \Title $title, $pageNamespace, $pageTitle ) {
+	public static function newFromRow( $row, Parameters $parameters, Title $title, $pageNamespace, $pageTitle ) {
 		global $wgLang;
 
-		$article = new Article( $title, $pageNamespace );
+		$contentLanguage = MediaWikiServices::getInstance()->getContentLanguage();
 
-		$revActorName = null;
-		if ( isset( $row['revactor_actor'] ) ) {
-			$revActorName = User::newFromActorId( $row['revactor_actor'] )->getName();
-		}
+		$article = new Article( $title, $pageNamespace );
 
 		$titleText = $title->getText();
 		if ( $parameters->getParameter( 'shownamespace' ) === true ) {
 			$titleText = $title->getPrefixedText();
 		}
+
 		$replaceInTitle = $parameters->getParameter( 'replaceintitle' );
 		if ( is_array( $replaceInTitle ) && count( $replaceInTitle ) === 2 ) {
 			$titleText = preg_replace( $replaceInTitle[0], $replaceInTitle[1], $titleText );
 		}
 
-		//Chop off title if longer than the 'titlemaxlen' parameter.
+		// Chop off title if longer than the 'titlemaxlen' parameter.
 		if ( $parameters->getParameter( 'titlemaxlen' ) !== null && strlen( $titleText ) > $parameters->getParameter( 'titlemaxlen' ) ) {
 			$titleText = substr( $titleText, 0, $parameters->getParameter( 'titlemaxlen' ) ) . '...';
 		}
+
 		if ( $parameters->getParameter( 'showcurid' ) === true && isset( $row['page_id'] ) ) {
 			$articleLink = '[' . $title->getLinkURL( [ 'curid' => $row['page_id'] ] ) . ' ' . htmlspecialchars( $titleText ) . ']';
 		} else {
@@ -237,43 +222,47 @@ public static function newFromRow( $row, Parameters $parameters, \Title $title,
 		}
 
 		$article->mLink = $articleLink;
-		$contLang = MediaWikiServices::getInstance()->getContentLanguage();
 
-		//get first char used for category-style output
+		$languageConverter = MediaWikiServices::getInstance()
+			->getLanguageConverterFactory()
+			->getLanguageConverter();
+
+		// get first char used for category-style output
 		if ( isset( $row['sortkey'] ) ) {
-			$article->mStartChar = $contLang->convert( $contLang->firstChar( $row['sortkey'] ) );
+			$article->mStartChar = $languageConverter->convert( $contentLanguage->firstChar( $row['sortkey'] ) );
 		} else {
-			$article->mStartChar = $contLang->convert( $contLang->firstChar( $pageTitle ) );
+			$article->mStartChar = $languageConverter->convert( $contentLanguage->firstChar( $pageTitle ) );
 		}
 
 		$article->mID = intval( $row['page_id'] );
 
-		//External link
+		// External link
 		if ( isset( $row['el_to'] ) ) {
 			$article->mExternalLink = $row['el_to'];
 		}
 
-		//SHOW PAGE_COUNTER
+		// SHOW PAGE_COUNTER
 		if ( isset( $row['page_counter'] ) ) {
 			$article->mCounter = intval( $row['page_counter'] );
 		}
 
-		//SHOW PAGE_SIZE
+		// SHOW PAGE_SIZE
 		if ( isset( $row['page_len'] ) ) {
 			$article->mSize = intval( $row['page_len'] );
 		}
-		//STORE initially selected PAGE
+
+		// STORE initially selected PAGE
 		if ( is_array( $parameters->getParameter( 'linksto' ) ) && ( count( $parameters->getParameter( 'linksto' ) ) || count( $parameters->getParameter( 'linksfrom' ) ) ) ) {
 			if ( !isset( $row['sel_title'] ) ) {
-				$article->mSelTitle     = 'unknown page';
+				$article->mSelTitle = 'unknown page';
 				$article->mSelNamespace = 0;
 			} else {
-				$article->mSelTitle     = $row['sel_title'];
+				$article->mSelTitle = $row['sel_title'];
 				$article->mSelNamespace = $row['sel_ns'];
 			}
 		}
 
-		//STORE selected image
+		// STORE selected image
 		if ( is_array( $parameters->getParameter( 'imageused' ) ) && count( $parameters->getParameter( 'imageused' ) ) > 0 ) {
 			if ( !isset( $row['image_sel_title'] ) ) {
 				$article->mImageSelTitle = 'unknown image';
@@ -283,49 +272,51 @@ public static function newFromRow( $row, Parameters $parameters, \Title $title,
 		}
 
 		if ( $parameters->getParameter( 'goal' ) != 'categories' ) {
-			//REVISION SPECIFIED
+			// REVISION SPECIFIED
 			if ( $parameters->getParameter( 'lastrevisionbefore' ) || $parameters->getParameter( 'allrevisionsbefore' ) || $parameters->getParameter( 'firstrevisionsince' ) || $parameters->getParameter( 'allrevisionssince' ) ) {
-				$article->mRevision = $row['revactor_rev'];
-				$article->mUser     = $revActorName;
-				$article->mDate     = $row['revactor_timestamp'];
+				$article->mRevision = $row['rev_id'];
+				$article->mUser = $row['rev_user_text'];
+				$article->mDate = $row['rev_timestamp'];
+				$article->mComment = $row['rev_comment'];
 			}
 
-			//SHOW "PAGE_TOUCHED" DATE, "FIRSTCATEGORYDATE" OR (FIRST/LAST) EDIT DATE
+			// SHOW "PAGE_TOUCHED" DATE, "FIRSTCATEGORYDATE" OR (FIRST/LAST) EDIT DATE
 			if ( $parameters->getParameter( 'addpagetoucheddate' ) ) {
 				$article->mDate = $row['page_touched'];
 			} elseif ( $parameters->getParameter( 'addfirstcategorydate' ) ) {
 				$article->mDate = $row['cl_timestamp'];
-			} elseif ( $parameters->getParameter( 'addeditdate' ) && isset( $row['revactor_timestamp'] ) ) {
-				$article->mDate = $row['revactor_timestamp'];
+			} elseif ( $parameters->getParameter( 'addeditdate' ) && isset( $row['rev_timestamp'] ) ) {
+				$article->mDate = $row['rev_timestamp'];
 			} elseif ( $parameters->getParameter( 'addeditdate' ) && isset( $row['page_touched'] ) ) {
 				$article->mDate = $row['page_touched'];
 			}
 
-			//Time zone adjustment
+			// Time zone adjustment
 			if ( $article->mDate ) {
 				$article->mDate = $wgLang->userAdjust( $article->mDate );
 			}
 
 			if ( $article->mDate && $parameters->getParameter( 'userdateformat' ) ) {
-				//Apply the userdateformat
-				$article->myDate = gmdate( $parameters->getParameter( 'userdateformat' ), wfTimeStamp( TS_UNIX, $article->mDate ) );
+				// Apply the userdateformat
+				$article->myDate = gmdate( $parameters->getParameter( 'userdateformat' ), (int)wfTimestamp( TS_UNIX, $article->mDate ) );
 			}
+
 			// CONTRIBUTION, CONTRIBUTOR
 			if ( $parameters->getParameter( 'addcontribution' ) ) {
 				$article->mContribution = $row['contribution'];
-				$article->mContributor  = User::newFromActorId( $row['contributor'] )->getName();
-				$article->mContrib      = substr( '*****************', 0, (int)round( log( $row['contribution'] ) ) );
+				$article->mContributor = $row['contributor'];
+				$article->mContrib = substr( '*****************', 0, (int)round( log( $row['contribution'] ) ) );
 			}
 
-			//USER/AUTHOR(S)
+			// USER/AUTHOR(S)
 			// because we are going to do a recursive parse at the end of the output phase
 			// we have to generate wiki syntax for linking to a users homepage
 			if ( $parameters->getParameter( 'adduser' ) || $parameters->getParameter( 'addauthor' ) || $parameters->getParameter( 'addlasteditor' ) ) {
-				$article->mUserLink = '[[User:' . $revActorName . '|' . $revActorName . ']]';
-				$article->mUser     = $revActorName;
+				$article->mUserLink = '[[User:' . $row['rev_user_text'] . '|' . $row['rev_user_text'] . ']]';
+				$article->mUser = $row['rev_user_text'];
 			}
 
-			//CATEGORY LINKS FROM CURRENT PAGE
+			// CATEGORY LINKS FROM CURRENT PAGE
 			if ( $parameters->getParameter( 'addcategories' ) && ( $row['cats'] ) ) {
 				$artCatNames = explode( ' | ', $row['cats'] );
 				foreach ( $artCatNames as $artCatName ) {
@@ -333,26 +324,24 @@ public static function newFromRow( $row, Parameters $parameters, \Title $title,
 					$article->mCategoryTexts[] = str_replace( '_', ' ', $artCatName );
 				}
 			}
+
 			// PARENT HEADING (category of the page, editor (user) of the page, etc. Depends on ordermethod param)
 			if ( $parameters->getParameter( 'headingmode' ) != 'none' ) {
 				switch ( $parameters->getParameter( 'ordermethod' )[0] ) {
 					case 'category':
-						//Count one more page in this heading
+						// Count one more page in this heading
 						self::$headings[$row['cl_to']] = ( isset( self::$headings[$row['cl_to']] ) ? self::$headings[$row['cl_to']] + 1 : 1 );
 						if ( $row['cl_to'] == '' ) {
-							//uncategorized page (used if ordermethod=category,...)
+							// uncategorized page (used if ordermethod=category,...)
 							$article->mParentHLink = '[[:Special:Uncategorizedpages|' . wfMessage( 'uncategorizedpages' ) . ']]';
 						} else {
 							$article->mParentHLink = '[[:Category:' . $row['cl_to'] . '|' . str_replace( '_', ' ', $row['cl_to'] ) . ']]';
 						}
 						break;
 					case 'user':
-						self::$headings[$revActorName] = ( isset( self::$headings[$revActorName] ) ? self::$headings[$revActorName] + 1 : 1 );
-						if ( $row['revactor_actor'] == 0 ) { //anonymous user
-							$article->mParentHLink = '[[User:' . $revActorName . '|' . $revActorName . ']]';
-						} else {
-							$article->mParentHLink = '[[User:' . $revActorName . '|' . $revActorName . ']]';
-						}
+						self::$headings[$row['rev_user_text']] = ( isset( self::$headings[$row['rev_user_text']] ) ? self::$headings[$row['rev_user_text']] + 1 : 1 );
+
+						$article->mParentHLink = '[[User:' . $row['rev_user_text'] . '|' . $row['rev_user_text'] . ']]';
 						break;
 				}
 			}
@@ -364,8 +353,7 @@ public static function newFromRow( $row, Parameters $parameters, \Title $title,
 	/**
 	 * Returns all heading information processed from all newly instantiated article objects.
 	 *
-	 * @access	public
-	 * @return	array	Headings
+	 * @return array
 	 */
 	public static function getHeadings() {
 		return self::$headings;
@@ -375,9 +363,6 @@ public static function getHeadings() {
 	 * Reset the headings to their initial state.
 	 * Ideally this Article class should not exist and be handled by the built in MediaWiki class.
 	 * Bug: https://jira/browse/HYD-913
-	 *
-	 * @access	public
-	 * @return	void
 	 */
 	public static function resetHeadings() {
 		self::$headings = [];
@@ -386,16 +371,17 @@ public static function resetHeadings() {
 	/**
 	 * Get the formatted date for this article if available.
 	 *
-	 * @access	public
-	 * @return	mixed	Formatted string or null for none set.
+	 * @return mixed Formatted string or null for none set.
 	 */
 	public function getDate() {
 		global $wgLang;
+
 		if ( $this->myDate !== null ) {
 			return $this->myDate;
 		} elseif ( $this->mDate !== null ) {
-			return $wgLang->timeanddate( $article->mDate, true );
+			return $wgLang->timeanddate( $this->mDate, true );
 		}
+
 		return null;
 	}
 }
diff --git a/includes/Config.php b/includes/Config.php
index 3bd7b0a6..659ce367 100644
--- a/includes/Config.php
+++ b/includes/Config.php
@@ -1,15 +1,9 @@
 <?php
-/**
- * DynamicPageList3
- * DPL Config Class
- *
- * @author		IlyaHaykinson, Unendlich, Dangerville, Algorithmix, Theaitetos, Alexia E. Smith
- * @license		GPL-2.0-or-later
- * @package		DynamicPageList3
- *
- */
+
 namespace DPL;
 
+use MWException;
+
 class Config {
 	/**
 	 * Configuration Settings
@@ -21,15 +15,13 @@ class Config {
 	/**
 	 * Initialize the static object with settings.
 	 *
-	 * @access	public
-	 * @param	array	Settings to initialize for DPL.
-	 * @return	void
+	 * @param array|false $settings
 	 */
 	public static function init( $settings = false ) {
 		if ( $settings === false ) {
 			global $wgDplSettings;
 
-			$settings = $wgDplSettings;
+			$settings = $wgDplSettings ?? false;
 		}
 
 		if ( !is_array( $settings ) ) {
@@ -42,19 +34,17 @@ public static function init( $settings = false ) {
 	/**
 	 * Return a single setting.
 	 *
-	 * @access	public
-	 * @param	string	Setting Key
-	 * @return	mixed	The setting's actual setting or null if it does not exist.
+	 * @param string $setting
+	 * @return mixed|null
 	 */
 	public static function getSetting( $setting ) {
-		return ( array_key_exists( $setting, self::$settings ) ? self::$settings[$setting] : null );
+		return ( self::$settings[$setting] ?? null );
 	}
 
 	/**
 	 * Return a all settings.
 	 *
-	 * @access	public
-	 * @return	array	All settings
+	 * @return array
 	 */
 	public static function getAllSettings() {
 		return self::$settings;
@@ -63,15 +53,14 @@ public static function getAllSettings() {
 	/**
 	 * Set a single setting.
 	 *
-	 * @access	public
-	 * @param	string	Setting Key
-	 * @param	mixed	[Optional] Appropriate value for the setting key.
-	 * @return	void
+	 * @param string $setting
+	 * @param mixed|null $value
 	 */
 	public static function setSetting( $setting, $value = null ) {
 		if ( empty( $setting ) || !is_string( $setting ) ) {
 			throw new MWException( __METHOD__ . ": Setting keys can not be blank." );
 		}
+
 		self::$settings[$setting] = $value;
 	}
 }
diff --git a/DynamicPageListHooks.php b/includes/DynamicPageListHooks.php
similarity index 62%
rename from DynamicPageListHooks.php
rename to includes/DynamicPageListHooks.php
index 2dfa4355..a1a14259 100644
--- a/DynamicPageListHooks.php
+++ b/includes/DynamicPageListHooks.php
@@ -1,130 +1,96 @@
 <?php
-/**
- *
- * @file
- * @ingroup Extensions
- * @link http://www.mediawiki.org/wiki/Extension:DynamicPageList3 Documentation
- * @author n:en:User:IlyaHaykinson
- * @author n:en:User:Amgine
- * @author w:de:Benutzer:Unendlich
- * @author m:User:Dangerman <cyril.dangerville@gmail.com>
- * @author m:User:Algorithmix <gero.scholz@gmx.de>
- * @license GPL-2.0-or-later
- *
- */
 
-class DynamicPageListHooks {
-	// FATAL
-	const FATAL_WRONGNS = 1001;	// $1: 'namespace' or 'notnamespace'
-															// $2: wrong parameter given by user
-															// $3: list of possible titles of namespaces (except pseudo-namespaces: Media, Special)
-
-	const FATAL_WRONGLINKSTO = 1002;	// $1: linksto'
-															// $2: the wrong parameter given by user
-
-	const FATAL_TOOMANYCATS = 1003;	// $1: max number of categories that can be included
+namespace DPL;
 
-	const FATAL_TOOFEWCATS = 1004;	// $1: min number of categories that have to be included
+use DatabaseUpdater;
+use Parser;
+use PPFrame;
 
-	const FATAL_NOSELECTION = 1005;
+class DynamicPageListHooks {
 
-	const FATAL_CATDATEBUTNOINCLUDEDCATS = 1006;
+	public const FATAL_WRONGNS = 1001;
 
-	const FATAL_CATDATEBUTMORETHAN1CAT = 1007;
+	public const FATAL_WRONGLINKSTO = 1002;
 
-	const FATAL_MORETHAN1TYPEOFDATE = 1008;
+	public const FATAL_TOOMANYCATS = 1003;
 
-	const FATAL_WRONGORDERMETHOD = 1009;	// $1: param=val that is possible only with $1 as last 'ordermethod' parameter
-															// $2: last 'ordermethod' parameter required for $0
+	public const FATAL_TOOFEWCATS = 1004;
 
-	const FATAL_DOMINANTSECTIONRANGE = 1010;	// $1: the number of arguments in includepage
+	public const FATAL_NOSELECTION = 1005;
 
-	const FATAL_OPENREFERENCES = 1012;
+	public const FATAL_CATDATEBUTNOINCLUDEDCATS = 1006;
 
-	const FATAL_MISSINGPARAMFUNCTION = 1022;
+	public const FATAL_CATDATEBUTMORETHAN1CAT = 1007;
 
-	const FATAL_NOTPROTECTED = 1023;
+	public const FATAL_MORETHAN1TYPEOFDATE = 1008;
 
-	const FATAL_SQLBUILDERROR = 1024;
+	public const FATAL_WRONGORDERMETHOD = 1009;
 
-	// ERROR
+	public const FATAL_DOMINANTSECTIONRANGE = 1010;
 
-	// WARN
+	public const FATAL_OPENREFERENCES = 1012;
 
-	const WARN_UNKNOWNPARAM = 2013;	// $1: unknown parameter given by user
-															// $2: list of DPL available parameters separated by ', '
+	public const FATAL_MISSINGPARAMFUNCTION = 1022;
 
-	const WARN_PARAMNOOPTION = 2022;	// $1: Parameter given by user
+	public const FATAL_NOTPROTECTED = 1023;
 
-	const WARN_WRONGPARAM = 2014;	// $3: list of valid param values separated by ' | '
+	public const FATAL_SQLBUILDERROR = 1024;
 
-	const WARN_WRONGPARAM_INT = 2015;	// $1: param name
-															// $2: wrong param value given by user
-															// $3: default param value used instead by program
+	public const WARN_UNKNOWNPARAM = 2013;
 
-	const WARN_NORESULTS = 2016;
+	public const WARN_PARAMNOOPTION = 2022;
 
-	const WARN_CATOUTPUTBUTWRONGPARAMS = 2017;
+	public const WARN_WRONGPARAM = 2014;
 
-	const WARN_HEADINGBUTSIMPLEORDERMETHOD = 2018;	// $1: 'headingmode' value given by user
-															// $2: value used instead by program (which means no heading)
+	public const WARN_WRONGPARAM_INT = 2015;
 
-	const WARN_DEBUGPARAMNOTFIRST = 2019;	// $1: 'log' value
+	public const WARN_NORESULTS = 2016;
 
-	const WARN_TRANSCLUSIONLOOP = 2020;	// $1: title of page that creates an infinite transclusion loop
+	public const WARN_CATOUTPUTBUTWRONGPARAMS = 2017;
 
-	// INFO
+	public const WARN_HEADINGBUTSIMPLEORDERMETHOD = 2018;
 
-	// DEBUG
+	public const WARN_DEBUGPARAMNOTFIRST = 2019;
 
-	const DEBUG_QUERY = 3021;	// $1: SQL query executed to generate the dynamic page list
+	public const WARN_TRANSCLUSIONLOOP = 2020;
 
-	// TRACE
-															// Output formatting
-															// $1: number of articles
+	public const DEBUG_QUERY = 3021;
 
+	/** @var array */
 	public static $fixedCategories = [];
 
-	public static $createdLinks; // the links created by DPL are collected here;
-								 // they can be removed during the final ouput
-								 // phase of the MediaWiki parser
+	/** @var array */
+	public static $createdLinks;
 
-	/**
-	 * DPL acting like Extension:Intersection
-	 *
-	 * @var bool
-	 */
+	/** @var bool */
 	private static $likeIntersection = false;
 
-	/**
-	 * Debugging Level
-	 *
-	 * @var int
-	 */
+	/** @var int */
 	private static $debugLevel = 0;
 
 	/**
-	 * Handle special on extension registration bits.
-	 *
-	 * @return void
+	 * @return string
 	 */
-	public static function onRegistration() {
-		if ( !defined( 'DPL_VERSION' ) ) {
-			define( 'DPL_VERSION', '3.3.5' );
+	public static function getVersion(): string {
+		static $version = null;
+
+		if ( $version === null ) {
+			$version = json_decode( file_get_contents( __DIR__ . '/../extension.json' ) )->version;
 		}
+
+		return $version;
 	}
 
 	/**
 	 * Sets up this extension's parser functions.
 	 *
-	 * @param object Parser object passed as a reference.
-	 * @return bool	true
+	 * @param Parser $parser
 	 */
-	public static function onParserFirstCallInit( Parser &$parser ) {
+	public static function onParserFirstCallInit( Parser $parser ) {
 		self::init();
 
-		//DPL offers the same functionality as Intersection.  So we register the <DynamicPageList> tag in case LabeledSection Extension is not installed so that the section markers are removed.
-		if ( \DPL\Config::getSetting( 'handleSectionTag' ) ) {
+		// DPL offers the same functionality as Intersection. So we register the <DynamicPageList> tag in case LabeledSection Extension is not installed so that the section markers are removed.
+		if ( Config::getSetting( 'handleSectionTag' ) ) {
 			$parser->setHook( 'section', [ __CLASS__, 'dplTag' ] );
 		}
 
@@ -137,33 +103,25 @@ public static function onParserFirstCallInit( Parser &$parser ) {
 		$parser->setFunctionHook( 'dplreplace', [ __CLASS__, 'dplReplaceParserFunction' ] );
 		$parser->setFunctionHook( 'dplchapter', [ __CLASS__, 'dplChapterParserFunction' ] );
 		$parser->setFunctionHook( 'dplmatrix', [ __CLASS__, 'dplMatrixParserFunction' ] );
-
-		return true;
 	}
 
 	/**
 	 * Sets up this extension's parser functions for migration from Intersection.
 	 *
-	 * @param object Parser object passed as a reference.
-	 * @returnbool true
+	 * @param Parser $parser
 	 */
-	public static function setupMigration( Parser &$parser ) {
+	public static function setupMigration( Parser $parser ) {
 		$parser->setHook( 'Intersection', [ __CLASS__, 'intersectionTag' ] );
 		$parser->addTrackingCategory( 'dpl-intersection-tracking-category' );
 
 		self::init();
-
-		return true;
 	}
 
 	/**
 	 * Common initializer for usage from parser entry points.
-	 *
-	 * @private
-	 * @return void
 	 */
 	private static function init() {
-		\DPL\Config::init();
+		Config::init();
 
 		if ( !isset( self::$createdLinks ) ) {
 			self::$createdLinks = [
@@ -180,9 +138,7 @@ private static function init() {
 	/**
 	 * Set to behave like intersection.
 	 *
-	 * @private
-	 * @param bool	Behave Like Intersection
-	 * @return void
+	 * @param bool $mode
 	 */
 	private static function setLikeIntersection( $mode = false ) {
 		self::$likeIntersection = $mode;
@@ -191,7 +147,7 @@ private static function setLikeIntersection( $mode = false ) {
 	/**
 	 * Is like intersection?
 	 *
-	 * @return bool	Behaving Like Intersection
+	 * @return bool
 	 */
 	public static function isLikeIntersection() {
 		return (bool)self::$likeIntersection;
@@ -200,70 +156,77 @@ public static function isLikeIntersection() {
 	/**
 	 * Tag <section> entry point.
 	 *
-	 * @param string Raw User Input
-	 * @param array Arguments on the tag.
-	 * @param object Parser object.
-	 * @param object PPFrame object.
-	 * @return string HTML
+	 * @param string $input
+	 * @param array $args
+	 * @param Parser $parser
+	 * @param PPFrame $frame
+	 * @return string
 	 */
 	public static function intersectionTag( $input, array $args, Parser $parser, PPFrame $frame ) {
 		self::setLikeIntersection( true );
+
 		return self::executeTag( $input, $args, $parser, $frame );
 	}
 
 	/**
 	 * Tag <dpl> entry point.
 	 *
-	 * @param string Raw User Input
-	 * @param array Arguments on the tag.
-	 * @param object Parser object.
-	 * @param object PPFrame object.
-	 * @return string HTML
+	 * @param string $input
+	 * @param array $args
+	 * @param Parser $parser
+	 * @param PPFrame $frame
+	 * @return string
 	 */
 	public static function dplTag( $input, array $args, Parser $parser, PPFrame $frame ) {
 		self::setLikeIntersection( false );
 		$parser->addTrackingCategory( 'dpl-tag-tracking-category' );
+
 		return self::executeTag( $input, $args, $parser, $frame );
 	}
 
 	/**
 	 * The callback function wrapper for converting the input text to HTML output
 	 *
-	 * @param string Raw User Input
-	 * @param array Arguments on the tag.(While not used, it is left here for future compatibility.)
-	 * @param object Parser object.
-	 * @param object PPFrame object.
-	 * @return string HTML
+	 * @param string $input
+	 * @param array $args
+	 * @param Parser $parser
+	 * @param PPFrame $frame
+	 * @return string
 	 */
 	private static function executeTag( $input, array $args, Parser $parser, PPFrame $frame ) {
-		// entry point for user tag <dpl>  or  <DynamicPageList>
+		// entry point for user tag <dpl> or <DynamicPageList>
 		// create list and do a recursive parse of the output
 
-		$parse = new \DPL\Parse();
-		if ( \DPL\Config::getSetting( 'recursiveTagParse' ) ) {
+		$parse = new Parse();
+		if ( Config::getSetting( 'recursiveTagParse' ) ) {
 			$input = $parser->recursiveTagParse( $input, $frame );
 		}
 
 		$text = $parse->parse( $input, $parser, $reset, $eliminate, true );
 
-		if ( isset( $reset['templates'] ) && $reset['templates'] ) {	// we can remove the templates by save/restore
+		if ( $reset['templates'] ?? false ) { // we can remove the templates by save/restore
 			$saveTemplates = $parser->getOutput()->mTemplates;
 		}
-		if ( isset( $reset['categories'] ) && $reset['categories'] ) {	// we can remove the categories by save/restore
+
+		if ( $reset['categories'] ?? false ) { // we can remove the categories by save/restore
 			$saveCategories = $parser->getOutput()->mCategories;
 		}
-		if ( isset( $reset['images'] ) && $reset['images'] ) {	// we can remove the images by save/restore
+
+		if ( $reset['images'] ?? false ) { // we can remove the images by save/restore
 			$saveImages = $parser->getOutput()->mImages;
 		}
+
 		$parsedDPL = $parser->recursiveTagParse( $text );
-		if ( isset( $reset['templates'] ) && $reset['templates'] ) {
-			$parser->getOutput()->mTemplates = $saveTemplates;
+		if ( $reset['templates'] ?? false ) {
+			$parser->getOutput()->mTemplates = $saveTemplates ?? [];
 		}
-		if ( isset( $reset['categories'] ) && $reset['categories'] ) {
-			$parser->getOutput()->mCategories = $saveCategories;
+
+		if ( $reset['categories'] ?? false ) {
+			$parser->getOutput()->mCategories = $saveCategories ?? [];
 		}
-		if ( isset( $reset['images'] ) && $reset['images'] ) {
-			$parser->getOutput()->mImages = $saveImages;
+
+		if ( $reset['images'] ?? false ) {
+			$parser->getOutput()->mImages = $saveImages ?? [];
 		}
 
 		return $parsedDPL;
@@ -272,20 +235,21 @@ private static function executeTag( $input, array $args, Parser $parser, PPFrame
 	/**
 	 * The #dpl parser tag entry point.
 	 *
-	 * @param object Parser object passed as a reference.
-	 * @return string Wiki Text
+	 * @param Parser $parser
+	 * @return array|string
 	 */
-	public static function dplParserFunction( &$parser ) {
+	public static function dplParserFunction( $parser ) {
 		self::setLikeIntersection( false );
 
 		$parser->addTrackingCategory( 'dpl-parserfunc-tracking-category' );
 
-		// callback for the parser function {{#dpl:	  or   {{DynamicPageList::
+		// callback for the parser function {{#dpl: or {{DynamicPageList::
 		$input = "";
 
 		$numargs = func_num_args();
 		if ( $numargs < 2 ) {
 			$input = "#dpl: no arguments specified";
+
 			return str_replace( '', '<', 'pre>nowiki>' . $input . '/nowiki>/pre>' );
 		}
 
@@ -293,13 +257,16 @@ public static function dplParserFunction( &$parser ) {
 		$arg_list = func_get_args();
 		for ( $i = 1; $i < $numargs; $i++ ) {
 			$p1 = $arg_list[$i];
+
 			$input .= str_replace( "\n", "", $p1 ) . "\n";
 		}
 
-		$parse = new \DPL\Parse();
+		$parse = new Parse();
 		$dplresult = $parse->parse( $input, $parser, $reset, $eliminate, false );
-		return [ // parser needs to be coaxed to do further recursive processing
-			$parser->getPreprocessor()->preprocessToObj( $dplresult, Parser::PTD_FOR_INCLUSION ),
+
+		return [
+			// @phan-suppress-next-line PhanPluginMixedKeyNoKey
+			$parser->getPreprocessor()->preprocessToObj( $dplresult, 1 ),
 			'isLocalObj' => true,
 			'title' => $parser->getTitle()
 		];
@@ -307,13 +274,15 @@ public static function dplParserFunction( &$parser ) {
 
 	/**
 	 * The #dplnum parser tag entry point.
-	 * From the old documentation: "Tries to guess a number that is buried in the text.  Uses a set of heuristic rules which may work or not.  The idea is to extract the number so that it can be used as a sorting value in the column of a DPL table output."
+	 * From the old documentation: "Tries to guess a number that is buried in the text. Uses a set of heuristic rules which may work or not. The idea is to extract the number so that it can be used as a sorting value in the column of a DPL table output."
 	 *
-	 * @param object Parser object passed as a reference.
-	 * @return string Wiki Text
+	 * @param Parser $parser
+	 * @param string $text
+	 * @return string
 	 */
-	public static function dplNumParserFunction( &$parser, $text = '' ) {
+	public static function dplNumParserFunction( $parser, $text = '' ) {
 		$parser->addTrackingCategory( 'dplnum-parserfunc-tracking-category' );
+
 		$num = str_replace( '&#160;', ' ', $text );
 		$num = str_replace( '&nbsp;', ' ', $text );
 		$num = preg_replace( '/([0-9])([.])([0-9][0-9]?[^0-9,])/', '\1,\3', $num );
@@ -328,34 +297,41 @@ public static function dplNumParserFunction( &$parser, $text = '' ) {
 		$num = preg_replace( '/[. ]/', '', $num );
 		$num = preg_replace( '/^[^0-9]+/', '', $num );
 		$num = preg_replace( '/[^0-9].*/', '', $num );
+
 		return $num;
 	}
 
 	public static function dplVarParserFunction( &$parser, $cmd ) {
 		$parser->addTrackingCategory( 'dplvar-parserfunc-tracking-category' );
 		$args = func_get_args();
+
 		if ( $cmd == 'set' ) {
-			return \DPL\Variables::setVar( $args );
+			return Variables::setVar( $args );
 		} elseif ( $cmd == 'default' ) {
-			return \DPL\Variables::setVarDefault( $args );
+			return Variables::setVarDefault( $args );
 		}
-		return \DPL\Variables::getVar( $cmd );
+
+		return Variables::getVar( $cmd );
 	}
 
 	private static function isRegexp( $needle ) {
 		if ( strlen( $needle ) < 3 ) {
 			return false;
 		}
+
 		if ( ctype_alnum( $needle[0] ) ) {
 			return false;
 		}
+
 		$nettoNeedle = preg_replace( '/[ismu]*$/', '', $needle );
 		if ( strlen( $nettoNeedle ) < 2 ) {
 			return false;
 		}
+
 		if ( $needle[0] == $nettoNeedle[strlen( $nettoNeedle ) - 1] ) {
 			return true;
 		}
+
 		return false;
 	}
 
@@ -364,7 +340,8 @@ public static function dplReplaceParserFunction( &$parser, $text, $pat = '', $re
 		if ( $text == '' || $pat == '' ) {
 			return '';
 		}
-		# convert \n to a real newline character
+
+		// convert \n to a real newline character
 		$repl = str_replace( '\n', "\n", $repl );
 
 		# replace
@@ -372,40 +349,47 @@ public static function dplReplaceParserFunction( &$parser, $text, $pat = '', $re
 			$pat = '`' . str_replace( '`', '\`', $pat ) . '`';
 		}
 
+		// phpcs:ignore Generic.PHP.NoSilencedErrors.Discouraged
 		return @preg_replace( $pat, $repl, $text );
 	}
 
 	public static function dplChapterParserFunction( &$parser, $text = '', $heading = ' ', $maxLength = -1, $page = '?page?', $link = 'default', $trim = false ) {
 		$parser->addTrackingCategory( 'dplchapter-parserfunc-tracking-category' );
-		$output = \DPL\LST::extractHeadingFromText( $parser, $page, '?title?', $text, $heading, '', $sectionHeading, true, $maxLength, $link, $trim );
+		$output = LST::extractHeadingFromText( $parser, $page, '?title?', $text, $heading, '', $sectionHeading, true, $maxLength, $link, $trim );
 		return $output[0];
 	}
 
 	public static function dplMatrixParserFunction( &$parser, $name = '', $yes = '', $no = '', $flip = '', $matrix = '' ) {
 		$parser->addTrackingCategory( 'dplmatrix-parserfunc-tracking-category' );
-		$lines   = explode( "\n", $matrix );
-		$m       = [];
+		$lines = explode( "\n", $matrix );
+		$m = [];
 		$sources = [];
 		$targets = [];
-		$from    = '';
-		$to      = '';
-		if ( $flip == '' | $flip == 'normal' ) {
+		$from = '';
+		$to = '';
+
+		if ( $flip == '' || $flip == 'normal' ) {
 			$flip = false;
 		} else {
 			$flip = true;
 		}
+
 		if ( $name == '' ) {
 			$name = '&#160;';
 		}
+
 		if ( $yes == '' ) {
 			$yes = ' x ';
 		}
+
 		if ( $no == '' ) {
 			$no = '&#160;';
 		}
+
 		if ( $no[0] == '-' ) {
 			$no = " $no ";
 		}
+
 		foreach ( $lines as $line ) {
 			if ( strlen( $line ) <= 0 ) {
 				continue;
@@ -419,18 +403,23 @@ public static function dplMatrixParserFunction( &$parser, $name = '', $yes = '',
 					} else {
 						$sources[$from[0]] = $from[1];
 					}
+
 					$m[$from[0]] = [];
 				}
 			} elseif ( trim( $line ) != '' ) {
 				$to = preg_split( ' *\~\~ *', trim( $line ), 2 );
+
 				if ( count( $to ) < 2 || $to[1] == '' ) {
 					$targets[$to[0]] = $to[0];
 				} else {
 					$targets[$to[0]] = $to[1];
 				}
+
+				// @phan-suppress-next-line PhanTypeInvalidDimOffset
 				$m[$from[0]][$to[0]] = true;
 			}
 		}
+
 		ksort( $targets );
 
 		$header = "\n";
@@ -439,8 +428,10 @@ public static function dplMatrixParserFunction( &$parser, $name = '', $yes = '',
 			foreach ( $sources as $from => $fromName ) {
 				$header .= "![[$from|" . $fromName . "]]\n";
 			}
+
 			foreach ( $targets as $to => $toName ) {
 				$targets[$to] = "[[$to|$toName]]";
+
 				foreach ( $sources as $from => $fromName ) {
 					if ( array_key_exists( $to, $m[$from] ) ) {
 						$targets[$to] .= "\n|$yes";
@@ -448,15 +439,19 @@ public static function dplMatrixParserFunction( &$parser, $name = '', $yes = '',
 						$targets[$to] .= "\n|$no";
 					}
 				}
+
 				$targets[$to] .= "\n|--\n";
 			}
+
 			return "{|class=dplmatrix\n|$name" . "\n" . $header . "|--\n!" . implode( "\n!", $targets ) . "\n|}";
 		} else {
 			foreach ( $targets as $to => $toName ) {
 				$header .= "![[$to|" . $toName . "]]\n";
 			}
+
 			foreach ( $sources as $from => $fromName ) {
 				$sources[$from] = "[[$from|$fromName]]";
+
 				foreach ( $targets as $to => $toName ) {
 					if ( array_key_exists( $to, $m[$from] ) ) {
 						$sources[$from] .= "\n|$yes";
@@ -464,14 +459,15 @@ public static function dplMatrixParserFunction( &$parser, $name = '', $yes = '',
 						$sources[$from] .= "\n|$no";
 					}
 				}
+
 				$sources[$from] .= "\n|--\n";
 			}
+
 			return "{|class=dplmatrix\n|$name" . "\n" . $header . "|--\n!" . implode( "\n!", $sources ) . "\n|}";
 		}
 	}
 
 	private static function dumpParsedRefs( $parser, $label ) {
-		// if (!preg_match("/Query Q/",$parser->mTitle->getText())) return '';
 		echo '<pre>parser mLinks: ';
 		ob_start();
 		var_dump( $parser->getOutput()->mLinks );
@@ -502,9 +498,7 @@ public static function fixCategory( $cat ) {
 	/**
 	 * Set Debugging Level
 	 *
-	 * @access	public
-	 * @param	integer	Debug Level
-	 * @return	void
+	 * @param int|string $level
 	 */
 	public static function setDebugLevel( $level ) {
 		self::$debugLevel = intval( $level );
@@ -513,87 +507,82 @@ public static function setDebugLevel( $level ) {
 	/**
 	 * Return Debugging Level
 	 *
-	 * @access	public
-	 * @return	void
+	 * @return int
 	 */
 	public static function getDebugLevel() {
 		return self::$debugLevel;
 	}
 
-	// reset everything; some categories may have been fixed, however via  fixcategory=
-	public static function endReset( &$parser, $text ) {
+	// reset everything; some categories may have been fixed, however via fixcategory=
+	public static function endReset( $parser, $text ) {
 		if ( !self::$createdLinks['resetdone'] ) {
 			self::$createdLinks['resetdone'] = true;
+
 			foreach ( $parser->getOutput()->mCategories as $key => $val ) {
 				if ( array_key_exists( $key, self::$fixedCategories ) ) {
 					self::$fixedCategories[$key] = $val;
 				}
 			}
-			// $text .= self::dumpParsedRefs($parser,"before final reset");
+
 			if ( self::$createdLinks['resetLinks'] ) {
 				$parser->getOutput()->mLinks = [];
 			}
+
 			if ( self::$createdLinks['resetCategories'] ) {
 				$parser->getOutput()->mCategories = self::$fixedCategories;
 			}
+
 			if ( self::$createdLinks['resetTemplates'] ) {
 				$parser->getOutput()->mTemplates = [];
 			}
+
 			if ( self::$createdLinks['resetImages'] ) {
 				$parser->getOutput()->mImages = [];
 			}
-			// $text .= self::dumpParsedRefs( $parser, 'after final reset' );
+
 			self::$fixedCategories = [];
 		}
-		return true;
 	}
 
-	public static function endEliminate( &$parser, &$text ) {
+	public static function endEliminate( $parser, &$text ) {
 		// called during the final output phase; removes links created by DPL
 		if ( isset( self::$createdLinks ) ) {
-			// self::dumpParsedRefs($parser,"before final eliminate");
 			if ( array_key_exists( 0, self::$createdLinks ) ) {
 				foreach ( $parser->getOutput()->getLinks() as $nsp => $link ) {
 					if ( !array_key_exists( $nsp, self::$createdLinks[0] ) ) {
 						continue;
 					}
-					// echo ("<pre> elim: created Links [$nsp] = ". count(DynamicPageListHooks::$createdLinks[0][$nsp])."</pre>\n");
-					// echo ("<pre> elim: parser  Links [$nsp] = ". count($parser->getOutput()->mLinks[$nsp])			 ."</pre>\n");
+
 					$parser->getOutput()->mLinks[$nsp] = array_diff_assoc( $parser->getOutput()->mLinks[$nsp], self::$createdLinks[0][$nsp] );
-					// echo ("<pre> elim: parser  Links [$nsp] nachher = ". count($parser->getOutput()->mLinks[$nsp])	  ."</pre>\n");
+
 					if ( count( $parser->getOutput()->mLinks[$nsp] ) == 0 ) {
 						unset( $parser->getOutput()->mLinks[$nsp] );
 					}
 				}
 			}
+
 			if ( isset( self::$createdLinks ) && array_key_exists( 1, self::$createdLinks ) ) {
 				foreach ( $parser->getOutput()->mTemplates as $nsp => $tpl ) {
 					if ( !array_key_exists( $nsp, self::$createdLinks[1] ) ) {
 						continue;
 					}
-					// echo ("<pre> elim: created Tpls [$nsp] = ". count(DynamicPageListHooks::$createdLinks[1][$nsp])."</pre>\n");
-					// echo ("<pre> elim: parser  Tpls [$nsp] = ". count($parser->getOutput()->mTemplates[$nsp])			."</pre>\n");
+
 					$parser->getOutput()->mTemplates[$nsp] = array_diff_assoc( $parser->getOutput()->mTemplates[$nsp], self::$createdLinks[1][$nsp] );
-					// echo ("<pre> elim: parser  Tpls [$nsp] nachher = ". count($parser->getOutput()->mTemplates[$nsp])	 ."</pre>\n");
+
 					if ( count( $parser->getOutput()->mTemplates[$nsp] ) == 0 ) {
 						unset( $parser->getOutput()->mTemplates[$nsp] );
 					}
 				}
 			}
+
 			if ( isset( self::$createdLinks ) && array_key_exists( 2, self::$createdLinks ) ) {
 				$parser->getOutput()->mCategories = array_diff_assoc( $parser->getOutput()->mCategories, self::$createdLinks[2] );
 			}
+
 			if ( isset( self::$createdLinks ) && array_key_exists( 3, self::$createdLinks ) ) {
 				$parser->getOutput()->mImages = array_diff_assoc( $parser->getOutput()->mImages, self::$createdLinks[3] );
 			}
-			// $text .= self::dumpParsedRefs($parser,"after final eliminate".$parser->mTitle->getText());
 		}
-
-		/* self::$createdLinks = [
-				'resetLinks'=> false, 'resetTemplates' => false,
-				'resetCategories' => false, 'resetImages' => false, 'resetdone' => false
-		]; */
-		return true;
 	}
 
 	/**
diff --git a/DynamicPageList.i18n.magic.php b/includes/DynamicPageListMagic.php
similarity index 68%
rename from DynamicPageList.i18n.magic.php
rename to includes/DynamicPageListMagic.php
index 9c6d7eca..834c8742 100644
--- a/DynamicPageList.i18n.magic.php
+++ b/includes/DynamicPageListMagic.php
@@ -1,13 +1,4 @@
 <?php
-/**
- * DynamicPageList3
- * Magic Words
- *
- * @author Alexia E. Smith
- * @license GPL-2.0-or-later
- * @package DynamicPageList3
- *
- */
 
 $magicWords = [];
 
diff --git a/includes/LST.php b/includes/LST.php
index d5af9f88..d2dfdabf 100644
--- a/includes/LST.php
+++ b/includes/LST.php
@@ -29,35 +29,44 @@
 
 use DPL\Lister\Lister;
 use MediaWiki\MediaWikiServices;
+use Parser;
+use Title;
 
 class LST {
-	##############################################################
+	# #############################################################
 	# To do transclusion from an extension, we need to interact with the parser
 	# at a low level. This is the general transclusion functionality
 	##############################################################
 
 	/**
 	 * Register what we're working on in the parser, so we don't fall into a trap.
-	 * @param $parser Parser
+	 *
+	 * @param Parser $parser
 	 * @param $part1
 	 * @return bool
+	 *
+	 * @suppress PhanUndeclaredProperty Use of Parser::mTemplatePath
 	 */
 	public static function open( $parser, $part1 ) {
 		// Infinite loop test
 		if ( isset( $parser->mTemplatePath[$part1] ) ) {
 			wfDebug( __METHOD__ . ": template loop broken at '$part1'\n" );
+
 			return false;
 		} else {
 			$parser->mTemplatePath[$part1] = 1;
+
 			return true;
 		}
 	}
 
 	/**
 	 * Finish processing the function.
-	 * @param $parser Parser
+	 *
+	 * @param Parser $parser
 	 * @param $part1
-	 * @return bool
+	 *
+	 * @suppress PhanUndeclaredProperty Use of Parser::mTemplatePath
 	 */
 	public static function close( $parser, $part1 ) {
 		// Infinite loop test
@@ -72,7 +81,7 @@ public static function close( $parser, $part1 ) {
 	 * Handle recursive substitution here, so we can break cycles, and set up
 	 * return values so that edit sections will resolve correctly.
 	 */
-	private static function parse( $parser, $title, $text, $part1, $skiphead = 0, $recursionCheck = true, $maxLength = -1, $link = '', $trim = false, $skipPattern = [] ) {
+	private static function parse( $parser, $text, $part1, $skiphead = 0, $recursionCheck = true, $maxLength = -1, $link = '', $trim = false, $skipPattern = [] ) {
 		// if someone tries something like<section begin=blah>lst only</section>
 		// text, may as well do the right thing.
 		$text = str_replace( '</section>', '', $text );
@@ -84,9 +93,9 @@ private static function parse( $parser, $title, $text, $part1, $skiphead = 0, $r
 
 		if ( self::open( $parser, $part1 ) ) {
 
-			//Handle recursion here, so we can break cycles.
+			// Handle recursion here, so we can break cycles.
 			if ( $recursionCheck == false ) {
-				$text = $parser->preprocess( $text, $parser->mTitle, $parser->mOptions );
+				$text = $parser->preprocess( $text, $parser->getTitle(), $parser->getOptions() );
 				self::close( $parser, $part1 );
 			}
 
@@ -99,11 +108,11 @@ private static function parse( $parser, $title, $text, $part1, $skiphead = 0, $r
 				return $text;
 			}
 		} else {
-			return "[[" . $title->getPrefixedText() . "]]" . "<!-- WARNING: LST loop detected -->";
+			return "[[" . $parser->getTitle()->getPrefixedText() . "]]" . "<!-- WARNING: LST loop detected -->";
 		}
 	}
 
-	##############################################################
+	# #############################################################
 	# And now, the labeled section transclusion
 	##############################################################
 
@@ -114,16 +123,17 @@ private static function parse( $parser, $title, $text, $part1, $skiphead = 0, $r
 	 * @param string $in
 	 * @param array $assocArgs
 	 * @param Parser $parser
-	 * @return string HTML output
+	 * @return string
 	 */
 	private static function noop( $in, $assocArgs = [], $parser = null ) {
 		return '';
 	}
 
-	///Generate a regex to match the section(s) we're interested in.
+	// Generate a regex to match the section(s) we're interested in.
 	private static function createSectionPattern( $sec, $to, &$any ) {
-		$any    = false;
+		$any = false;
 		$to_sec = ( $to == '' ) ? $sec : $to;
+
 		if ( $sec[0] == '*' ) {
 			$any = true;
 			if ( $sec == '**' ) {
@@ -134,6 +144,7 @@ private static function createSectionPattern( $sec, $to, &$any ) {
 		} else {
 			$sec = preg_quote( $sec, '/' );
 		}
+
 		if ( $to_sec[0] == '*' ) {
 			if ( $to_sec == '**' ) {
 				$to_sec = '[^\/>"' . "']+";
@@ -143,20 +154,21 @@ private static function createSectionPattern( $sec, $to, &$any ) {
 		} else {
 			$to_sec = preg_quote( $to_sec, '/' );
 		}
-		$ws = "(?:\s+[^>]+)?"; //was like $ws="\s*"
+
+		$ws = "(?:\s+[^>]+)?";
+
 		return "/<section$ws\s+(?i:begin)=['\"]?" . "($sec)" . "['\"]?$ws\/?>(.*?)\n?<section$ws\s+(?:[^>]+\s+)?(?i:end)=" . "['\"]?\\1['\"]?" . "$ws\/?>/s";
 	}
 
 	/**
 	 * Count headings in skipped text.
 	 *
-	 * Count skipped headings, so parser (as of r18218) can skip them, to
-	 * prevent wrong heading links (see bug 6563).
+	 * Count skipped headings, so parser can skip them, to
+	 * prevent wrong heading links.
 	 *
 	 * @param string $text
-	 * @param int $limit Cutoff point in the text to stop searching
-	 * @return int Number of matches
-	 * @private
+	 * @param int $limit
+	 * @return int
 	 */
 	private static function countHeadings( $text, $limit ) {
 		$pat = '^(={1,6}).+\1\s*$()';
@@ -164,6 +176,7 @@ private static function countHeadings( $text, $limit ) {
 		$count = 0;
 		$offset = 0;
 		$m = [];
+
 		while ( preg_match( "/$pat/im", $text, $m, PREG_OFFSET_CAPTURE, $offset ) ) {
 			if ( $m[2][1] > $limit ) {
 				break;
@@ -177,7 +190,7 @@ private static function countHeadings( $text, $limit ) {
 	}
 
 	public static function text( $parser, $page, &$title, &$text ) {
-		$title = \Title::newFromText( $page );
+		$title = Title::newFromText( $page );
 
 		if ( $title === null ) {
 			$text = '';
@@ -186,7 +199,7 @@ public static function text( $parser, $page, &$title, &$text ) {
 			$text = $parser->fetchTemplateAndTitle( $title )[0];
 		}
 
-		//if article doesn't exist, return a red link.
+		// if article doesn't exist, return a red link.
 		if ( $text == false ) {
 			$text = "[[" . $title->getPrefixedText() . "]]";
 			return false;
@@ -195,26 +208,30 @@ public static function text( $parser, $page, &$title, &$text ) {
 		}
 	}
 
-	///section inclusion - include all matching sections
+	// section inclusion - include all matching sections
 	public static function includeSection( $parser, $page = '', $sec = '', $to = '', $recursionCheck = true, $trim = false, $skipPattern = [] ) {
 		$output = [];
+
 		if ( self::text( $parser, $page, $title, $text ) == false ) {
 			$output[] = $text;
 			return $output;
 		}
+
 		$any = false;
 		$pat = self::createSectionPattern( $sec, $to, $any );
 
 		preg_match_all( $pat, $text, $m, PREG_PATTERN_ORDER );
 
 		foreach ( $m[2] as $nr => $piece ) {
-			$piece = self::parse( $parser, $title, $piece, "#lst:${page}|${sec}", 0, $recursionCheck, $trim, $skipPattern );
+			$piece = self::parse( $parser, $piece, "#lst:${page}|${sec}", 0, $recursionCheck, $trim, $skipPattern );
+
 			if ( $any ) {
 				$output[] = $m[1][$nr] . '::' . $piece;
 			} else {
 				$output[] = $piece;
 			}
 		}
+
 		return $output;
 	}
 
@@ -225,10 +242,12 @@ public static function includeSection( $parser, $page = '', $sec = '', $to = '',
 	 * ... it is balanced in terms of braces, brackets and tags
 	 * ... it is cut at a word boundary (white space) if possible
 	 * ... can be used as content of a wikitable field without spoiling the whole surrounding wikitext structure
-	 * @param  $lim     limit of character count for the result
-	 * @param  $text    the wikitext to be truncated
-	 * @param  $link    an optional link which will be appended to the text if it was truncatedt
-	 * @return the truncated text;
+	 *
+	 * @param $text the wikitext to be truncated
+	 * @param $limit limit of character count for the result
+	 * @param $link an optional link which will be appended to the text if it was truncated
+	 *
+	 * @return string the truncated text;
 	 *         note that the returned text may be longer than the limit if this is necessary
 	 *         to return something at all. We do not want to return an empty string if the input is not empty
 	 *         if the text is already shorter than the limit, the text
@@ -249,24 +268,29 @@ public static function limitTranscludedText( $text, $limit, $link = '' ) {
 		// search latest position with balanced brackets/braces
 		// store also the position of the last preceding space
 
-		$brackets  = 0;
+		$brackets = 0;
 		$cbrackets = 0;
-		$n0        = -1;
-		$nb        = 0;
+		$n0 = -1;
+		$nb = 0;
+
 		for ( $i = 0; $i < $limit; $i++ ) {
 			$c = $text[$i];
 			if ( $c == '[' ) {
 				$brackets++;
 			}
+
 			if ( $c == ']' ) {
 				$brackets--;
 			}
+
 			if ( $c == '{' ) {
 				$cbrackets++;
 			}
+
 			if ( $c == '}' ) {
 				$cbrackets--;
 			}
+
 			// we store the position if it is valid in terms of parentheses balancing
 			if ( $brackets == 0 && $cbrackets == 0 ) {
 				$n0 = $i;
@@ -279,9 +303,11 @@ public static function limitTranscludedText( $text, $limit, $link = '' ) {
 		// if there is a valid cut-off point we use it; it will be the largest one which is not above the limit
 		if ( $n0 >= 0 ) {
 			// we try to cut off at a word boundary, this may lead to a shortening of max. 15 chars
+			// @phan-suppress-next-line PhanSuspiciousValueComparison
 			if ( $nb > 0 && $nb + 15 > $n0 ) {
 				$n0 = $nb;
 			}
+
 			$cut = substr( $text, 0, $n0 + 1 );
 
 			// an open html comment would be fatal, but this should not happen as we already have
@@ -293,9 +319,9 @@ public static function limitTranscludedText( $text, $limit, $link = '' ) {
 			// currently we ignore the nesting, i.e. all closing tags are appended at the end.
 			// This simple approach may fail in some cases ...
 
-			$matches   = [];
+			$matches = [];
 			$noMatches = preg_match_all( '#<\s*(/?ref|/?pre|/?nowiki)(\s+[^>]*?)*>#im', $cut, $matches );
-			$tags      = [
+			$tags = [
 				'ref' => 0,
 				'pre' => 0,
 				'nowiki' => 0
@@ -310,8 +336,10 @@ public static function limitTranscludedText( $text, $limit, $link = '' ) {
 						$tags[$mm]++;
 					}
 				}
+
 				// append missing closing tags - should the tags be ordered by precedence ?
 				foreach ( $tags as $tagName => $level ) {
+					// @phan-suppress-next-line PhanPluginLoopVariableReuse
 					while ( $level > 0 ) {
 						// avoid empty ref tag
 						if ( $tagName == 'ref' && substr( $cut, strlen( $cut ) - 5 ) == '<ref>' ) {
@@ -319,10 +347,12 @@ public static function limitTranscludedText( $text, $limit, $link = '' ) {
 						} else {
 							$cut .= '</' . $tagName . '>';
 						}
+
 						$level--;
 					}
 				}
 			}
+
 			return $cut . $link;
 		} elseif ( $limit == 0 ) {
 			return $link;
@@ -335,43 +365,57 @@ public static function limitTranscludedText( $text, $limit, $link = '' ) {
 	}
 
 	public static function includeHeading( $parser, $page = '', $sec = '', $to = '', &$sectionHeading, $recursionCheck = true, $maxLength = -1, $link = 'default', $trim = false, $skipPattern = [] ) {
+		// @phan-suppress-previous-line PhanParamReqAfterOpt
+
 		$output = [];
+
 		if ( self::text( $parser, $page, $title, $text ) == false ) {
 			$output[0] = $text;
+
 			return $output;
 		}
-		/* throw away comments */
+
+		// throw away comments
 		$text = preg_replace( '/<!--.*?-->/s', '', $text );
+
 		return self::extractHeadingFromText( $parser, $page, $title, $text, $sec, $to, $sectionHeading, $recursionCheck, $maxLength, $link, $trim, $skipPattern );
 	}
 
-	//section inclusion - include all matching sections (return array)
+	// section inclusion - include all matching sections (return array)
 	public static function extractHeadingFromText( $parser, $page, $title, $text, $sec = '', $to = '', &$sectionHeading, $recursionCheck = true, $maxLength = -1, $cLink = 'default', $trim = false, $skipPattern = [] ) {
+		// @phan-suppress-previous-line PhanParamReqAfterOpt
+
 		$continueSearch = true;
-		$n              = 0;
-		$output[$n]     = '';
-		$nr             = 0;
+		$output = [];
+
+		$n = 0;
+		$output[$n] = '';
+		$nr = 0;
+
 		// check if we are going to fetch the n-th section
 		if ( preg_match( '/^%-?[1-9][0-9]*$/', $sec ) ) {
 			$nr = substr( $sec, 1 );
 		}
+
 		if ( preg_match( '/^%0$/', $sec ) ) {
 			$nr = -2; // transclude text before the first section
 		}
 
 		// if the section name starts with a # or with a @ we use it as regexp, otherwise as plain string
 		$isPlain = true;
+
 		if ( $sec != '' && ( $sec[0] == '#' || $sec[0] == '@' ) ) {
-			$sec     = substr( $sec, 1 );
+			$sec = substr( $sec, 1 );
 			$isPlain = false;
 		}
+
 		do {
-			//Generate a regex to match the === classical heading section(s) === we're
+			// Generate a regex to match the === classical heading section(s) === we're
 			//interested in.
 			$headLine = '';
+			$begin_off = 0;
 			if ( $sec == '' ) {
-				$begin_off = 0;
-				$head_len  = 6;
+				$head_len = 6;
 			} else {
 				if ( $nr != 0 ) {
 					$pat = '^(={1,6})\s*[^=\s\n][^\n=]*\s*\1\s*($)';
@@ -380,12 +424,13 @@ public static function extractHeadingFromText( $parser, $page, $title, $text, $s
 				} else {
 					$pat = '^(={1,6})\s*' . str_replace( '/', '\/', $sec ) . '\s*\1\s*($)';
 				}
+
 				if ( preg_match( "/$pat/im", $text, $m, PREG_OFFSET_CAPTURE ) ) {
-					$mata           = [];
+					$mata = [];
 					$no_parenthesis = preg_match_all( '/\(/', $pat, $mata );
-					$begin_off      = $m[$no_parenthesis][1];
-					$head_len       = strlen( $m[1][0] );
-					$headLine       = trim( $m[0][0], "\n =\t" );
+					$begin_off = $m[$no_parenthesis][1];
+					$head_len = strlen( $m[1][0] );
+					$headLine = trim( $m[0][0], "\n =\t" );
 				} elseif ( $nr == -2 ) {
 					$m[1][1] = strlen( $text ) + 1; // take whole article if no heading found
 				} else {
@@ -393,6 +438,7 @@ public static function extractHeadingFromText( $parser, $page, $title, $text, $s
 					return $output;
 				}
 			}
+
 			// create a link symbol (arrow, img, ...) in case we have to cut the text block to maxLength
 			$link = $cLink;
 			if ( $link == 'default' ) {
@@ -404,33 +450,40 @@ public static function extractHeadingFromText( $parser, $page, $title, $text, $s
 			} else {
 				$link = str_replace( '%SECTION%', $page . '#' . $headLine, $link );
 			}
+
 			if ( $nr == -2 ) {
 				// output text before first section and done
-				$piece     = substr( $text, 0, $m[1][1] - 1 );
-				$output[0] = self::parse( $parser, $title, $piece, "#lsth:${page}|${sec}", 0, $recursionCheck, $maxLength, $link, $trim, $skipPattern );
+				$piece = substr( $text, 0, $m[1][1] - 1 );
+				$output[0] = self::parse( $parser, $piece, "#lsth:${page}|${sec}", 0, $recursionCheck, $maxLength, $link, $trim, $skipPattern );
+
 				return $output;
 			}
 
 			if ( isset( $end_off ) ) {
 				unset( $end_off );
 			}
+
 			if ( $to != '' ) {
-				//if $to is supplied, try and match it.  If we don't match, just ignore it.
+				// if $to is supplied, try and match it. If we don't match, just ignore it.
 				if ( $isPlain ) {
 					$pat = '^(={1,6})\s*' . preg_quote( $to, '/' ) . '\s*\1\s*$';
 				} else {
 					$pat = '^(={1,6})\s*' . str_replace( '/', '\/', $to ) . '\s*\1\s*$';
 				}
+
 				if ( preg_match( "/$pat/im", $text, $mm, PREG_OFFSET_CAPTURE, $begin_off ) ) {
 					$end_off = $mm[0][1] - 1;
 				}
 			}
+
 			if ( !isset( $end_off ) ) {
 				if ( $nr != 0 ) {
 					$pat = '^(={1,6})\s*[^\s\n=][^\n=]*\s*\1\s*$';
 				} else {
+					// @phan-suppress-next-line PhanPossiblyUndeclaredVariable
 					$pat = '^(={1,' . $head_len . '})(?!=)\s*.*?\1\s*$';
 				}
+
 				if ( preg_match( "/$pat/im", $text, $mm, PREG_OFFSET_CAPTURE, $begin_off ) ) {
 					$end_off = $mm[0][1] - 1;
 				} elseif ( $sec == '' ) {
@@ -439,12 +492,14 @@ public static function extractHeadingFromText( $parser, $page, $title, $text, $s
 			}
 
 			$nhead = self::countHeadings( $text, $begin_off );
+
 			wfDebug( "LSTH: head offset = $nhead" );
 
 			if ( isset( $end_off ) ) {
 				if ( $end_off == -1 ) {
 					return $output;
 				}
+
 				$piece = substr( $text, $begin_off, $end_off - $begin_off );
 				if ( $sec == '' ) {
 					$continueSearch = false;
@@ -452,7 +507,7 @@ public static function extractHeadingFromText( $parser, $page, $title, $text, $s
 					$text = substr( $text, $end_off );
 				}
 			} else {
-				$piece          = substr( $text, $begin_off );
+				$piece = substr( $text, $begin_off );
 				$continueSearch = false;
 			}
 
@@ -464,27 +519,25 @@ public static function extractHeadingFromText( $parser, $page, $title, $text, $s
 
 			if ( isset( $m[0][0] ) ) {
 				$sectionHeading[$n] = $headLine;
-				//$sectionHeading[$n]=preg_replace("/^=+\s*/","",$m[0][0]);
-				//$sectionHeading[$n]=preg_replace("/\s*=+\s*$/","",$sectionHeading[$n]);
 			} else {
-				// $sectionHeading[$n] = '';
 				$sectionHeading[0] = $headLine;
 			}
 
 			if ( $nr == 1 ) {
 				// output n-th section and done
-				$output[0] = self::parse( $parser, $title, $piece, "#lsth:${page}|${sec}", $nhead, $recursionCheck, $maxLength, $link, $trim, $skipPattern );
+				$output[0] = self::parse( $parser, $piece, "#lsth:${page}|${sec}", $nhead, $recursionCheck, $maxLength, $link, $trim, $skipPattern );
 				break;
 			}
+
 			if ( $nr == -1 ) {
 				if ( !isset( $end_off ) ) {
 					// output last section and done
-					$output[0] = self::parse( $parser, $title, $piece, "#lsth:${page}|${sec}", $nhead, $recursionCheck, $maxLength, $link, $trim, $skipPattern );
+					$output[0] = self::parse( $parser, $piece, "#lsth:${page}|${sec}", $nhead, $recursionCheck, $maxLength, $link, $trim, $skipPattern );
 					break;
 				}
 			} else {
 				// output section by name and continue search for another section with the same name
-				$output[$n++] = self::parse( $parser, $title, $piece, "#lsth:${page}|${sec}", $nhead, $recursionCheck, $maxLength, $link, $trim, $skipPattern );
+				$output[$n++] = self::parse( $parser, $piece, "#lsth:${page}|${sec}", $nhead, $recursionCheck, $maxLength, $link, $trim, $skipPattern );
 			}
 		} while ( $continueSearch );
 
@@ -497,21 +550,26 @@ public static function extractHeadingFromText( $parser, $page, $title, $text, $s
 	// and do NOT match the condition "$mustNotMatch" (if specified)
 	// we use a callback function to format retrieved parameters, accessible via $lister->formatTemplateArg()
 	public static function includeTemplate( $parser, Lister $lister, $dplNr, $article, $template1 = '', $template2 = '', $defaultTemplate, $mustMatch, $mustNotMatch, $matchParsed, $catlist ) {
-		$page  = $article->mTitle->getPrefixedText();
-		$date  = $article->myDate;
-		$user  = $article->mUserLink;
-		$title = \Title::newFromText( $page );
-		/* get text and throw away html comments */
+		// @phan-suppress-previous-line PhanParamReqAfterOpt
+
+		$page = $article->mTitle->getPrefixedText();
+		$date = $article->myDate;
+		$user = $article->mUserLink;
+		$title = Title::newFromText( $page );
+
+		// get text and throw away html comments
 		$text = preg_replace( '/<!--.*?-->/s', '', $parser->fetchTemplateAndTitle( $title )[0] );
 
 		if ( $template1 != '' && $template1[0] == '#' ) {
 			// --------------------------------------------- looking for a parser function call
-			$template1       = substr( $template1, 1 );
-			$template2       = substr( $template2, 1 );
+			$template1 = substr( $template1, 1 );
+			$template2 = substr( $template2, 1 );
 			$defaultTemplate = substr( $defaultTemplate, 1 );
+
 			// when looking for parser function calls we accept regexp search patterns
-			$text2           = preg_replace( "/\{\{\s*#(" . $template1 . ')(\s*[:}])/i', '|%PFUNC%=\1\2|', $text );
-			$tCalls          = preg_split( '//', ' ' . $text2 );
+			$text2 = preg_replace( "/\{\{\s*#(" . $template1 . ')(\s*[:}])/i', '|%PFUNC%=\1\2|', $text );
+			$tCalls = preg_split( '//', ' ' . $text2 );
+
 			foreach ( $tCalls as $i => $tCall ) {
 				if ( ( $n = strpos( $tCall, ':' ) ) !== false ) {
 					$tCalls[$i][$n] = ' ';
@@ -519,12 +577,14 @@ public static function includeTemplate( $parser, Lister $lister, $dplNr, $articl
 			}
 		} elseif ( $template1 != '' && $template1[0] == '~' ) {
 			// --------------------------------------------- looking for an xml-tag extension call
-			$template1       = substr( $template1, 1 );
-			$template2       = substr( $template2, 1 );
+			$template1 = substr( $template1, 1 );
+			$template2 = substr( $template2, 1 );
 			$defaultTemplate = substr( $defaultTemplate, 1 );
+
 			// looking for tags
-			$text2           = preg_replace( '/\<\s*(' . $template1 . ')\s*\>/i', '|%TAG%=\1|%TAGBODY%=', $text );
-			$tCalls          = preg_split( '//', ' ' . $text2 );
+			$text2 = preg_replace( '/\<\s*(' . $template1 . ')\s*\>/i', '|%TAG%=\1|%TAGBODY%=', $text );
+			$tCalls = preg_split( '//', ' ' . $text2 );
+
 			foreach ( $tCalls as $i => $tCall ) {
 				$tCalls[$i] = preg_replace( '/\<\s*\/' . $template1 . '\s*\>.*/is', '}}', $tCall );
 			}
@@ -536,7 +596,8 @@ public static function includeTemplate( $parser, Lister $lister, $dplNr, $articl
 			$contLang = MediaWikiServices::getInstance()->getContentLanguage();
 
 			$nsNames = $contLang->getNamespaces();
-			$tCalls  = preg_split( '/\{\{\s*(Template:|' . $nsNames[10] . ':)?' . self::spaceOrUnderscore( preg_quote( $template1, '/' ) ) . '\s*[|}]/i', ' ' . $text );
+			$tCalls = preg_split( '/\{\{\s*(Template:|' . $nsNames[10] . ':)?' . self::spaceOrUnderscore( preg_quote( $template1, '/' ) ) . '\s*[|}]/i', ' ' . $text );
+
 			// We restore the first separator symbol (we had to include that symbol into the SPLIT, because we must make
 			// sure that we only accept exact matches of the complete template name
 			// (e.g. when looking for "foo" we must not accept "foo xyz")
@@ -549,7 +610,7 @@ public static function includeTemplate( $parser, Lister $lister, $dplNr, $articl
 			}
 		}
 
-		$output      = [];
+		$output = [];
 		$extractParm = [];
 
 		// check if we want to extract parameters directly from the call
@@ -565,6 +626,7 @@ public static function includeTemplate( $parser, Lister $lister, $dplNr, $articl
 				// if parameters are required directly: return empty columns
 				if ( count( $extractParm ) > 1 ) {
 					$output[0] = $lister->formatTemplateArg( '', $dplNr, 0, true, -1, $article );
+
 					for ( $i = 1; $i < count( $extractParm ); $i++ ) {
 						$output[0] .= "\n|" . $lister->formatTemplateArg( '', $dplNr, $i, true, -1, $article );
 					}
@@ -573,134 +635,164 @@ public static function includeTemplate( $parser, Lister $lister, $dplNr, $articl
 				}
 			} else {
 				// put a red link into the output
-				$output[0] = $parser->preprocess( '{{' . $defaultTemplate . '|%PAGE%=' . $page . '|%TITLE%=' . $title->getText() . '|%DATE%=' . $date . '|%USER%=' . $user . '}}', $parser->mTitle, $parser->mOptions );
+				$output[0] = $parser->preprocess( '{{' . $defaultTemplate . '|%PAGE%=' . $page . '|%TITLE%=' . $title->getText() . '|%DATE%=' . $date . '|%USER%=' . $user . '}}', $parser->getTitle(), $parser->getOptions() );
 			}
+
 			unset( $title );
+
 			return $output;
 		}
 
 		$output[0] = '';
-		$n         = -2;
+		$n = -2;
+
 		// loop for all template invocations
 		$firstCall = true;
+
 		foreach ( $tCalls as $iii => $tCall ) {
 			if ( $n == -2 ) {
 				$n++;
 				continue;
 			}
+
 			$c = $tCall[0];
 			// normally we construct a call for template2 with the parameters of template1
 			if ( count( $extractParm ) == 0 ) {
 				// find the end of the call: bracket level must be zero
-				$cbrackets    = 0;
+				$cbrackets = 0;
 				$templateCall = '{{' . $template2 . $tCall;
-				$size         = strlen( $templateCall );
+				$size = strlen( $templateCall );
 
 				for ( $i = 0; $i < $size; $i++ ) {
 					$c = $templateCall[$i];
 					if ( $c == '{' ) {
 						$cbrackets++;
 					}
+
 					if ( $c == '}' ) {
 						$cbrackets--;
 					}
+
 					if ( $cbrackets == 0 ) {
 						// if we must match a condition: test against it
 						if ( ( $mustMatch == '' || preg_match( $mustMatch, substr( $templateCall, 0, $i - 1 ) ) ) && ( $mustNotMatch == '' || !preg_match( $mustNotMatch, substr( $templateCall, 0, $i - 1 ) ) ) ) {
 							$invocation = substr( $templateCall, 0, $i - 1 );
-							$argChain   = $invocation . '|%PAGE%=' . $page . '|%TITLE%=' . $title->getText();
+							$argChain = $invocation . '|%PAGE%=' . $page . '|%TITLE%=' . $title->getText();
+
 							if ( $catlist != '' ) {
 								$argChain .= "|%CATLIST%=$catlist";
 							}
+
 							$argChain .= '|%DATE%=' . $date . '|%USER%=' . $user . '|%ARGS%=' . str_replace( '|', '', preg_replace( '/[}]+/', '}', preg_replace( '/[{]+/', '{', substr( $invocation, strlen( $template2 ) + 2 ) ) ) ) . '}}';
-							$output[++$n] = $parser->preprocess( $argChain, $parser->mTitle, $parser->mOptions );
+							$output[++$n] = $parser->preprocess( $argChain, $parser->getTitle(), $parser->getOptions() );
 						}
 						break;
 					}
 				}
 			} else {
 				// if the user wants parameters directly from the call line of template1 we return just those
-				$cbrackets    = 2;
+				$cbrackets = 2;
 				$templateCall = $tCall;
-				$size         = strlen( $templateCall );
-				$parms        = [];
-				$parm         = '';
-				$hasParm      = false;
+				$size = strlen( $templateCall );
+				$parms = [];
+				$parm = '';
+				$hasParm = false;
 
 				for ( $i = 0; $i < $size; $i++ ) {
 					$c = $templateCall[$i];
+
 					if ( $c == '{' || $c == '[' ) {
 						$cbrackets++; // we count both types of brackets
 					}
+
 					if ( $c == '}' || $c == ']' ) {
 						$cbrackets--;
 					}
+
 					if ( $cbrackets == 2 && $c == '|' ) {
 						$parms[] = trim( $parm );
 						$hasParm = true;
-						$parm    = '';
+						$parm = '';
 					} else {
 						$parm .= $c;
 					}
+
 					if ( $cbrackets == 0 ) {
 						if ( $hasParm ) {
 							$parms[] = trim( substr( $parm, 0, strlen( $parm ) - 2 ) );
 						}
-						array_splice( $parms, 0, 1 ); // remove artifact;
+
+						array_splice( $parms, 0, 1 );
 						// if we must match a condition: test against it
 						$callText = substr( $templateCall, 0, $i - 1 );
+
 						if ( ( $mustMatch == '' || ( ( $matchParsed && preg_match( $mustMatch, $parser->recursiveTagParse( $callText ) ) ) || ( !$matchParsed && preg_match( $mustMatch, $callText ) ) ) ) && ( $mustNotMatch == '' || ( ( $matchParsed && !preg_match( $mustNotMatch, $parser->recursiveTagParse( $callText ) ) ) || ( !$matchParsed && !preg_match( $mustNotMatch, $callText ) ) ) ) ) {
 							$output[++$n] = '';
-							$second       = false;
+							$second = false;
+
 							foreach ( $extractParm as $exParmKey => $exParm ) {
 								$maxlen = -1;
 								if ( ( $limpos = strpos( $exParm, '[' ) ) > 0 && $exParm[strlen( $exParm ) - 1] == ']' ) {
 									$maxlen = intval( substr( $exParm, $limpos + 1, strlen( $exParm ) - $limpos - 2 ) );
 									$exParm = substr( $exParm, 0, $limpos );
 								}
+
 								if ( $second ) {
+									// @phan-suppress-next-line PhanTypeInvalidDimOffset
 									if ( $output[$n] == '' || $output[$n][strlen( $output[$n] ) - 1] != "\n" ) {
 										$output[$n] .= "\n";
 									}
+
 									$output[$n] .= "|"; // \n";
 								}
+
 								$found = false;
+
 								// % in parameter name
 								if ( strpos( $exParm, '%' ) !== false ) {
 									// %% is a short form for inclusion of %PAGE% and %TITLE%
 									$found = true;
 									$output[$n] .= $lister->formatTemplateArg( $exParm, $dplNr, $exParmKey, $firstCall, $maxlen, $article );
 								}
+
 								if ( !$found ) {
 									// named parameter
 									$exParmQuote = str_replace( '/', '\/', $exParm );
+
 									foreach ( $parms as $parm ) {
 										if ( !preg_match( "/^\s*$exParmQuote\s*=/", $parm ) ) {
 											continue;
 										}
+
 										$found = true;
 										$output[$n] .= $lister->formatTemplateArg( preg_replace( "/^$exParmQuote\s*=\s*/", "", $parm ), $dplNr, $exParmKey, $firstCall, $maxlen, $article );
 										break;
 									}
 								}
+
 								if ( !$found && is_numeric( $exParm ) && intval( $exParm ) == $exParm ) {
 									// numeric parameter
 									$np = 0;
+
 									foreach ( $parms as $parm ) {
 										if ( strstr( $parm, '=' ) === false ) {
 											++$np;
 										}
+
 										if ( $np != $exParm ) {
 											continue;
 										}
+
 										$found = true;
 										$output[$n] .= $lister->formatTemplateArg( $parm, $dplNr, $exParmKey, $firstCall, $maxlen, $article );
 										break;
 									}
 								}
+
 								if ( !$found ) {
 									$output[$n] .= $lister->formatTemplateArg( '', $dplNr, $exParmKey, $firstCall, $maxlen, $article );
 								}
+
 								$second = true;
 							}
 						}
@@ -708,6 +800,7 @@ public static function includeTemplate( $parser, Lister $lister, $dplNr, $articl
 					}
 				}
 			}
+
 			$firstCall = false;
 		}
 
diff --git a/includes/Logger.php b/includes/Logger.php
index 2484da3a..28bb9651 100644
--- a/includes/Logger.php
+++ b/includes/Logger.php
@@ -1,13 +1,5 @@
 <?php
-/**
- * DynamicPageList3
- * DPL Logger Class
- *
- * @author		IlyaHaykinson, Unendlich, Dangerville, Algorithmix, Theaitetos, Alexia E. Smith
- * @license		GPL-2.0-or-later
- * @package		DynamicPageList3
- *
- */
+
 namespace DPL;
 
 class Logger {
@@ -18,63 +10,57 @@ class Logger {
 	 */
 	private $buffer = [];
 
-	/**
-	 * Function Documentation
-	 *
-	 * @access	public
-	 * @return	void
-	 */
-	public function addMessage( $errorId ) {
+	public function addMessage() {
 		$args = func_get_args();
 		$args = array_map( 'htmlspecialchars', $args );
-		return call_user_func_array( [ $this, 'msg' ], $args );
+
+		call_user_func_array( [ $this, 'msg' ], $args );
 	}
 
 	/**
 	 * Return the buffer of messages.
 	 *
-	 * @access	public
-	 * @param	boolean	[Optional] Clear the message buffer.
-	 * @return	array	Messages in the order added.
+	 * @param bool $clearBuffer
+	 * @return array
 	 */
 	public function getMessages( $clearBuffer = true ) {
 		$buffer = $this->buffer;
+
 		if ( $clearBuffer === true ) {
 			$this->buffer = [];
 		}
+
 		return $buffer;
 	}
 
 	/**
 	 * Get a message, with optional parameters
 	 * Parameters from user input must be escaped for HTML *before* passing to this function
-	 *
-	 * @access	public
-	 * @param	integer	Message ID
-	 * @return	string
 	 */
 	public function msg() {
 		$args = func_get_args();
 		$errorId = array_shift( $args );
 		$errorLevel = floor( $errorId / 1000 );
 		$errorMessageId = $errorId % 1000;
-		if ( \DynamicPageListHooks::getDebugLevel() >= $errorLevel ) {
-			if ( \DynamicPageListHooks::isLikeIntersection() ) {
-				if ( $errorId == \DynamicPageListHooks::FATAL_TOOMANYCATS ) {
+
+		if ( DynamicPageListHooks::getDebugLevel() >= $errorLevel ) {
+			if ( DynamicPageListHooks::isLikeIntersection() ) {
+				if ( $errorId == DynamicPageListHooks::FATAL_TOOMANYCATS ) {
 					$text = wfMessage( 'intersection_toomanycats', $args )->text();
-				} elseif ( $errorId == \DynamicPageListHooks::FATAL_TOOFEWCATS ) {
+				} elseif ( $errorId == DynamicPageListHooks::FATAL_TOOFEWCATS ) {
 					$text = wfMessage( 'intersection_toofewcats', $args )->text();
-				} elseif ( $errorId == \DynamicPageListHooks::WARN_NORESULTS ) {
+				} elseif ( $errorId == DynamicPageListHooks::WARN_NORESULTS ) {
 					$text = wfMessage( 'intersection_noresults', $args )->text();
-				} elseif ( $errorId == \DynamicPageListHooks::FATAL_NOSELECTION ) {
+				} elseif ( $errorId == DynamicPageListHooks::FATAL_NOSELECTION ) {
 					$text = wfMessage( 'intersection_noincludecats', $args )->text();
 				}
 			}
+
 			if ( empty( $text ) ) {
 				$text = wfMessage( 'dpl_log_' . $errorMessageId, $args )->text();
 			}
-			$this->buffer[] = '<p>Extension:DynamicPageList (DPL), version ' . DPL_VERSION . ': ' . $text . '</p>';
+
+			$this->buffer[] = '<p>Extension:DynamicPageList (DPL), version ' . DynamicPageListHooks::getVersion() . ': ' . $text . '</p>';
 		}
-		return false;
 	}
 }
diff --git a/includes/Parameters.php b/includes/Parameters.php
index 614fa926..992cf75e 100644
--- a/includes/Parameters.php
+++ b/includes/Parameters.php
@@ -1,17 +1,12 @@
 <?php
-/**
- * DynamicPageList3
- * DPL Variables Class
- *
- * @author IlyaHaykinson, Unendlich, Dangerville, Algorithmix, Theaitetos, Alexia E. Smith
- * @license GPL-2.0-or-later
- * @package DynamicPageList3
- *
- */
 
 namespace DPL;
 
 use MediaWiki\MediaWikiServices;
+use MWException;
+use PermissionsError;
+use RequestContext;
+use Title;
 
 class Parameters extends ParametersData {
 	/**
@@ -42,21 +37,17 @@ class Parameters extends ParametersData {
 	 */
 	private $parametersProcessed = [];
 
-	/**
-	 * Main Constructor
-	 *
-	 * @return void
-	 */
 	public function __construct() {
 		parent::__construct();
+
 		$this->setDefaults();
 	}
 
 	/**
 	 * Handle simple parameter functions.
 	 *
-	 * @param string $parameter Function(Parameter) Called
-	 * @param string $arguments Function Arguments
+	 * @param string $parameter
+	 * @param mixed $arguments
 	 * @return bool
 	 */
 	public function __call( $parameter, $arguments ) {
@@ -68,16 +59,17 @@ public function __call( $parameter, $arguments ) {
 
 		// Check permission to use this parameter.
 		if ( array_key_exists( 'permission', $parameterData ) ) {
-			global $wgUser;
-			if ( !$wgUser->isAllowed( $parameterData['permission'] ) ) {
-				throw new \PermissionsError( $parameterData['permission'] );
-				return;
+			$user = RequestContext::getMain()->getUser();
+
+			if ( !$user->isAllowed( $parameterData['permission'] ) ) {
+				throw new PermissionsError( $parameterData['permission'] );
 			}
 		}
 
-		// Subvert to the real function if it exists.  This keeps code elsewhere clean from needed to check if it exists first.
-		$function = "_" . $parameter;
+		// Subvert to the real function if it exists. This keeps code elsewhere clean from needed to check if it exists first.
+		$function = '_' . $parameter;
 		$this->parametersProcessed[$parameter] = true;
+
 		if ( method_exists( $this, $function ) ) {
 			return call_user_func_array( [ $this, $function ], $arguments );
 		}
@@ -118,6 +110,7 @@ public function __call( $parameter, $arguments ) {
 			// Booleans
 			if ( array_key_exists( 'boolean', $parameterData ) && $parameterData['boolean'] === true ) {
 				$option = $this->filterBoolean( $option );
+
 				if ( $option === null ) {
 					$success = false;
 				}
@@ -126,6 +119,7 @@ public function __call( $parameter, $arguments ) {
 			// Timestamps
 			if ( array_key_exists( 'timestamp', $parameterData ) && $parameterData['timestamp'] === true ) {
 				$option = strtolower( $option );
+
 				switch ( $option ) {
 					case 'today':
 					case 'last hour':
@@ -148,10 +142,13 @@ public function __call( $parameter, $arguments ) {
 			// List of Pages
 			if ( array_key_exists( 'page_name_list', $parameterData ) && $parameterData['page_name_list'] === true ) {
 				$pageGroups = $this->getParameter( $parameter );
+
 				if ( !is_array( $pageGroups ) ) {
 					$pageGroups = [];
 				}
+
 				$pages = $this->getPageNameList( $option, (bool)$parameterData['page_name_must_exist'] );
+
 				if ( $pages === false ) {
 					$success = false;
 				} else {
@@ -163,7 +160,7 @@ public function __call( $parameter, $arguments ) {
 			// Regex Pattern Matching
 			if ( array_key_exists( 'pattern', $parameterData ) ) {
 				if ( preg_match( $parameterData['pattern'], $option, $matches ) ) {
-					//Nuke the total pattern match off the beginning of the array.
+					// Nuke the total pattern match off the beginning of the array.
 					array_shift( $matches );
 					$option = $matches;
 				} else {
@@ -177,15 +174,15 @@ public function __call( $parameter, $arguments ) {
 			}
 
 			// If none of the above checks marked this as a failure then set it.
-			if ( $success === true ) {
+			if ( $success ) {
 				$this->setParameter( $parameter, $option );
 
-				//Set that criteria was found for a selection.
+				// Set that criteria was found for a selection.
 				if ( array_key_exists( 'set_criteria_found', $parameterData ) && $parameterData['set_criteria_found'] === true ) {
 					$this->setSelectionCriteriaFound( true );
 				}
 
-				//Set open references conflict possibility.
+				// Set open references conflict possibility.
 				if ( array_key_exists( 'open_ref_conflict', $parameterData ) && $parameterData['open_ref_conflict'] === true ) {
 					$this->setOpenReferencesConflict( true );
 				}
@@ -197,28 +194,29 @@ public function __call( $parameter, $arguments ) {
 
 	/**
 	 * Sort cleaned parameter arrays by priority.
-	 * Users can not be told to put the parameters into a specific order each time.  Some parameters are dependent on each other coming in a certain order due to some procedural legacy issues.
+	 * Users can not be told to put the parameters into a specific order each time. Some parameters are dependent on each other coming in a certain order due to some procedural legacy issues.
 	 *
 	 * @param array	$parameters
 	 * @return array
 	 */
 	public static function sortByPriority( $parameters ) {
 		if ( !is_array( $parameters ) ) {
-			throw new \MWException( __METHOD__ . ': A non-array was passed.' );
+			throw new MWException( __METHOD__ . ': A non-array was passed.' );
 		}
-		//'category' to get category headings first for ordermethod.
-		//'include'/'includepage' to make sure section labels are ready for 'table'.
+
+		// 'category' to get category headings first for ordermethod.
+		// 'include'/'includepage' to make sure section labels are ready for 'table'.
 		$priority = [
-			'distinct'			=> 1,
-			'openreferences'	=> 2,
-			'ignorecase'		=> 3,
-			'category'			=> 4,
-			'title'				=> 5,
-			'goal'				=> 6,
-			'ordercollation'	=> 7,
-			'ordermethod'		=> 8,
-			'includepage'		=> 9,
-			'include'			=> 10
+			'distinct' => 1,
+			'openreferences' => 2,
+			'ignorecase' => 3,
+			'category' => 4,
+			'title' => 5,
+			'goal' => 6,
+			'ordercollation' => 7,
+			'ordermethod' => 8,
+			'includepage' => 9,
+			'include' => 10
 		];
 
 		$_first = [];
@@ -237,7 +235,7 @@ public static function sortByPriority( $parameters ) {
 	/**
 	 * Set Selection Criteria Found
 	 *
-	 * @param bool $found|true
+	 * @param bool $found
 	 * @return void
 	 */
 	private function setSelectionCriteriaFound( $found = true ) {
@@ -282,9 +280,6 @@ public function isOpenReferencesConflict() {
 
 	/**
 	 * Set default parameters based on ParametersData.
-	 *
-	 * @private
-	 * @return void
 	 */
 	private function setDefaults() {
 		$this->setParameter( 'defaulttemplatesuffix', '.default' );
@@ -293,8 +288,9 @@ private function setDefaults() {
 		foreach ( $parameters as $parameter ) {
 			if ( $this->getData( $parameter )['default'] !== null && !( $this->getData( $parameter )['default'] === false && $this->getData( $parameter )['boolean'] === true ) ) {
 				if ( $parameter == 'debug' ) {
-					\DynamicPageListHooks::setDebugLevel( $this->getData( $parameter )['default'] );
+					DynamicPageListHooks::setDebugLevel( $this->getData( $parameter )['default'] );
 				}
+
 				$this->setParameter( $parameter, $this->getData( $parameter )['default'] );
 			}
 		}
@@ -305,7 +301,6 @@ private function setDefaults() {
 	 *
 	 * @param string $parameter
 	 * @param mixed	$option
-	 * @return void
 	 */
 	public function setParameter( $parameter, $option ) {
 		$this->parameterOptions[$parameter] = $option;
@@ -324,7 +319,7 @@ public function getParameter( $parameter ) {
 	/**
 	 * Get all parameters.
 	 *
-	 * @return array Parameter => Options
+	 * @return array
 	 */
 	public function getAllParameters() {
 		return self::sortByPriority( $this->parameterOptions );
@@ -333,7 +328,7 @@ public function getAllParameters() {
 	/**
 	 * Filter a standard boolean like value into an actual boolean.
 	 *
-	 * @param mixed	Integer or string to evaluated through filter_var().
+	 * @param int|string|bool $boolean
 	 * @return bool
 	 */
 	public function filterBoolean( $boolean ) {
@@ -343,9 +338,8 @@ public function filterBoolean( $boolean ) {
 	/**
 	 * Strip <html> tags.
 	 *
-	 * @private
-	 * @param string $text Dirty Text
-	 * @return string $text Clean Text
+	 * @param string $text
+	 * @return string
 	 */
 	private function stripHtmlTags( $text ) {
 		$text = preg_replace( "#<.*?html.*?>#is", "", $text );
@@ -356,25 +350,29 @@ private function stripHtmlTags( $text ) {
 	/**
 	 * Get a list of valid page names.
 	 *
-	 * @private
-	 * @param string Raw Text of Pages
-	 * @param bool [Optional] Each Title MUST Exist
-	 * @return mixed List of page titles or false on error.
+	 * @param string $text
+	 * @param bool $mustExist
+	 * @return array|bool
 	 */
 	private function getPageNameList( $text, $mustExist = true ) {
 		$list = [];
 		$pages = explode( '|', trim( $text ) );
+
 		foreach ( $pages as $page ) {
 			$page = trim( $page );
-			$page = rtrim( $page, '\\' ); //This was fixed from the original code, but I am not sure what its intended purpose was.
+			$page = rtrim( $page, '\\' );
+
 			if ( empty( $page ) ) {
 				continue;
 			}
+
 			if ( $mustExist === true ) {
-				$title = \Title::newFromText( $page );
+				$title = Title::newFromText( $page );
+
 				if ( !$title ) {
 					return false;
 				}
+
 				$list[] = $title;
 			} else {
 				$list[] = $page;
@@ -387,9 +385,8 @@ private function getPageNameList( $text, $mustExist = true ) {
 	/**
 	 * Check if a regular expression is valid.
 	 *
-	 * @private
-	 * @param mixed	Regular Expression(s) in an array or a single expression in a string.
-	 * @param bool Is this a database REGEXP?
+	 * @param array|string $regexes
+	 * @param bool $forDb
 	 * @return bool
 	 */
 	private function isRegexValid( $regexes, $forDb = false ) {
@@ -401,11 +398,17 @@ private function isRegexValid( $regexes, $forDb = false ) {
 			if ( empty( trim( $regex ) ) ) {
 				continue;
 			}
+
 			if ( $forDb ) {
 				$regex = '#' . str_replace( '#', '\#', $regex ) . '#';
 			}
-			//Purposely silencing the errors here since we are testing if preg_match would throw an error due to a bad regex from user input.
+
+			// Purposely silencing the errors here since we are testing if preg_match
+			// would throw an error due to a bad regex from user input.
+
+			// phpcs:ignore Generic.PHP.NoSilencedErrors.Discouraged
 			if ( @preg_match( $regex, null ) === false ) {
+				// @phan-suppress-previous-line PhanParamSuspiciousOrder, PhanTypeMismatchArgumentInternalProbablyReal
 				return false;
 			}
 		}
@@ -416,30 +419,34 @@ private function isRegexValid( $regexes, $forDb = false ) {
 	/**
 	 * Clean and test 'category' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _category( $option ) {
 		$option = trim( $option );
+
 		if ( empty( $option ) ) {
 			return false;
 		}
 
 		// Init array of categories to include
 		$categories = [];
-		$heading    = false;
+		$heading = false;
 		$notHeading = false;
+
 		if ( substr( $option, 0, 1 ) == '+' ) { // categories are headings
 			$heading = true;
 			$option = ltrim( $option, '+' );
 		}
+
 		if ( substr( $option, 0, 1 ) == '-' ) { // categories are NOT headings
 			$notHeading = true;
 			$option = ltrim( $option, '-' );
 		}
 
-		//We expand html entities because they contain an '& 'which would be interpreted as an AND condition
+		// We expand html entities because they contain an '& 'which would be interpreted as an AND condition
 		$option = html_entity_decode( $option, ENT_QUOTES );
+
 		if ( strpos( $option, '|' ) !== false ) {
 			$parameters = explode( '|', $option );
 			$operator = 'OR';
@@ -447,8 +454,10 @@ public function _category( $option ) {
 			$parameters = explode( '&', $option );
 			$operator = 'AND';
 		}
+
 		foreach ( $parameters as $parameter ) {
 			$parameter = trim( $parameter );
+
 			if ( $parameter === '_none_' || $parameter === '' ) {
 				$this->setParameter( 'includeuncat', true );
 				$categories[] = '';
@@ -461,55 +470,68 @@ public function _category( $option ) {
 						$parameter = substr( $parameter, 1 );
 						$subCategories = Query::getSubcategories( $parameter, 1 );
 					}
+
 					$subCategories[] = $parameter;
 					foreach ( $subCategories as $subCategory ) {
-						$title = \Title::newFromText( $subCategory );
+						$title = Title::newFromText( $subCategory );
+
 						if ( $title !== null ) {
-							//The * helper is just like listing "Category1|SubCategory1".  This gets hard coded here for this purpose.
+							// The * helper is just like listing "Category1|SubCategory1". This gets hard coded here for this purpose.
 							$categories['OR'][] = $title->getDbKey();
 						}
 					}
 				} else {
-					$title = \Title::newFromText( $parameter );
+					$title = Title::newFromText( $parameter );
+
 					if ( $title !== null ) {
 						$categories[$operator][] = $title->getDbKey();
 					}
 				}
 			}
 		}
+
 		if ( !empty( $categories ) ) {
 			$data = $this->getParameter( 'category' );
-			//Do a bunch of data integrity checks to avoid E_NOTICE.
+
+			// Do a bunch of data integrity checks to avoid E_NOTICE.
 			if ( !is_array( $data ) ) {
 				$data = [];
 			}
+
 			if ( !array_key_exists( '=', $data ) || !is_array( $data['='] ) ) {
 				$data['='] = [];
 			}
+
 			foreach ( $categories as $_operator => $_categories ) {
 				if ( !array_key_exists( $_operator, $data['='] ) || !is_array( $data['='][$_operator] ) ) {
 					$data['='][$_operator] = [];
 				}
+
 				$data['='][$_operator][] = $_categories;
 			}
+
 			$this->setParameter( 'category', $data );
 			if ( $heading ) {
 				$this->setParameter( 'catheadings', array_unique( array_merge( ( is_array( $this->getParameter( 'catheadings' ) ) ? $this->getParameter( 'catheadings' ) : [] ), $categories ) ) );
 			}
+
 			if ( $notHeading ) {
 				$this->setParameter( 'catnotheadings', array_unique( array_merge( ( is_array( $this->getParameter( 'catnotheadings' ) ) ? $this->getParameter( 'catnotheadings' ) : [] ), $categories ) ) );
 			}
+
 			$this->setOpenReferencesConflict( true );
+
 			return true;
 		}
+
 		return false;
 	}
 
 	/**
 	 * Clean and test 'categoryregexp' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _categoryregexp( $option ) {
 		if ( !$this->isRegexValid( $option, true ) ) {
@@ -517,18 +539,21 @@ public function _categoryregexp( $option ) {
 		}
 
 		$data = $this->getParameter( 'category' );
-		//REGEXP input only supports AND operator.
-		$data['REGEXP']['AND'][] = [ $option ]; //Wrapped in an array since the category Query handler expects an array.
+
+		// REGEXP input only supports AND operator.
+		$data['REGEXP']['AND'][] = [ $option ];
+
 		$this->setParameter( 'category', $data );
 		$this->setOpenReferencesConflict( true );
+
 		return true;
 	}
 
 	/**
 	 * Clean and test 'categorymatch' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _categorymatch( $option ) {
 		if ( strpos( $option, '|' ) !== false ) {
@@ -545,34 +570,40 @@ public function _categorymatch( $option ) {
 		}
 
 		$data['LIKE'][$operator][] = $newMatches;
+
 		$this->setParameter( 'category', $data );
 		$this->setOpenReferencesConflict( true );
+
 		return true;
 	}
 
 	/**
 	 * Clean and test 'notcategory' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _notcategory( $option ) {
-		$title = \Title::newFromText( $option );
+		$title = Title::newFromText( $option );
+
 		if ( $title !== null ) {
 			$data = $this->getParameter( 'notcategory' );
 			$data['='][] = $title->getDbKey();
+
 			$this->setParameter( 'notcategory', $data );
 			$this->setOpenReferencesConflict( true );
+
 			return true;
 		}
+
 		return false;
 	}
 
 	/**
 	 * Clean and test 'notcategoryregexp' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _notcategoryregexp( $option ) {
 		if ( !$this->isRegexValid( $option, true ) ) {
@@ -581,48 +612,56 @@ public function _notcategoryregexp( $option ) {
 
 		$data = $this->getParameter( 'notcategory' );
 		$data['regexp'][] = $option;
+
 		$this->setParameter( 'notcategory', $data );
 		$this->setOpenReferencesConflict( true );
+
 		return true;
 	}
 
 	/**
 	 * Clean and test 'notcategorymatch' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _notcategorymatch( $option ) {
 		$data = $this->getParameter( 'notcategory' );
-		if ( !isset( $data['like'] ) || !is_array( $data['like'] ) ) {
+
+		if ( !is_array( $data['like'] ?? false ) ) {
 			$data['like'] = [];
 		}
+
 		$newMatches = explode( '|', $option );
 		$data['like'] = array_merge( $data['like'], $newMatches );
+
 		$this->setParameter( 'notcategory', $data );
 		$this->setOpenReferencesConflict( true );
+
 		return true;
 	}
 
 	/**
 	 * Clean and test 'count' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string|int $option
+	 * @return bool
 	 */
 	public function _count( $option ) {
 		if ( !Config::getSetting( 'allowUnlimitedResults' ) && $option <= Config::getSetting( 'maxResultCount' ) && $option > 0 ) {
 			$this->setParameter( 'count', intval( $option ) );
+
 			return true;
 		}
+
 		return false;
 	}
 
 	/**
 	 * Clean and test 'namespace' parameter.
 	 *
-	 * @param string Option passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _namespace( $option ) {
 		$contLang = MediaWikiServices::getInstance()->getContentLanguage();
@@ -631,24 +670,28 @@ public function _namespace( $option ) {
 		foreach ( $extraParams as $parameter ) {
 			$parameter = trim( $parameter );
 			$namespaceId = $contLang->getNsIndex( $parameter );
+
 			if ( $namespaceId === false || ( is_array( Config::getSetting( 'allowedNamespaces' ) ) && !in_array( $parameter, Config::getSetting( 'allowedNamespaces' ) ) ) ) {
-				//Let the user know this namespace is not allowed or does not exist.
+				// Let the user know this namespace is not allowed or does not exist.
 				return false;
 			}
+
 			$data = $this->getParameter( 'namespace' );
 			$data[] = $namespaceId;
 			$data = array_unique( $data );
+
 			$this->setParameter( 'namespace', $data );
 			$this->setSelectionCriteriaFound( true );
 		}
+
 		return true;
 	}
 
 	/**
 	 * Clean and test 'notnamespace' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _notnamespace( $option ) {
 		$contLang = MediaWikiServices::getInstance()->getContentLanguage();
@@ -657,32 +700,37 @@ public function _notnamespace( $option ) {
 		foreach ( $extraParams as $parameter ) {
 			$parameter = trim( $parameter );
 			$namespaceId = $contLang->getNsIndex( $parameter );
+
 			if ( $namespaceId === false ) {
-				//Let the user know this namespace is not allowed or does not exist.
+				// Let the user know this namespace is not allowed or does not exist.
 				return false;
 			}
+
 			$data = $this->getParameter( 'notnamespace' );
 			$data[] = $namespaceId;
 			$data = array_unique( $data );
+
 			$this->setParameter( 'notnamespace', $data );
 			$this->setSelectionCriteriaFound( true );
 		}
+
 		return true;
 	}
 
 	/**
 	 * Clean and test 'openreferences' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _openreferences( $option ) {
 		$option = $this->filterBoolean( $option );
+
 		if ( $option === null ) {
 			return false;
 		}
 
-		//Force 'ordermethod' back to none.
+		// Force 'ordermethod' back to none.
 		$this->setParameter( 'ordermethod', [ 'none' ] );
 		$this->setParameter( 'openreferences', $option );
 
@@ -692,12 +740,13 @@ public function _openreferences( $option ) {
 	/**
 	 * Clean and test 'ordermethod' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _ordermethod( $option ) {
 		$methods = explode( ',', $option );
 		$success = true;
+
 		foreach ( $methods as $method ) {
 			if ( !in_array( $method, $this->getData( 'ordermethod' )['values'] ) ) {
 				return false;
@@ -715,12 +764,12 @@ public function _ordermethod( $option ) {
 	/**
 	 * Clean and test 'mode' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _mode( $option ) {
 		if ( in_array( $option, $this->getData( 'mode' )['values'] ) ) {
-			//'none' mode is implemented as a specific submode of 'inline' with <br/> as inline text
+			// 'none' mode is implemented as a specific submode of 'inline' with <br/> as inline text
 			if ( $option == 'none' ) {
 				$this->setParameter( 'mode', 'inline' );
 				$this->setParameter( 'inlinetext', '<br/>' );
@@ -731,6 +780,7 @@ public function _mode( $option ) {
 			} else {
 				$this->setParameter( 'mode', $option );
 			}
+
 			return true;
 		} else {
 			return false;
@@ -740,11 +790,12 @@ public function _mode( $option ) {
 	/**
 	 * Clean and test 'distinct' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _distinct( $option ) {
 		$boolean = $this->filterBoolean( $option );
+
 		if ( $option == 'strict' ) {
 			$this->setParameter( 'distinctresultset', 'strict' );
 		} elseif ( $boolean !== null ) {
@@ -752,14 +803,15 @@ public function _distinct( $option ) {
 		} else {
 			return false;
 		}
+
 		return true;
 	}
 
 	/**
 	 * Clean and test 'ordercollation' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _ordercollation( $option ) {
 		if ( $option == 'bridge' ) {
@@ -769,6 +821,7 @@ public function _ordercollation( $option ) {
 		} else {
 			return false;
 		}
+
 		return true;
 	}
 
@@ -784,28 +837,32 @@ public function _listseparators() {
 	/**
 	 * Clean and test 'format' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _format( $option ) {
-		//Parsing of wikitext will happen at the end of the output phase.  Replace '\n' in the input by linefeed because wiki syntax depends on linefeeds.
+		// Parsing of wikitext will happen at the end of the output phase. Replace '\n' in the input by linefeed because wiki syntax depends on linefeeds.
 		$option = $this->stripHtmlTags( $option );
 		$option = Parse::replaceNewLines( $option );
+
 		$this->setParameter( 'listseparators', explode( ',', $option, 4 ) );
-		//Set the 'mode' parameter to userformat automatically.
+
+		// Set the 'mode' parameter to userformat automatically.
 		$this->setParameter( 'mode', 'userformat' );
 		$this->setParameter( 'inlinetext', '' );
+
 		return true;
 	}
 
 	/**
 	 * Clean and test 'title' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _title( $option ) {
-		$title = \Title::newFromText( $option );
+		$title = Title::newFromText( $option );
+
 		if ( $title ) {
 			$data = $this->getParameter( 'title' );
 			$data['='][] = str_replace( ' ', '_', $title->getText() );
@@ -814,27 +871,32 @@ public function _title( $option ) {
 			$data = $this->getParameter( 'namespace' );
 			$data[] = $title->getNamespace();
 			$data = array_unique( $data );
-			$this->setParameter( 'namespace', $data );
 
+			$this->setParameter( 'namespace', $data );
 			$this->setParameter( 'mode', 'userformat' );
+
 			$this->setSelectionCriteriaFound( true );
 			$this->setOpenReferencesConflict( true );
+
 			return true;
 		}
+
 		return false;
 	}
 
 	/**
 	 * Clean and test 'titleregexp' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _titleregexp( $option ) {
 		$data = $this->getParameter( 'title' );
-		if ( !isset( $data['regexp'] ) || !is_array( $data['regexp'] ) ) {
+
+		if ( !is_array( $data['regexp'] ?? false ) ) {
 			$data['regexp'] = [];
 		}
+
 		$newMatches = explode( '|', str_replace( ' ', '\_', $option ) );
 
 		if ( !$this->isRegexValid( $newMatches, true ) ) {
@@ -842,26 +904,29 @@ public function _titleregexp( $option ) {
 		}
 
 		$data['regexp'] = array_merge( $data['regexp'], $newMatches );
+
 		$this->setParameter( 'title', $data );
 		$this->setSelectionCriteriaFound( true );
+
 		return true;
 	}
 
 	/**
 	 * Clean and test 'titlematch' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _titlematch( $option ) {
 		$data = $this->getParameter( 'title' );
 
-		if ( !isset( $data['like'] ) || !is_array( $data['like'] ) ) {
+		if ( !is_array( $data['like'] ?? false ) ) {
 			$data['like'] = [];
 		}
 
 		$newMatches = explode( '|', str_replace( ' ', '\_', $option ) );
 		$data['like'] = array_merge( $data['like'], $newMatches );
+
 		$this->setParameter( 'title', $data );
 		$this->setSelectionCriteriaFound( true );
 
@@ -871,14 +936,16 @@ public function _titlematch( $option ) {
 	/**
 	 * Clean and test 'nottitleregexp' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _nottitleregexp( $option ) {
 		$data = $this->getParameter( 'nottitle' );
+
 		if ( !is_array( $data['regexp'] ) ) {
 			$data['regexp'] = [];
 		}
+
 		$newMatches = explode( '|', str_replace( ' ', '\_', $option ) );
 		$data['regexp'] = array_merge( $data['regexp'], $newMatches );
 
@@ -888,24 +955,26 @@ public function _nottitleregexp( $option ) {
 
 		$this->setParameter( 'nottitle', $data );
 		$this->setSelectionCriteriaFound( true );
+
 		return true;
 	}
 
 	/**
 	 * Clean and test 'nottitlematch' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _nottitlematch( $option ) {
 		$data = $this->getParameter( 'nottitle' );
 
-		if ( !isset( $data['like'] ) || !is_array( $data['like'] ) ) {
+		if ( !is_array( $data['like'] ?? false ) ) {
 			$data['like'] = [];
 		}
 
 		$newMatches = explode( '|', str_replace( ' ', '\_', $option ) );
 		$data['like'] = array_merge( $data['like'], $newMatches );
+
 		$this->setParameter( 'nottitle', $data );
 		$this->setSelectionCriteriaFound( true );
 
@@ -915,50 +984,56 @@ public function _nottitlematch( $option ) {
 	/**
 	 * Clean and test 'scroll' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _scroll( $option ) {
 		$option = $this->filterBoolean( $option );
 		$this->setParameter( 'scroll', $option );
-		//If scrolling is active we adjust the values for certain other parameters based on URL arguments
+
+		// If scrolling is active we adjust the values for certain other parameters based on URL arguments
 		if ( $option === true ) {
 			global $wgRequest;
 
-			//The 'findTitle' option has argument over the 'fromTitle' argument.
+			// The 'findTitle' option has argument over the 'fromTitle' argument.
 			$titlegt = $wgRequest->getVal( 'DPL_findTitle', '' );
+
 			if ( !empty( $titlegt ) ) {
 				$titlegt = '=_' . ucfirst( $titlegt );
 			} else {
 				$titlegt = $wgRequest->getVal( 'DPL_fromTitle', '' );
 				$titlegt = ucfirst( $titlegt );
 			}
+
 			$this->setParameter( 'titlegt', str_replace( ' ', '_', $titlegt ) );
 
-			//Lets get the 'toTitle' argument.
+			// Lets get the 'toTitle' argument.
 			$titlelt = $wgRequest->getVal( 'DPL_toTitle', '' );
 			$titlelt = ucfirst( $titlelt );
+
 			$this->setParameter( 'titlelt', str_replace( ' ', '_', $titlelt ) );
 
-			//Make sure the 'scrollDir' arugment is captured.  This is mainly used for the Variables extension and in the header/footer replacements.
+			// Make sure the 'scrollDir' arugment is captured. This is mainly used for the Variables extension and in the header/footer replacements.
 			$this->setParameter( 'scrolldir', $wgRequest->getVal( 'DPL_scrollDir', '' ) );
 
-			//Also set count limit from URL if not otherwise set.
+			// Also set count limit from URL if not otherwise set.
 			$this->_count( $wgRequest->getInt( 'DPL_count' ) );
 		}
-		//We do not return false since they could have just left it out.  Who knows why they put the parameter in the list in the first place.
+
+		// We do not return false since they could have just left it out. Who knows why they put the parameter in the list in the first place.
 		return true;
 	}
 
 	/**
 	 * Clean and test 'replaceintitle' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _replaceintitle( $option ) {
-		//We offer a possibility to replace some part of the title
+		// We offer a possibility to replace some part of the title
 		$replaceInTitle = explode( ',', $option, 2 );
+
 		if ( isset( $replaceInTitle[1] ) ) {
 			$replaceInTitle[1] = $this->stripHtmlTags( $replaceInTitle[1] );
 		}
@@ -971,12 +1046,12 @@ public function _replaceintitle( $option ) {
 	/**
 	 * Clean and test 'debug' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _debug( $option ) {
 		if ( in_array( $option, $this->getData( 'debug' )['values'] ) ) {
-			\DynamicPageListHooks::setDebugLevel( $option );
+			DynamicPageListHooks::setDebugLevel( $option );
 		} else {
 			return false;
 		}
@@ -996,8 +1071,8 @@ public function _includepage() {
 	/**
 	 * Clean and test 'include' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _include( $option ) {
 		if ( !empty( $option ) ) {
@@ -1006,14 +1081,15 @@ public function _include( $option ) {
 		} else {
 			return false;
 		}
+
 		return true;
 	}
 
 	/**
 	 * Clean and test 'includematch' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _includematch( $option ) {
 		$regexes = explode( ',', $option );
@@ -1023,14 +1099,15 @@ public function _includematch( $option ) {
 		}
 
 		$this->setParameter( 'seclabelsmatch', $regexes );
+
 		return true;
 	}
 
 	/**
 	 * Clean and test 'includematchparsed' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _includematchparsed( $option ) {
 		$regexes = explode( ',', $option );
@@ -1041,14 +1118,15 @@ public function _includematchparsed( $option ) {
 
 		$this->setParameter( 'incparsed', true );
 		$this->setParameter( 'seclabelsmatch', $regexes );
+
 		return true;
 	}
 
 	/**
 	 * Clean and test 'includenotmatch' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _includenotmatch( $option ) {
 		$regexes = explode( ',', $option );
@@ -1058,14 +1136,15 @@ public function _includenotmatch( $option ) {
 		}
 
 		$this->setParameter( 'seclabelsnotmatch', $regexes );
+
 		return true;
 	}
 
 	/**
 	 * Clean and test 'includenotmatchparsed' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _includenotmatchparsed( $option ) {
 		$regexes = explode( ',', $option );
@@ -1076,82 +1155,94 @@ public function _includenotmatchparsed( $option ) {
 
 		$this->setParameter( 'incparsed', true );
 		$this->setParameter( 'seclabelsnotmatch', $regexes );
+
 		return true;
 	}
 
 	/**
 	 * Clean and test 'secseparators' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _secseparators( $option ) {
-		//We replace '\n' by newline to support wiki syntax within the section separators
+		// We replace '\n' by newline to support wiki syntax within the section separators
 		$this->setParameter( 'secseparators', explode( ',', Parse::replaceNewLines( $option ) ) );
+
 		return true;
 	}
 
 	/**
 	 * Clean and test 'multisecseparators' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _multisecseparators( $option ) {
-		//We replace '\n' by newline to support wiki syntax within the section separators
+		// We replace '\n' by newline to support wiki syntax within the section separators
 		$this->setParameter( 'multisecseparators', explode( ',', Parse::replaceNewLines( $option ) ) );
+
 		return true;
 	}
 
 	/**
 	 * Clean and test 'table' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _table( $option ) {
 		$this->setParameter( 'defaulttemplatesuffix', '' );
 		$this->setParameter( 'mode', 'userformat' );
 		$this->setParameter( 'inlinetext', '' );
+
 		$withHLink = "[[%PAGE%|%TITLE%]]\n|";
+		$listSeparators = [];
 
 		foreach ( explode( ',', $option ) as $tabnr => $tab ) {
 			if ( $tabnr == 0 ) {
 				if ( $tab == '' ) {
 					$tab = 'class=wikitable';
 				}
+
 				$listSeparators[0] = '{|' . $tab;
 			} else {
 				if ( $tabnr == 1 && $tab == '-' ) {
 					$withHLink = '';
 					continue;
 				}
+
 				if ( $tabnr == 1 && $tab == '' ) {
 					$tab = wfMessage( 'article' )->text();
 				}
+
 				$listSeparators[0] .= "\n!{$tab}";
 			}
 		}
+
 		$listSeparators[1] = '';
+
 		// the user may have specified the third parameter of 'format' to add meta attributes of articles to the table
-		if ( !array_key_exists( 2, $listSeparators ) ) {
-			$listSeparators[2] = '';
-		}
+		$listSeparators[2] = '';
+
 		$listSeparators[3] = "\n|}";
-		//Overwrite 'listseparators'.
+
+		// Overwrite 'listseparators'.
 		$this->setParameter( 'listseparators', $listSeparators );
 
 		$sectionLabels = (array)$this->getParameter( 'seclabels' );
 		$sectionSeparators = $this->getParameter( 'secseparators' );
 		$multiSectionSeparators = $this->getParameter( 'multisecseparators' );
+
 		for ( $i = 0; $i < count( $sectionLabels ); $i++ ) {
 			if ( $i == 0 ) {
-				$sectionSeparators[0]		= "\n|-\n|" . $withHLink; //."\n";
-				$sectionSeparators[1]		= '';
-				$multiSectionSeparators[0]	= "\n|-\n|" . $withHLink; // ."\n";
+				$sectionSeparators[0] = "\n|-\n|" . $withHLink; // ."\n";
+				$sectionSeparators[1] = '';
+				$multiSectionSeparators[0] = "\n|-\n|" . $withHLink; // ."\n";
 			} else {
-				$sectionSeparators[2 * $i]		= "\n|"; // ."\n";
-				$sectionSeparators[2 * $i + 1]	= '';
+				$sectionSeparators[2 * $i] = "\n|"; // ."\n";
+				$sectionSeparators[2 * $i + 1] = '';
+
 				if ( is_array( $sectionLabels[$i] ) && $sectionLabels[$i][0] == '#' ) {
 					$multiSectionSeparators[$i] = "\n----\n";
 				} else {
@@ -1159,27 +1250,31 @@ public function _table( $option ) {
 				}
 			}
 		}
-		//Overwrite 'secseparators' and 'multisecseparators'.
+
+		// Overwrite 'secseparators' and 'multisecseparators'.
 		$this->setParameter( 'secseparators', $sectionSeparators );
 		$this->setParameter( 'multisecseparators', $multiSectionSeparators );
 
 		$this->setParameter( 'table', Parse::replaceNewLines( $option ) );
+
 		return true;
 	}
 
 	/**
 	 * Clean and test 'tablerow' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _tablerow( $option ) {
 		$option = Parse::replaceNewLines( trim( $option ) );
+
 		if ( empty( $option ) ) {
 			$this->setParameter( 'tablerow', [] );
 		} else {
 			$this->setParameter( 'tablerow', explode( ',', $option ) );
 		}
+
 		return true;
 	}
 
@@ -1187,17 +1282,19 @@ public function _tablerow( $option ) {
 	 * Clean and test 'allowcachedresults' parameter.
 	 * This function is necessary for the custom 'yes+warn' option that sets 'warncachedresults'.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool|int|string
 	 */
 	public function _allowcachedresults( $option ) {
-		//If execAndExit was previously set (i.e. if it is not empty) we will ignore all cache settings which are placed AFTER the execandexit statement thus we make sure that the cache will only become invalid if the query is really executed.
+		// If execAndExit was previously set (i.e. if it is not empty) we will ignore all cache settings which are placed AFTER the execandexit statement thus we make sure that the cache will only become invalid if the query is really executed.
 		if ( $this->getParameter( 'execandexit' ) === null ) {
 			if ( $option === 'yes+warn' ) {
 				$this->setParameter( 'allowcachedresults', true );
 				$this->setParameter( 'warncachedresults', true );
+
 				return true;
 			}
+
 			$option = $this->filterBoolean( $option );
 			if ( $option !== null ) {
 				$this->setParameter( 'allowcachedresults', $this->filterBoolean( $option ) );
@@ -1207,31 +1304,35 @@ public function _allowcachedresults( $option ) {
 		} else {
 			$this->setParameter( 'allowcachedresults', false );
 		}
+
 		return true;
 	}
 
 	/**
 	 * Clean and test 'fixcategory' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _fixcategory( $option ) {
-		\DynamicPageListHooks::fixCategory( $option );
+		DynamicPageListHooks::fixCategory( $option );
+
 		return true;
 	}
 
 	/**
 	 * Clean and test 'reset' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _reset( $option ) {
 		$arguments = explode( ',', $option );
 		$reset = [];
+
 		foreach ( $arguments as $argument ) {
 			$argument = trim( $argument );
+
 			if ( empty( $argument ) ) {
 				continue;
 			}
@@ -1241,9 +1342,10 @@ public function _reset( $option ) {
 				return false;
 			} else {
 				if ( $argument == 'all' || $argument == 'none' ) {
-					$boolean = ( $argument == 'all' ? true : false );
+					$boolean = ( $argument == 'all' );
 					$values = array_diff( $values, [ 'all', 'none' ] );
 					$reset = array_flip( $values );
+
 					foreach ( $reset as $value => $key ) {
 						$reset[$value] = $boolean;
 					}
@@ -1252,35 +1354,42 @@ public function _reset( $option ) {
 				}
 			}
 		}
+
 		$data = $this->getParameter( 'reset' );
 		$data = array_merge( $data, $reset );
+
 		$this->setParameter( 'reset', $data );
+
 		return true;
 	}
 
 	/**
 	 * Clean and test 'eliminate' parameter.
 	 *
-	 * @param string Options passed to parameter.
-	 * @return bool	Success
+	 * @param string $option
+	 * @return bool
 	 */
 	public function _eliminate( $option ) {
 		$arguments = explode( ',', $option );
 		$eliminate = [];
+
 		foreach ( $arguments as $argument ) {
 			$argument = trim( $argument );
+
 			if ( empty( $argument ) ) {
 				continue;
 			}
 
 			$values = $this->getData( 'eliminate' )['values'];
+
 			if ( !in_array( $argument, $values ) ) {
 				return false;
 			} else {
 				if ( $argument == 'all' || $argument == 'none' ) {
-					$boolean = ( $argument == 'all' ? true : false );
+					$boolean = ( $argument == 'all' );
 					$values = array_diff( $values, [ 'all', 'none' ] );
 					$eliminate = array_flip( $values );
+
 					foreach ( $eliminate as $value => $key ) {
 						$eliminate[$value] = $boolean;
 					}
@@ -1289,9 +1398,11 @@ public function _eliminate( $option ) {
 				}
 			}
 		}
+
 		$data = $this->getParameter( 'eliminate' );
 		$data = array_merge( $data, $eliminate );
 		$this->setParameter( 'eliminate', $data );
+
 		return true;
 	}
 }
diff --git a/includes/ParametersData.php b/includes/ParametersData.php
index eb9cc382..01bb047a 100644
--- a/includes/ParametersData.php
+++ b/includes/ParametersData.php
@@ -1,15 +1,9 @@
 <?php
-/**
- * DynamicPageList3
- * DPL ParametersData Class
- *
- * @author		IlyaHaykinson, Unendlich, Dangerville, Algorithmix, Theaitetos, Alexia E. Smith
- * @license		GPL-2.0-or-later
- * @package		DynamicPageList3
- *
- */
+
 namespace DPL;
 
+use MWException;
+
 class ParametersData {
 	/**
 	 * Parameter Richness
@@ -167,72 +161,72 @@ class ParametersData {
 	 */
 	private $data = [
 		'addauthor' => [
-			'default'			=> false,
-			'boolean'			=> true,
-			'open_ref_conflict'	=> true
+			'default' => false,
+			'boolean' => true,
+			'open_ref_conflict' => true
 		],
 		'addcategories' => [
-			'default'			=> false,
-			'boolean'			=> true,
-			'open_ref_conflict'	=> true
+			'default' => false,
+			'boolean' => true,
+			'open_ref_conflict' => true
 		],
 		'addcontribution' => [
-			'default'			=> false,
-			'boolean'			=> true,
-			'open_ref_conflict'	=> true
+			'default' => false,
+			'boolean' => true,
+			'open_ref_conflict' => true
 		],
 		'addeditdate' => [
-			'default'			=> false,
-			'boolean'			=> true,
-			'open_ref_conflict'	=> true
+			'default' => false,
+			'boolean' => true,
+			'open_ref_conflict' => true
 		],
 		'addexternallink' => [
-			'default'			=> false,
-			'boolean'			=> true,
-			'open_ref_conflict'	=> true
+			'default' => false,
+			'boolean' => true,
+			'open_ref_conflict' => true
 		],
 		'addfirstcategorydate' => [
-			'default'			=> false,
-			'boolean'			=> true,
-			'open_ref_conflict'	=> true
+			'default' => false,
+			'boolean' => true,
+			'open_ref_conflict' => true
 		],
 		'addlasteditor' => [
-			'default'			=> false,
-			'boolean'			=> true,
-			'open_ref_conflict'	=> true
+			'default' => false,
+			'boolean' => true,
+			'open_ref_conflict' => true
 		],
 		'addpagecounter' => [
-			'default'			=> false,
-			'boolean'			=> true,
-			'open_ref_conflict'	=> true
+			'default' => false,
+			'boolean' => true,
+			'open_ref_conflict' => true
 		],
 		'addpagesize' => [
-			'default'			=> false,
-			'boolean'			=> true,
-			'open_ref_conflict'	=> true
+			'default' => false,
+			'boolean' => true,
+			'open_ref_conflict' => true
 		],
 		'addpagetoucheddate' => [
-			'default'			=> false,
-			'boolean'			=> true,
-			'open_ref_conflict'	=> true
+			'default' => false,
+			'boolean' => true,
+			'open_ref_conflict' => true
 		],
 		'adduser' => [
-			'default'			=> false,
-			'boolean'			=> true,
-			'open_ref_conflict'	=> true
+			'default' => false,
+			'boolean' => true,
+			'open_ref_conflict' => true
 		],
 
 		// default of allowcachedresults depends on behaveasIntersetion and on LocalSettings ...
 		'allowcachedresults' => [
-			'default'			=> true,
-			'boolean'			=> true
+			'default' => true,
+			'boolean' => true
 		],
 		/**
 		 * search for a page with the same title in another namespace (this is normally the article to a talk page)
 		 */
 		'articlecategory' => [
-			'default'			=> null,
-			'db_format'			=> true
+			'default' => null,
+			'db_format' => true
 		],
 
 		/**
@@ -247,13 +241,13 @@ class ParametersData {
 		 * @todo define 'category' options (retrieve list of categories from 'categorylinks' table?)
 		 */
 		'category' => [
-			'default'	=> null,
+			'default' => null,
 		],
 		'categorymatch' => [
-			'default'	=> null,
+			'default' => null,
 		],
 		'categoryregexp' => [
-			'default'	=> null,
+			'default' => null,
 		],
 		/**
 		 * Min and Max of categories allowed for an article
@@ -266,14 +260,14 @@ class ParametersData {
 		 * hiddencategories
 		 */
 		'hiddencategories' => [
-			'default'	=> 'include',
-			'values'	=> [ 'include', 'exclude', 'only' ]
+			'default' => 'include',
+			'values' => [ 'include', 'exclude', 'only' ]
 		],
 		/**
 		 * Perform the command and do not query the database.
 		 */
 		'execandexit' => [
-			'default'	=> null
+			'default' => null
 		],
 
 		/**
@@ -281,40 +275,40 @@ class ParametersData {
 		 * default is 0
 		 */
 		'offset' => [
-			'default'	=> 0,
-			'integer'	=> true
+			'default' => 0,
+			'integer' => true
 		],
 		/**
 		 * Max of results to display, selection is based on random.
 		 */
 		'count' => [
-			'default'	=> 500,
-			'integer'	=> true
+			'default' => 500,
+			'integer' => true
 		],
 		/**
 		 * Max number of results to display, selection is based on random.
 		 */
 		'randomcount' => [
-			'default'	=> null,
-			'integer'	=> true
+			'default' => null,
+			'integer' => true
 		],
 		/**
 		 * shall the result set be distinct (=default) or not?
 		 */
 		'distinct' => [
-			'default'	=> true,
-			'values'	=> [ 'strict' ]
+			'default' => true,
+			'values' => [ 'strict' ]
 		],
 		'cacheperiod' => [
-			'default'	=> 3600, // Number of seconds, default one day at 86400 seconds.
-			'integer'	=> true
+			'default' => 3600,
+			'integer' => true
 		],
 		/**
 		 * number of columns for output, default is 1
 		 */
 		'columns' => [
-			'default'	=> 1,
-			'integer'	=> true
+			'default' => 1,
+			'integer' => true
 		],
 
 		/**
@@ -327,8 +321,8 @@ class ParametersData {
 		 * - 5: <nowiki> tags around the ouput
 		 */
 		'debug' => [
-			'default'	=> 1,
-			'values'	=> [ 0, 1, 2, 3, 4, 5 ]
+			'default' => 1,
+			'values' => [ 0, 1, 2, 3, 4, 5 ]
 		],
 
 		/**
@@ -341,8 +335,8 @@ class ParametersData {
 		 * all		   all of the above
 		 */
 		'eliminate' => [
-			'default'	=> [],
-			'values'	=> [
+			'default' => [],
+			'values' => [
 				'categories',
 				'templates',
 				'links',
@@ -353,22 +347,22 @@ class ParametersData {
 		],
 
 		'format' => [
-			'default'	=> null,
+			'default' => null,
 		],
 
 		'goal' => [
-			'default'	=> 'pages',
-			'values'	=> [
+			'default' => 'pages',
+			'values' => [
 				'pages',
 				'categories'
 			],
-			'open_ref_conflict'	=> true
+			'open_ref_conflict' => true
 		],
 
-		//Include the lowercase variants of header tiers for ease of use.
+		// Include the lowercase variants of header tiers for ease of use.
 		'headingmode' => [
-			'default'	=> 'none',
-			'values'	=> [
+			'default' => 'none',
+			'values' => [
 				'H1',
 				'H2',
 				'H3',
@@ -381,22 +375,22 @@ class ParametersData {
 				'h4',
 				'h5',
 				'h6',
-				//'header',
+				// 'header',
 				'definition',
 				'none',
 				'ordered',
 				'unordered'
 			],
-			'open_ref_conflict'	=> true
+			'open_ref_conflict' => true
 		],
 
 		/**
 		 * we can display the number of articles within a heading group
 		 */
 		'headingcount' => [
-			'default'			=> false,
-			'boolean'			=> true,
-			'open_ref_conflict'	=> true
+			'default' => false,
+			'boolean' => true,
+			'open_ref_conflict' => true
 		],
 
 		/**
@@ -406,7 +400,7 @@ class ParametersData {
 		 * Example: hitemattr= class="topmenuli" style="color: red;"
 		 */
 		'hitemattr' => [
-			'default'	=> null
+			'default' => null
 		],
 
 		/**
@@ -416,7 +410,7 @@ class ParametersData {
 		 * Example: hlistattr= class="topmenul" id="dmenu"
 		 */
 		'hlistattr' => [
-			'default'	=> null
+			'default' => null
 		],
 
 		/**
@@ -434,58 +428,58 @@ class ParametersData {
 		 */
 
 		'includepage' => [
-			'default'	=> null
+			'default' => null
 		],
 
 		/**
 		 * make comparisons (linksto, linksfrom ) case insensitive
 		 */
 		'ignorecase' => [
-			'default'	=> false,
-			'boolean'	=> true
+			'default' => false,
+			'boolean' => true
 		],
-		'include'			   => [
-			'default'	=> null
+		'include' => [
+			'default' => null
 		],
 
 		/**
 		 * includesubpages
 		 */
 		'includesubpages' => [
-			'default'	=> true,
-			'boolean'	=> true
+			'default' => true,
+			'boolean' => true
 		],
 
 		/**
 		 * includematch=..,..	 allows to specify regular expressions which must match the included contents
 		 */
 		'includematch' => [
-			'default'	=> null
+			'default' => null
 		],
 		'includematchparsed' => [
-			'default'	=> false,
-			'boolean'	=> true
+			'default' => false,
+			'boolean' => true
 		],
 		/**
 		 * includenotmatch=..,..	allows to specify regular expressions which must NOT match the included contents
 		 */
 		'includenotmatch' => [
-			'default'	=> null
+			'default' => null
 		],
 		'includenotmatchparsed' => [
-			'default'	=> false,
-			'boolean'	=> true
+			'default' => false,
+			'boolean' => true
 		],
 		'includetrim' => [
-			'default'	=> false,
-			'boolean'	=> true
+			'default' => false,
+			'boolean' => true
 		],
 		/**
 		 * Inline text is some wiki text used to separate list items with 'mode=inline'.
 		 */
 		'inlinetext' => [
-			'default'		=> '&#160;-&#160;',
-			'strip_html'	=> true
+			'default' => '&#160;-&#160;',
+			'strip_html' => true
 		],
 		/**
 		 * Max # characters of included page to display.
@@ -493,8 +487,8 @@ class ParametersData {
 		 * If we include sections the limit will apply to each section.
 		 */
 		'includemaxlength' => [
-			'default'	=> null,
-			'integer'	=> true
+			'default' => null,
+			'integer' => true
 		],
 		/**
 		 * Attributes for HTML list items, depending on 'mode' ('li' for ordered/unordered, 'span' for others).
@@ -503,7 +497,7 @@ class ParametersData {
 		 * Example: itemattr= class="submenuli" style="color: red;"
 		 */
 		'itemattr' => [
-			'default'	=> null
+			'default' => null
 		],
 		/**
 		 * listseparators is an array of four tags (in wiki syntax) which defines the output of DPL
@@ -517,7 +511,7 @@ class ParametersData {
 		 *		   : listseparators={|,\n|-\n|[[%PAGE%]],,\n|}
 		 */
 		'listseparators' => [
-			'default'	=> []
+			'default' => []
 		],
 		/**
 		 * sequence of four wiki tags (separated by ",") to be used together with mode = 'userformat'
@@ -526,167 +520,167 @@ class ParametersData {
 		 *	 example:	listattr=<ul>,<li>,</li>,</ul>
 		 */
 		'listattr' => [
-			'default'	=> null
+			'default' => null
 		],
 		/**
 		 * this parameter restricts the output to articles which can reached via a link from the specified pages.
 		 * Examples:   linksfrom=my article|your article
 		 */
 		'linksfrom' => [
-			'default'				=> null,
-			'page_name_list'		=> true,
-			'page_name_must_exist'	=> true,
-			'set_criteria_found'	=> true
+			'default' => null,
+			'page_name_list' => true,
+			'page_name_must_exist' => true,
+			'set_criteria_found' => true
 		],
 		/**
 		 * this parameter restricts the output to articles which cannot be reached via a link from the specified pages.
 		 * Examples:   notlinksfrom=my article|your article
 		 */
 		'notlinksfrom' => [
-			'default'				=> null,
-			'page_name_list'		=> true,
-			'page_name_must_exist'	=> true,
-			'set_criteria_found'	=> true
+			'default' => null,
+			'page_name_list' => true,
+			'page_name_must_exist' => true,
+			'set_criteria_found' => true
 		],
 		/**
 		 * this parameter restricts the output to articles which contain a reference to one of the specified pages.
 		 * Examples:   linksto=my article|your article	 ,	linksto=Template:my template   ,  linksto = {{FULLPAGENAME}}
 		 */
 		'linksto' => [
-			'default'				=> null,
-			'open_ref_conflict'		=> true,
-			'page_name_list'		=> true,
-			'page_name_must_exist'	=> true,
-			'set_criteria_found'	=> true
+			'default' => null,
+			'open_ref_conflict' => true,
+			'page_name_list' => true,
+			'page_name_must_exist' => true,
+			'set_criteria_found' => true
 		],
 		/**
 		 * this parameter restricts the output to articles which do not contain a reference to the specified page.
 		 */
 		'notlinksto' => [
-			'default'				=> null,
-			'open_ref_conflict'		=> true,
-			'page_name_list'		=> true,
-			'page_name_must_exist'	=> true,
-			'set_criteria_found'	=> true
+			'default' => null,
+			'open_ref_conflict' => true,
+			'page_name_list' => true,
+			'page_name_must_exist' => true,
+			'set_criteria_found' => true
 		],
 		/**
 		 * this parameter restricts the output to articles which contain an external reference that conatins a certain pattern
 		 * Examples:   linkstoexternal= www.xyz.com|www.xyz2.com
 		 */
 		'linkstoexternal' => [
-			'default'				=> null,
-			'open_ref_conflict'		=> true,
-			'page_name_list'		=> true,
-			'page_name_must_exist'	=> false,
-			'set_criteria_found'	=> true
+			'default' => null,
+			'open_ref_conflict' => true,
+			'page_name_list' => true,
+			'page_name_must_exist' => false,
+			'set_criteria_found' => true
 		],
 		/**
 		 * this parameter restricts the output to articles which use one of the specified images.
 		 * Examples:   imageused=Image:my image|Image:your image
 		 */
 		'imageused' => [
-			'default'				=> null,
-			'open_ref_conflict'		=> true,
-			'page_name_list'		=> true,
-			'page_name_must_exist'	=> true,
-			'set_criteria_found'	=> true
+			'default' => null,
+			'open_ref_conflict' => true,
+			'page_name_list' => true,
+			'page_name_must_exist' => true,
+			'set_criteria_found' => true
 		],
 		 /**
 		  * this parameter restricts the output to images which are used (contained) by one of the specified pages.
 		  * Examples:   imagecontainer=my article|your article
 		  */
 		'imagecontainer' => [
-			'default'				=> null,
-			'open_ref_conflict'		=> false,
-			'page_name_list'		=> true,
-			'page_name_must_exist'	=> true,
-			'set_criteria_found'	=> true
+			'default' => null,
+			'open_ref_conflict' => false,
+			'page_name_list' => true,
+			'page_name_must_exist' => true,
+			'set_criteria_found' => true
 		],
 		/**
 		 * this parameter restricts the output to articles which use the specified template.
 		 * Examples:   uses=Template:my template
 		 */
 		'uses' => [
-			'default'				=> null,
-			'open_ref_conflict'		=> true,
-			'page_name_list'		=> true,
-			'page_name_must_exist'	=> true,
-			'set_criteria_found'	=> true
+			'default' => null,
+			'open_ref_conflict' => true,
+			'page_name_list' => true,
+			'page_name_must_exist' => true,
+			'set_criteria_found' => true
 		],
 		/**
 		 * this parameter restricts the output to articles which do not use the specified template.
 		 * Examples:   notuses=Template:my template
 		 */
 		'notuses' => [
-			'default'				=> null,
-			'open_ref_conflict'		=> true,
-			'page_name_list'		=> true,
-			'page_name_must_exist'	=> true,
-			'set_criteria_found'	=> true
+			'default' => null,
+			'open_ref_conflict' => true,
+			'page_name_list' => true,
+			'page_name_must_exist' => true,
+			'set_criteria_found' => true
 		],
 		/**
 		 * this parameter restricts the output to the template used by the specified page.
 		 */
 		'usedby' => [
-			'default'				=> null,
-			'open_ref_conflict'		=> true,
-			'page_name_list'		=> true,
-			'page_name_must_exist'	=> true,
-			'set_criteria_found'	=> true
+			'default' => null,
+			'open_ref_conflict' => true,
+			'page_name_list' => true,
+			'page_name_must_exist' => true,
+			'set_criteria_found' => true
 		],
 		/**
 		 * allows to specify a username who must be the first editor of the pages we select
 		 */
-		'createdby'	=> [
-			'default'				=> null,
-			'set_criteria_found'	=> true,
-			'open_ref_conflict'		=> true,
-			'preserve_case'			=> true
+		'createdby' => [
+			'default' => null,
+			'set_criteria_found' => true,
+			'open_ref_conflict' => true,
+			'preserve_case' => true
 		],
 		/**
 		 * allows to specify a username who must not be the first editor of the pages we select
 		 */
-		'notcreatedby'	=> [
-			'default'				=> null,
-			'set_criteria_found'	=> true,
-			'open_ref_conflict'		=> true,
-			'preserve_case'			=> true
+		'notcreatedby' => [
+			'default' => null,
+			'set_criteria_found' => true,
+			'open_ref_conflict' => true,
+			'preserve_case' => true
 		],
 		/**
 		 * allows to specify a username who must be among the editors of the pages we select
 		 */
-		'modifiedby'	=> [
-			'default'				=> null,
-			'set_criteria_found'	=> true,
-			'open_ref_conflict'		=> true,
-			'preserve_case'			=> true
+		'modifiedby' => [
+			'default' => null,
+			'set_criteria_found' => true,
+			'open_ref_conflict' => true,
+			'preserve_case' => true
 		],
 		/**
 		 * allows to specify a username who must not be among the editors of the pages we select
 		 */
-		'notmodifiedby'	=> [
-			'default'				=> null,
-			'set_criteria_found'	=> true,
-			'open_ref_conflict'		=> true,
-			'preserve_case'			=> true
+		'notmodifiedby' => [
+			'default' => null,
+			'set_criteria_found' => true,
+			'open_ref_conflict' => true,
+			'preserve_case' => true
 		],
 		/**
 		 * allows to specify a username who must be the last editor of the pages we select
 		 */
 		'lastmodifiedby' => [
-			'default'				=> null,
-			'set_criteria_found'	=> true,
-			'open_ref_conflict'		=> true,
-			'preserve_case'			=> true
+			'default' => null,
+			'set_criteria_found' => true,
+			'open_ref_conflict' => true,
+			'preserve_case' => true
 		],
 		/**
 		 * allows to specify a username who must not be the last editor of the pages we select
 		 */
-		'notlastmodifiedby'	=> [
-			'default'				=> null,
-			'set_criteria_found'	=> true,
-			'open_ref_conflict'		=> true,
-			'preserve_case'			=> true
+		'notlastmodifiedby' => [
+			'default' => null,
+			'set_criteria_found' => true,
+			'open_ref_conflict' => true,
+			'preserve_case' => true
 		],
 		/**
 		 * Mode for list of pages (possibly within a heading, see 'headingmode' param).
@@ -694,8 +688,8 @@ class ParametersData {
 		 * 'userformat' does not produce any html tags unless 'listseparators' are specified
 		 */
 		'mode' => [
-			'default'	=> 'unordered',
-			'values'	=> [
+			'default' => 'unordered',
+			'values' => [
 				'category',
 				'definition',
 				'gallery',
@@ -714,8 +708,8 @@ class ParametersData {
 		 * 'false'	images are shown, categories are assigned to the current document
 		 */
 		'escapelinks' => [
-			'default'	=> true,
-			'boolean'	=> true
+			'default' => true,
+			'boolean' => true
 		],
 		/**
 		 * By default the page containingthe query will not be part of the result set.
@@ -723,8 +717,8 @@ class ParametersData {
 		 * problems which are hard to track down, esp. in combination with contents transclusion.
 		 */
 		'skipthispage' => [
-			'default'	=> true,
-			'boolean'	=> true
+			'default' => true,
+			'boolean' => true
 		],
 		/**
 		 * namespace= Ns1 | Ns2 | ...
@@ -733,7 +727,7 @@ class ParametersData {
 		 * Magic words allowed.
 		 */
 		'namespace' => [
-			'default'	=> null,
+			'default' => null,
 		],
 		/**
 		 * notcategory= Cat1
@@ -743,13 +737,13 @@ class ParametersData {
 		 * @todo define 'notcategory' options (retrieve list of categories from 'categorylinks' table?)
 		 */
 		'notcategory' => [
-			'default'	=> null,
+			'default' => null,
 		],
 		'notcategorymatch' => [
-			'default'	=> null,
+			'default' => null,
 		],
 		'notcategoryregexp' => [
-			'default'	=> null,
+			'default' => null,
 		],
 		/**
 		 * notnamespace= Ns1
@@ -760,50 +754,50 @@ class ParametersData {
 		 * Magic words allowed.
 		 */
 		'notnamespace' => [
-			'default'	=> null,
+			'default' => null,
 		],
 		/**
 		 * title is the exact name of a page; this is useful if you want to use DPL
 		 * just for contents inclusion; mode=userformat is automatically implied with title=
 		 */
 		'title' => [
-			'default'	=> null,
+			'default' => null,
 		],
 		/**
 		 * titlematch is a (SQL-LIKE-expression) pattern
 		 * which restricts the result to pages matching that pattern
 		 */
 		'titlelt' => [
-			'default'				=> null,
-			'db_format'				=> true,
-			'set_criteria_found'	=> true
+			'default' => null,
+			'db_format' => true,
+			'set_criteria_found' => true
 		],
 		'titlegt' => [
-			'default'				=> null,
-			'db_format'				=> true,
-			'set_criteria_found'	=> true
+			'default' => null,
+			'db_format' => true,
+			'set_criteria_found' => true
 		],
 		'scroll' => [
-			'default'	=> false,
-			'boolean'	=> true
+			'default' => false,
+			'boolean' => true
 		],
 		'titlematch' => [
-			'default'	=> null
+			'default' => null
 		],
 		'titleregexp' => [
-			'default'	=> null
+			'default' => null
 		],
 		'userdateformat' => [
-			'default'		=> 'Y-m-d H:i:s',
-			'strip_html'	=> true
+			'default' => 'Y-m-d H:i:s',
+			'strip_html' => true
 		],
 		'updaterules' => [
-			'default'		=> null,
-			'permission'	=> 'dpl_param_update_rules'
+			'default' => null,
+			'permission' => 'dpl_param_update_rules'
 		],
 		'deleterules' => [
-			'default'		=> null,
-			'permission'	=> 'dpl_param_delete_rules'
+			'default' => null,
+			'permission' => 'dpl_param_delete_rules'
 		],
 
 		/**
@@ -811,14 +805,14 @@ class ParametersData {
 		 * which excludes pages matching that pattern from the result
 		 */
 		'nottitlematch' => [
-			'default'	=> null
+			'default' => null
 		],
 		'nottitleregexp' => [
-			'default'	=> null
+			'default' => null
 		],
 		'order' => [
-			'default'	=> 'ascending',
-			'values'	=> [ 'ascending', 'descending', 'asc', 'desc' ]
+			'default' => 'ascending',
+			'values' => [ 'ascending', 'descending', 'asc', 'desc' ]
 		],
 		/**
 		 * we can specify something like "latin1_swedish_ci" for case insensitive sorting
@@ -831,8 +825,8 @@ class ParametersData {
 		 * @todo: add 'ordermethod=category,categoryadd' (for each category CAT, pages ordered by date when page was added to CAT).
 		 */
 		'ordermethod' => [
-			'default'	=> [ 'none' ],
-			'values'	=> [
+			'default' => [ 'none' ],
+			'values' => [
 				'counter',
 				'size',
 				'category',
@@ -854,56 +848,56 @@ class ParametersData {
 		 * - include: include minor edits
 		 */
 		'minoredits' => [
-			'default'			=> null,
-			'values'			=> [ 'include', 'exclude' ],
-			'open_ref_conflict'	=> true
+			'default' => null,
+			'values' => [ 'include', 'exclude' ],
+			'open_ref_conflict' => true
 		],
 		/**
 		 * lastrevisionbefore = select the latest revision which was existent before the specified point in time
 		 */
 		'lastrevisionbefore' => [
-			'default'			=> null,
-			'timestamp'			=> true,
-			'open_ref_conflict'	=> true
+			'default' => null,
+			'timestamp' => true,
+			'open_ref_conflict' => true
 		],
 		/**
 		 * allrevisionsbefore = select the revisions which were created before the specified point in time
 		 */
 		'allrevisionsbefore' => [
-			'default'			=> null,
-			'timestamp'			=> true,
-			'open_ref_conflict'	=> true
+			'default' => null,
+			'timestamp' => true,
+			'open_ref_conflict' => true
 		],
 		/**
 		 * firstrevisionsince = select the first revision which was created after the specified point in time
 		 */
 		'firstrevisionsince' => [
-			'default'			=> null,
-			'timestamp'			=> true,
-			'open_ref_conflict'	=> true
+			'default' => null,
+			'timestamp' => true,
+			'open_ref_conflict' => true
 		],
 		/**
 		 * allrevisionssince = select the latest revisions which were created after the specified point in time
 		 */
 		'allrevisionssince' => [
-			'default'			=> null,
-			'timestamp'			=> true,
-			'open_ref_conflict'	=> true
+			'default' => null,
+			'timestamp' => true,
+			'open_ref_conflict' => true
 		],
 		/**
 		 * Minimum/Maximum number of revisions required
 		 */
 		'minrevisions' => [
-			'default'	=> null,
-			'integer'	=> true
+			'default' => null,
+			'integer' => true
 		],
 		'maxrevisions' => [
-			'default'	=> null,
-			'integer'	=> true
+			'default' => null,
+			'integer' => true
 		],
 		'suppresserrors' => [
-			'default'	=> false,
-			'boolean'	=> true
+			'default' => false,
+			'boolean' => true
 		],
 		/**
 		 * noresultsheader / footer is some wiki text which will be output (instead of a warning message)
@@ -911,28 +905,28 @@ class ParametersData {
 		 * the warning about empty result set.
 		 */
 		'noresultsheader' => [
-			'default'		=> null,
-			'strip_html'	=> true,
-			'preserve_case'	=> true
+			'default' => null,
+			'strip_html' => true,
+			'preserve_case' => true
 		],
 		'noresultsfooter' => [
-			'default'		=> null,
-			'strip_html'	=> true,
-			'preserve_case'	=> true
+			'default' => null,
+			'strip_html' => true,
+			'preserve_case' => true
 		],
 		/**
 		 * oneresultsheader / footer is some wiki text which will be output
 		 * if the result set contains exactly one entry.
 		 */
 		'oneresultheader' => [
-			'default'		=> null,
-			'strip_html'	=> true,
-			'preserve_case'	=> true
+			'default' => null,
+			'strip_html' => true,
+			'preserve_case' => true
 		],
 		'oneresultfooter' => [
-			'default'		=> null,
-			'strip_html'	=> true,
-			'preserve_case'	=> true
+			'default' => null,
+			'strip_html' => true,
+			'preserve_case' => true
 		],
 		/**
 		 * openreferences =...
@@ -940,8 +934,8 @@ class ParametersData {
 		 * - yes: includes pages which do not exist -- this conflicts with some other options
 		 */
 		'openreferences' => [
-			'default'	=> false,
-			'boolean'	=> true
+			'default' => false,
+			'boolean' => true
 		],
 		/**
 		 * redirects =...
@@ -950,8 +944,8 @@ class ParametersData {
 		 * - only: lists only redirect pages in lists (page_is_redirect = 1 only)
 		 */
 		'redirects' => [
-			'default'	=> 'exclude',
-			'values'	=> [ 'include', 'exclude', 'only' ]
+			'default' => 'exclude',
+			'values' => [ 'include', 'exclude', 'only' ]
 		],
 		/**
 		 * stablepages =...
@@ -960,8 +954,8 @@ class ParametersData {
 		 * - only: lists only stable pages in lists
 		 */
 		'stablepages' => [
-			'default'	=> null,
-			'values'	=> [ 'exclude', 'only' ]
+			'default' => null,
+			'values' => [ 'exclude', 'only' ]
 		],
 		/**
 		 * qualitypages =...
@@ -970,8 +964,8 @@ class ParametersData {
 		 * - only: lists only quality pages in lists
 		 */
 		'qualitypages' => [
-			'default'	=> null,
-			'values'	=> [ 'exclude', 'only' ]
+			'default' => null,
+			'values' => [ 'exclude', 'only' ]
 		],
 		/**
 		 * resultsheader / footer is some wiki text which will be output before / after the result list
@@ -979,14 +973,14 @@ class ParametersData {
 		 * used if there are at least TWO results
 		 */
 		'resultsheader' => [
-			'default'		=> null,
-			'strip_html'	=> true,
-			'preserve_case'	=> true
+			'default' => null,
+			'strip_html' => true,
+			'preserve_case' => true
 		],
 		'resultsfooter' => [
-			'default'		=> null,
-			'strip_html'	=> true,
-			'preserve_case'	=> true
+			'default' => null,
+			'strip_html' => true,
+			'preserve_case' => true
 		],
 		/**
 		 * reset=..
@@ -999,7 +993,7 @@ class ParametersData {
 		 */
 		'reset' => [
 			'default' => [],
-			'values'	=> [
+			'values' => [
 				'categories',
 				'templates',
 				'links',
@@ -1021,8 +1015,8 @@ class ParametersData {
 		 * Note: a "row" is a group of lines for which the heading tags defined in listseparators/format will be repeated
 		 */
 		'rows' => [
-			'default'	=> 1,
-			'integer'	=> true
+			'default' => 1,
+			'integer' => true
 		],
 
 		/**
@@ -1030,16 +1024,16 @@ class ParametersData {
 		 * Note: a "row" is a group of lines for which the heading tags defined in listeseparators will be repeated
 		 */
 		'rowsize' => [
-			'default'	=> 0,
-			'integer'	=> true
+			'default' => 0,
+			'integer' => true
 		],
 
 		/**
 		 * The HTML attribute tags(class, cellspacing) used for columns and rows in MediaWiki table markup.
 		 */
 		'rowcolformat' => [
-			'default'		=> null,
-			'strip_html'	=> true
+			'default' => null,
+			'strip_html' => true
 		],
 		/**
 		 * secseparators  is a sequence of pairs of tags used to separate sections (see "includepage=name1, name2, ..")
@@ -1062,48 +1056,48 @@ class ParametersData {
 		 * dominant column
 		 */
 		'dominantsection' => [
-			'default'	=> 0,
-			'integer'	=> true
+			'default' => 0,
+			'integer' => true
 		],
 		/**
 		 * showcurid creates a stable link to the current revision of a page
 		 */
 		'showcurid' => [
-			'default'			=> false,
-			'boolean'			=> true,
-			'open_ref_conflict'	=> true
+			'default' => false,
+			'boolean' => true,
+			'open_ref_conflict' => true
 		],
 		/**
 		 * shownamespace decides whether to show the namespace prefix or not
 		 */
 		'shownamespace' => [
-			'default'	=> true,
-			'boolean'	=> true
+			'default' => true,
+			'boolean' => true
 		],
 		/**
 		 * replaceintitle applies a regex replacement to %TITLE%
 		 */
 		'replaceintitle' => [
-			'default'	=> null
+			'default' => null
 		],
 		/**
 		 * table is a short hand for combined values of listseparators, colseparators and mulicolseparators
 		 */
 		'table' => [
-			'default'	=> null
+			'default' => null
 		],
 		/**
 		 * tablerow allows to define individual formats for table columns
 		 */
 		'tablerow' => [
-			'default'	=> []
+			'default' => []
 		],
 		/**
 		 * The number (starting with 1) of the column to be used for sorting
 		 */
 		'tablesortcol' => [
-			'default'	=> null,
-			'integer'	=> true
+			'default' => null,
+			'integer' => true
 		],
 		/**
 		 * The sorting algorithm for table columns when 'tablesortcol'
@@ -1112,8 +1106,8 @@ class ParametersData {
 		 * - natural: Use PHP natsort()
 		 */
 		'tablesortmethod' => [
-			'default'	=> null,
-			'values'	=> ['standard', 'natural']
+			'default' => null,
+			'values' => [ 'standard', 'natural' ]
 		],
 		/**
 		 * Max # characters of page title to display.
@@ -1121,47 +1115,45 @@ class ParametersData {
 		 * Not applicable to mode=category.
 		 */
 		'titlemaxlength' => [
-			'default'	=> null,
-			'integer'	=> true
+			'default' => null,
+			'integer' => true
 		]
 	];
 
-	/**
-	 * Main Constructor
-	 *
-	 * @access	public
-	 * @return	void
-	 */
 	public function __construct() {
 		$this->setRichness( Config::getSetting( 'functionalRichness' ) );
 
-		if ( \DynamicPageListHooks::isLikeIntersection() ) {
+		if ( DynamicPageListHooks::isLikeIntersection() ) {
 			$this->data['ordermethod'] = [
-				'default'	=> 'categoryadd',
-				'values'	=> [
+				'default' => 'categoryadd',
+				'values' => [
 					'categoryadd',
 					'lastedit',
 					'none'
 				]
 			];
+
 			$this->data['order'] = [
-				'default'	=> 'descending',
-				'values'	=> [
+				'default' => 'descending',
+				'values' => [
 					'ascending',
 					'descending'
 				]
 			];
+
 			$this->data['mode'] = [
-				'default'	=> 'unordered',
-				'values'	=> [
+				'default' => 'unordered',
+				'values' => [
 					'none',
 					'ordered',
 					'unordered'
 				]
 			];
+
 			$this->data['userdateformat'] = [
 				'default' => 'Y-m-d: '
 			];
+
 			$this->data['allowcachedresults']['default'] = 'true';
 		}
 	}
@@ -1169,9 +1161,8 @@ public function __construct() {
 	/**
 	 * Return if the parameter exists.
 	 *
-	 * @access	public
-	 * @param	string	Parameter name.
-	 * @return	boolean	Exists
+	 * @param string $parameter
+	 * @return bool
 	 */
 	public function exists( $parameter ) {
 		return array_key_exists( $parameter, $this->data );
@@ -1180,9 +1171,8 @@ public function exists( $parameter ) {
 	/**
 	 * Return data for the supplied parameter.
 	 *
-	 * @access	public
-	 * @param	string	Parameter name.
-	 * @return	mixed	Parameter array or false if it does not exist.
+	 * @param string $parameter
+	 * @return mixed
 	 */
 	public function getData( $parameter ) {
 		if ( array_key_exists( $parameter, $this->data ) ) {
@@ -1195,9 +1185,7 @@ public function getData( $parameter ) {
 	/**
 	 * Sets the current parameter richness.
 	 *
-	 * @access	public
-	 * @param	integer	Integer level.
-	 * @return	void
+	 * @param int $level
 	 */
 	public function setRichness( $level ) {
 		$this->parameterRichness = intval( $level );
@@ -1206,8 +1194,7 @@ public function setRichness( $level ) {
 	/**
 	 * Returns the current parameter richness.
 	 *
-	 * @access	public
-	 * @return	integer
+	 * @return int
 	 */
 	public function getRichness() {
 		return $this->parameterRichness;
@@ -1216,27 +1203,27 @@ public function getRichness() {
 	/**
 	 * Tests if the function is valid for the current functional richness level.
 	 *
-	 * @access	public
-	 * @param	string	Function to test.
-	 * @return	boolean	Valid for this functional richness level.
+	 * @param string $function
+	 * @return bool
 	 */
 	public function testRichness( $function ) {
 		$valid = false;
+
 		for ( $i = 0; $i <= $this->getRichness(); $i++ ) {
 			if ( in_array( $function, self::$parametersForRichnessLevel[$i] ) ) {
 				$valid = true;
 				break;
 			}
 		}
+
 		return $valid;
 	}
 
 	/**
 	 * Returns all parameters for the current richness level or limited to the optional maximum richness.
 	 *
-	 * @access	public
-	 * @param	integer	[Optional] Maximum richness level
-	 * @return	array	The functional richness parameters list.
+	 * @param int|null $level
+	 * @return array
 	 */
 	public function getParametersForRichness( $level = null ) {
 		if ( $level === null ) {
@@ -1244,9 +1231,11 @@ public function getParametersForRichness( $level = null ) {
 		}
 
 		$parameters = [];
+
 		for ( $i = 0; $i <= $level; $i++ ) {
 			$parameters = array_merge( $parameters, self::$parametersForRichnessLevel[$i] );
 		}
+
 		sort( $parameters );
 
 		return $parameters;
@@ -1255,136 +1244,144 @@ public function getParametersForRichness( $level = null ) {
 	/**
 	 * Return the default value for the parameter.
 	 *
-	 * @access	public
-	 * @param	string	Parameter Name
-	 * @return	mixed
+	 * @param string $parameter
+	 * @return mixed
 	 */
 	public function getDefault( $parameter ) {
 		if ( array_key_exists( $parameter, $this->data ) ) {
 			if ( array_key_exists( 'default', $this->data[$parameter] ) ) {
 				return (bool)$this->data[$parameter]['default'];
 			}
+
 			return null;
 		}
+
 		throw new MWException( __METHOD__ . ": Attempted to load a parameter that does not exist." );
 	}
 
 	/**
 	 * Return the acceptable values for the parameter.
 	 *
-	 * @access	public
-	 * @param	string	Parameter Name
-	 * @return	mixed	Array of allowed values or false that the parameter allows any.
+	 * @param string $parameter
+	 * @return mixed
 	 */
 	public function getValues( $parameter ) {
 		if ( array_key_exists( $parameter, $this->data ) ) {
 			if ( array_key_exists( 'values', $this->data[$parameter] ) ) {
 				return (bool)$this->data[$parameter]['values'];
 			}
+
 			return false;
 		}
+
 		throw new MWException( __METHOD__ . ": Attempted to load a parameter that does not exist." );
 	}
 
 	/**
 	 * Does the parameter set that criteria for selection was found?
 	 *
-	 * @access	public
-	 * @param	string	Parameter Name
-	 * @return	bool
+	 * @param string $parameter
+	 * @return bool
 	 */
 	public function setsCriteriaFound( $parameter ) {
 		if ( array_key_exists( $parameter, $this->data ) ) {
 			if ( array_key_exists( 'set_criteria_found', $this->data[$parameter] ) ) {
 				return (bool)$this->data[$parameter]['set_criteria_found'];
 			}
+
 			return false;
 		}
+
 		throw new MWException( __METHOD__ . ": Attempted to load a parameter that does not exist." );
 	}
 
 	/**
 	 * Does the parameter cause an open reference conflict?
 	 *
-	 * @access	public
-	 * @param	string	Parameter Name
-	 * @return	bool
+	 * @param string $parameter
+	 * @return bool
 	 */
 	public function isOpenReferenceConflict( $parameter ) {
 		if ( array_key_exists( $parameter, $this->data ) ) {
 			if ( array_key_exists( 'open_ref_conflict', $this->data[$parameter] ) ) {
 				return (bool)$this->data[$parameter]['open_ref_conflict'];
 			}
+
 			return false;
 		}
+
 		throw new MWException( __METHOD__ . ": Attempted to load a parameter that does not exist." );
 	}
 
 	/**
 	 * Should this parameter preserve the case of the user supplied input?
 	 *
-	 * @access	public
-	 * @param	string	Parameter Name
-	 * @return	bool
+	 * @param string $parameter
+	 * @return bool
 	 */
 	public function shouldPreserveCase( $parameter ) {
 		if ( array_key_exists( $parameter, $this->data ) ) {
 			if ( array_key_exists( 'preserve_case', $this->data[$parameter] ) ) {
 				return (bool)$this->data[$parameter]['preserve_case'];
 			}
+
 			return false;
 		}
+
 		throw new MWException( __METHOD__ . ": Attempted to load a parameter that does not exist." );
 	}
 
 	/**
 	 * Does this parameter take a list of page names?
 	 *
-	 * @access	public
-	 * @param	string	Parameter Name
-	 * @return	bool
+	 * @param string $parameter
+	 * @return bool
 	 */
 	public function isPageNameList( $parameter ) {
 		if ( array_key_exists( $parameter, $this->data ) ) {
 			if ( array_key_exists( 'page_name_list', $this->data[$parameter] ) ) {
 				return (bool)$this->data[$parameter]['page_name_list'];
 			}
+
 			return false;
 		}
+
 		throw new MWException( __METHOD__ . ": Attempted to load a parameter that does not exist." );
 	}
 
 	/**
 	 * Is the parameter supposed to be parsed as a boolean?
 	 *
-	 * @access	public
-	 * @param	string	Parameter Name
-	 * @return	bool
+	 * @param string $parameter
+	 * @return bool
 	 */
 	public function isBoolean( $parameter ) {
 		if ( array_key_exists( $parameter, $this->data ) ) {
 			if ( array_key_exists( 'boolean', $this->data[$parameter] ) ) {
 				return (bool)$this->data[$parameter]['boolean'];
 			}
+
 			return false;
 		}
+
 		throw new MWException( __METHOD__ . ": Attempted to load a parameter that does not exist." );
 	}
 
 	/**
 	 * Is the parameter supposed to be parsed as a Mediawiki timestamp?
 	 *
-	 * @access	public
-	 * @param	string	Parameter Name
-	 * @return	bool
+	 * @param string $parameter
+	 * @return bool
 	 */
 	public function isTimestamp( $parameter ) {
 		if ( array_key_exists( $parameter, $this->data ) ) {
 			if ( array_key_exists( 'timestamp', $this->data[$parameter] ) ) {
 				return (bool)$this->data[$parameter]['timestamp'];
 			}
+
 			return false;
 		}
+
 		throw new MWException( __METHOD__ . ": Attempted to load a parameter that does not exist." );
 	}
 }
diff --git a/includes/Parse.php b/includes/Parse.php
index 97f09f49..f9de2fbe 100644
--- a/includes/Parse.php
+++ b/includes/Parse.php
@@ -1,51 +1,44 @@
 <?php
-/**
- * DynamicPageList3
- * DPL Parse Class
- *
- * @author		IlyaHaykinson, Unendlich, Dangerville, Algorithmix, Theaitetos, Alexia E. Smith, Universal Omega
- * @license		GPL-2.0-or-later
- * @package		DynamicPageList3
- *
- */
+
 namespace DPL;
 
+use ActorMigration;
 use DPL\Heading\Heading;
 use DPL\Lister\Lister;
+use ExtVariables;
+use MediaWiki\MediaWikiServices;
+use MWException;
+use Parser;
+use Title;
+use WebRequest;
+use Wikimedia\Rdbms\IDatabase;
 
 class Parse {
 	/**
 	 * Mediawiki Database Object
 	 *
-	 * @var object
+	 * @var IDatabase
 	 */
 	private $DB = null;
 
 	/**
-	 * Mediawiki Parser Object
-	 *
-	 * @var object
-	 */
-	private $parser = null;
-
-	/**
-	 * \DPL\Parameters Object
+	 * Parameters Object
 	 *
-	 * @var object
+	 * @var Parameters
 	 */
 	private $parameters = null;
 
 	/**
-	 * \DPL\Logger Object
+	 * Logger Object
 	 *
-	 * @var object
+	 * @var Logger
 	 */
 	private $logger = null;
 
 	/**
 	 * Array of prequoted table names.
 	 *
-	 * @var array
+	 * @var string[]
 	 */
 	private $tableNames = [];
 
@@ -84,6 +77,13 @@ class Parse {
 	 */
 	private $replacementVariables = [];
 
+	/**
+	 * WebRequest object
+	 *
+	 * @var WebRequest
+	 */
+	private $request;
+
 	/**
 	 * Array of possible URL arguments.
 	 *
@@ -97,50 +97,46 @@ class Parse {
 		'DPL_toTitle'
 	];
 
-	/**
-	 * Main Constructor
-	 *
-	 * @access	public
-	 * @return	void
-	 */
 	public function __construct() {
 		global $wgRequest;
 
-		$this->DB			= wfGetDB( DB_REPLICA, 'dpl' );
-		$this->parameters	= new Parameters();
-		$this->logger		= new Logger( $this->parameters->getData( 'debug' )['default'] );
-		$this->tableNames	= Query::getTableNames();
-		$this->wgRequest	= $wgRequest;
+		$this->DB = wfGetDB( DB_REPLICA, 'dpl' );
+		$this->parameters = new Parameters();
+		$this->logger = new Logger();
+		$this->tableNames = Query::getTableNames();
+		$this->request = $wgRequest;
 	}
 
 	/**
 	 * The real callback function for converting the input text to wiki text output
 	 *
-	 * @access	public
-	 * @param	string	Raw User Input
-	 * @param	object	Mediawiki Parser object.
-	 * @param	array	End Reset Booleans
-	 * @param	array	End Eliminate Booleans
-	 * @param	boolean	[Optional] Called as a parser tag
-	 * @return	string	Wiki/HTML Output
+	 * @param string $input
+	 * @param Parser $parser
+	 * @param array &$reset
+	 * @param array	&$eliminate
+	 * @param bool $isParserTag
+	 * @return string
+	 *
+	 * @suppress PhanUndeclaredProperty Use of Parser::mTemplatePath
 	 */
-	public function parse( $input, \Parser $parser, &$reset, &$eliminate, $isParserTag = false ) {
+	public function parse( $input, Parser $parser, &$reset, &$eliminate, $isParserTag = false ) {
 		$dplStartTime = microtime( true );
-		$this->parser = $parser;
 
-		//Reset headings when being ran more than once in the same page load.
+		// Reset headings when being ran more than once in the same page load.
 		Article::resetHeadings();
 
-		//Check that we are not in an infinite transclusion loop
-		if ( isset( $this->parser->mTemplatePath[$this->parser->mTitle->getPrefixedText()] ) ) {
-			$this->logger->addMessage( \DynamicPageListHooks::WARN_TRANSCLUSIONLOOP, $this->parser->mTitle->getPrefixedText() );
+		// Check that we are not in an infinite transclusion loop
+		if ( isset( $parser->mTemplatePath[$parser->getTitle()->getPrefixedText()] ) ) {
+			$this->logger->addMessage( DynamicPageListHooks::WARN_TRANSCLUSIONLOOP, $parser->getTitle()->getPrefixedText() );
+
 			return $this->getFullOutput();
 		}
 
-		//Check if DPL shall only be executed from protected pages.
-		if ( Config::getSetting( 'runFromProtectedPagesOnly' ) === true && !$this->parser->mTitle->isProtected( 'edit' ) ) {
-			//Ideally we would like to allow using a DPL query if the query istelf is coded on a template page which is protected. Then there would be no need for the article to be protected.  However, how can one find out from which wiki source an extension has been invoked???
-			$this->logger->addMessage( \DynamicPageListHooks::FATAL_NOTPROTECTED, $this->parser->mTitle->getPrefixedText() );
+		// Check if DPL shall only be executed from protected pages.
+		if ( Config::getSetting( 'runFromProtectedPagesOnly' ) === true && !$parser->getTitle()->isProtected( 'edit' ) ) {
+			// Ideally we would like to allow using a DPL query if the query istelf is coded on a template page which is protected. Then there would be no need for the article to be protected. However, how can one find out from which wiki source an extension has been invoked???
+			$this->logger->addMessage( DynamicPageListHooks::FATAL_NOTPROTECTED, $parser->getTitle()->getPrefixedText() );
+
 			return $this->getFullOutput();
 		}
 
@@ -152,10 +148,11 @@ public function parse( $input, \Parser $parser, &$reset, &$eliminate, $isParserT
 				$this->urlArguments[] = 'DPL_arg' . $i;
 			}
 		}
+
 		$input = $this->resolveUrlArguments( $input, $this->urlArguments );
-		$this->getUrlArgs( $this->parser );
+		$this->getUrlArgs( $parser );
 
-		$this->parameters->setParameter( 'offset', $this->wgRequest->getInt( 'DPL_offset', $this->parameters->getData( 'offset' )['default'] ) );
+		$this->parameters->setParameter( 'offset', $this->request->getInt( 'DPL_offset', $this->parameters->getData( 'offset' )['default'] ) );
 		$offset = $this->parameters->getParameter( 'offset' );
 
 		/***************************************/
@@ -163,19 +160,21 @@ public function parse( $input, \Parser $parser, &$reset, &$eliminate, $isParserT
 		/***************************************/
 		$cleanParameters = $this->prepareUserInput( $input );
 		if ( !is_array( $cleanParameters ) ) {
-			//Short circuit for dumb things.
-			$this->logger->addMessage( \DynamicPageListHooks::FATAL_NOSELECTION );
+			// Short circuit for dumb things.
+			$this->logger->addMessage( DynamicPageListHooks::FATAL_NOSELECTION );
+
 			return $this->getFullOutput();
 		}
+
 		$cleanParameters = Parameters::sortByPriority( $cleanParameters );
 		$this->parameters->setParameter( 'includeuncat', false ); // to check if pseudo-category of Uncategorized pages is included
 
 		foreach ( $cleanParameters as $parameter => $option ) {
 			foreach ( $option as $_option ) {
-				//Parameter functions return true or false.  The full parameter data will be passed into the Query object later.
+				// Parameter functions return true or false. The full parameter data will be passed into the Query object later.
 				if ( $this->parameters->$parameter( $_option ) === false ) {
-					//Do not build this into the output just yet.  It will be collected at the end.
-					$this->logger->addMessage( \DynamicPageListHooks::WARN_WRONGPARAM, $parameter, $_option );
+					// Do not build this into the output just yet. It will be collected at the end.
+					$this->logger->addMessage( DynamicPageListHooks::WARN_WRONGPARAM, $parameter, $_option );
 				}
 			}
 		}
@@ -184,15 +183,16 @@ public function parse( $input, \Parser $parser, &$reset, &$eliminate, $isParserT
 		/* Execute and Exit Only */
 		/*************************/
 		if ( $this->parameters->getParameter( 'execandexit' ) !== null ) {
-			//The keyword "geturlargs" is used to return the Url arguments and do nothing else.
+			// The keyword "geturlargs" is used to return the Url arguments and do nothing else.
 			if ( $this->parameters->getParameter( 'execandexit' ) == 'geturlargs' ) {
-				return;
+				return '';
 			}
-			//In all other cases we return the value of the argument which may contain parser function calls.
+
+			// In all other cases we return the value of the argument which may contain parser function calls.
 			return $this->parameters->getParameter( 'execandexit' );
 		}
 
-		//Construct internal keys for TableRow according to the structure of "include".  This will be needed in the output phase.
+		// Construct internal keys for TableRow according to the structure of "include". This will be needed in the output phase.
 		$secLabels = $this->parameters->getParameter( 'seclabels' );
 		if ( is_array( $secLabels ) && !empty( $this->parameters->getParameter( 'seclabels' ) ) ) {
 			$this->parameters->setParameter( 'tablerow', $this->updateTableRowKeys( $this->parameters->getParameter( 'tablerow' ), $this->parameters->getParameter( 'seclabels' ) ) );
@@ -203,7 +203,7 @@ public function parse( $input, \Parser $parser, &$reset, &$eliminate, $isParserT
 		/****************/
 		$errors = $this->doQueryErrorChecks();
 		if ( $errors === false ) {
-			//WHAT HAS HAPPENED OH NOOOOOOOOOOOOO.
+			// WHAT HAS HAPPENED OH NOOOOOOOOOOOOO.
 			return $this->getFullOutput();
 		}
 
@@ -216,48 +216,50 @@ public function parse( $input, \Parser $parser, &$reset, &$eliminate, $isParserT
 		/* Query */
 		/*********/
 		try {
-			$this->query = new Query( $this->parameters );
-			$result = $this->query->buildAndSelect( $calcRows );
+			$actorMigration = ActorMigration::newMigration();
+			$commentStore = MediaWikiServices::getInstance()->getCommentStore();
+			$query = new Query( $this->parameters, $actorMigration, $commentStore );
+			$result = $query->buildAndSelect( $calcRows );
 		} catch ( MWException $e ) {
-			$this->logger->addMessage( \DynamicPageListHooks::FATAL_SQLBUILDERROR, $e->getMessage() );
+			$this->logger->addMessage( DynamicPageListHooks::FATAL_SQLBUILDERROR, $e->getMessage() );
 			return $this->getFullOutput();
 		}
 
 		$numRows = $this->DB->numRows( $result );
-		$articles = $this->processQueryResults( $result );
+		$articles = $this->processQueryResults( $result, $parser );
 
 		global $wgDebugDumpSql;
-		if ( \DynamicPageListHooks::getDebugLevel() >= 4 && $wgDebugDumpSql ) {
-			$this->addOutput( $this->query->getSqlQuery() . "\n" );
+		if ( DynamicPageListHooks::getDebugLevel() >= 4 && $wgDebugDumpSql ) {
+			$this->addOutput( $query->getSqlQuery() . "\n" );
 		}
 
 		$this->addOutput( '{{Extension DPL}}' );
 
-		//Preset these to defaults.
-		$this->setVariable( 'TOTALPAGES', 0 );
-		$this->setVariable( 'PAGES', 0 );
-		$this->setVariable( 'VERSION', DPL_VERSION );
+		// Preset these to defaults.
+		$this->setVariable( 'TOTALPAGES', '0' );
+		$this->setVariable( 'PAGES', '0' );
+		$this->setVariable( 'VERSION', DynamicPageListHooks::getVersion() );
 
 		/*********************/
 		/* Handle No Results */
 		/*********************/
 		if ( $numRows <= 0 || empty( $articles ) ) {
-			//Shortcut out since there is no processing to do.
+			// Shortcut out since there is no processing to do.
 			$this->DB->freeResult( $result );
 			return $this->getFullOutput( 0, false );
 		}
 
 		$foundRows = null;
 		if ( $calcRows ) {
-			$foundRows = $this->query->getFoundRows();
+			$foundRows = $query->getFoundRows();
 		}
 
-		//Backward scrolling: If the user specified only titlelt with descending reverse the output order.
+		// Backward scrolling: If the user specified only titlelt with descending reverse the output order.
 		if ( $this->parameters->getParameter( 'titlelt' ) && !$this->parameters->getParameter( 'titlegt' ) && $this->parameters->getParameter( 'order' ) == 'descending' ) {
 			$articles = array_reverse( $articles );
 		}
 
-		//Special sort for card suits (Bridge)
+		// Special sort for card suits (Bridge)
 		if ( $this->parameters->getParameter( 'ordersuitsymbols' ) ) {
 			$articles = $this->cardSuitSort( $articles );
 		}
@@ -265,7 +267,7 @@ public function parse( $input, \Parser $parser, &$reset, &$eliminate, $isParserT
 		/*******************/
 		/* Generate Output */
 		/*******************/
-		$lister = Lister::newFromStyle( $this->parameters->getParameter( 'mode' ), $this->parameters, $this->parser );
+		$lister = Lister::newFromStyle( $this->parameters->getParameter( 'mode' ), $this->parameters, $parser );
 		$heading = Heading::newFromStyle( $this->parameters->getParameter( 'headingmode' ), $this->parameters );
 		if ( $heading !== null ) {
 			$this->addOutput( $heading->format( $articles, $lister ) );
@@ -273,30 +275,37 @@ public function parse( $input, \Parser $parser, &$reset, &$eliminate, $isParserT
 			$this->addOutput( $lister->format( $articles ) );
 		}
 
-		//$this->addOutput($lister->format($articles));
+		// $this->addOutput($lister->format($articles));
 		if ( $foundRows === null ) {
-			$foundRows = $lister->getRowCount(); //Get row count after calling format() otherwise the count will be inaccurate.
+			$foundRows = $lister->getRowCount(); // Get row count after calling format() otherwise the count will be inaccurate.
 		}
 
 		/*******************************/
 		/* Replacement Variables       */
 		/*******************************/
-		$this->setVariable( 'TOTALPAGES', $foundRows ); //Guaranteed to be an accurate count if SQL_CALC_FOUND_ROWS was used.  Otherwise only accurate if results are less than the SQL LIMIT.
-		$this->setVariable( 'PAGES', $lister->getRowCount() ); //This could be different than TOTALPAGES.  PAGES represents the total results within the constraints of SQL LIMIT.
+		$this->setVariable( 'TOTALPAGES', (string)$foundRows ); // Guaranteed to be an accurate count if SQL_CALC_FOUND_ROWS was used. Otherwise only accurate if results are less than the SQL LIMIT.
+		$this->setVariable( 'PAGES', $lister->getRowCount() ); // This could be different than TOTALPAGES. PAGES represents the total results within the constraints of SQL LIMIT.
 
 		//Replace %DPLTIME% by execution time and timestamp in header and footer
-		$nowTimeStamp   = date( 'Y/m/d H:i:s' );
+		$nowTimeStamp = date( 'Y/m/d H:i:s' );
 		$dplElapsedTime = sprintf( '%.3f sec.', microtime( true ) - $dplStartTime );
 		$dplTime = "{$dplElapsedTime} ({$nowTimeStamp})";
 		$this->setVariable( 'DPLTIME', $dplTime );
 
-		//Replace %LASTTITLE% / %LASTNAMESPACE% by the last title found in header and footer
-		if ( ( $n = count( $articles ) ) > 0 ) {
+		$firstNamespaceFound = '';
+		$firstTitleFound = '';
+		$lastNamespaceFound = '';
+		$lastTitleFound = '';
+
+		// Replace %LASTTITLE% / %LASTNAMESPACE% by the last title found in header and footer
+		$n = count( $articles );
+		if ( $n > 0 ) {
 			$firstNamespaceFound = str_replace( ' ', '_', $articles[0]->mTitle->getNamespace() );
-			$firstTitleFound     = str_replace( ' ', '_', $articles[0]->mTitle->getText() );
-			$lastNamespaceFound  = str_replace( ' ', '_', $articles[$n - 1]->mTitle->getNamespace() );
-			$lastTitleFound      = str_replace( ' ', '_', $articles[$n - 1]->mTitle->getText() );
+			$firstTitleFound = str_replace( ' ', '_', $articles[0]->mTitle->getText() );
+			$lastNamespaceFound = str_replace( ' ', '_', $articles[$n - 1]->mTitle->getNamespace() );
+			$lastTitleFound = str_replace( ' ', '_', $articles[$n - 1]->mTitle->getText() );
 		}
+
 		$this->setVariable( 'FIRSTNAMESPACE', $firstNamespaceFound );
 		$this->setVariable( 'FIRSTTITLE', $firstTitleFound );
 		$this->setVariable( 'LASTNAMESPACE', $lastNamespaceFound );
@@ -307,27 +316,28 @@ public function parse( $input, \Parser $parser, &$reset, &$eliminate, $isParserT
 		/* Scroll Variables            */
 		/*******************************/
 		$scrollVariables = [
-			'DPL_firstNamespace'	=> $firstNamespaceFound,
-			'DPL_firstTitle'		=> $firstTitleFound,
-			'DPL_lastNamespace'		=> $lastNamespaceFound,
-			'DPL_lastTitle'			=> $lastTitleFound,
-			'DPL_scrollDir'			=> $this->parameters->getParameter( 'scrolldir' ),
-			'DPL_time'				=> $dplTime,
-			'DPL_count'				=> $this->parameters->getParameter( 'count' ),
-			'DPL_totalPages'		=> $foundRows,
-			'DPL_pages'				=> $lister->getRowCount()
+			'DPL_firstNamespace' => $firstNamespaceFound,
+			'DPL_firstTitle' => $firstTitleFound,
+			'DPL_lastNamespace' => $lastNamespaceFound,
+			'DPL_lastTitle' => $lastTitleFound,
+			'DPL_scrollDir' => $this->parameters->getParameter( 'scrolldir' ),
+			'DPL_time' => $dplTime,
+			'DPL_count' => $this->parameters->getParameter( 'count' ),
+			'DPL_totalPages' => $foundRows,
+			'DPL_pages' => $lister->getRowCount()
 		];
-		$this->defineScrollVariables( $scrollVariables );
+
+		$this->defineScrollVariables( $scrollVariables, $parser );
 
 		if ( $this->parameters->getParameter( 'allowcachedresults' ) || Config::getSetting( 'alwaysCacheResults' ) ) {
-			$this->parser->getOutput()->updateCacheExpiry( $this->parameters->getParameter( 'cacheperiod' ) ?? 3600 );
+			$parser->getOutput()->updateCacheExpiry( $this->parameters->getParameter( 'cacheperiod' ) ?? 3600 );
 		} else {
-			$this->parser->getOutput()->updateCacheExpiry( 0 );
+			$parser->getOutput()->updateCacheExpiry( 0 );
 		}
 
 		$finalOutput = $this->getFullOutput( $foundRows, false );
 
-		$this->triggerEndResets( $finalOutput, $reset, $eliminate, $isParserTag );
+		$this->triggerEndResets( $finalOutput, $reset, $eliminate, $isParserTag, $parser );
 
 		return $finalOutput;
 	}
@@ -335,29 +345,29 @@ public function parse( $input, \Parser $parser, &$reset, &$eliminate, $isParserT
 	/**
 	 * Process Query Results
 	 *
-	 * @private
-	 * @param	object	Mediawiki Result Object
-	 * @return	array	Array of Article objects.
+	 * @param $result
+	 * @param Parser $parser
+	 * @return array
 	 */
-	private function processQueryResults( $result ) {
+	private function processQueryResults( $result, Parser $parser ) {
 		/*******************************/
 		/* Random Count Pick Generator */
 		/*******************************/
 		$randomCount = $this->parameters->getParameter( 'randomcount' );
 		if ( $randomCount > 0 ) {
 			$nResults = $this->DB->numRows( $result );
-			//mt_srand() seeding was removed due to PHP 5.2.1 and above no longer generating the same sequence for the same seed.
+			// mt_srand() seeding was removed due to PHP 5.2.1 and above no longer generating the same sequence for the same seed.
 			//Constrain the total amount of random results to not be greater than the total results.
 			if ( $randomCount > $nResults ) {
 				$randomCount = $nResults;
 			}
 
-			//This is 50% to 150% faster than the old while (true) version that could keep rechecking the same random key over and over again.
-			//Generate pick numbers for results.
+			// This is 50% to 150% faster than the old while (true) version that could keep rechecking the same random key over and over again.
+			// Generate pick numbers for results.
 			$pick = range( 1, $nResults );
-			//Shuffle the pick numbers.
+			// Shuffle the pick numbers.
 			shuffle( $pick );
-			//Select pick numbers from the beginning to the maximum of $randomCount.
+			// Select pick numbers from the beginning to the maximum of $randomCount.
 			$pick = array_slice( $pick, 0, $randomCount );
 		}
 
@@ -370,27 +380,27 @@ private function processQueryResults( $result ) {
 		while ( $row = $result->fetchRow() ) {
 			$i++;
 
-			//In random mode skip articles which were not chosen.
-			if ( $randomCount > 0 && !in_array( $i, $pick ) ) {
+			// In random mode skip articles which were not chosen.
+			if ( $randomCount > 0 && !in_array( $i, $pick ?? [] ) ) {
 				continue;
 			}
 
 			if ( $this->parameters->getParameter( 'goal' ) == 'categories' ) {
 				$pageNamespace = NS_CATEGORY;
-				$pageTitle     = $row['cl_to'];
+				$pageTitle = $row['cl_to'];
 			} elseif ( $this->parameters->getParameter( 'openreferences' ) ) {
 				if ( count( $this->parameters->getParameter( 'imagecontainer' ) ) > 0 ) {
 					$pageNamespace = NS_FILE;
-					$pageTitle     = $row['il_to'];
+					$pageTitle = $row['il_to'];
 				} else {
-					//Maybe non-existing title
+					// Maybe non-existing title
 					$pageNamespace = $row['pl_namespace'];
-					$pageTitle     = $row['pl_title'];
+					$pageTitle = $row['pl_title'];
 				}
 			} else {
-				//Existing PAGE TITLE
+				// Existing PAGE TITLE
 				$pageNamespace = $row['page_namespace'];
-				$pageTitle     = $row['page_title'];
+				$pageTitle = $row['page_title'];
 			}
 
 			// if subpages are to be excluded: skip them
@@ -398,16 +408,17 @@ private function processQueryResults( $result ) {
 				continue;
 			}
 
-			$title     = \Title::makeTitle( $pageNamespace, $pageTitle );
-			$thisTitle = $this->parser->getTitle();
+			$title = Title::makeTitle( $pageNamespace, $pageTitle );
+			$thisTitle = $parser->getTitle();
 
-			//Block recursion from happening by seeing if this result row is the page the DPL query was ran from.
+			// Block recursion from happening by seeing if this result row is the page the DPL query was ran from.
 			if ( $this->parameters->getParameter( 'skipthispage' ) && $thisTitle->equals( $title ) ) {
 				continue;
 			}
 
 			$articles[] = Article::newFromRow( $row, $this->parameters, $title, $pageNamespace, $pageTitle );
 		}
+
 		$this->DB->freeResult( $result );
 
 		return $articles;
@@ -416,70 +427,71 @@ private function processQueryResults( $result ) {
 	/**
 	 * Do basic clean up and structuring of raw user input.
 	 *
-	 * @private
-	 * @param	string	Raw User Input
-	 * @return	array	Array of raw text parameter => option.
+	 * @param string $input
+	 * @return array
 	 */
 	private function prepareUserInput( $input ) {
-		//We replace double angle brackets with single angle brackets to avoid premature tag expansion in the input.
-		//The  symbol is an alias for |.
-		//The combination '{' and '}'will be translated to double curly braces; this allows postponed template execution which is crucial for DPL queries which call other DPL queries.
+		// We replace double angle brackets with single angle brackets to avoid premature tag expansion in the input.
+		// The  symbol is an alias for |.
+		// The combination '{' and '}'will be translated to double curly braces; this allows postponed template execution which is crucial for DPL queries which call other DPL queries.
 		$input = str_replace( [ '', '', '', '{', '}' ], [ '<', '>', '|', '{{', '}}' ], $input );
 
-		//Standard new lines into the standard \n and clean up any hanging new lines.
+		// Standard new lines into the standard \n and clean up any hanging new lines.
 		$input = str_replace( [ "\r\n", "\r" ], "\n", $input );
 		$input = trim( $input, "\n" );
 		$rawParameters = explode( "\n", $input );
 
-		$parameters = false;
+		$parameters = [];
 		foreach ( $rawParameters as $parameterOption ) {
 			if ( empty( $parameterOption ) ) {
-				//Softly ignore blank lines.
+				// Softly ignore blank lines.
 				continue;
 			}
 
 			if ( strpos( $parameterOption, '=' ) === false ) {
-				$this->logger->addMessage( \DynamicPageListHooks::WARN_PARAMNOOPTION, $parameterOption );
+				$this->logger->addMessage( DynamicPageListHooks::WARN_PARAMNOOPTION, $parameterOption );
+
 				continue;
 			}
 
-			list( $parameter, $option ) = explode( '=', $parameterOption, 2 );
+			[ $parameter, $option ] = explode( '=', $parameterOption, 2 );
 			$parameter = trim( $parameter );
-			$option  = trim( $option );
+			$option = trim( $option );
 
 			if ( strpos( $parameter, '<' ) !== false || strpos( $parameter, '>' ) !== false ) {
-				//Having the actual less than and greater than symbols is nasty for programatic look up.  The old parameter is still supported along with the new, but we just fix it here before calling it.
+				// Having the actual less than and greater than symbols is nasty for programatic look up. The old parameter is still supported along with the new, but we just fix it here before calling it.
 				$parameter = str_replace( '<', 'lt', $parameter );
 				$parameter = str_replace( '>', 'gt', $parameter );
 			}
 
-			$parameter = strtolower( $parameter ); //Force lower case for ease of use.
+			$parameter = strtolower( $parameter ); // Force lower case for ease of use.
 			if ( empty( $parameter ) || substr( $parameter, 0, 1 ) == '#' || ( $this->parameters->exists( $parameter ) && !$this->parameters->testRichness( $parameter ) ) ) {
 				continue;
 			}
 
 			if ( !$this->parameters->exists( $parameter ) ) {
-				$this->logger->addMessage( \DynamicPageListHooks::WARN_UNKNOWNPARAM, $parameter, implode( ', ', $this->parameters->getParametersForRichness() ) );
+				$this->logger->addMessage( DynamicPageListHooks::WARN_UNKNOWNPARAM, $parameter, implode( ', ', $this->parameters->getParametersForRichness() ) );
+
 				continue;
 			}
 
-			//Ignore parameter settings without argument (except namespace and category).
+			// Ignore parameter settings without argument (except namespace and category).
 			if ( !strlen( $option ) ) {
 				if ( $parameter != 'namespace' && $parameter != 'notnamespace' && $parameter != 'category' && $this->parameters->exists( $parameter ) ) {
 					continue;
 				}
 			}
+
 			$parameters[$parameter][] = $option;
 		}
+
 		return $parameters;
 	}
 
 	/**
 	 * Concatenate output
 	 *
-	 * @private
-	 * @param	string	Output to add
-	 * @return	void
+	 * @param string $output
 	 */
 	private function addOutput( $output ) {
 		$this->output .= $output;
@@ -488,32 +500,32 @@ private function addOutput( $output ) {
 	/**
 	 * Set the output text.
 	 *
-	 * @private
-	 * @return	string	Output Text
+	 * @return string
 	 */
 	private function getOutput() {
-		//@TODO: 2015-08-28 Consider calling $this->replaceVariables() here.  Might cause issues with text returned in the results.
+		// @TODO: 2015-08-28 Consider calling $this->replaceVariables() here. Might cause issues with text returned in the results.
 		return $this->output;
 	}
 
 	/**
 	 * Return output optionally including header and footer.
 	 *
-	 * @private
-	 * @param	boolean	[Optional] Total results.
-	 * @param	boolean	[Optional] Skip adding the header and footer.
-	 * @return	string	Output
+	 * @param bool|int $totalResults
+	 * @param bool $skipHeaderFooter
+	 * @return string
 	 */
 	private function getFullOutput( $totalResults = false, $skipHeaderFooter = true ) {
 		if ( !$skipHeaderFooter ) {
 			$header = '';
 			$footer = '';
-			//Only override header and footers if specified.
-			$_headerType = $this->getHeaderFooterType( 'header', $totalResults );
+
+			// Only override header and footers if specified.
+			$_headerType = $this->getHeaderFooterType( 'header', (int)$totalResults );
 			if ( $_headerType !== false ) {
 				$header = $this->parameters->getParameter( $_headerType );
 			}
-			$_footerType = $this->getHeaderFooterType( 'footer', $totalResults );
+
+			$_footerType = $this->getHeaderFooterType( 'footer', (int)$totalResults );
 			if ( $_footerType !== false ) {
 				$footer = $this->parameters->getParameter( $_footerType );
 			}
@@ -523,8 +535,9 @@ private function getFullOutput( $totalResults = false, $skipHeaderFooter = true
 		}
 
 		if ( !$totalResults && !strlen( $this->getHeader() ) && !strlen( $this->getFooter() ) ) {
-			$this->logger->addMessage( \DynamicPageListHooks::WARN_NORESULTS );
+			$this->logger->addMessage( DynamicPageListHooks::WARN_NORESULTS );
 		}
+
 		$messages = $this->logger->getMessages( false );
 
 		return ( count( $messages ) ? implode( "<br/>\n", $messages ) : null ) . $this->getHeader() . $this->getOutput() . $this->getFooter();
@@ -533,22 +546,20 @@ private function getFullOutput( $totalResults = false, $skipHeaderFooter = true
 	/**
 	 * Set the header text.
 	 *
-	 * @private
-	 * @param	string	Header Text
-	 * @return	void
+	 * @param string $header
 	 */
 	private function setHeader( $header ) {
-		if ( \DynamicPageListHooks::getDebugLevel() == 5 ) {
+		if ( DynamicPageListHooks::getDebugLevel() == 5 ) {
 			$header = '<pre><nowiki>' . $header;
 		}
+
 		$this->header = $this->replaceVariables( $header );
 	}
 
 	/**
 	 * Set the header text.
 	 *
-	 * @private
-	 * @return	string	Header Text
+	 * @return string
 	 */
 	private function getHeader() {
 		return $this->header;
@@ -557,22 +568,20 @@ private function getHeader() {
 	/**
 	 * Set the footer text.
 	 *
-	 * @private
-	 * @param	string	Footer Text
-	 * @return	void
+	 * @param string $footer
 	 */
 	private function setFooter( $footer ) {
-		if ( \DynamicPageListHooks::getDebugLevel() == 5 ) {
+		if ( DynamicPageListHooks::getDebugLevel() == 5 ) {
 			$footer .= '</nowiki></pre>';
 		}
+
 		$this->footer = $this->replaceVariables( $footer );
 	}
 
 	/**
 	 * Set the footer text.
 	 *
-	 * @private
-	 * @return	string	Footer Text
+	 * @return string
 	 */
 	private function getFooter() {
 		return $this->footer;
@@ -581,13 +590,13 @@ private function getFooter() {
 	/**
 	 * Determine the header/footer type to use based on what output format parameters were chosen and the number of results.
 	 *
-	 * @private
-	 * @param	string	Page position to check: 'header' or 'footer'.
-	 * @param	integer	Count of pages.
-	 * @return	mixed	Type to use: 'results', 'oneresult', or 'noresults'.  False if invalid or none should be used.
+	 * @param string $position
+	 * @param int $count
+	 * @return mixed Type to use: 'results', 'oneresult', or 'noresults'. False if invalid or none should be used.
 	 */
 	private function getHeaderFooterType( $position, $count ) {
 		$count = intval( $count );
+
 		if ( $position != 'header' && $position != 'footer' ) {
 			return false;
 		}
@@ -601,16 +610,15 @@ private function getHeaderFooterType( $position, $count ) {
 		} else {
 			$_type = false;
 		}
+
 		return $_type;
 	}
 
 	/**
 	 * Set a variable to be replaced with the provided text later at the end of the output.
 	 *
-	 * @private
-	 * @param	string	Variable name, will be transformed to uppercase and have leading and trailing percent signs added.
-	 * @param	string	Text to replace the variable with.
-	 * @return	void
+	 * @param string $variable
+	 * @param string $replacement
 	 */
 	private function setVariable( $variable, $replacement ) {
 		$variable = "%" . mb_strtoupper( $variable, "UTF-8" ) . "%";
@@ -620,24 +628,24 @@ private function setVariable( $variable, $replacement ) {
 	/**
 	 * Return text with variables replaced.
 	 *
-	 * @private
-	 * @param	string	Text to perform replacements on.
-	 * @return	string	Replaced Text
+	 * @param string $text
+	 * @return string
 	 */
 	private function replaceVariables( $text ) {
 		$text = self::replaceNewLines( $text );
+
 		foreach ( $this->replacementVariables as $variable => $replacement ) {
 			$text = str_replace( $variable, $replacement, $text );
 		}
+
 		return $text;
 	}
 
 	/**
 	 * Return text with custom new line characters replaced.
 	 *
-	 * @private
-	 * @param	string	Text
-	 * @return	string	New Lined Text
+	 * @param string $text
+	 * @return string
 	 */
 	public static function replaceNewLines( $text ) {
 		return str_replace( [ '\n', "" ], "\n", $text );
@@ -646,8 +654,7 @@ public static function replaceNewLines( $text ) {
 	/**
 	 * Work through processed parameters and check for potential issues.
 	 *
-	 * @private
-	 * @return	void
+	 * @return bool
 	 */
 	private function doQueryErrorChecks() {
 		/**************************/
@@ -666,6 +673,7 @@ private function doQueryErrorChecks() {
 				}
 			}
 		}
+
 		if ( is_array( $this->parameters->getParameter( 'notcategory' ) ) ) {
 			foreach ( $this->parameters->getParameter( 'notcategory' ) as $comparisonType => $operatorTypes ) {
 				foreach ( $operatorTypes as $operatorType => $categories ) {
@@ -676,64 +684,73 @@ private function doQueryErrorChecks() {
 			}
 		}
 
-		//Too many categories.
+		// Too many categories.
 		if ( $totalCategories > Config::getSetting( 'maxCategoryCount' ) && !Config::getSetting( 'allowUnlimitedCategories' ) ) {
-			$this->logger->addMessage( \DynamicPageListHooks::FATAL_TOOMANYCATS, Config::getSetting( 'maxCategoryCount' ) );
+			$this->logger->addMessage( DynamicPageListHooks::FATAL_TOOMANYCATS, Config::getSetting( 'maxCategoryCount' ) );
+
 			return false;
 		}
 
-		//Not enough categories.(Really?)
+		// Not enough categories.(Really?)
 		if ( $totalCategories < Config::getSetting( 'minCategoryCount' ) ) {
-			$this->logger->addMessage( \DynamicPageListHooks::FATAL_TOOFEWCATS, Config::getSetting( 'minCategoryCount' ) );
+			$this->logger->addMessage( DynamicPageListHooks::FATAL_TOOFEWCATS, Config::getSetting( 'minCategoryCount' ) );
+
 			return false;
 		}
 
-		//Selection criteria needs to be found.
+		// Selection criteria needs to be found.
 		if ( !$totalCategories && !$this->parameters->isSelectionCriteriaFound() ) {
-			$this->logger->addMessage( \DynamicPageListHooks::FATAL_NOSELECTION );
+			$this->logger->addMessage( DynamicPageListHooks::FATAL_NOSELECTION );
+
 			return false;
 		}
 
-		//ordermethod=sortkey requires ordermethod=category
-		//Delayed to the construction of the SQL query, see near line 2211, gs
-		//if (in_array('sortkey',$aOrderMethods) && ! in_array('category',$aOrderMethods)) $aOrderMethods[] = 'category';
+		// ordermethod=sortkey requires ordermethod=category
+		// Delayed to the construction of the SQL query, see near line 2211, gs
+		// if (in_array('sortkey',$aOrderMethods) && ! in_array('category',$aOrderMethods)) $aOrderMethods[] = 'category';
 
 		$orderMethods = (array)$this->parameters->getParameter( 'ordermethod' );
-		//Throw an error in no categories were selected when using category sorting modes or requesting category information.
+		// Throw an error in no categories were selected when using category sorting modes or requesting category information.
 		if ( $totalCategories == 0 && ( in_array( 'categoryadd', $orderMethods ) || $this->parameters->getParameter( 'addfirstcategorydate' ) === true ) ) {
-			$this->logger->addMessage( \DynamicPageListHooks::FATAL_CATDATEBUTNOINCLUDEDCATS );
+			$this->logger->addMessage( DynamicPageListHooks::FATAL_CATDATEBUTNOINCLUDEDCATS );
+
 			return false;
 		}
 
-		//No more than one type of date at a time!
-		//@TODO: Can this be fixed to allow all three later after fixing the article class?
+		// No more than one type of date at a time!
+		// @TODO: Can this be fixed to allow all three later after fixing the article class?
 		if ( ( intval( $this->parameters->getParameter( 'addpagetoucheddate' ) ) + intval( $this->parameters->getParameter( 'addfirstcategorydate' ) ) + intval( $this->parameters->getParameter( 'addeditdate' ) ) ) > 1 ) {
-			$this->logger->addMessage( \DynamicPageListHooks::FATAL_MORETHAN1TYPEOFDATE );
+			$this->logger->addMessage( DynamicPageListHooks::FATAL_MORETHAN1TYPEOFDATE );
+
 			return false;
 		}
 
 		// the dominant section must be one of the sections mentioned in includepage
 		if ( $this->parameters->getParameter( 'dominantsection' ) > 0 && count( $this->parameters->getParameter( 'seclabels' ) ) < $this->parameters->getParameter( 'dominantsection' ) ) {
-			$this->logger->addMessage( \DynamicPageListHooks::FATAL_DOMINANTSECTIONRANGE, count( $this->parameters->getParameter( 'seclabels' ) ) );
+			$this->logger->addMessage( DynamicPageListHooks::FATAL_DOMINANTSECTIONRANGE, count( $this->parameters->getParameter( 'seclabels' ) ) );
+
 			return false;
 		}
 
 		// category-style output requested with not compatible order method
 		if ( $this->parameters->getParameter( 'mode' ) == 'category' && !array_intersect( $orderMethods, [ 'sortkey', 'title', 'titlewithoutnamespace' ] ) ) {
-			$this->logger->addMessage( \DynamicPageListHooks::FATAL_WRONGORDERMETHOD, 'mode=category', 'sortkey | title | titlewithoutnamespace' );
+			$this->logger->addMessage( DynamicPageListHooks::FATAL_WRONGORDERMETHOD, 'mode=category', 'sortkey | title | titlewithoutnamespace' );
+
 			return false;
 		}
 
 		// addpagetoucheddate=true with unappropriate order methods
 		if ( $this->parameters->getParameter( 'addpagetoucheddate' ) && !array_intersect( $orderMethods, [ 'pagetouched', 'title' ] ) ) {
-			$this->logger->addMessage( \DynamicPageListHooks::FATAL_WRONGORDERMETHOD, 'addpagetoucheddate=true', 'pagetouched | title' );
+			$this->logger->addMessage( DynamicPageListHooks::FATAL_WRONGORDERMETHOD, 'addpagetoucheddate=true', 'pagetouched | title' );
+
 			return false;
 		}
 
 		// addeditdate=true but not (ordermethod=...,firstedit or ordermethod=...,lastedit)
-		//firstedit (resp. lastedit) -> add date of first (resp. last) revision
+		// firstedit (resp. lastedit) -> add date of first (resp. last) revision
 		if ( $this->parameters->getParameter( 'addeditdate' ) && !array_intersect( $orderMethods, [ 'firstedit', 'lastedit' ] ) && ( $this->parameters->getParameter( 'allrevisionsbefore' ) || $this->parameters->getParameter( 'allrevisionssince' ) || $this->parameters->getParameter( 'firstrevisionsince' ) || $this->parameters->getParameter( 'lastrevisionbefore' ) ) ) {
-			$this->logger->addMessage( \DynamicPageListHooks::FATAL_WRONGORDERMETHOD, 'addeditdate=true', 'firstedit | lastedit' );
+			$this->logger->addMessage( DynamicPageListHooks::FATAL_WRONGORDERMETHOD, 'addeditdate=true', 'firstedit | lastedit' );
+
 			return false;
 		}
 
@@ -744,82 +761,92 @@ private function doQueryErrorChecks() {
 		 * Ideally, we could use values such as 'all', 'first' or 'last' for the adduser parameter.
 		 */
 		if ( $this->parameters->getParameter( 'adduser' ) && !array_intersect( $orderMethods, [ 'firstedit', 'lastedit' ] ) && !$this->parameters->getParameter( 'allrevisionsbefore' ) && !$this->parameters->getParameter( 'allrevisionssince' ) && !$this->parameters->getParameter( 'firstrevisionsince' ) && !$this->parameters->getParameter( 'lastrevisionbefore' ) ) {
-			$this->logger->addMessage( \DynamicPageListHooks::FATAL_WRONGORDERMETHOD, 'adduser=true', 'firstedit | lastedit' );
+			$this->logger->addMessage( DynamicPageListHooks::FATAL_WRONGORDERMETHOD, 'adduser=true', 'firstedit | lastedit' );
+
 			return false;
 		}
+
 		if ( $this->parameters->getParameter( 'minoredits' ) && !array_intersect( $orderMethods, [ 'firstedit', 'lastedit' ] ) ) {
-			$this->logger->addMessage( \DynamicPageListHooks::FATAL_WRONGORDERMETHOD, 'minoredits', 'firstedit | lastedit' );
+			$this->logger->addMessage( DynamicPageListHooks::FATAL_WRONGORDERMETHOD, 'minoredits', 'firstedit | lastedit' );
+
 			return false;
 		}
 
-		//add*** parameters have no effect with 'mode=category' (only namespace/title can be viewed in this mode)
+		// add*** parameters have no effect with 'mode=category' (only namespace/title can be viewed in this mode)
 		if ( $this->parameters->getParameter( 'mode' ) == 'category' && ( $this->parameters->getParameter( 'addcategories' ) || $this->parameters->getParameter( 'addeditdate' ) || $this->parameters->getParameter( 'addfirstcategorydate' ) || $this->parameters->getParameter( 'addpagetoucheddate' ) || $this->parameters->getParameter( 'incpage' ) || $this->parameters->getParameter( 'adduser' ) || $this->parameters->getParameter( 'addauthor' ) || $this->parameters->getParameter( 'addcontribution' ) || $this->parameters->getParameter( 'addlasteditor' ) ) ) {
-			$this->logger->addMessage( \DynamicPageListHooks::WARN_CATOUTPUTBUTWRONGPARAMS );
+			$this->logger->addMessage( DynamicPageListHooks::WARN_CATOUTPUTBUTWRONGPARAMS );
 		}
 
-		//headingmode has effects with ordermethod on multiple components only
+		// headingmode has effects with ordermethod on multiple components only
 		if ( $this->parameters->getParameter( 'headingmode' ) !== 'none' && count( $orderMethods ) < 2 ) {
-			$this->logger->addMessage( \DynamicPageListHooks::WARN_HEADINGBUTSIMPLEORDERMETHOD, $this->parameters->getParameter( 'headingmode' ), 'none' );
+			$this->logger->addMessage( DynamicPageListHooks::WARN_HEADINGBUTSIMPLEORDERMETHOD, $this->parameters->getParameter( 'headingmode' ), 'none' );
 			$this->parameters->setParameter( 'headingmode', 'none' );
 		}
 
-		//The 'openreferences' parameter is incompatible with many other options.
+		// The 'openreferences' parameter is incompatible with many other options.
 		if ( $this->parameters->isOpenReferencesConflict() && $this->parameters->getParameter( 'openreferences' ) === true ) {
-			$this->logger->addMessage( \DynamicPageListHooks::FATAL_OPENREFERENCES );
+			$this->logger->addMessage( DynamicPageListHooks::FATAL_OPENREFERENCES );
+
 			return false;
 		}
+
 		return true;
 	}
 
 	/**
 	 * Create keys for TableRow which represent the structure of the "include=" arguments.
 	 *
-	 * @access	public
-	 * @param	array	Array of 'tablerow' parameter data.
-	 * @param	array	Array of 'include' parameter data.
-	 * @return	array	Updated 'tablerow' parameter.
+	 * @param array	$tableRow
+	 * @param array	$sectionLabels
+	 * @return array
 	 */
 	private static function updateTableRowKeys( $tableRow, $sectionLabels ) {
-		$_tableRow	= (array)$tableRow;
-		$tableRow	= [];
-		$groupNr	= -1;
-		$t			= -1;
+		$_tableRow = (array)$tableRow;
+		$tableRow = [];
+		$groupNr = -1;
+		$t = -1;
+
 		foreach ( $sectionLabels as $label ) {
 			$t++;
 			$groupNr++;
 			$cols = explode( '}:', $label );
+
 			if ( count( $cols ) <= 1 ) {
 				if ( array_key_exists( $t, $_tableRow ) ) {
 					$tableRow[$groupNr] = $_tableRow[$t];
 				}
 			} else {
-				$n     = count( explode( ':', $cols[1] ) );
+				$n = count( explode( ':', $cols[1] ) );
 				$colNr = -1;
 				$t--;
+
 				for ( $i = 1; $i <= $n; $i++ ) {
 					$colNr++;
 					$t++;
+
 					if ( array_key_exists( $t, $_tableRow ) ) {
 						$tableRow[$groupNr . '.' . $colNr] = $_tableRow[$t];
 					}
 				}
 			}
 		}
+
 		return $tableRow;
 	}
 
 	/**
 	 * Resolve arguments in the input that would normally be in the URL.
 	 *
-	 * @access	public
-	 * @param	string	Raw Uncleaned User Input
-	 * @param	array	Array of URL arguments to resolve.  Non-arrays will be casted to an array.
-	 * @return	string	Raw input with variables replaced
+	 * @param string $input
+	 * @param array $arguments
+	 * @return string
 	 */
 	private function resolveUrlArguments( $input, $arguments ) {
 		$arguments = (array)$arguments;
+
 		foreach ( $arguments as $arg ) {
-			$dplArg = $this->wgRequest->getVal( $arg, '' );
+			$dplArg = $this->request->getVal( $arg, '' );
+
 			if ( $dplArg == '' ) {
 				$input = preg_replace( '/\{%' . $arg . ':(.*)%\}/U', '\1', $input );
 				$input = str_replace( '{%' . $arg . '%}', '', $input );
@@ -828,42 +855,45 @@ private function resolveUrlArguments( $input, $arguments ) {
 				$input = str_replace( '{%' . $arg . '%}', $dplArg, $input );
 			}
 		}
+
 		return $input;
 	}
 
 	/**
 	 * This function uses the Variables extension to provide URL-arguments like &DPL_xyz=abc in the form of a variable which can be accessed as {{#var:xyz}} if Extension:Variables is installed.
 	 *
-	 * @access	public
-	 * @return	void
+	 * @param Parser $parser
 	 */
-	private function getUrlArgs() {
-		$args = $this->wgRequest->getValues();
+	private function getUrlArgs( Parser $parser ) {
+		$args = $this->request->getValues();
+
 		foreach ( $args as $argName => $argValue ) {
 			if ( strpos( $argName, 'DPL_' ) === false ) {
 				continue;
 			}
+
 			Variables::setVar( [ '', '', $argName, $argValue ] );
+
 			if ( defined( 'ExtVariables::VERSION' ) ) {
-				\ExtVariables::get( $this->parser )->setVarValue( $argName, $argValue );
+				ExtVariables::get( $parser )->setVarValue( $argName, $argValue );
 			}
 		}
 	}
 
 	/**
-	 * This function uses the Variables extension to provide navigation aids such as DPL_firstTitle, DPL_lastTitle, or DPL_findTitle.  These variables can be accessed as {{#var:DPL_firstTitle}} if Extension:Variables is installed.
+	 * This function uses the Variables extension to provide navigation aids such as DPL_firstTitle, DPL_lastTitle, or DPL_findTitle. These variables can be accessed as {{#var:DPL_firstTitle}} if Extension:Variables is installed.
 	 *
-	 * @access	public
-	 * @param	array	Array of scroll variables with the key as the variable name and the value as the value.  Non-arrays will be casted to arrays.
-	 * @return	void
+	 * @param array $scrollVariables
+	 * @param Parser $parser
 	 */
-	private function defineScrollVariables( $scrollVariables ) {
+	private function defineScrollVariables( $scrollVariables, Parser $parser ) {
 		$scrollVariables = (array)$scrollVariables;
 
 		foreach ( $scrollVariables as $variable => $value ) {
 			Variables::setVar( [ '', '', $variable, $value ] );
+
 			if ( defined( 'ExtVariables::VERSION' ) ) {
-				\ExtVariables::get( $this->parser )->setVarValue( $variable, $value );
+				ExtVariables::get( $parser )->setVarValue( $variable, $value );
 			}
 		}
 	}
@@ -871,87 +901,100 @@ private function defineScrollVariables( $scrollVariables ) {
 	/**
 	 * Trigger Resets and Eliminates that run at the end of parsing.
 	 *
-	 * @private
-	 * @param	string	Full output including header, footer, and any warnings.
-	 * @param	array	End Reset Booleans
-	 * @param	array	End Eliminate Booleans
-	 * @param	boolean	Call as a parser tag
-	 * @return	void
+	 * @param string $output
+	 * @param array &$reset
+	 * @param array &$eliminate
+	 * @param bool $isParserTag
+	 * @param Parser $parser
 	 */
-	private function triggerEndResets( $output, &$reset, &$eliminate, $isParserTag ) {
+	private function triggerEndResets( $output, &$reset, &$eliminate, $isParserTag, Parser $parser ) {
 		global $wgHooks;
 
-		$localParser = \MediaWiki\MediaWikiServices::getInstance()->getParserFactory()->create();
-		$parserOutput = $localParser->parse( $output, $this->parser->mTitle, $this->parser->mOptions );
+		$localParser = MediaWikiServices::getInstance()->getParserFactory()->create();
+		$parserOutput = $localParser->parse( $output, $parser->getTitle(), $parser->getOptions() );
 
 		if ( !is_array( $reset ) ) {
 			$reset = [];
 		}
+
 		$reset = array_merge( $reset, (array)$this->parameters->getParameter( 'reset' ) );
 
 		if ( !is_array( $eliminate ) ) {
 			$eliminate = [];
 		}
+
 		$eliminate = array_merge( $eliminate, (array)$this->parameters->getParameter( 'eliminate' ) );
+
 		if ( $isParserTag === true ) {
-			//In tag mode 'eliminate' is the same as 'reset' for templates, categories, and images.
+			// In tag mode 'eliminate' is the same as 'reset' for templates, categories, and images.
 			if ( isset( $eliminate['templates'] ) && $eliminate['templates'] ) {
 				$reset['templates'] = true;
 				$eliminate['templates'] = false;
 			}
+
 			if ( isset( $eliminate['categories'] ) && $eliminate['categories'] ) {
 				$reset['categories'] = true;
 				$eliminate['categories'] = false;
 			}
+
 			if ( isset( $eliminate['images'] ) && $eliminate['images'] ) {
 				$reset['images'] = true;
 				$eliminate['images'] = false;
 			}
 		} else {
 			if ( isset( $reset['templates'] ) && $reset['templates'] ) {
-				\DynamicPageListHooks::$createdLinks['resetTemplates'] = true;
+				DynamicPageListHooks::$createdLinks['resetTemplates'] = true;
 			}
+
 			if ( isset( $reset['categories'] ) && $reset['categories'] ) {
-				\DynamicPageListHooks::$createdLinks['resetCategories'] = true;
+				DynamicPageListHooks::$createdLinks['resetCategories'] = true;
 			}
+
 			if ( isset( $reset['images'] ) && $reset['images'] ) {
-				\DynamicPageListHooks::$createdLinks['resetImages'] = true;
+				DynamicPageListHooks::$createdLinks['resetImages'] = true;
 			}
 		}
+
 		if ( ( $isParserTag === true && isset( $reset['links'] ) ) || $isParserTag === false ) {
 			if ( isset( $reset['links'] ) ) {
-				\DynamicPageListHooks::$createdLinks['resetLinks'] = true;
+				DynamicPageListHooks::$createdLinks['resetLinks'] = true;
 			}
-			//Register a hook to reset links which were produced during parsing DPL output.
+
+			// Register a hook to reset links which were produced during parsing DPL output.
 			if ( !isset( $wgHooks['ParserAfterTidy'] ) || !is_array( $wgHooks['ParserAfterTidy'] ) || !in_array( 'DynamicPageListHooks::endReset', $wgHooks['ParserAfterTidy'] ) ) {
 				$wgHooks['ParserAfterTidy'][] = 'DynamicPageListHooks::endReset';
 			}
 		}
 
 		if ( array_sum( $eliminate ) ) {
-			//Register a hook to reset links which were produced during parsing DPL output
+			// Register a hook to reset links which were produced during parsing DPL output
 			if ( !isset( $wgHooks['ParserAfterTidy'] ) || !is_array( $wgHooks['ParserAfterTidy'] ) || !in_array( 'DynamicPageListHooks::endEliminate', $wgHooks['ParserAfterTidy'] ) ) {
 				$wgHooks['ParserAfterTidy'][] = 'DynamicPageListHooks::endEliminate';
 			}
 
 			if ( isset( $eliminate['links'] ) && $eliminate['links'] ) {
-				//Trigger the mediawiki parser to find links, images, categories etc. which are contained in the DPL output.  This allows us to remove these links from the link list later.  If the article containing the DPL statement itself uses one of these links they will be thrown away!
-				\DynamicPageListHooks::$createdLinks[0] = [];
+				// Trigger the mediawiki parser to find links, images, categories etc. which are contained in the DPL output. This allows us to remove these links from the link list later. If the article containing the DPL statement itself uses one of these links they will be thrown away!
+				DynamicPageListHooks::$createdLinks[0] = [];
+
 				foreach ( $parserOutput->getLinks() as $nsp => $link ) {
-					\DynamicPageListHooks::$createdLinks[0][$nsp] = $link;
+					DynamicPageListHooks::$createdLinks[0][$nsp] = $link;
 				}
 			}
+
 			if ( isset( $eliminate['templates'] ) && $eliminate['templates'] ) {
-				\DynamicPageListHooks::$createdLinks[1] = [];
+				DynamicPageListHooks::$createdLinks[1] = [];
+
 				foreach ( $parserOutput->getTemplates() as $nsp => $tpl ) {
-					\DynamicPageListHooks::$createdLinks[1][$nsp] = $tpl;
+					DynamicPageListHooks::$createdLinks[1][$nsp] = $tpl;
 				}
 			}
+
 			if ( isset( $eliminate['categories'] ) && $eliminate['categories'] ) {
-				\DynamicPageListHooks::$createdLinks[2] = $parserOutput->mCategories;
+				DynamicPageListHooks::$createdLinks[2] = $parserOutput->mCategories;
 			}
+
 			if ( isset( $eliminate['images'] ) && $eliminate['images'] ) {
-				\DynamicPageListHooks::$createdLinks[3] = $parserOutput->mImages;
+				DynamicPageListHooks::$createdLinks[3] = $parserOutput->mImages;
 			}
 		}
 	}
@@ -959,21 +1002,24 @@ private function triggerEndResets( $output, &$reset, &$eliminate, $isParserTag )
 	/**
 	 * Sort an array of Article objects by the card suit symbol.
 	 *
-	 * @private
-	 * @param	array	Article objects in an array.
-	 * @return	array	Sorted objects
+	 * @param array	$articles
+	 * @return array
 	 */
 	private function cardSuitSort( $articles ) {
 		$sortKeys = [];
+
 		foreach ( $articles as $key => $article ) {
-			$title  = preg_replace( '/.*:/', '', $article->mTitle );
-			$tokens  = preg_split( '/ - */', $title );
+			$title = preg_replace( '/.*:/', '', $article->mTitle );
+			$tokens = preg_split( '/ - */', $title );
 			$newKey = '';
+
 			foreach ( $tokens as $token ) {
 				$initial = substr( $token, 0, 1 );
+
 				if ( $initial >= '1' && $initial <= '7' ) {
 					$newKey .= $initial;
 					$suit = substr( $token, 1 );
+
 					if ( $suit == '' ) {
 						$newKey .= '1';
 					} elseif ( $suit == '' ) {
@@ -995,12 +1041,18 @@ private function cardSuitSort( $articles ) {
 					$newKey .= $token;
 				}
 			}
+
 			$sortKeys[$key] = $newKey;
 		}
+
 		asort( $sortKeys );
+
+		$sortedArticles = [];
+
 		foreach ( $sortKeys as $oldKey => $newKey ) {
 			$sortedArticles[] = $articles[$oldKey];
 		}
+
 		return $sortedArticles;
 	}
 }
diff --git a/includes/Query.php b/includes/Query.php
index 01444811..2283a84e 100644
--- a/includes/Query.php
+++ b/includes/Query.php
@@ -1,32 +1,41 @@
 <?php
-/**
- * DynamicPageList3
- * DPL Variables Class
- *
- * @author		IlyaHaykinson, Unendlich, Dangerville, Algorithmix, Theaitetos, Alexia E. Smith, Universal Omega
- * @license		GPL-2.0-or-later
- * @package		DynamicPageList3
- *
- */
+
 namespace DPL;
 
+use ActorMigration;
+use CommentStore;
+use DateInterval;
+use DateTime;
+use Exception;
 use MediaWiki\MediaWikiServices;
+use MWException;
+use Wikimedia\Rdbms\IDatabase;
 
 class Query {
 	/**
 	 * Parameters Object
 	 *
-	 * @var object
+	 * @var Parameters
 	 */
 	private $parameters;
 
 	/**
 	 * Mediawiki DB Object
 	 *
-	 * @var object
+	 * @var IDatabase
 	 */
 	private $DB;
 
+	/**
+	 * @var ActorMigration
+	 */
+	private $actorMigration;
+
+	/** @var UserQueryBuilder */
+	private $userQueryBuilder;
+	/** @var RevisionJoinBuilder */
+	private $revisionJoinBuilder;
+
 	/**
 	 * Array of prefixed and escaped table names.
 	 *
@@ -100,14 +109,14 @@ class Query {
 	/**
 	 * Limit
 	 *
-	 * @var int
+	 * @var int|bool
 	 */
 	private $limit = false;
 
 	/**
 	 * Offset
 	 *
-	 * @var int
+	 * @var int|bool
 	 */
 	private $offset = false;
 
@@ -128,7 +137,7 @@ class Query {
 	/**
 	 * Character Set Collation
 	 *
-	 * @var string
+	 * @var string|bool
 	 */
 	private $collation = false;
 
@@ -147,26 +156,34 @@ class Query {
 	private $revisionAuxWhereAdded = false;
 
 	/**
-	 * Main Constructor
-	 *
-	 * @access	public
-	 * @param	\DPL\Parameters	$parameters
-	 * @return	void
+	 * @param Parameters $parameters
+	 * @param ActorMigration $actorMigration
+	 * @param CommentStore $commentStore
 	 */
-	public function __construct( Parameters $parameters ) {
+	public function __construct(
+		Parameters $parameters,
+		ActorMigration $actorMigration,
+		CommentStore $commentStore
+	) {
 		$this->parameters = $parameters;
 
 		$this->tableNames = self::getTableNames();
 
 		$this->DB = wfGetDB( DB_REPLICA, 'dpl' );
+		$this->actorMigration = $actorMigration;
+		$this->userQueryBuilder = new UserQueryBuilder( $this->DB, $this->actorMigration );
+		$this->revisionJoinBuilder = new RevisionJoinBuilder(
+			$this->DB,
+			$this->actorMigration,
+			$commentStore
+		);
 	}
 
 	/**
 	 * Start a query build.
 	 *
-	 * @access	public
-	 * @param	boolean	Calculate Found Rows
-	 * @return	mixed	Mediawiki Result Object or False
+	 * @param bool $calcRows
+	 * @return mixed Mediawiki Result Object or False
 	 */
 	public function buildAndSelect( $calcRows = false ) {
 		global $wgNonincludableNamespaces;
@@ -176,19 +193,39 @@ public function buildAndSelect( $calcRows = false ) {
 		$parameters = $this->parameters->getAllParameters();
 		foreach ( $parameters as $parameter => $option ) {
 			$function = "_" . $parameter;
-			//Some parameters do not modifiy the query so we check if the function to modify the query exists first.
+			// Some parameters do not modifiy the query so we check if the function to modify the query exists first.
 			$success = true;
 			if ( method_exists( $this, $function ) ) {
 				$success = $this->$function( $option );
 			}
+
 			if ( $success === false ) {
-				throw new \MWException( __METHOD__ . ": SQL Build Error returned from {$function} for " . serialize( $option ) . "." );
+				throw new MWException( __METHOD__ . ": SQL Build Error returned from {$function} for " . serialize( $option ) . "." );
 			}
+
 			$this->parametersProcessed[$parameter] = true;
 		}
 
+		$userQueryConds = $this->userQueryBuilder->getWhere();
+		if ( $userQueryConds ) {
+			$this->addWhere( $userQueryConds );
+		}
+
+		$revQueryInfo = $this->revisionJoinBuilder->getQueryInfo();
+		$this->addSelect( $revQueryInfo['fields'] );
+
+		foreach ( $revQueryInfo['tables'] as $alias => $table ) {
+			if ( !isset( $this->tables[$alias] ) ) {
+				$this->tables[$alias] = $table;
+			}
+		}
+
+		foreach ( $revQueryInfo['joins'] as $joinTarget => $joinConds ) {
+			$this->addJoin( $joinTarget, $joinConds );
+		}
+
 		if ( !$this->parameters->getParameter( 'openreferences' ) ) {
-			//Add things that are always part of the query.
+			// Add things that are always part of the query.
 			$this->addTable( 'page', $this->tableNames['page'] );
 			$this->addSelect(
 				[
@@ -198,7 +235,8 @@ public function buildAndSelect( $calcRows = false ) {
 				]
 			);
 		}
-		//Always add nonincludeable namespaces.
+
+		// Always add nonincludeable namespaces.
 		if ( is_array( $wgNonincludableNamespaces ) && count( $wgNonincludableNamespaces ) ) {
 			$this->addNotWhere(
 				[
@@ -210,26 +248,28 @@ public function buildAndSelect( $calcRows = false ) {
 		if ( $this->offset !== false ) {
 			$options['OFFSET'] = $this->offset;
 		}
+
 		if ( $this->limit !== false ) {
 			$options['LIMIT'] = $this->limit;
-		} elseif ( $this->offset !== false && $this->limit === false ) {
+		} elseif ( $this->offset !== false ) {
 			$options['LIMIT'] = $this->parameters->getParameter( 'count' );
 		}
 
 		if ( $this->parameters->getParameter( 'openreferences' ) ) {
 			if ( count( $this->parameters->getParameter( 'imagecontainer' ) ) > 0 ) {
-				//$sSqlSelectFrom = $sSqlCl_to.'ic.il_to, '.$sSqlSelPage."ic.il_to AS sortkey".' FROM '.$this->tableNames['imagelinks'].' AS ic';
+				// $sSqlSelectFrom = $sSqlCl_to.'ic.il_to, '.$sSqlSelPage."ic.il_to AS sortkey".' FROM '.$this->tableNames['imagelinks'].' AS ic';
 				$tables = [
 					'ic'	=> 'imagelinks'
 				];
 			} else {
-				//$sSqlSelectFrom = "SELECT $sSqlCalcFoundRows $sSqlDistinct ".$sSqlCl_to.'pl_namespace, pl_title'.$sSqlSelPage.$sSqlSortkey.' FROM '.$this->tableNames['pagelinks'];
+				// $sSqlSelectFrom = "SELECT $sSqlCalcFoundRows $sSqlDistinct ".$sSqlCl_to.'pl_namespace, pl_title'.$sSqlSelPage.$sSqlSortkey.' FROM '.$this->tableNames['pagelinks'];
 				$this->addSelect(
 					[
 						'pl_namespace',
 						'pl_title'
 					]
 				);
+
 				$tables = [
 					'pagelinks'
 				];
@@ -251,14 +291,17 @@ public function buildAndSelect( $calcRows = false ) {
 			$select = [
 				$this->tableNames['page'] . '.page_id'
 			];
+
 			$options[] = 'DISTINCT';
 		} else {
 			if ( $calcRows ) {
 				$options[] = 'SQL_CALC_FOUND_ROWS';
 			}
+
 			if ( $this->distinct ) {
 				$options[] = 'DISTINCT';
 			}
+
 			$categoriesGoal = false;
 			$select = $this->select;
 		}
@@ -275,22 +318,25 @@ public function buildAndSelect( $calcRows = false ) {
 					$this->join
 				);
 
+				$pageIds = [];
+
 				while ( $row = $result->fetchRow() ) {
 					$pageIds[] = $row['page_id'];
 				}
+
 				$sql = $this->DB->selectSQLText(
 					[
-						'clgoal'	=> 'categorylinks'
+						'clgoal' => 'categorylinks'
 					],
 					[
 						'clgoal.cl_to'
 					],
 					[
-						'clgoal.cl_from'	=> $pageIds
+						'clgoal.cl_from' => $pageIds
 					],
 					__METHOD__,
 					[
-						'ORDER BY'	=> 'clgoal.cl_to ' . $this->direction
+						'ORDER BY' => 'clgoal.cl_to ' . $this->direction
 					]
 				);
 			} else {
@@ -316,8 +362,9 @@ public function buildAndSelect( $calcRows = false ) {
 		} catch ( Exception $e ) {
 			$queryError = true;
 		}
-		if ( $queryError == true || $result === false ) {
-			throw new \MWException( __METHOD__ . ": " . wfMessage( 'dpl_query_error', DPL_VERSION, $this->DB->lastError() )->text() );
+
+		if ( $queryError || $result === false ) {
+			throw new MWException( __METHOD__ . ": " . wfMessage( 'dpl_query_error', DynamicPageListHooks::getVersion(), $this->DB->lastError() )->text() );
 		}
 
 		return $result;
@@ -326,8 +373,7 @@ public function buildAndSelect( $calcRows = false ) {
 	/**
 	 * Return the number of found rows.
 	 *
-	 * @access	public
-	 * @return	integer	Number of Found Rows
+	 * @return int
 	 */
 	public function getFoundRows() {
 		return $this->foundRows;
@@ -336,8 +382,7 @@ public function getFoundRows() {
 	/**
 	 * Returns the generated SQL Query
 	 *
-	 * @access	public
-	 * @return	string	SQL Query
+	 * @return string
 	 */
 	public function getSqlQuery() {
 		return $this->sqlQuery;
@@ -346,11 +391,11 @@ public function getSqlQuery() {
 	/**
 	 * Return prefixed and quoted tables that are needed.
 	 *
-	 * @access	public
-	 * @return	array	Prepared table names.
+	 * @return array
 	 */
 	public static function getTableNames() {
 		$DB = wfGetDB( DB_REPLICA, 'dpl' );
+
 		$tables = [
 			'categorylinks',
 			'dpl_clview',
@@ -361,7 +406,6 @@ public static function getTableNames() {
 			'pagelinks',
 			'recentchanges',
 			'revision',
-			'revision_actor_temp',
 			'templatelinks'
 		];
 
@@ -369,75 +413,88 @@ public static function getTableNames() {
 		foreach ( $tables as $table ) {
 			$tableNames[$table] = $DB->tableName( $table );
 		}
+
 		return $tableNames;
 	}
 
 	/**
 	 * Add a table to the output.
 	 *
-	 * @access	public
-	 * @param	string	Raw Table Name - Will be ran through tableName().
-	 * @param	string	Table Alias
-	 * @return	boolean	Success - Added, false if the table alias already exists.
+	 * @param string $table
+	 * @param string $alias
+	 * @return bool
 	 */
 	public function addTable( $table, $alias ) {
 		if ( empty( $table ) ) {
-			throw new \MWException( __METHOD__ . ': An empty table name was passed.' );
+			throw new MWException( __METHOD__ . ': An empty table name was passed.' );
 		}
+
 		if ( empty( $alias ) || is_numeric( $alias ) ) {
-			throw new \MWException( __METHOD__ . ': An empty or numeric table alias was passed.' );
+			throw new MWException( __METHOD__ . ': An empty or numeric table alias was passed.' );
 		}
+
 		if ( !isset( $this->tables[$alias] ) ) {
 			$this->tables[$alias] = $this->DB->tableName( $table );
+
 			return true;
 		} else {
 			return false;
 		}
 	}
 
+	/**
+	 * Add multiple tables to the output.
+	 *
+	 * @param array $tablesByAlias
+	 */
+	public function addTables( array $tablesByAlias ) {
+		foreach ( $tablesByAlias as $alias => $table ) {
+			$this->addTable( $table, $alias );
+		}
+	}
+
 	/**
 	 * Add a where clause to the output.
-	 * Where clauses get imploded together with AND at the end.	 Any custom where clauses should be preformed before placed into here.
+	 * Where clauses get imploded together with AND at the end. Any custom where clauses should be preformed before placed into here.
 	 *
-	 * @access	public
-	 * @param	string	Where clause
-	 * @return	boolean	Success
+	 * @param array|string $where
+	 * @return bool
 	 */
 	public function addWhere( $where ) {
 		if ( empty( $where ) ) {
-			throw new \MWException( __METHOD__ . ': An empty where clause was passed.' );
+			throw new MWException( __METHOD__ . ': An empty where clause was passed.' );
 		}
+
 		if ( is_string( $where ) ) {
 			$this->where[] = $where;
 		} elseif ( is_array( $where ) ) {
 			$this->where = array_merge( $this->where, $where );
 		} else {
-			throw new \MWException( __METHOD__ . ': An invalid where clause was passed.' );
-			return false;
+			throw new MWException( __METHOD__ . ': An invalid where clause was passed.' );
 		}
+
 		return true;
 	}
 
 	/**
 	 * Add a where clause to the output that uses NOT IN or !=.
 	 *
-	 * @access	public
-	 * @param	array	Field => Value(s)
-	 * @return	boolean	Success
+	 * @param array $where
+	 * @return bool
 	 */
 	public function addNotWhere( $where ) {
 		if ( empty( $where ) ) {
-			throw new \MWException( __METHOD__ . ': An empty not where clause was passed.' );
-			return false;
+			throw new MWException( __METHOD__ . ': An empty not where clause was passed.' );
 		}
+
 		if ( is_array( $where ) ) {
 			foreach ( $where as $field => $values ) {
 				$this->where[] = $field . ( count( $values ) > 1 ? ' NOT IN(' . $this->DB->makeList( $values ) . ')' : ' != ' . $this->DB->addQuotes( current( $values ) ) );
 			}
 		} else {
-			throw new \MWException( __METHOD__ . ': An invalid not where clause was passed.' );
-			return false;
+			throw new MWException( __METHOD__ . ': An invalid not where clause was passed.' );
 		}
+
 		return true;
 	}
 
@@ -445,88 +502,99 @@ public function addNotWhere( $where ) {
 	 * Add a field to select.
 	 * Will ignore duplicate values if the exact same alias and exact same field are passed.
 	 *
-	 * @access	public
-	 * @param	array	Array of fields with the array key being the field alias.  Leave the array key as a numeric index to not specify an alias.
-	 * @return	boolean	Success
+	 * @param array $fields
+	 * @return bool
 	 */
 	public function addSelect( $fields ) {
 		if ( !is_array( $fields ) ) {
-			throw new \MWException( __METHOD__ . ': A non-array was passed.' );
+			throw new MWException( __METHOD__ . ': A non-array was passed.' );
 		}
+
 		foreach ( $fields as $alias => $field ) {
 			if ( !is_numeric( $alias ) && array_key_exists( $alias, $this->select ) && $this->select[$alias] != $field ) {
-				//In case of a code bug that is overwriting an existing field alias throw an exception.
-				throw new \MWException( __METHOD__ . ": Attempted to overwrite existing field alias `{$this->select[$alias]}` AS `{$alias}` with `{$field}` AS `{$alias}`." );
+				// In case of a code bug that is overwriting an existing field alias throw an exception.
+				throw new MWException( __METHOD__ . ": Attempted to overwrite existing field alias `{$this->select[$alias]}` AS `{$alias}` with `{$field}` AS `{$alias}`." );
 			}
-			//String alias and does not exist already.
+
+			// String alias and does not exist already.
 			if ( !is_numeric( $alias ) && !array_key_exists( $alias, $this->select ) ) {
 				$this->select[$alias] = $field;
 			}
 
-			//Speed up by not using in_array() or array_key_exists().  Toss the field names into their own array as keys => true to exploit a speedy look up with isset().
+			// Speed up by not using in_array() or array_key_exists(). Toss the field names into their own array as keys => true to exploit a speedy look up with isset().
 			if ( is_numeric( $alias ) && !isset( $this->selectedFields[$field] ) ) {
 				$this->select[] = $field;
 				$this->selectedFields[$field] = true;
 			}
 		}
+
 		return true;
 	}
 
 	/**
 	 * Add a GROUP BY clause to the output.
 	 *
-	 * @access	public
-	 * @param	string	Group By Clause
-	 * @return	boolean	Success
+	 * @param string $groupBy
+	 * @return bool
 	 */
 	public function addGroupBy( $groupBy ) {
 		if ( empty( $groupBy ) ) {
-			throw new \MWException( __METHOD__ . ': An empty group by clause was passed.' );
+			throw new MWException( __METHOD__ . ': An empty group by clause was passed.' );
 		}
+
 		$this->groupBy[] = $groupBy;
+
 		return true;
 	}
 
 	/**
 	 * Add a ORDER BY clause to the output.
 	 *
-	 * @access	public
-	 * @param	string	Order By Clause
-	 * @return	boolean	Success
+	 * @param string $orderBy
+	 * @return bool
 	 */
 	public function addOrderBy( $orderBy ) {
 		if ( empty( $orderBy ) ) {
-			throw new \MWException( __METHOD__ . ': An empty order by clause was passed.' );
+			throw new MWException( __METHOD__ . ': An empty order by clause was passed.' );
 		}
+
 		$this->orderBy[] = $orderBy;
+
 		return true;
 	}
 
 	/**
 	 * Add a JOIN clause to the output.
 	 *
-	 * @access	public
-	 * @param	string	Table Alias
-	 * @param	array	Join Conditions in the format of the join type to the on where condition.  Example: ['JOIN TYPE' => 'this = that']
-	 * @return	boolean	Success
+	 * @param string $tableAlias
+	 * @param array $joinConditions
+	 * @return bool
 	 */
 	public function addJoin( $tableAlias, $joinConditions ) {
 		if ( empty( $tableAlias ) || empty( $joinConditions ) ) {
-			throw new \MWException( __METHOD__ . ': An empty join clause was passed.' );
+			throw new MWException( __METHOD__ . ': An empty join clause was passed.' );
 		}
+
 		if ( isset( $this->join[$tableAlias] ) ) {
-			throw new \MWException( __METHOD__ . ': Attempted to overwrite existing join clause.' );
+			throw new MWException( __METHOD__ . ': Attempted to overwrite existing join clause.' );
 		}
+
 		$this->join[$tableAlias] = $joinConditions;
+
 		return true;
 	}
 
+	public function addJoins( array $joins ) {
+		foreach ( $joins as $alias => $conds ) {
+			$this->addJoin( $alias, $conds );
+		}
+	}
+
 	/**
 	 * Set the limit.
 	 *
-	 * @access	public
-	 * @param	mixed	Integer limit or false to unset.
-	 * @return	boolean	Success
+	 * @param mixed $limit
+	 * @return bool
 	 */
 	public function setLimit( $limit ) {
 		if ( is_numeric( $limit ) ) {
@@ -534,15 +602,15 @@ public function setLimit( $limit ) {
 		} else {
 			$this->limit = false;
 		}
+
 		return true;
 	}
 
 	/**
 	 * Set the offset.
 	 *
-	 * @access	public
-	 * @param	mixed	Integer offset or false to unset.
-	 * @return	boolean	Success
+	 * @param mixed $offset
+	 * @return bool
 	 */
 	public function setOffset( $offset ) {
 		if ( is_numeric( $offset ) ) {
@@ -550,27 +618,26 @@ public function setOffset( $offset ) {
 		} else {
 			$this->offset = false;
 		}
+
 		return true;
 	}
 
 	/**
 	 * Set the ORDER BY direction
 	 *
-	 * @access	public
-	 * @param	string	SQL direction key word.
-	 * @return	boolean	Success
+	 * @param string $direction
+	 * @return bool
 	 */
 	public function setOrderDir( $direction ) {
 		$this->direction = $direction;
+
 		return true;
 	}
 
 	/**
 	 * Set the character set collation.
 	 *
-	 * @access	public
-	 * @param	string	Collation
-	 * @return	void
+	 * @param string $collation
 	 */
 	public function setCollation( $collation ) {
 		$this->collation = $collation;
@@ -579,8 +646,7 @@ public function setCollation( $collation ) {
 	/**
 	 * Return SQL prefixed collation.
 	 *
-	 * @access	public
-	 * @return	string	SQL Collation
+	 * @return string|null
 	 */
 	public function getCollateSQL() {
 		return ( $this->collation !== false ? 'COLLATE ' . $this->collation : null );
@@ -589,18 +655,18 @@ public function getCollateSQL() {
 	/**
 	 * Recursively get and return an array of subcategories.
 	 *
-	 * @access	public
-	 * @param	string	Category Name
-	 * @param	integer	[Optional] Maximum Depth
-	 * @return	array	Subcategories
+	 * @param string $categoryName
+	 * @param int $depth
+	 * @return array
 	 */
 	public static function getSubcategories( $categoryName, $depth = 1 ) {
 		$DB = wfGetDB( DB_REPLICA, 'dpl' );
 
 		if ( $depth > 2 ) {
-			//Hard constrain depth because lots of recursion is bad.
+			// Hard constrain depth because lots of recursion is bad.
 			$depth = 2;
 		}
+
 		$categories = [];
 		$result = $DB->select(
 			[ 'page', 'categorylinks' ],
@@ -618,23 +684,25 @@ public static function getSubcategories( $categoryName, $depth = 1 ) {
 				]
 			]
 		);
+
 		while ( $row = $result->fetchRow() ) {
 			$categories[] = $row['page_title'];
 			if ( $depth > 1 ) {
 				$categories = array_merge( $categories, self::getSubcategories( $row['page_title'], $depth - 1 ) );
 			}
 		}
+
 		$categories = array_unique( $categories );
 		$DB->freeResult( $result );
+
 		return $categories;
 	}
 
 	/**
 	 * Helper method to handle relative timestamps.
 	 *
-	 * @private
-	 * @param	mixed	Integer or string
-	 * @return	integer
+	 * @param mixed $inputDate
+	 * @return int|string
 	 */
 	private function convertTimestamp( $inputDate ) {
 		$timestamp = $inputDate;
@@ -643,28 +711,28 @@ private function convertTimestamp( $inputDate ) {
 				$timestamp = date( 'YmdHis' );
 				break;
 			case 'last hour':
-				$date = new \DateTime();
-				$date->sub( new \DateInterval( 'P1H' ) );
+				$date = new DateTime();
+				$date->sub( new DateInterval( 'P1H' ) );
 				$timestamp = $date->format( 'YmdHis' );
 				break;
 			case 'last day':
-				$date = new \DateTime();
-				$date->sub( new \DateInterval( 'P1D' ) );
+				$date = new DateTime();
+				$date->sub( new DateInterval( 'P1D' ) );
 				$timestamp = $date->format( 'YmdHis' );
 				break;
 			case 'last week':
-				$date = new \DateTime();
-				$date->sub( new \DateInterval( 'P7D' ) );
+				$date = new DateTime();
+				$date->sub( new DateInterval( 'P7D' ) );
 				$timestamp = $date->format( 'YmdHis' );
 				break;
 			case 'last month':
-				$date = new \DateTime();
-				$date->sub( new \DateInterval( 'P1M' ) );
+				$date = new DateTime();
+				$date->sub( new DateInterval( 'P1M' ) );
 				$timestamp = $date->format( 'YmdHis' );
 				break;
 			case 'last year':
-				$date = new \DateTime();
-				$date->sub( new \DateInterval( 'P1Y' ) );
+				$date = new DateTime();
+				$date->sub( new DateInterval( 'P1Y' ) );
 				$timestamp = $date->format( 'YmdHis' );
 				break;
 		}
@@ -672,36 +740,28 @@ private function convertTimestamp( $inputDate ) {
 		if ( is_numeric( $timestamp ) ) {
 			return $this->DB->addQuotes( $timestamp );
 		}
+
 		return 0;
 	}
 
 	/**
 	 * Set SQL for 'addauthor' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _addauthor( $option ) {
-		//Addauthor can not be used with addlasteditor.
+		// Addauthor can not be used with addlasteditor.
 		if ( !isset( $this->parametersProcessed['addlasteditor'] ) || !$this->parametersProcessed['addlasteditor'] ) {
-			$this->addTable( 'revision_actor_temp', 'rev' );
-			$this->addWhere(
-				[
-					$this->tableNames['page'] . '.page_id = rev.revactor_page',
-					'rev.revactor_timestamp = (SELECT MIN(rev_aux_min.revactor_timestamp) FROM ' . $this->tableNames['revision_actor_temp'] . ' AS rev_aux_min WHERE rev_aux_min.revactor_page = rev.revactor_page)'
-				]
+			$this->revisionJoinBuilder->addFieldsFromFirst(
+				[ 'rev_user_text' => 'rev_user_text' ]
 			);
-			$this->_adduser( null, 'rev' );
 		}
 	}
 
 	/**
 	 * Set SQL for 'addcategories' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _addcategories( $option ) {
 		$this->addTable( 'categorylinks', 'cl_gc' );
@@ -710,6 +770,7 @@ private function _addcategories( $option ) {
 				'cats' => "GROUP_CONCAT(DISTINCT cl_gc.cl_to ORDER BY cl_gc.cl_to ASC SEPARATOR ' | ')"
 			]
 		);
+
 		$this->addJoin(
 			'cl_gc',
 			[
@@ -717,48 +778,39 @@ private function _addcategories( $option ) {
 				'page_id = cl_gc.cl_from'
 			]
 		);
+
 		$this->addGroupBy( $this->tableNames['page'] . '.page_id' );
 	}
 
 	/**
 	 * Set SQL for 'addcontribution' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _addcontribution( $option ) {
-		$this->addTable( 'recentchanges', 'rc' );
+		$actorQuery = $this->actorMigration->getJoin( 'rc_user' );
 
-		$field = 'rc.rc_actor';
+		$this->addTables( [ 'rc' => 'recentchanges' ] + $actorQuery['tables'] );
+		$this->addSelect( [
+			'contribution' => 'SUM(ABS(rc_new_len - rc_old_len))',
+			'contributor' => $actorQuery['fields']['rc_user_text']
+		] );
 
-		$this->addSelect(
-			[
-				'contribution'	=> 'SUM(ABS(rc.rc_new_len - rc.rc_old_len))',
-				'contributor'	=> $field
-			]
-		);
-		$this->addWhere(
-			[
-				$this->tableNames['page'] . '.page_id = rc.rc_cur_id'
-			]
-		);
-		$this->addGroupBy( 'rc.rc_cur_id' );
+		$this->addGroupBy( 'rc_cur_id, ' . $actorQuery['fields']['rc_actor'] );
+		$this->addJoins( [ 'rc' => [ 'JOIN', 'page_id = rc_cur_id' ] ] + $actorQuery['joins'] );
 	}
 
 	/**
 	 * Set SQL for 'addeditdate' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _addeditdate( $option ) {
-		$this->addTable( 'revision_actor_temp', 'rev' );
-		$this->addSelect( [ 'rev.revactor_timestamp' ] );
+		$this->addTable( 'revision', 'rev' );
+		$this->addSelect( [ 'rev.rev_timestamp' ] );
 		$this->addWhere(
 			[
-				$this->tableNames['page'] . '.page_id = rev.revactor_page',
+				$this->tableNames['page'] . '.page_id = rev.rev_page',
 			]
 		);
 	}
@@ -766,12 +818,10 @@ private function _addeditdate( $option ) {
 	/**
 	 * Set SQL for 'addfirstcategorydate' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _addfirstcategorydate( $option ) {
-		//@TODO: This should be programmatically determining which categorylink table to use instead of assuming the first one.
+		// @TODO: This should be programmatically determining which categorylink table to use instead of assuming the first one.
 		$this->addSelect(
 			[
 				'cl_timestamp'	=> "DATE_FORMAT(cl1.cl_timestamp, '%Y%m%d%H%i%s')"
@@ -782,30 +832,19 @@ private function _addfirstcategorydate( $option ) {
 	/**
 	 * Set SQL for 'addlasteditor' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _addlasteditor( $option ) {
-		//Addlasteditor can not be used with addauthor.
+		// Addlasteditor can not be used with addauthor.
 		if ( !isset( $this->parametersProcessed['addauthor'] ) || !$this->parametersProcessed['addauthor'] ) {
-			$this->addTable( 'revision_actor_temp', 'rev' );
-			$this->addWhere(
-				[
-					$this->tableNames['page'] . '.page_id = rev.revactor_page',
-					'rev.revactor_timestamp = (SELECT MAX(rev_aux_max.revactor_timestamp) FROM ' . $this->tableNames['revision_actor_temp'] . ' AS rev_aux_max WHERE rev_aux_max.revactor_page = rev.revactor_page)'
-				]
-			);
-			$this->_adduser( null, 'rev' );
+			$this->revisionJoinBuilder->addFieldsFromLast( [ 'rev_user_text' => 'rev_user_text' ] );
 		}
 	}
 
 	/**
 	 * Set SQL for 'addpagecounter' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _addpagecounter( $option ) {
 		if ( class_exists( "\\HitCounters\\Hooks" ) ) {
@@ -815,6 +854,7 @@ private function _addpagecounter( $option ) {
 					"page_counter"	=> "hit_counter.page_counter"
 				]
 			);
+
 			if ( !isset( $this->join['hit_counter'] ) ) {
 				$this->addJoin(
 					'hit_counter',
@@ -830,9 +870,7 @@ private function _addpagecounter( $option ) {
 	/**
 	 * Set SQL for 'addpagesize' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _addpagesize( $option ) {
 		$this->addSelect(
@@ -845,9 +883,7 @@ private function _addpagesize( $option ) {
 	/**
 	 * Set SQL for 'addpagetoucheddate' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _addpagetoucheddate( $option ) {
 		$this->addSelect(
@@ -857,44 +893,26 @@ private function _addpagetoucheddate( $option ) {
 		);
 	}
 
-	/**
-	 * Set SQL for 'adduser' parameter.
-	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @param	string	[Optional] Table Alias
-	 * @return	void
-	 */
-	private function _adduser( $option, $tableAlias = '' ) {
-		$tableAlias = ( !empty( $tableAlias ) ? $tableAlias . '.' : '' );
-		$this->addSelect(
-			[
-				$tableAlias . 'revactor_actor',
-			]
-		);
-	}
-
 	/**
 	 * Set SQL for 'allrevisionsbefore' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _allrevisionsbefore( $option ) {
-		$this->addTable( 'revision_actor_temp', 'rev' );
+		$this->addTable( 'revision', 'rev' );
 		$this->addSelect(
 			[
-				'rev.revactor_rev',
-				'rev.revactor_timestamp'
+				'rev.rev_id',
+				'rev.rev_timestamp'
 			]
 		);
-		$this->addOrderBy( 'rev.revactor_rev' );
+
+		$this->addOrderBy( 'rev.rev_id' );
 		$this->setOrderDir( 'DESC' );
 		$this->addWhere(
 			[
-				$this->tableNames['page'] . '.page_id = rev.revactor_page',
-				'rev.revactor_timestamp < ' . $this->convertTimestamp( $option )
+				$this->tableNames['page'] . '.page_id = rev.rev_page',
+				'rev.rev_timestamp < ' . $this->convertTimestamp( $option )
 			]
 		);
 	}
@@ -902,24 +920,23 @@ private function _allrevisionsbefore( $option ) {
 	/**
 	 * Set SQL for 'allrevisionssince' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _allrevisionssince( $option ) {
-		$this->addTable( 'revision_actor_temp', 'rev' );
+		$this->addTable( 'revision', 'rev' );
 		$this->addSelect(
 			[
-				'rev.revactor_rev',
-				'rev.revactor_timestamp'
+				'rev.rev_id',
+				'rev.rev_timestamp'
 			]
 		);
-		$this->addOrderBy( 'rev.revactor_rev' );
+
+		$this->addOrderBy( 'rev.rev_id' );
 		$this->setOrderDir( 'DESC' );
 		$this->addWhere(
 			[
-				$this->tableNames['page'] . '.page_id = rev.revactor_page',
-				'rev.revactor_timestamp >= ' . $this->convertTimestamp( $option )
+				$this->tableNames['page'] . '.page_id = rev.rev_page',
+				'rev.rev_timestamp >= ' . $this->convertTimestamp( $option )
 			]
 		);
 	}
@@ -927,9 +944,7 @@ private function _allrevisionssince( $option ) {
 	/**
 	 * Set SQL for 'articlecategory' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _articlecategory( $option ) {
 		$this->addWhere( "{$this->tableNames['page']}.page_title IN (SELECT p2.page_title FROM {$this->tableNames['page']} p2 INNER JOIN {$this->tableNames['categorylinks']} clstc ON (clstc.cl_from = p2.page_id AND clstc.cl_to = " . $this->DB->addQuotes( $option ) . ") WHERE p2.page_namespace = 0)" );
@@ -938,34 +953,33 @@ private function _articlecategory( $option ) {
 	/**
 	 * Set SQL for 'categoriesminmax' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _categoriesminmax( $option ) {
 		if ( is_numeric( $option[0] ) ) {
 			$this->addWhere( intval( $option[0] ) . ' <= (SELECT count(*) FROM ' . $this->tableNames['categorylinks'] . ' WHERE ' . $this->tableNames['categorylinks'] . '.cl_from=page_id)' );
 		}
-		if ( is_numeric( $option[1] ) ) {
+
+		if ( isset( $option[1] ) && is_numeric( $option[1] ) ) {
 			$this->addWhere( intval( $option[1] ) . ' >= (SELECT count(*) FROM ' . $this->tableNames['categorylinks'] . ' WHERE ' . $this->tableNames['categorylinks'] . '.cl_from=page_id)' );
 		}
 	}
 
 	/**
-	 * Set SQL for 'category' parameter.  This includes 'category', 'categorymatch', and 'categoryregexp'.
+	 * Set SQL for 'category' parameter. This includes 'category', 'categorymatch', and 'categoryregexp'.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _category( $option ) {
 		$i = 0;
+
 		foreach ( $option as $comparisonType => $operatorTypes ) {
 			foreach ( $operatorTypes as $operatorType => $categoryGroups ) {
 				foreach ( $categoryGroups as $categories ) {
 					if ( !is_array( $categories ) ) {
 						continue;
 					}
+
 					$tableName = ( in_array( '', $categories ) ? 'dpl_clview' : 'categorylinks' );
 					if ( $operatorType == 'AND' ) {
 						foreach ( $categories as $category ) {
@@ -987,9 +1001,11 @@ private function _category( $option ) {
 
 						$joinOn = "{$this->tableNames['page']}.page_id = {$tableAlias}.cl_from AND (";
 						$ors = [];
+
 						foreach ( $categories as $category ) {
 							$ors[] = "{$tableAlias}.cl_to {$comparisonType} " . $this->DB->addQuotes( str_replace( ' ', '_', $category ) );
 						}
+
 						$joinOn .= implode( " {$operatorType} ", $ors );
 						$joinOn .= ')';
 
@@ -1009,9 +1025,7 @@ private function _category( $option ) {
 	/**
 	 * Set SQL for 'notcategory' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _notcategory( $option ) {
 		$i = 0;
@@ -1029,6 +1043,7 @@ private function _notcategory( $option ) {
 						"{$this->tableNames['page']}.page_id = {$tableAlias}.cl_from AND {$tableAlias}.cl_to {$operatorType}" . $this->DB->addQuotes( str_replace( ' ', '_', $category ) )
 					]
 				);
+
 				$this->addWhere(
 					[
 						"{$tableAlias}.cl_to"	=> null
@@ -1041,31 +1056,16 @@ private function _notcategory( $option ) {
 	/**
 	 * Set SQL for 'createdby' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _createdby( $option ) {
-		$this->addTable( 'revision', 'creation_rev' );
-		$this->addTable( 'revision_actor_temp', 'creation_rev_actor' );
-		$this->_adduser( null, 'creation_rev_actor' );
-		$user = new \User;
-
-		$this->addWhere(
-			[
-				$this->DB->addQuotes( $user->newFromName( $option )->getActorId() ) . ' = creation_rev_actor.revactor_actor',
-				'creation_rev_actor.revactor_page = page_id',
-				'creation_rev.rev_parent_id = 0'
-			]
-		);
+		$this->userQueryBuilder->addCreatedByConstraint( $option );
 	}
 
 	/**
 	 * Set SQL for 'distinct' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _distinct( $option ) {
 		if ( $option == 'strict' || $option === true ) {
@@ -1078,29 +1078,29 @@ private function _distinct( $option ) {
 	/**
 	 * Set SQL for 'firstrevisionsince' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _firstrevisionsince( $option ) {
-		$this->addTable( 'revision_actor_temp', 'rev' );
+		$this->addTable( 'revision', 'rev' );
 		$this->addSelect(
 			[
-				'rev.revactor_rev',
-				'rev.revactor_timestamp'
+				'rev.rev_id',
+				'rev.rev_timestamp'
 			]
 		);
+
 		// tell the query optimizer not to look at rows that the following subquery will filter out anyway
 		$this->addWhere(
 			[
-				$this->tableNames['page'] . '.page_id = rev.revactor_page',
-				'rev.revactor_timestamp >= ' . $this->DB->addQuotes( $option )
+				$this->tableNames['page'] . '.page_id = rev.rev_page',
+				'rev.rev_timestamp >= ' . $this->DB->addQuotes( $option )
 			]
 		);
+
 		$this->addWhere(
 			[
-				$this->tableNames['page'] . '.page_id = rev.revactor_page',
-				'rev.revactor_timestamp = (SELECT MIN(rev_aux_snc.revactor_timestamp) FROM ' . $this->tableNames['revision_actor_temp'] . ' AS rev_aux_snc WHERE rev_aux_snc.revactor_page=rev.revactor_page AND rev_aux_snc.revactor_timestamp >= ' . $this->convertTimestamp( $option ) . ')'
+				$this->tableNames['page'] . '.page_id = rev.rev_page',
+				'rev.rev_timestamp = (SELECT MIN(rev_aux_snc.rev_timestamp) FROM ' . $this->tableNames['revision'] . ' AS rev_aux_snc WHERE rev_aux_snc.rev_page=rev.rev_page AND rev_aux_snc.rev_timestamp >= ' . $this->convertTimestamp( $option ) . ')'
 			]
 		);
 	}
@@ -1108,9 +1108,7 @@ private function _firstrevisionsince( $option ) {
 	/**
 	 * Set SQL for 'goal' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _goal( $option ) {
 		if ( $option == 'categories' ) {
@@ -1122,34 +1120,34 @@ private function _goal( $option ) {
 	/**
 	 * Set SQL for 'hiddencategories' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _hiddencategories( $option ) {
-		//@TODO: Unfinished functionality!  Never implemented by original author.
+		// @TODO: Unfinished functionality! Never implemented by original author.
 	}
 
 	/**
 	 * Set SQL for 'imagecontainer' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _imagecontainer( $option ) {
+		$where = [];
+
 		$this->addTable( 'imagelinks', 'ic' );
 		$this->addSelect(
 			[
 				'sortkey'	=> 'ic.il_to'
 			]
 		);
+
 		if ( !$this->parameters->getParameter( 'openreferences' ) ) {
 			$where = [
 				"{$this->tableNames['page']}.page_namespace = " . intval( NS_FILE ),
 				"{$this->tableNames['page']}.page_title = ic.il_to"
 			];
 		}
+
 		$ors = [];
 		foreach ( $option as $linkGroup ) {
 			foreach ( $linkGroup as $link ) {
@@ -1160,6 +1158,7 @@ private function _imagecontainer( $option ) {
 				}
 			}
 		}
+
 		$where[] = '(' . implode( ' OR ', $ors ) . ')';
 		$this->addWhere( $where );
 	}
@@ -1167,22 +1166,25 @@ private function _imagecontainer( $option ) {
 	/**
 	 * Set SQL for 'imageused' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _imageused( $option ) {
+		$where = [];
+
 		if ( $this->parameters->getParameter( 'distinct' ) == 'strict' ) {
 			$this->addGroupBy( 'page_title' );
 		}
+
 		$this->addTable( 'imagelinks', 'il' );
 		$this->addSelect(
 			[
 				'image_sel_title'	=> 'il.il_to'
 			]
 		);
+
 		$where[] = $this->tableNames['page'] . '.page_id = il.il_from';
 		$ors = [];
+
 		foreach ( $option as $linkGroup ) {
 			foreach ( $linkGroup as $link ) {
 				if ( $this->parameters->getParameter( 'ignorecase' ) ) {
@@ -1192,6 +1194,7 @@ private function _imageused( $option ) {
 				}
 			}
 		}
+
 		$where[] = '(' . implode( ' OR ', $ors ) . ')';
 		$this->addWhere( $where );
 	}
@@ -1199,37 +1202,33 @@ private function _imageused( $option ) {
 	/**
 	 * Set SQL for 'lastmodifiedby' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _lastmodifiedby( $option ) {
-	   $user = new \User;
-
-	   $this->addWhere( $this->DB->addQuotes( $user->newFromName( $option )->getActorId() ) . ' = (SELECT revactor_actor FROM ' . $this->tableNames['revision_actor_temp'] . ' WHERE ' . $this->tableNames['revision_actor_temp'] . '.revactor_page=page_id ORDER BY ' . $this->tableNames['revision_actor_temp'] . '.revactor_timestamp DESC LIMIT 1)' );
+		$this->userQueryBuilder->addLastModifiedByConstraint( $option );
 	}
 
 	/**
 	 * Set SQL for 'lastrevisionbefore' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _lastrevisionbefore( $option ) {
-		$this->addTable( 'revision_actor_temp', 'rev' );
-		$this->addSelect( [ 'rev.revactor_rev', 'rev.revactor_timestamp' ] );
+		$this->addTable( 'revision', 'rev' );
+		$this->addSelect( [ 'rev.rev_id', 'rev.rev_timestamp' ] );
+
 		// tell the query optimizer not to look at rows that the following subquery will filter out anyway
 		$this->addWhere(
 			[
-				$this->tableNames['page'] . '.page_id = rev.revactor_page',
-				'rev.revactor_timestamp < ' . $this->convertTimestamp( $option )
+				$this->tableNames['page'] . '.page_id = rev.rev_page',
+				'rev.rev_timestamp < ' . $this->convertTimestamp( $option )
 			]
 		);
+
 		$this->addWhere(
 			[
-				$this->tableNames['page'] . '.page_id = rev.revactor_page',
-				'rev.revactor_timestamp = (SELECT MAX(rev_aux_bef.revactor_timestamp) FROM ' . $this->tableNames['revision_actor_temp'] . ' AS rev_aux_bef WHERE rev_aux_bef.revactor_page=rev.revactor_page AND rev_aux_bef.revactor_timestamp < ' . $this->convertTimestamp( $option ) . ')'
+				$this->tableNames['page'] . '.page_id = rev.rev_page',
+				'rev.rev_timestamp = (SELECT MAX(rev_aux_bef.rev_timestamp) FROM ' . $this->tableNames['revision'] . ' AS rev_aux_bef WHERE rev_aux_bef.rev_page=rev.rev_page AND rev_aux_bef.rev_timestamp < ' . $this->convertTimestamp( $option ) . ')'
 			]
 		);
 	}
@@ -1237,14 +1236,15 @@ private function _lastrevisionbefore( $option ) {
 	/**
 	 * Set SQL for 'linksfrom' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _linksfrom( $option ) {
+		$where = [];
+
 		if ( $this->parameters->getParameter( 'distinct' ) == 'strict' ) {
 			$this->addGroupBy( 'page_title' );
 		}
+
 		if ( $this->parameters->getParameter( 'openreferences' ) ) {
 			$ors = [];
 			foreach ( $option as $linkGroup ) {
@@ -1252,6 +1252,7 @@ private function _linksfrom( $option ) {
 					$ors[] = '(pl_from = ' . $link->getArticleID() . ')';
 				}
 			}
+
 			$where[] = '(' . implode( ' OR ', $ors ) . ')';
 		} else {
 			$this->addTable( 'pagelinks', 'plf' );
@@ -1262,40 +1263,45 @@ private function _linksfrom( $option ) {
 					'sel_ns' => 'pagesrc.page_namespace'
 				]
 			);
+
 			$where = [
 				$this->tableNames['page'] . '.page_namespace = plf.pl_namespace',
 				$this->tableNames['page'] . '.page_title = plf.pl_title',
 				'pagesrc.page_id = plf.pl_from'
 			];
+
 			$ors = [];
 			foreach ( $option as $linkGroup ) {
 				foreach ( $linkGroup as $link ) {
 					$ors[] = 'plf.pl_from = ' . $link->getArticleID();
 				}
 			}
+
 			$where[] = '(' . implode( ' OR ', $ors ) . ')';
 		}
+
 		$this->addWhere( $where );
 	}
 
 	/**
 	 * Set SQL for 'linksto' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _linksto( $option ) {
 		if ( $this->parameters->getParameter( 'distinct' ) == 'strict' ) {
 			$this->addGroupBy( 'page_title' );
 		}
+
 		if ( count( $option ) > 0 ) {
 			$this->addTable( 'pagelinks', 'pl' );
 			$this->addSelect( [ 'sel_title' => 'pl.pl_title', 'sel_ns' => 'pl.pl_namespace' ] );
+
 			foreach ( $option as $index => $linkGroup ) {
 				if ( $index == 0 ) {
 					$where = $this->tableNames['page'] . '.page_id=pl.pl_from AND ';
 					$ors = [];
+
 					foreach ( $linkGroup as $link ) {
 						$_or = '(pl.pl_namespace=' . intval( $link->getNamespace() );
 						if ( strpos( $link->getDbKey(), '%' ) >= 0 ) {
@@ -1303,18 +1309,22 @@ private function _linksto( $option ) {
 						} else {
 							$operator = '=';
 						}
+
 						if ( $this->parameters->getParameter( 'ignorecase' ) ) {
 							$_or .= ' AND LOWER(CAST(pl.pl_title AS char)) ' . $operator . ' LOWER(' . $this->DB->addQuotes( $link->getDbKey() ) . ')';
 						} else {
 							$_or .= ' AND pl.pl_title ' . $operator . ' ' . $this->DB->addQuotes( $link->getDbKey() );
 						}
+
 						$_or .= ')';
 						$ors[] = $_or;
 					}
+
 					$where .= '(' . implode( ' OR ', $ors ) . ')';
 				} else {
 					$where = 'EXISTS(select pl_from FROM ' . $this->tableNames['pagelinks'] . ' WHERE (' . $this->tableNames['pagelinks'] . '.pl_from=page_id AND ';
 					$ors = [];
+
 					foreach ( $linkGroup as $link ) {
 						$_or = '(' . $this->tableNames['pagelinks'] . '.pl_namespace=' . intval( $link->getNamespace() );
 						if ( strpos( $link->getDbKey(), '%' ) >= 0 ) {
@@ -1322,17 +1332,21 @@ private function _linksto( $option ) {
 						} else {
 							$operator = '=';
 						}
+
 						if ( $this->parameters->getParameter( 'ignorecase' ) ) {
 							$_or .= ' AND LOWER(CAST(' . $this->tableNames['pagelinks'] . '.pl_title AS char)) ' . $operator . ' LOWER(' . $this->DB->addQuotes( $link->getDbKey() ) . ')';
 						} else {
 							$_or .= ' AND ' . $this->tableNames['pagelinks'] . '.pl_title ' . $operator . ' ' . $this->DB->addQuotes( $link->getDbKey() );
 						}
+
 						$_or .= ')';
 						$ors[] = $_or;
 					}
+
 					$where .= '(' . implode( ' OR ', $ors ) . ')';
 					$where .= '))';
 				}
+
 				$this->addWhere( $where );
 			}
 		}
@@ -1341,14 +1355,13 @@ private function _linksto( $option ) {
 	/**
 	 * Set SQL for 'notlinksfrom' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _notlinksfrom( $option ) {
 		if ( $this->parameters->getParameter( 'distinct' ) == 'strict' ) {
 			$this->addGroupBy( 'page_title' );
 		}
+
 		if ( $this->parameters->getParameter( 'openreferences' ) ) {
 			$ands = [];
 			foreach ( $option as $linkGroup ) {
@@ -1356,34 +1369,38 @@ private function _notlinksfrom( $option ) {
 					$ands[] = 'pl_from <> ' . intval( $link->getArticleID() ) . ' ';
 				}
 			}
+
 			$where = '(' . implode( ' AND ', $ands ) . ')';
 		} else {
 			$where = 'CONCAT(page_namespace,page_title) NOT IN (SELECT CONCAT(' . $this->tableNames['pagelinks'] . '.pl_namespace,' . $this->tableNames['pagelinks'] . '.pl_title) FROM ' . $this->tableNames['pagelinks'] . ' WHERE ';
 			$ors = [];
+
 			foreach ( $option as $linkGroup ) {
 				foreach ( $linkGroup as $link ) {
 					$ors[] = $this->tableNames['pagelinks'] . '.pl_from = ' . intval( $link->getArticleID() );
 				}
 			}
+
 			$where .= implode( ' OR ', $ors ) . ')';
 		}
+
 		$this->addWhere( $where );
 	}
 
 	/**
 	 * Set SQL for 'notlinksto' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _notlinksto( $option ) {
 		if ( $this->parameters->getParameter( 'distinct' ) == 'strict' ) {
 			$this->addGroupBy( 'page_title' );
 		}
+
 		if ( count( $option ) ) {
 			$where = $this->tableNames['page'] . '.page_id NOT IN (SELECT ' . $this->tableNames['pagelinks'] . '.pl_from FROM ' . $this->tableNames['pagelinks'] . ' WHERE ';
 			$ors = [];
+
 			foreach ( $option as $linkGroup ) {
 				foreach ( $linkGroup as $link ) {
 					$_or = '(' . $this->tableNames['pagelinks'] . '.pl_namespace=' . intval( $link->getNamespace() );
@@ -1392,50 +1409,59 @@ private function _notlinksto( $option ) {
 					} else {
 						$operator = '=';
 					}
+
 					if ( $this->parameters->getParameter( 'ignorecase' ) ) {
 						$_or .= ' AND LOWER(CAST(' . $this->tableNames['pagelinks'] . '.pl_title AS char)) ' . $operator . ' LOWER(' . $this->DB->addQuotes( $link->getDbKey() ) . '))';
 					} else {
 						$_or .= ' AND ' . $this->tableNames['pagelinks'] . '.pl_title ' . $operator . ' ' . $this->DB->addQuotes( $link->getDbKey() ) . ')';
 					}
+
 					$ors[] = $_or;
 				}
 			}
+
 			$where .= '(' . implode( ' OR ', $ors ) . '))';
 		}
-		$this->addWhere( $where );
+
+		$this->addWhere( $where ?? '' );
 	}
 
 	/**
 	 * Set SQL for 'linkstoexternal' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _linkstoexternal( $option ) {
 		if ( $this->parameters->getParameter( 'distinct' ) == 'strict' ) {
 			$this->addGroupBy( 'page_title' );
 		}
+
 		if ( count( $option ) > 0 ) {
 			$this->addTable( 'externallinks', 'el' );
 			$this->addSelect( [ 'el_to' => 'el.el_to' ] );
+
 			foreach ( $option as $index => $linkGroup ) {
 				if ( $index == 0 ) {
 					$where = $this->tableNames['page'] . '.page_id=el.el_from AND ';
 					$ors = [];
+
 					foreach ( $linkGroup as $link ) {
 						$ors[] = 'el.el_to LIKE ' . $this->DB->addQuotes( $link );
 					}
+
 					$where .= '(' . implode( ' OR ', $ors ) . ')';
 				} else {
 					$where = 'EXISTS(SELECT el_from FROM ' . $this->tableNames['externallinks'] . ' WHERE (' . $this->tableNames['externallinks'] . '.el_from=page_id AND ';
 					$ors = [];
+
 					foreach ( $linkGroup as $link ) {
 						$ors[] = $this->tableNames['externallinks'] . '.el_to LIKE ' . $this->DB->addQuotes( $link );
 					}
+
 					$where .= '(' . implode( ' OR ', $ors ) . ')';
 					$where .= '))';
 				}
+
 				$this->addWhere( $where );
 			}
 		}
@@ -1444,62 +1470,48 @@ private function _linkstoexternal( $option ) {
 	/**
 	 * Set SQL for 'maxrevisions' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _maxrevisions( $option ) {
-		$this->addWhere( "((SELECT count(rev_aux3.revactor_page) FROM {$this->tableNames['revision_actor_temp']} AS rev_aux3 WHERE rev_aux3.revactor_page = {$this->tableNames['page']}.page_id) <= {$option})" );
+		$this->addWhere( "((SELECT count(rev_aux3.rev_page) FROM {$this->tableNames['revision']} AS rev_aux3 WHERE rev_aux3.rev_page = {$this->tableNames['page']}.page_id) <= {$option})" );
 	}
 
 	/**
 	 * Set SQL for 'minoredits' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _minoredits( $option ) {
 		if ( isset( $option ) && $option == 'exclude' ) {
-			$this->addTable( 'revision', 'revision' );
-			$this->addWhere( 'revision.rev_minor_edit = 0' );
+			$this->addTable( 'revision', 'rev' );
+			$this->addWhere( 'rev.rev_minor_edit = 0' );
 		}
 	}
 
 	/**
 	 * Set SQL for 'minrevisions' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _minrevisions( $option ) {
-		$this->addWhere( "((SELECT count(rev_aux2.revactor_page) FROM {$this->tableNames['revision_actor_temp']} AS rev_aux2 WHERE rev_aux2.revactor_page = {$this->tableNames['page']}.page_id) >= {$option})" );
+		$this->addWhere( "((SELECT count(rev_aux2.rev_page) FROM {$this->tableNames['revision']} AS rev_aux2 WHERE rev_aux2.rev_page = {$this->tableNames['page']}.page_id) >= {$option})" );
 	}
 
 	/**
 	 * Set SQL for 'modifiedby' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _modifiedby( $option ) {
-		$this->addTable( 'revision_actor_temp', 'change_rev' );
-		$user = new \User;
-
-		$this->addWhere( $this->DB->addQuotes( $user->newFromName( $option )->getActorId() ) . ' = change_rev.revactor_actor AND change_rev.revactor_page = page_id' );
+		$this->userQueryBuilder->addModifiedByConstraint( $option );
 	}
 
 	/**
 	 * Set SQL for 'namespace' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _namespace( $option ) {
-		$option === 0 ?? $option = '0';
 		if ( is_array( $option ) && count( $option ) ) {
 			if ( $this->parameters->getParameter( 'openreferences' ) ) {
 				$this->addWhere(
@@ -1520,48 +1532,34 @@ private function _namespace( $option ) {
 	/**
 	 * Set SQL for 'notcreatedby' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _notcreatedby( $option ) {
-		$this->addTable( 'revision', 'no_creation_rev' );
-		$this->addTable( 'revision_actor_temp', 'no_creation_rev_actor' );
-		$user = new \User;
-
-		$this->addWhere( $this->DB->addQuotes( $user->newFromName( $option )->getActorId() ) . ' != no_creation_rev_actor.revactor_actor AND no_creation_rev_actor.revactor_page = page_id AND no_creation_rev.rev_parent_id = 0' );
+		$this->userQueryBuilder->addNotCreatedByConstraint( $option );
 	}
 
 	/**
 	 * Set SQL for 'notlastmodifiedby' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _notlastmodifiedby( $option ) {
-		$user = new \User;
-		$this->addWhere( $this->DB->addQuotes( $user->newFromName( $option )->getActorId() ) . ' != (SELECT revactor_actor FROM ' . $this->tableNames['revision_actor_temp'] . ' WHERE ' . $this->tableNames['revision_actor_temp'] . '.revactor_page=page_id ORDER BY ' . $this->tableNames['revision_actor_temp'] . '.revactor_timestamp DESC LIMIT 1)' );
+		$this->userQueryBuilder->addNotLastModifiedByConstraint( $option );
 	}
 
 	/**
 	 * Set SQL for 'notmodifiedby' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _notmodifiedby( $option ) {
-		$user = new \User;
-		$this->addWhere( 'NOT EXISTS (SELECT 1 FROM ' . $this->tableNames['revision_actor_temp'] . ' WHERE ' . $this->tableNames['revision_actor_temp'] . '.revactor_page=page_id AND ' . $this->tableNames['revision_actor_temp'] . '.revactor_actor = ' . $this->DB->addQuotes( $user->newFromName( $option )->getActorId() ) . ' LIMIT 1)' );
+		$this->userQueryBuilder->addNotModifiedByConstraint( $option );
 	}
 
 	/**
 	 * Set SQL for 'notnamespace' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _notnamespace( $option ) {
 		if ( is_array( $option ) && count( $option ) ) {
@@ -1584,9 +1582,7 @@ private function _notnamespace( $option ) {
 	/**
 	 * Set SQL for 'count' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _count( $option ) {
 		$this->setLimit( $option );
@@ -1595,9 +1591,7 @@ private function _count( $option ) {
 	/**
 	 * Set SQL for 'offset' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _offset( $option ) {
 		$this->setOffset( $option );
@@ -1606,12 +1600,11 @@ private function _offset( $option ) {
 	/**
 	 * Set SQL for 'order' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _order( $option ) {
 		$orderMethod = $this->parameters->getParameter( 'ordermethod' );
+
 		if ( !empty( $orderMethod ) && is_array( $orderMethod ) && $orderMethod[0] !== 'none' ) {
 			if ( $option === 'descending' || $option === 'desc' ) {
 				$this->setOrderDir( 'DESC' );
@@ -1624,9 +1617,8 @@ private function _order( $option ) {
 	/**
 	 * Set SQL for 'ordercollation' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
+	 * @return bool
 	 */
 	private function _ordercollation( $option ) {
 		$option = mb_strtolower( $option );
@@ -1642,39 +1634,46 @@ private function _ordercollation( $option ) {
 				break;
 			}
 		}
+
 		return true;
 	}
 
 	/**
 	 * Set SQL for 'ordermethod' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _ordermethod( $option ) {
-		$contLang = MediaWikiServices::getInstance()->getContentLanguage();
-
 		if ( $this->parameters->getParameter( 'goal' ) == 'categories' ) {
-			//No order methods for returning categories.
+			// No order methods for returning categories.
 			return true;
 		}
 
-		$namespaces = $contLang->getNamespaces();
-		//$aStrictNs = array_slice((array) Config::getSetting('allowedNamespaces'), 1, count(Config::getSetting('allowedNamespaces')), true);
+		$services = MediaWikiServices::getInstance();
+		$namespaces = $services->getContentLanguage()->getNamespaces();
+
+		// $aStrictNs = array_slice( (array)Config::getSetting( 'allowedNamespaces' ), 1, count( Config::getSetting( 'allowedNamespaces' ) ), true );
+
 		$namespaces = array_slice( $namespaces, 3, count( $namespaces ), true );
 		$_namespaceIdToText = "CASE {$this->tableNames['page']}.page_namespace";
+
 		foreach ( $namespaces as $id => $name ) {
 			$_namespaceIdToText .= ' WHEN ' . intval( $id ) . " THEN " . $this->DB->addQuotes( $name . ':' );
 		}
+
 		$_namespaceIdToText .= ' END';
 
 		$option = (array)$option;
+
+		$willOrderByLastEdit = in_array( 'lastedit', $option );
+		$willOrderByFirstEdit = in_array( 'firstedit', $option );
+
 		foreach ( $option as $orderMethod ) {
 			switch ( $orderMethod ) {
 				case 'category':
 					$this->addOrderBy( 'cl_head.cl_to' );
-					$this->addSelect( [ 'cl_head.cl_to' ] ); //Gives category headings in the result.
+					$this->addSelect( [ 'cl_head.cl_to' ] );
+
 					if ( ( is_array( $this->parameters->getParameter( 'catheadings' ) ) && in_array( '', $this->parameters->getParameter( 'catheadings' ) ) ) || ( is_array( $this->parameters->getParameter( 'catnotheadings' ) ) && in_array( '', $this->parameters->getParameter( 'catnotheadings' ) ) ) ) {
 						$_clTableName = 'dpl_clview';
 						$_clTableAlias = $_clTableName;
@@ -1682,6 +1681,7 @@ private function _ordermethod( $option ) {
 						$_clTableName = 'categorylinks';
 						$_clTableAlias = 'cl_head';
 					}
+
 					$this->addTable( $_clTableName, $_clTableAlias );
 					$this->addJoin(
 						$_clTableAlias,
@@ -1690,6 +1690,7 @@ private function _ordermethod( $option ) {
 							"page_id = cl_head.cl_from"
 						]
 					);
+
 					if ( is_array( $this->parameters->getParameter( 'catheadings' ) ) && count( $this->parameters->getParameter( 'catheadings' ) ) ) {
 						$this->addWhere(
 							[
@@ -1697,6 +1698,7 @@ private function _ordermethod( $option ) {
 							]
 						);
 					}
+
 					if ( is_array( $this->parameters->getParameter( 'catnotheadings' ) ) && count( $this->parameters->getParameter( 'catnotheadings' ) ) ) {
 						$this->addNotWhere(
 							[
@@ -1706,12 +1708,12 @@ private function _ordermethod( $option ) {
 					}
 					break;
 				case 'categoryadd':
-					//@TODO: See TODO in __addfirstcategorydate().
+					// @TODO: See TODO in __addfirstcategorydate().
 					$this->addOrderBy( 'cl1.cl_timestamp' );
 					break;
 				case 'counter':
 					if ( class_exists( "\\HitCounters\\Hooks" ) ) {
-						//If the "addpagecounter" parameter was not used the table and join need to be added now.
+						// If the "addpagecounter" parameter was not used the table and join need to be added now.
 						if ( !array_key_exists( 'hit_counter', $this->tables ) ) {
 							$this->addTable( 'hit_counter', 'hit_counter' );
 
@@ -1725,29 +1727,19 @@ private function _ordermethod( $option ) {
 								);
 							}
 						}
+
 						$this->addOrderBy( 'hit_counter.page_counter' );
 					}
 					break;
 				case 'firstedit':
-					$this->addOrderBy( 'rev.revactor_timestamp' );
-					$this->addTable( 'revision_actor_temp', 'rev' );
-					$this->addSelect(
-						[
-							'rev.revactor_timestamp'
-						]
-					);
-					if ( !$this->revisionAuxWhereAdded ) {
-						$this->addWhere(
-							[
-								"{$this->tableNames['page']}.page_id = rev.revactor_page",
-								"rev.revactor_timestamp = (SELECT MIN(rev_aux.revactor_timestamp) FROM {$this->tableNames['revision_actor_temp']} AS rev_aux WHERE rev_aux.revactor_page=rev.revactor_page)"
-							]
-						);
-					}
-					$this->revisionAuxWhereAdded = true;
+					$this->revisionJoinBuilder->addFieldsFromFirst( [
+						'first_rev_timestamp' => 'rev_timestamp'
+					] );
+
+					$this->addOrderBy( 'first_rev_timestamp' );
 					break;
 				case 'lastedit':
-					if ( \DynamicPageListHooks::isLikeIntersection() ) {
+					if ( DynamicPageListHooks::isLikeIntersection() ) {
 						$this->addOrderBy( 'page_touched' );
 						$this->addSelect(
 							[
@@ -1755,18 +1747,11 @@ private function _ordermethod( $option ) {
 							]
 						);
 					} else {
-						$this->addOrderBy( 'rev.revactor_timestamp' );
-						$this->addTable( 'revision_actor_temp', 'rev' );
-						$this->addSelect( [ 'rev.revactor_timestamp' ] );
-						if ( !$this->revisionAuxWhereAdded ) {
-							$this->addWhere(
-								[
-									"{$this->tableNames['page']}.page_id = rev.revactor_page",
-									"rev.revactor_timestamp = (SELECT MAX(rev_aux.revactor_timestamp) FROM {$this->tableNames['revision_actor_temp']} AS rev_aux WHERE rev_aux.revactor_page = rev.revactor_page)"
-								]
-							);
-						}
-						$this->revisionAuxWhereAdded = true;
+						$this->revisionJoinBuilder->addFieldsFromLast( [
+							'latest_rev_timestamp' => 'rev_timestamp'
+						] );
+
+						$this->addOrderBy( 'latest_rev_timestamp' );
 					}
 					break;
 				case 'pagesel':
@@ -1790,6 +1775,7 @@ private function _ordermethod( $option ) {
 					break;
 				case 'sortkey':
 					$this->addOrderBy( 'sortkey' );
+
 					// If cl_sortkey is null (uncategorized page), generate a sortkey in the usual way (full page name, underscores replaced with spaces).
 					// UTF-8 created problems with non-utf-8 MySQL databases
 					$replaceConcat = "REPLACE(CONCAT({$_namespaceIdToText}, " . $this->tableNames['page'] . ".page_title), '_', ' ')";
@@ -1804,7 +1790,7 @@ private function _ordermethod( $option ) {
 								]
 							);
 						} else {
-							//This runs on the assumption that at least one category parameter was used and that numbering starts at 1.
+							// This runs on the assumption that at least one category parameter was used and that numbering starts at 1.
 							$this->addSelect(
 								[
 									'sortkey' => "IFNULL(cl1.cl_sortkey, {$replaceConcat}) " . $this->getCollateSQL()
@@ -1825,6 +1811,7 @@ private function _ordermethod( $option ) {
 					} else {
 						$this->addOrderBy( "page_title" );
 					}
+
 					$this->addSelect(
 						[
 							'sortkey' => "{$this->tableNames['page']}.page_title " . $this->getCollateSQL()
@@ -1836,11 +1823,11 @@ private function _ordermethod( $option ) {
 					if ( $this->parameters->getParameter( 'openreferences' ) ) {
 						$this->addSelect(
 							[
-								'sortkey' => "REPLACE(CONCAT(IF(pl_namespace  =0, '', CONCAT(" . $_namespaceIdToText . ", ':')), pl_title), '_', ' ') " . $this->getCollateSQL()
+								'sortkey' => "REPLACE(CONCAT(IF(pl_namespace =0, '', CONCAT(" . $_namespaceIdToText . ", ':')), pl_title), '_', ' ') " . $this->getCollateSQL()
 							]
 						);
 					} else {
-						//Generate sortkey like for category links. UTF-8 created problems with non-utf-8 MySQL databases.
+						// Generate sortkey like for category links. UTF-8 created problems with non-utf-8 MySQL databases.
 						$this->addSelect(
 							[
 								'sortkey' => "REPLACE(CONCAT(IF(" . $this->tableNames['page'] . ".page_namespace = 0, '', CONCAT(" . $_namespaceIdToText . ", ':')), " . $this->tableNames['page'] . ".page_title), '_', ' ') " . $this->getCollateSQL()
@@ -1849,10 +1836,26 @@ private function _ordermethod( $option ) {
 					}
 					break;
 				case 'user':
-					$user = new \User;
-					$this->addOrderBy( $user->newFromName( 'rev.revactor_actor' )->getActorId() );
-					$this->addTable( 'revision_actor_temp', 'rev' );
-					$this->_adduser( null, 'rev' );
+					$actorQuery = $this->actorMigration->getJoin( 'rev_user' );
+					$sortField = $actorQuery['fields']['rev_actor'] !== 'NULL' ? 'rev_actor' : 'rev_user_text';
+
+					if ( $willOrderByFirstEdit ) {
+						$this->revisionJoinBuilder->addFieldsFromFirst( [
+							'rev_user_text' => 'rev_user_text',
+							'first_rev_actor' => $sortField
+						] );
+
+						$this->addOrderBy( 'first_rev_actor' );
+					}
+
+					if ( $willOrderByLastEdit ) {
+						$this->revisionJoinBuilder->addFieldsFromLast( [
+							'rev_user_text' => 'rev_user_text',
+							'last_rev_actor' => $sortField
+						] );
+
+						$this->addOrderBy( 'last_rev_actor' );
+					}
 					break;
 				case 'none':
 					break;
@@ -1863,9 +1866,7 @@ private function _ordermethod( $option ) {
 	/**
 	 * Set SQL for 'redirects' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _redirects( $option ) {
 		if ( !$this->parameters->getParameter( 'openreferences' ) ) {
@@ -1891,13 +1892,11 @@ private function _redirects( $option ) {
 	/**
 	 * Set SQL for 'stablepages' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _stablepages( $option ) {
 		if ( function_exists( 'efLoadFlaggedRevs' ) ) {
-			//Do not add this again if 'qualitypages' has already added it.
+			// Do not add this again if 'qualitypages' has already added it.
 			if ( !$this->parametersProcessed['qualitypages'] ) {
 				$this->addJoin(
 					'flaggedpages',
@@ -1907,6 +1906,7 @@ private function _stablepages( $option ) {
 					]
 				);
 			}
+
 			switch ( $option ) {
 				case 'only':
 					$this->addWhere(
@@ -1929,13 +1929,11 @@ private function _stablepages( $option ) {
 	/**
 	 * Set SQL for 'qualitypages' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _qualitypages( $option ) {
 		if ( function_exists( 'efLoadFlaggedRevs' ) ) {
-			//Do not add this again if 'stablepages' has already added it.
+			// Do not add this again if 'stablepages' has already added it.
 			if ( !$this->parametersProcessed['stablepages'] ) {
 				$this->addJoin(
 					'flaggedpages',
@@ -1945,6 +1943,7 @@ private function _qualitypages( $option ) {
 					]
 				);
 			}
+
 			switch ( $option ) {
 				case 'only':
 					$this->addWhere( 'fp_quality >= 1' );
@@ -1959,12 +1958,11 @@ private function _qualitypages( $option ) {
 	/**
 	 * Set SQL for 'title' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _title( $option ) {
 		$ors = [];
+
 		foreach ( $option as $comparisonType => $titles ) {
 			foreach ( $titles as $title ) {
 				if ( $this->parameters->getParameter( 'openreferences' ) ) {
@@ -1980,9 +1978,11 @@ private function _title( $option ) {
 						$_or = "{$this->tableNames['page']}.page_title {$comparisonType}" . $this->DB->addQuotes( $title );
 					}
 				}
+
 				$ors[] = $_or;
 			}
 		}
+
 		$where = '(' . implode( ' OR ', $ors ) . ')';
 		$this->addWhere( $where );
 	}
@@ -1990,12 +1990,11 @@ private function _title( $option ) {
 	/**
 	 * Set SQL for 'nottitle' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _nottitle( $option ) {
 		$ors = [];
+
 		foreach ( $option as $comparisonType => $titles ) {
 			foreach ( $titles as $title ) {
 				if ( $this->parameters->getParameter( 'openreferences' ) ) {
@@ -2011,9 +2010,11 @@ private function _nottitle( $option ) {
 						$_or = "{$this->tableNames['page']}.page_title {$comparisonType}" . $this->DB->addQuotes( $title );
 					}
 				}
+
 				$ors[] = $_or;
 			}
 		}
+
 		$where = 'NOT (' . implode( ' OR ', $ors ) . ')';
 		$this->addWhere( $where );
 	}
@@ -2021,15 +2022,14 @@ private function _nottitle( $option ) {
 	/**
 	 * Set SQL for 'titlegt' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _titlegt( $option ) {
 		$where = '(';
+
 		if ( substr( $option, 0, 2 ) == '=_' ) {
 			if ( $this->parameters->getParameter( 'openreferences' ) ) {
-				$where .= 'pl_title >= ' . $this->DB->addQuotes( substr( $sTitleGE, 2 ) );
+				$where .= 'pl_title >= ' . $this->DB->addQuotes( substr( $option, 2 ) );
 			} else {
 				$where .= $this->tableNames['page'] . '.page_title >= ' . $this->DB->addQuotes( substr( $option, 2 ) );
 			}
@@ -2040,6 +2040,7 @@ private function _titlegt( $option ) {
 				$where .= $this->tableNames['page'] . '.page_title > ' . $this->DB->addQuotes( $option );
 			}
 		}
+
 		$where .= ')';
 		$this->addWhere( $where );
 	}
@@ -2047,12 +2048,11 @@ private function _titlegt( $option ) {
 	/**
 	 * Set SQL for 'titlelt' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _titlelt( $option ) {
 		$where = '(';
+
 		if ( substr( $option, 0, 2 ) == '=_' ) {
 			if ( $this->parameters->getParameter( 'openreferences' ) ) {
 				$where .= 'pl_title <= ' . $this->DB->addQuotes( substr( $option, 2 ) );
@@ -2066,6 +2066,7 @@ private function _titlelt( $option ) {
 				$where .= $this->tableNames['page'] . '.page_title < ' . $this->DB->addQuotes( $option );
 			}
 		}
+
 		$where .= ')';
 		$this->addWhere( $where );
 	}
@@ -2073,18 +2074,18 @@ private function _titlelt( $option ) {
 	/**
 	 * Set SQL for 'usedby' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _usedby( $option ) {
 		if ( $this->parameters->getParameter( 'openreferences' ) ) {
 			$ors = [];
+
 			foreach ( $option as $linkGroup ) {
 				foreach ( $linkGroup as $link ) {
 					$ors[] = 'tpl_from = ' . intval( $link->getArticleID() );
 				}
 			}
+
 			$where = '(' . implode( ' OR ', $ors ) . ')';
 		} else {
 			$this->addTable( 'templatelinks', 'tpl' );
@@ -2093,38 +2094,43 @@ private function _usedby( $option ) {
 			$where = $this->tableNames['page'] . '.page_namespace = tpl.tl_namespace AND ' .
 					 $this->tableNames['page'] . '.page_title = tpl.tl_title AND tplsrc.page_id = tpl.tl_from AND ';
 			$ors = [];
+
 			foreach ( $option as $linkGroup ) {
 				foreach ( $linkGroup as $link ) {
 					$ors[] = 'tpl.tl_from = ' . intval( $link->getArticleID() );
 				}
 			}
+
 			$where .= '(' . implode( ' OR ', $ors ) . ')';
 		}
+
 		$this->addWhere( $where );
 	}
 
 	/**
 	 * Set SQL for 'uses' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _uses( $option ) {
 		$this->addTable( 'templatelinks', 'tl' );
 		$where = $this->tableNames['page'] . '.page_id=tl.tl_from AND (';
 		$ors = [];
+
 		foreach ( $option as $linkGroup ) {
 			foreach ( $linkGroup as $link ) {
 				$_or = '(tl.tl_namespace=' . intval( $link->getNamespace() );
+
 				if ( $this->parameters->getParameter( 'ignorecase' ) ) {
 					$_or .= " AND LOWER(CAST(tl.tl_title AS char))=LOWER(" . $this->DB->addQuotes( $link->getDbKey() ) . '))';
 				} else {
 					$_or .= " AND tl.tl_title=" . $this->DB->addQuotes( $link->getDbKey() ) . ')';
 				}
+
 				$ors[] = $_or;
 			}
 		}
+
 		$where .= implode( ' OR ', $ors ) . ')';
 		$this->addWhere( $where );
 	}
@@ -2132,17 +2138,17 @@ private function _uses( $option ) {
 	/**
 	 * Set SQL for 'notuses' parameter.
 	 *
-	 * @private
-	 * @param	mixed	Parameter Option
-	 * @return	void
+	 * @param mixed $option
 	 */
 	private function _notuses( $option ) {
 		if ( count( $option ) > 0 ) {
 			$where = $this->tableNames['page'] . '.page_id NOT IN (SELECT ' . $this->tableNames['templatelinks'] . '.tl_from FROM ' . $this->tableNames['templatelinks'] . ' WHERE (';
 			$ors = [];
+
 			foreach ( $option as $linkGroup ) {
 				foreach ( $linkGroup as $link ) {
 					$_or = '(' . $this->tableNames['templatelinks'] . '.tl_namespace=' . intval( $link->getNamespace() );
+
 					if ( $this->parameters->getParameter( 'ignorecase' ) ) {
 						$_or .= ' AND LOWER(CAST(' . $this->tableNames['templatelinks'] . '.tl_title AS char))=LOWER(' . $this->DB->addQuotes( $link->getDbKey() ) . '))';
 					} else {
@@ -2151,8 +2157,10 @@ private function _notuses( $option ) {
 					$ors[] = $_or;
 				}
 			}
+
 			$where .= implode( ' OR ', $ors ) . '))';
 		}
-		$this->addWhere( $where );
+
+		$this->addWhere( $where ?? '' );
 	}
 }
diff --git a/includes/RevisionJoinBuilder.php b/includes/RevisionJoinBuilder.php
new file mode 100644
index 00000000..972b1075
--- /dev/null
+++ b/includes/RevisionJoinBuilder.php
@@ -0,0 +1,123 @@
+<?php
+
+namespace DPL;
+
+use ActorMigration;
+use CommentStore;
+use Wikimedia\Rdbms\IDatabase;
+
+class RevisionJoinBuilder {
+	/** @var IDatabase */
+	private $dbr;
+
+	/** @var ActorMigration */
+	private $actorMigration;
+
+	/** @var CommentStore */
+	private $commentStore;
+
+	/**
+	 * List of fields to select from the first revision of the article, keyed by alias.
+	 * @var string[]
+	 */
+	private $firstRevisionFields = [];
+
+	/**
+	 * List of fields to select from the last revision of the article, keyed by alias.
+	 * @var string[]
+	 */
+	private $lastRevisionFields = [];
+
+	public function __construct(
+		IDatabase $dbr,
+		ActorMigration $actorMigration,
+		CommentStore $commentStore
+	) {
+		$this->dbr = $dbr;
+		$this->actorMigration = $actorMigration;
+		$this->commentStore = $commentStore;
+	}
+
+	public function addFieldsFromFirst( array $fields ): void {
+		$this->firstRevisionFields += $fields;
+	}
+
+	public function addFieldsFromLast( array $fields ): void {
+		$this->lastRevisionFields += $fields;
+	}
+
+	public function getQueryInfo(): array {
+		$queryInfo = [
+			'fields' => [],
+			'tables' => [],
+			'joins' => [],
+		];
+
+		return array_merge_recursive(
+			$queryInfo,
+			$this->addRevisionQueryInfo(
+				'latest_rev',
+				$this->lastRevisionFields,
+				[ 'rev_id=page_latest' ]
+			),
+			$this->addRevisionQueryInfo(
+				'first_rev',
+				$this->firstRevisionFields,
+				[
+					// @phan-suppress-next-line PhanPluginMixedKeyNoKey
+					'rev_page=page_id',
+					'rev_parent_id' => 0,
+				]
+			)
+		);
+	}
+
+	private function addRevisionQueryInfo(
+		string $tableAlias,
+		array $fieldsByAlias,
+		array $joinConds
+	): array {
+		if ( !$fieldsByAlias ) {
+			return [];
+		}
+
+		$fieldsByAlias += [ 'rev_id', 'rev_page', 'rev_parent_id' ];
+
+		$actorQuery = $this->actorMigration->getJoin( 'rev_user' );
+		$commentQuery = $this->commentStore->getJoin( 'rev_comment' );
+
+		// Ensure we correctly fetch aliased fields such as rev_user
+		// from the revision_actor_temp table if it is active.
+		$actorFields = array_keys( $actorQuery['fields'] );
+		$revFields = array_diff( $fieldsByAlias, $actorFields );
+
+		// Since multiple instances of the revision and associated actor tables may be used per
+		// query, join on the derived result of an aliased subquery to avoid naming conflicts.
+		$revQuery = $this->dbr->buildSelectSubquery(
+			[ $tableAlias => 'revision' ] + $actorQuery['tables'] + $commentQuery['tables'],
+			$actorQuery['fields'] + $commentQuery['fields'] + array_values( $revFields ),
+			[],
+			__METHOD__,
+			[],
+			$actorQuery['joins'] + $commentQuery['joins']
+		);
+
+		$fieldsWithPrefix = [];
+		$quotedTableAlias = $this->dbr->addIdentifierQuotes( $tableAlias );
+
+		foreach ( $fieldsByAlias as $alias => $revFieldName ) {
+			$quotedRevField = $this->dbr->addIdentifierQuotes( $revFieldName );
+			$fieldsWithPrefix[$alias] = "$quotedTableAlias.$quotedRevField";
+		}
+
+		return [
+			'fields' => $fieldsWithPrefix,
+			'tables' => [
+				$tableAlias => $revQuery
+			],
+			'joins' => [
+				$tableAlias => [ 'JOIN', $joinConds ]
+			]
+		];
+	}
+}
diff --git a/includes/UpdateArticle.php b/includes/UpdateArticle.php
index 5b0e45b4..812402f0 100644
--- a/includes/UpdateArticle.php
+++ b/includes/UpdateArticle.php
@@ -1,20 +1,20 @@
 <?php
-/**
- * DynamicPageList3
- * DPL UpdateArticle Class
- *
- * @license		GPL-2.0-or-later
- * @package		DynamicPageList3
- *
- */
 
 namespace DPL;
 
+use Article;
+use CommentStoreComment;
+use MediaWiki\MediaWikiServices;
+use MediaWiki\Revision\SlotRecord;
+use ReadOnlyError;
+use RequestContext;
+use Title;
+
 class UpdateArticle {
 	/**
 	 * this fucntion hast three tasks (depending on $exec):
 	 * (1) show an edit dialogue for template fields (exec = edit)
-	 * (2) set template parameters to  values specified in the query (exec=set)v
+	 * (2) set template parameters to values specified in the query (exec=set)v
 	 * (2) preview the source code including any changes of these parameters made in the edit form or with other changes (exec=preview)
 	 * (3) save the article with the changed value set or with other changes (exec=save)
 	 * "other changes" means that a regexp can be applied to the source text or arbitrary text can be
@@ -23,71 +23,75 @@ class UpdateArticle {
 	public static function updateArticleByRule( $title, $text, $rulesText ) {
 		// we use ; as command delimiter; \; stands for a semicolon
 		// \n is translated to a real linefeed
-		$rulesText       = str_replace( ";", '', $rulesText );
-		$rulesText       = str_replace( '\', ';', $rulesText );
-		$rulesText       = str_replace( "\\n", "\n", $rulesText );
-		$rules           = explode( '', $rulesText );
-		$exec            = 'edit';
-		$replaceThis     = '';
-		$replacement     = '';
-		$after           = '';
-		$insertionAfter  = '';
-		$before          = '';
+		$rulesText = str_replace( ";", '', $rulesText );
+		$rulesText = str_replace( '\', ';', $rulesText );
+		$rulesText = str_replace( "\\n", "\n", $rulesText );
+		$rules = explode( '', $rulesText );
+		$exec = 'edit';
+		$replaceThis = '';
+		$replacement = '';
+		$after = '';
+		$insertionAfter = '';
+		$before = '';
 		$insertionBefore = '';
-		$template        = '';
-		$parameter       = [];
-		$value           = [];
-		$afterparm       = [];
-		$format          = [];
-		$preview         = [];
-		$save            = [];
-		$tooltip         = [];
-		$optional        = [];
-
-		$lastCmd         = '';
-		$message         = '';
-		$summary         = '';
-		$editForm        = false;
-		$action          = '';
-		$hidden          = [];
-		$legendPage      = '';
+		$template = '';
+		$parameter = [];
+		$value = [];
+		$afterparm = [];
+		$format = [];
+		$preview = [];
+		$save = [];
+		$tooltip = [];
+		$optional = [];
+
+		$lastCmd = '';
+		$message = '';
+		$summary = '';
+		$editForm = false;
+		$action = '';
+		$hidden = [];
+		$legendPage = '';
 		$instructionPage = '';
-		$table           = '';
-		$fieldFormat     = '';
+		$table = '';
+		$fieldFormat = '';
 
-		// $message .= 'updaterules=<pre><nowiki>';
 		$nr = -1;
 		foreach ( $rules as $rule ) {
 			if ( preg_match( '/^\s*#/', $rule ) > 0 ) {
-				continue; // # is comment symbol
+				continue;
 			}
 
-			$rule = preg_replace( '/^[\s]*/', '', $rule ); // strip leading white space
-			$cmd  = preg_split( "/ +/", $rule, 2 );
+			$rule = preg_replace( '/^[\s]*/', '', $rule );
+			$cmd = preg_split( "/ +/", $rule, 2 );
+
 			if ( count( $cmd ) > 1 ) {
 				$arg = $cmd[1];
 			} else {
 				$arg = '';
 			}
+
 			$cmd[0] = trim( $cmd[0] );
 
-			// after ... insert ...     ,   before ... insert ...
+			// after ... insert ..., before ... insert ...
 			if ( $cmd[0] == 'before' ) {
-				$before  = $arg;
+				$before = $arg;
 				$lastCmd = 'B';
 			}
 			if ( $cmd[0] == 'after' ) {
-				$after   = $arg;
+				$after = $arg;
 				$lastCmd = 'A';
 			}
+
 			if ( $cmd[0] == 'insert' && $lastCmd != '' ) {
 				if ( $lastCmd == 'A' ) {
 					$insertionAfter = $arg;
 				}
+
 				if ( $lastCmd == 'B' ) {
 					$insertionBefore = $arg;
 				}
 			}
+
 			if ( $cmd[0] == 'template' ) {
 				$template = $arg;
 			}
@@ -99,39 +103,49 @@ public static function updateArticleByRule( $title, $text, $rulesText ) {
 					$afterparm[$nr] = [
 						$parameter[$nr - 1]
 					];
-					$n              = $nr - 1;
+
+					$n = $nr - 1;
 					while ( $n > 0 && array_key_exists( $n, $optional ) ) {
 						$n--;
 						$afterparm[$nr][] = $parameter[$n];
 					}
 				}
 			}
+
 			if ( $cmd[0] == 'value' ) {
 				$value[$nr] = $arg;
 			}
+
 			if ( $cmd[0] == 'format' ) {
 				$format[$nr] = $arg;
 			}
+
 			if ( $cmd[0] == 'tooltip' ) {
 				$tooltip[$nr] = $arg;
 			}
+
 			if ( $cmd[0] == 'optional' ) {
 				$optional[$nr] = true;
 			}
+
 			if ( $cmd[0] == 'afterparm' ) {
 				$afterparm[$nr] = [
 					$arg
 				];
 			}
+
 			if ( $cmd[0] == 'legend' ) {
 				$legendPage = $arg;
 			}
+
 			if ( $cmd[0] == 'instruction' ) {
 				$instructionPage = $arg;
 			}
+
 			if ( $cmd[0] == 'table' ) {
 				$table = $arg;
 			}
+
 			if ( $cmd[0] == 'field' ) {
 				$fieldFormat = $arg;
 			}
@@ -139,6 +153,7 @@ public static function updateArticleByRule( $title, $text, $rulesText ) {
 			if ( $cmd[0] == 'replace' ) {
 				$replaceThis = $arg;
 			}
+
 			if ( $cmd[0] == 'by' ) {
 				$replacement = $arg;
 			}
@@ -146,15 +161,19 @@ public static function updateArticleByRule( $title, $text, $rulesText ) {
 			if ( $cmd[0] == 'editform' ) {
 				$editForm = $arg;
 			}
+
 			if ( $cmd[0] == 'action' ) {
 				$action = $arg;
 			}
+
 			if ( $cmd[0] == 'hidden' ) {
 				$hidden[] = $arg;
 			}
+
 			if ( $cmd[0] == 'preview' ) {
 				$preview[] = $arg;
 			}
+
 			if ( $cmd[0] == 'save' ) {
 				$save[] = $arg;
 			}
@@ -162,6 +181,7 @@ public static function updateArticleByRule( $title, $text, $rulesText ) {
 			if ( $cmd[0] == 'summary' ) {
 				$summary = $arg;
 			}
+
 			if ( $cmd[0] == 'exec' ) {
 				$exec = $arg; // desired action (set or edit or preview)
 			}
@@ -172,16 +192,16 @@ public static function updateArticleByRule( $title, $text, $rulesText ) {
 			if ( $replaceThis != '' ) {
 				$summary .= "\n replace $replaceThis\n by $replacement";
 			}
+
 			if ( $before != '' ) {
-				$summary .= "\n before  $before\n insertionBefore";
+				$summary .= "\n before $before\n insertionBefore";
 			}
+
 			if ( $after != '' ) {
-				$summary .= "\n after   $after\n insertionAfter";
+				$summary .= "\n after $after\n insertionAfter";
 			}
 		}
 
-		// $message.= '</nowiki></pre>';
-
 		// perform changes to the wiki source text =======================================
 
 		if ( $replaceThis != '' ) {
@@ -198,86 +218,109 @@ public static function updateArticleByRule( $title, $text, $rulesText ) {
 
 		// deal with template parameters =================================================
 
-		global $wgRequest, $wgUser;
+		global $wgRequest;
 
-		if ( $template != '' ) {
+		$user = RequestContext::getMain()->getUser();
 
+		if ( $template != '' ) {
 			if ( $exec == 'edit' ) {
-				$tpv        = self::getTemplateParmValues( $text, $template );
+				$tpv = self::getTemplateParmValues( $text, $template );
 				$legendText = '';
+
 				if ( $legendPage != '' ) {
 					$legendTitle = '';
-					global $wgParser, $wgUser;
-					$parser = clone $wgParser;
+
+					$parser = clone MediaWikiServices::getInstance()->getParser();
+
 					LST::text( $parser, $legendPage, $legendTitle, $legendText );
 					$legendText = preg_replace( '/^.*?\<section\s+begin\s*=\s*legend\s*\/\>/s', '', $legendText );
 					$legendText = preg_replace( '/\<section\s+end\s*=\s*legend\s*\/\>.*/s', '', $legendText );
 				}
+
 				$instructionText = '';
-				$instructions    = [];
+				$instructions = [];
+
 				if ( $instructionPage != '' ) {
 					$instructionTitle = '';
-					global $wgParser, $wgUser;
-					$parser = clone $wgParser;
+
+					$parser = clone MediaWikiServices::getInstance()->getParser();
+
 					LST::text( $parser, $instructionPage, $instructionTitle, $instructionText );
 					$instructions = self::getTemplateParmValues( $instructionText, 'Template field' );
 				}
+
 				// construct an edit form containing all template invocations
 				$form = "<html><form method=post action=\"$action\" $editForm>\n";
+
 				foreach ( $tpv as $call => $tplValues ) {
 					$form .= "<table $table>\n";
 					foreach ( $parameter as $nr => $parm ) {
 						// try to extract legend from the docs of the template
 						$myToolTip = '';
+
 						if ( array_key_exists( $nr, $tooltip ) ) {
 							$myToolTip = $tooltip[$nr];
 						}
+
 						$myInstruction = '';
-						$myType        = '';
+						$myType = '';
+
 						foreach ( $instructions as $instruct ) {
 							if ( array_key_exists( 'field', $instruct ) && $instruct['field'] == $parm ) {
 								if ( array_key_exists( 'doc', $instruct ) ) {
 									$myInstruction = $instruct['doc'];
 								}
+
 								if ( array_key_exists( 'type', $instruct ) ) {
 									$myType = $instruct['type'];
 								}
 								break;
 							}
 						}
+
 						$myFormat = '';
 						if ( array_key_exists( $nr, $format ) ) {
 							$myFormat = $format[$nr];
 						}
+
 						$myOptional = array_key_exists( $nr, $optional );
 						if ( $legendText != '' && $myToolTip == '' ) {
 							$myToolTip = preg_replace( '/^.*\<section\s+begin\s*=\s*' . preg_quote( $parm, '/' ) . '\s*\/\>/s', '', $legendText );
+
 							if ( strlen( $myToolTip ) == strlen( $legendText ) ) {
 								$myToolTip = '';
 							} else {
 								$myToolTip = preg_replace( '/\<section\s+end\s*=\s*' . preg_quote( $parm, '/' ) . '\s*\/\>.*/s', '', $myToolTip );
 							}
 						}
+
 						$myValue = '';
 						if ( array_key_exists( $parm, $tpv[$call] ) ) {
 							$myValue = $tpv[$call][$parm];
 						}
+
 						$form .= self::editTemplateCall( $text, $template, $call, $parm, $myType, $myValue, $myFormat, $myToolTip, $myInstruction, $myOptional, $fieldFormat );
 					}
+
 					$form .= "</table>\n<br/><br/>";
 				}
+
 				foreach ( $hidden as $hide ) {
 					$form .= "<input type='hidden' " . $hide . " />";
 				}
-				$form .= "<input type='hidden' name='wpEditToken' value='{$wgUser->getEditToken()}'/>";
+
+				$form .= "<input type='hidden' name='wpEditToken' value='{$user->getEditToken()}'/>";
 				foreach ( $preview as $prev ) {
 					$form .= "<input type='submit' " . $prev . " /> ";
 				}
+
 				$form .= "</form></html>\n";
+
 				return $form;
 			} elseif ( $exec == 'set' || $exec == 'preview' ) {
 				// loop over all invocations and parameters, this could be improved to enhance performance
 				$matchCount = 10;
+
 				for ( $call = 0; $call < 10; $call++ ) {
 					foreach ( $parameter as $nr => $parm ) {
 						// set parameters to values specified in the dpl source or get them from the http request
@@ -289,33 +332,41 @@ public static function updateArticleByRule( $title, $text, $rulesText ) {
 							}
 							$myValue = $wgRequest->getVal( urlencode( $call . '_' . $parm ), '' );
 						}
-						$myOptional  = array_key_exists( $nr, $optional );
+
+						$myOptional = array_key_exists( $nr, $optional );
 						$myAfterParm = [];
+
 						if ( array_key_exists( $nr, $afterparm ) ) {
 							$myAfterParm = $afterparm[$nr];
 						}
-						$text = self::updateTemplateCall( $matchCount, $text, $template, $call, $parm, $myValue, $myAfterParm, $myOptional );
+
+						$text = self::updateTemplateCall( $matchCount, $text, $template, $call, $parm, $myValue ?? '', $myAfterParm, $myOptional );
 					}
+
 					if ( $exec == 'set' ) {
-						break; // values taken from dpl text only populate the first invocation
+						break;
 					}
 				}
 			}
 		}
 
 		if ( $exec == 'set' ) {
-			return self::updateArticle( $title, $text, $summary );
+			return self::doUpdateArticle( $title, $text, $summary );
 		} elseif ( $exec == 'preview' ) {
 			global $wgScriptPath, $wgRequest;
-			$titleX   = \Title::newFromText( $title );
-			$articleX = new \Article( $titleX );
-			$form     = '<html>
+
+			$titleX = Title::newFromText( $title );
+			$articleX = new Article( $titleX );
+
+			$userOptionsLookup = MediaWikiServices::getInstance()->getUserOptionsLookup();
+
+			$form = '<html>
 	<form id="editform" name="editform" method="post" action="' . $wgScriptPath . '/index.php?title=' . urlencode( $title ) . '&action=submit" enctype="multipart/form-data">
 		<input type="hidden" value="" name="wpSection" />
 		<input type="hidden" value="' . wfTimestampNow() . '" name="wpStarttime" />
-		<input type="hidden" value="' . $articleX->getTimestamp() . '" name="wpEdittime" />
+		<input type="hidden" value="' . $articleX->getPage()->getTimestamp() . '" name="wpEdittime" />
 		<input type="hidden" value="" name="wpScrolltop" id="wpScrolltop" />
-		<textarea tabindex="1" accesskey="," name="wpTextbox1" id="wpTextbox1" rows="' . $wgUser->getIntOption( 'rows' ) . '" cols="' . $wgUser->getIntOption( 'cols' ) . '" >' . htmlspecialchars( $text ) . '</textarea>
+		<textarea tabindex="1" accesskey="," name="wpTextbox1" id="wpTextbox1" rows="' . $userOptionsLookup->getIntOption( $user, 'rows' ) . '" cols="' . $userOptionsLookup->getIntOption( $user, 'cols' ) . '" >' . htmlspecialchars( $text ) . '</textarea>
 		<input type="hidden" name="wpSummary value="' . $summary . '" id="wpSummary" />
 		<input name="wpAutoSummary" type="hidden" value="" />
 		<input id="wpSave" name="wpSave" type="submit" value="Save page" accesskey="s" title="Save your changes [s]" />
@@ -324,27 +375,44 @@ public static function updateArticleByRule( $title, $text, $rulesText ) {
 </html>';
 			return $form;
 		}
+
 		return "exec must be one of the following: edit, preview, set";
 	}
 
-	private static function updateArticle( $title, $text, $summary ) {
-		global $wgUser, $wgRequest, $wgOut;
+	private static function doUpdateArticle( $title, $text, $summary ) {
+		global $wgRequest, $wgOut;
+
+		$user = RequestContext::getMain()->getUser();
 
-		if ( !$wgUser->matchEditToken( $wgRequest->getVal( 'wpEditToken' ) ) ) {
+		if ( !$user->matchEditToken( $wgRequest->getVal( 'wpEditToken' ) ) ) {
 			$wgOut->addWikiMsg( 'sessionfailure' );
+
 			return 'session failure';
 		}
 
-		$titleX = \Title::newFromText( $title );
-		$permission_errors = $titleX->getUserPermissionsErrors( 'edit', $wgUser );
+		$titleX = Title::newFromText( $title );
+		$permission_errors = MediaWikiServices::getInstance()->getPermissionManager()->getPermissionErrors( 'edit', $user, $titleX );
+
 		if ( count( $permission_errors ) == 0 ) {
-			$articleX = \WikiPage::factory( $titleX );
-			$articleXContent = \ContentHandler::makeContent( $text, $titleX );
-			$articleX->doEditContent( $articleXContent, $summary, EDIT_UPDATE | EDIT_DEFER_UPDATES | EDIT_AUTOSUMMARY );
-			$wgOut->redirect( $titleX->getFullUrl( $articleX->isRedirect() ? 'redirect=no' : '' ) );
+			$wikiPageFactory = MediaWikiServices::getInstance()->getWikiPageFactory();
+
+			$page = $wikiPageFactory->newFromTitle( $titleX );
+			$updater = $page->newPageUpdater( $user );
+			$content = $page->getContentHandler()->makeContent( $text, $titleX );
+			$updater->setContent( SlotRecord::MAIN, $content );
+			$comment = CommentStoreComment::newUnsavedComment( $summary );
+
+			$updater->saveRevision(
+				$comment,
+				EDIT_UPDATE | EDIT_DEFER_UPDATES | EDIT_AUTOSUMMARY
+			);
+
+			$wgOut->redirect( $titleX->getFullUrl( $page->isRedirect() ? 'redirect=no' : '' ) );
+
 			return '';
 		} else {
 			$wgOut->showPermissionsErrorPage( $permission_errors );
+
 			return 'permission error';
 		}
 	}
@@ -352,19 +420,24 @@ private static function updateArticle( $title, $text, $summary ) {
 	private static function editTemplateCall( $text, $template, $call, $parameter, $type, $value, $format, $legend, $instruction, $optional, $fieldFormat ) {
 		$matches = [];
 		$nlCount = preg_match_all( '/\n/', $value, $matches );
+
 		if ( $nlCount > 0 ) {
 			$rows = $nlCount + 1;
 		} else {
 			$rows = floor( strlen( $value ) / 50 ) + 1;
 		}
+
 		if ( preg_match( '/rows\s*=/', $format ) <= 0 ) {
 			$format .= " rows=$rows";
 		}
+
 		$cols = 50;
 		if ( preg_match( '/cols\s*=/', $format ) <= 0 ) {
 			$format .= " cols=$cols";
 		}
+
 		$textArea = "<textarea name=\"" . urlencode( $call . '_' . $parameter ) . "\" $format/>" . htmlspecialchars( $value ) . "</textarea>";
+
 		return str_replace( '%NAME%', htmlspecialchars( str_replace( '_', ' ', $parameter ) ), str_replace( '%TYPE%', $type, str_replace( '%INPUT%', $textArea, str_replace( '%LEGEND%', "</html>" . htmlspecialchars( $legend ) . "<html>", str_replace( '%INSTRUCTION%', "</html>" . htmlspecialchars( $instruction ) . "<html>", $fieldFormat ) ) ) ) );
 	}
 
@@ -372,39 +445,44 @@ private static function editTemplateCall( $text, $template, $call, $parameter, $
 	 * return an array of template invocations; each element is an associative array of parameter and value
 	 */
 	private static function getTemplateParmValues( $text, $template ) {
-		$matches   = [];
+		$matches = [];
 		$noMatches = preg_match_all( '/\{\{\s*' . preg_quote( $template, '/' ) . '\s*[|}]/i', $text, $matches, PREG_OFFSET_CAPTURE );
+
 		if ( $noMatches <= 0 ) {
 			return '';
 		}
+
 		$textLen = strlen( $text );
-		$tval    = []; // the result array of template values
-		$call    = -1; // index for tval
+		$tval = [];
+		$call = -1;
 
 		foreach ( $matches as $matchA ) {
 			foreach ( $matchA as $matchB ) {
-				$match         = $matchB[0];
-				$start         = $matchB[1];
+				$match = $matchB[0];
+				$start = $matchB[1];
 				$tval[++$call] = [];
-				$nr            = 0; // number of parameter if no name given
-				$parmValue     = '';
-				$parmName      = '';
-				$parm          = '';
+				$nr = 0;
+				$parmValue = '';
+				$parmName = '';
+				$parm = '';
 
 				if ( $match[strlen( $match ) - 1] == '}' ) {
-					break; // template was called without parameters, continue with next invocation
+					break;
 				}
 
 				// search to the end of the template call
 				$cbrackets = 2;
+
 				for ( $i = $start + strlen( $match ); $i < $textLen; $i++ ) {
 					$c = $text[$i];
 					if ( $c == '{' || $c == '[' ) {
-						$cbrackets++; // we count both types of brackets
+						$cbrackets++;
 					}
+
 					if ( $c == '}' || $c == ']' ) {
 						$cbrackets--;
 					}
+
 					if ( ( $cbrackets == 2 && $c == '|' ) || ( $cbrackets == 1 && $c == '}' ) ) {
 						// parameter (name or value) found
 						if ( $parmName == '' ) {
@@ -412,9 +490,11 @@ private static function getTemplateParmValues( $text, $template ) {
 						} else {
 							$tval[$call][$parmName] = trim( $parmValue );
 						}
-						$parmName  = '';
+
+						$parmName = '';
 						$parmValue = '';
-						$parm      = '';
+						$parm = '';
+
 						continue;
 					} else {
 						if ( $parmName == '' ) {
@@ -425,13 +505,15 @@ private static function getTemplateParmValues( $text, $template ) {
 							$parmValue .= $c;
 						}
 					}
+
 					$parm .= $c;
 					if ( $cbrackets == 0 ) {
-						break; // end of parameter list
+						break;
 					}
 				}
 			}
 		}
+
 		return $tval;
 	}
 
@@ -444,46 +526,54 @@ private static function updateTemplateCall( &$matchCount, $text, $template, $cal
 			return $text;
 		}
 
-		$matches   = [];
+		$matches = [];
 		$noMatches = preg_match_all( '/\{\{\s*' . preg_quote( $template, '/' ) . '\s*[|}]/i', $text, $matches, PREG_OFFSET_CAPTURE );
+
 		if ( $noMatches <= 0 ) {
 			return $text;
 		}
-		$beginSubst  = -1;
-		$endSubst    = -1;
+
+		$beginSubst = -1;
+		$endSubst = -1;
 		$posInsertAt = 0;
-		$apNrLast    = 1000; // last (optional) predecessor
+		$apNrLast = 1000;
 
 		foreach ( $matches as $matchA ) {
 			$matchCount = count( $matchA );
+
 			foreach ( $matchA as $occurence => $matchB ) {
 				if ( $occurence < $call ) {
 					continue;
 				}
+
 				$match = $matchB[0];
 				$start = $matchB[1];
 
 				if ( $match[strlen( $match ) - 1] == '}' ) {
 					// template was called without parameters, add new parameter and value
 					// append parameter and value
-					$beginSubst   = $i;
-					$endSubst     = $i;
+					$beginSubst = 0;
+					$endSubst = 0;
 					$substitution = "|$parameter = $value";
 					break;
 				} else {
 					// there is already a list of parameters; we search to the end of the template call
 					$cbrackets = 2;
-					$parm      = '';
-					$pos       = $start + strlen( $match ) - 1;
-					$textLen   = strlen( $text );
+					$parm = '';
+					$pos = $start + strlen( $match ) - 1;
+					$textLen = strlen( $text );
+
 					for ( $i = $pos + 1; $i < $textLen; $i++ ) {
 						$c = $text[$i];
+
 						if ( $c == '{' || $c == '[' ) {
 							$cbrackets++; // we count both types of brackets
 						}
+
 						if ( $c == '}' || $c == ']' ) {
 							$cbrackets--;
 						}
+
 						if ( ( $cbrackets == 2 && $c == '|' ) || ( $cbrackets == 1 && $c == '}' ) ) {
 							// parameter (name / value) found
 
@@ -491,12 +581,15 @@ private static function updateTemplateCall( &$matchCount, $text, $template, $cal
 							if ( count( $token ) == 2 ) {
 								// we need a pair of name / value
 								$parmName = trim( $token[0] );
+
 								if ( $parmName == $parameter ) {
 									// we found the parameter, now replace the current value
 									$parmValue = trim( $token[1] );
+
 									if ( $parmValue == $value ) {
 										break; // no need to change when values are identical
 									}
+
 									// keep spaces;
 									if ( $parmValue == '' ) {
 										if ( strlen( $token[1] ) > 0 && $token[1][strlen( $token[1] ) - 1] == "\n" ) {
@@ -507,15 +600,16 @@ private static function updateTemplateCall( &$matchCount, $text, $template, $cal
 									} else {
 										$substitution = str_replace( $parmValue, $value, $token[1] );
 									}
+
 									$beginSubst = $pos + strlen( $token[0] ) + 2;
-									$endSubst   = $i;
+									$endSubst = $i;
 									break;
 								} else {
 									foreach ( $afterParm as $apNr => $ap ) {
 										// store position for insertion
 										if ( $parmName == $ap && $apNr < $apNrLast ) {
 											$posInsertAt = $i;
-											$apNrLast    = $apNr;
+											$apNrLast = $apNr;
 											break;
 										}
 									}
@@ -529,20 +623,23 @@ private static function updateTemplateCall( &$matchCount, $text, $template, $cal
 								} else {
 									$beginSubst = $i;
 								}
+
 								$substitution = "|$parameter = $value";
 								if ( $text[$beginSubst - 1] == "\n" ) {
 									--$beginSubst;
 									$substitution = "\n" . $substitution;
 								}
+
 								$endSubst = $beginSubst;
 								break;
 							}
 
-							$pos  = $i;
+							$pos = $i;
 							$parm = '';
 						} else {
 							$parm .= $c;
 						}
+
 						if ( $cbrackets == 0 ) {
 							break;
 						}
@@ -557,11 +654,11 @@ private static function updateTemplateCall( &$matchCount, $text, $template, $cal
 			return $text;
 		}
 
-		return substr( $text, 0, $beginSubst ) . $substitution . substr( $text, $endSubst );
+		return substr( $text, 0, $beginSubst ) . ( $substitution ?? '' ) . substr( $text, $endSubst );
 	}
 
-	public function deleteArticleByRule( $title, $text, $rulesText ) {
-		global $wgUser, $wgOut;
+	public static function deleteArticleByRule( $title, $text, $rulesText ) {
+		global $wgOut;
 
 		// return "deletion of articles by DPL is disabled.";
 
@@ -570,23 +667,25 @@ public function deleteArticleByRule( $title, $text, $rulesText ) {
 		$rulesText = str_replace( ";", '', $rulesText );
 		$rulesText = str_replace( '\', ';', $rulesText );
 		$rulesText = str_replace( "\\n", "\n", $rulesText );
-		$rules     = explode( '', $rulesText );
-		$exec      = false;
-		$message   = '';
-		$reason    = '';
+		$rules = explode( '', $rulesText );
+		$exec = false;
+		$message = '';
+		$reason = '';
 
 		foreach ( $rules as $rule ) {
 			if ( preg_match( '/^\s*#/', $rule ) > 0 ) {
 				continue; // # is comment symbol
 			}
 
-			$rule = preg_replace( '/^[\s]*/', '', $rule ); // strip leading white space
-			$cmd  = preg_split( "/ +/", $rule, 2 );
+			$rule = preg_replace( '/^[\s]*/', '', $rule );
+			$cmd = preg_split( "/ +/", $rule, 2 );
+
 			if ( count( $cmd ) > 1 ) {
 				$arg = $cmd[1];
 			} else {
 				$arg = '';
 			}
+
 			$cmd[0] = trim( $cmd[0] );
 
 			if ( $cmd[0] == 'reason' ) {
@@ -598,26 +697,33 @@ public function deleteArticleByRule( $title, $text, $rulesText ) {
 				$exec = true;
 			}
 		}
+
 		$reason .= "\nbulk delete by DPL query";
 
-		$titleX = \Title::newFromText( $title );
+		$titleX = Title::newFromText( $title );
+
 		if ( $exec ) {
+			$user = RequestContext::getMain()->getUser();
+
 			# Check permissions
-			$permission_errors = $titleX->getUserPermissionsErrors( 'delete', $wgUser );
+			$permission_errors = MediaWikiServices::getInstance()->getPermissionManager()->getPermissionErrors( 'delete', $user, $titleX );
+			$isReadOnly = MediaWikiServices::getInstance()->getReadOnlyMode()->isReadOnly();
+
 			if ( count( $permission_errors ) > 0 ) {
 				$wgOut->showPermissionsErrorPage( $permission_errors );
 				return 'permission error';
-			} elseif ( wfReadOnly() ) {
-				$wgOut->readOnlyPage();
-				return 'DPL: read only mode';
+			} elseif ( $isReadOnly ) {
+				throw new ReadOnlyError;
 			} else {
-				$articleX = new \Article( $titleX );
+				$articleX = new Article( $titleX );
 				$articleX->doDelete( $reason );
 			}
 		} else {
 			$message .= "set 'exec yes' to delete &#160; &#160; <big>'''$title'''</big>\n";
 		}
-		$message .= "<pre><nowiki>\n{$text}</nowiki></pre>"; // <pre><nowiki>\n"; // .$text."\n</nowiki></pre>\n";
+
+		$message .= "<pre><nowiki>\n{$text}</nowiki></pre>"; // <pre><nowiki>\n";
+
 		return $message;
 	}
 }
diff --git a/includes/UserQueryBuilder.php b/includes/UserQueryBuilder.php
new file mode 100644
index 00000000..b0e19c78
--- /dev/null
+++ b/includes/UserQueryBuilder.php
@@ -0,0 +1,161 @@
+<?php
+
+namespace DPL;
+
+use ActorMigration;
+use MediaWiki\MediaWikiServices;
+use MediaWiki\User\UserFactory;
+use MediaWiki\User\UserIdentity;
+use Wikimedia\Rdbms\IDatabase;
+
+class UserQueryBuilder {
+	/** @var IDatabase */
+	private $dbr;
+
+	/** @var ActorMigration */
+	private $actorMigration;
+
+	/** @var UserIdentity|array */
+	private $modifiedByConstraints = [];
+
+	/** @var UserIdentity|array */
+	private $notModifiedByConstraints = [];
+
+	/** @var UserIdentity|array */
+	private $notCreatedByConstraints = [];
+
+	/** @var UserIdentity|array */
+	private $notLastModifiedByConstraints = [];
+
+	/** @var UserIdentity|null */
+	private $createdByConstraint;
+
+	/** @var UserIdentity|null */
+	private $lastModifiedByConstraint;
+
+	public function __construct( IDatabase $dbr, ActorMigration $actorMigration ) {
+		$this->dbr = $dbr;
+		$this->actorMigration = $actorMigration;
+	}
+
+	public function addModifiedByConstraint( string $userName ): void {
+		$this->modifiedByConstraints[] = $this->getUserForQuery( $userName );
+	}
+
+	public function addNotModifiedByConstraint( string $userName ): void {
+		$this->notModifiedByConstraints[] = $this->getUserForQuery( $userName );
+	}
+
+	public function addCreatedByConstraint( string $userName ): void {
+		$this->createdByConstraint = $this->getUserForQuery( $userName );
+	}
+
+	public function addNotCreatedByConstraint( string $userName ): void {
+		$this->notCreatedByConstraints[] = $this->getUserForQuery( $userName );
+	}
+
+	public function addLastModifiedByConstraint( string $userName ): void {
+		$this->lastModifiedByConstraint = $this->getUserForQuery( $userName );
+	}
+
+	public function addNotLastModifiedByConstraint( string $userName ): void {
+		$this->notLastModifiedByConstraints[] = $this->getUserForQuery( $userName );
+	}
+
+	/**
+	 * Combine the constraints into a single condition suitable for inclusion in a WHERE clause.
+	 * @return string
+	 */
+	public function getWhere(): string {
+		$conds = [];
+
+		$modifiedByQuery = $this->getSubqueryForConstraint( $this->modifiedByConstraints );
+		if ( $modifiedByQuery ) {
+			$conds[] = "page_id IN $modifiedByQuery";
+		}
+
+		$notModifiedByQuery = $this->getSubqueryForConstraint( $this->notModifiedByConstraints );
+		if ( $notModifiedByQuery ) {
+			$conds[] = "NOT EXISTS $notModifiedByQuery";
+		}
+
+		$lastModifiedByQuery = $this->getSubqueryForConstraint(
+			[ $this->lastModifiedByConstraint ],
+			$this->notLastModifiedByConstraints,
+			'rev_id'
+		);
+		if ( $lastModifiedByQuery ) {
+			$conds[] = "page_latest IN $lastModifiedByQuery";
+		}
+
+		$createdByQuery = $this->getSubqueryForConstraint(
+			[ $this->createdByConstraint ],
+			$this->notCreatedByConstraints,
+			'rev_page',
+			[ 'rev_parent_id' => 0 ]
+		);
+		if ( $createdByQuery ) {
+			$conds[] = "page_id IN $createdByQuery";
+		}
+
+		return $this->dbr->makeList( $conds, IDatabase::LIST_AND );
+	}
+
+	private function getUserForQuery( string $userName ): ?UserIdentity {
+		$userFactory = MediaWikiServices::getInstance()->getUserFactory();
+
+		return $userFactory->newFromName( $userName, UserFactory::RIGOR_NONE ) ?: null;
+	}
+
+	/**
+	 * Construct a subquery for filtering revisions based on given user-specific criteria.
+	 * @param UserIdentity[] $constraints -users to include in the result set
+	 * @param UserIdentity[] $notConstraints - users to exclude from the result set
+	 * @param string $selectField - field name to select from the revision table
+	 * @param array $conds - additional query conditions
+	 * @return string|null - the subquery, or null if no constraints were given
+	 */
+	private function getSubqueryForConstraint(
+		array $constraints,
+		array $notConstraints = [],
+		string $selectField = 'rev_page',
+		array $conds = []
+	): ?string {
+		$constraints = array_filter( $constraints );
+		$notConstraints = array_filter( $notConstraints );
+		if ( !$constraints && !$notConstraints ) {
+			return null;
+		}
+
+		$constraintActorQuery = $this->actorMigration->getWhere(
+			$this->dbr,
+			'rev_user',
+			$constraints
+		);
+
+		$notConstraintActorQuery = $this->actorMigration->getWhere(
+			$this->dbr,
+			'rev_user',
+			$notConstraints
+		);
+
+		if ( $constraints ) {
+			$conds[] = $constraintActorQuery['conds'];
+		}
+
+		if ( $notConstraints ) {
+			$conds[] = "NOT ({$notConstraintActorQuery['conds']})";
+		}
+
+		$conds[] = 'rev_page=page_id';
+
+		return (string)$this->dbr->buildSelectSubquery(
+			[ 'revision' ] + $constraintActorQuery['tables'] + $notConstraintActorQuery['tables'],
+			[ $selectField ],
+			$conds,
+			__METHOD__,
+			[],
+			(array)$constraintActorQuery['joins'] + (array)$notConstraintActorQuery['joins']
+		);
+	}
+}
diff --git a/includes/Variables.php b/includes/Variables.php
index f20375ea..1b0ab7ff 100644
--- a/includes/Variables.php
+++ b/includes/Variables.php
@@ -1,13 +1,5 @@
 <?php
-/**
- * DynamicPageList3
- * DPL Variables Class
- *
- * @author		IlyaHaykinson, Unendlich, Dangerville, Algorithmix, Theaitetos, Alexia E. Smith
- * @license		GPL-2.0-or-later
- * @package		DynamicPageList3
- *
- */
+
 namespace DPL;
 
 class Variables {
@@ -29,33 +21,41 @@ class Variables {
 	// if the first parameter is empty it will be ignored {{#vardefine:|a|b}} is the same as {{#vardefine:a|b}}
 	public static function setVar( $arg ) {
 		$numargs = count( $arg );
+
 		if ( $numargs >= 3 && $arg[2] == '' ) {
 			$start = 3;
 		} else {
 			$start = 2;
 		}
+
 		for ( $i = $start; $i < $numargs; $i++ ) {
 			$var = $arg[$i];
+
 			if ( ++$i <= $numargs - 1 ) {
 				self::$memoryVar[$var] = $arg[$i];
 			} else {
 				self::$memoryVar[$var] = '';
 			}
 		}
+
 		return '';
 	}
 
 	public static function setVarDefault( $arg ) {
 		$numargs = count( $arg );
+
 		if ( $numargs > 3 ) {
 			$value = $arg[3];
 		} else {
 			return '';
 		}
+
 		$var = $arg[2];
+
 		if ( !array_key_exists( $var, self::$memoryVar ) || self::$memoryVar[$var] == '' ) {
 			self::$memoryVar[$var] = $value;
 		}
+
 		return '';
 	}
 
@@ -63,74 +63,95 @@ public static function getVar( $var ) {
 		if ( array_key_exists( $var, self::$memoryVar ) ) {
 			return self::$memoryVar[$var];
 		}
+
 		return '';
 	}
 
 	public static function setArray( $arg ) {
 		$numargs = count( $arg );
+
 		if ( $numargs < 5 ) {
 			return '';
 		}
-		$var       = trim( $arg[2] );
-		$value     = $arg[3];
+
+		$var = trim( $arg[2] );
+		$value = $arg[3];
 		$delimiter = $arg[4];
+
 		if ( $var == '' ) {
 			return '';
 		}
+
 		if ( $value == '' ) {
 			self::$memoryArray[$var] = [];
 			return;
 		}
+
 		if ( $delimiter == '' ) {
 			self::$memoryArray[$var] = [
 				$value
 			];
+
 			return;
 		}
-		if ( 0 !== strpos( $delimiter, '/' ) || ( strlen( $delimiter ) - 1 ) !== strrpos( $delimiter, '/' ) ) {
+
+		if ( strpos( $delimiter, '/' ) !== 0 || ( strlen( $delimiter ) - 1 ) !== strrpos( $delimiter, '/' ) ) {
 			$delimiter = '/\s*' . $delimiter . '\s*/';
 		}
+
 		self::$memoryArray[$var] = preg_split( $delimiter, $value );
+
 		return "value={$value}, delimiter={$delimiter}," . count( self::$memoryArray[$var] );
 	}
 
 	public static function dumpArray( $arg ) {
 		$numargs = count( $arg );
+
 		if ( $numargs < 3 ) {
 			return '';
 		}
-		$var  = trim( $arg[2] );
+
+		$var = trim( $arg[2] );
 		$text = " array {$var} = {";
-		$n    = 0;
+		$n = 0;
+
 		if ( array_key_exists( $var, self::$memoryArray ) ) {
 			foreach ( self::$memoryArray[$var] as $value ) {
 				if ( $n++ > 0 ) {
 					$text .= ', ';
 				}
+
 				$text .= "{$value}";
 			}
 		}
+
 		return $text . "}\n";
 	}
 
 	public static function printArray( $var, $delimiter, $search, $subject ) {
 		$var = trim( $var );
+
 		if ( $var == '' ) {
 			return '';
 		}
+
 		if ( !array_key_exists( $var, self::$memoryArray ) ) {
 			return '';
 		}
-		$values          = self::$memoryArray[$var];
+
+		$values = self::$memoryArray[$var];
 		$rendered_values = [];
+
 		foreach ( $values as $v ) {
 			$temp_result_value = str_replace( $search, $v, $subject );
 			$rendered_values[] = $temp_result_value;
 		}
+
 		return [
+			// @phan-suppress-next-line PhanPluginMixedKeyNoKey
 			implode( $delimiter, $rendered_values ),
-			'noparse'	=> false,
-			'isHTML'	=> false
+			'noparse' => false,
+			'isHTML' => false
 		];
 	}
 }
diff --git a/includes/heading/DefinitionHeading.php b/includes/heading/DefinitionHeading.php
index 167fa6de..a10b8cd4 100644
--- a/includes/heading/DefinitionHeading.php
+++ b/includes/heading/DefinitionHeading.php
@@ -1,12 +1,4 @@
 <?php
-/**
- * DynamicPageList3
- * DPL DefinitionHeading Class
- *
- * @license		GPL-2.0-or-later
- * @package		DynamicPageList3
- *
- */
 
 namespace DPL\Heading;
 
@@ -74,21 +66,22 @@ class DefinitionHeading extends Heading {
 	/**
 	 * Format a heading group.
 	 *
-	 * @access	public
-	 * @param	integer	Article start index for this heading.
-	 * @param	integer	Article count for this heading.
-	 * @param	string	Heading link/text display.
-	 * @param	array	List of \DPL\Article.
-	 * @param	object	List of \DPL\Lister\Lister
-	 * @return	string	Heading HTML
+	 * @param int $headingStart
+	 * @param int $headingCount
+	 * @param string $headingLink
+	 * @param array $articles
+	 * @param Lister $lister
+	 * @return string
 	 */
 	public function formatItem( $headingStart, $headingCount, $headingLink, $articles, Lister $lister ) {
 		$item = '';
 
 		$item .= $this->headListStart . $headingLink;
+
 		if ( $this->showHeadingCount ) {
 			$item .= $this->articleCountMessage( $headingCount );
 		}
+
 		$item .= $this->headListEnd;
 		$item .= $this->getItemStart() . $lister->formatList( $articles, $headingStart, $headingCount ) . $this->getItemEnd();
 
diff --git a/includes/heading/Heading.php b/includes/heading/Heading.php
index 8ece3015..512a4dfd 100644
--- a/includes/heading/Heading.php
+++ b/includes/heading/Heading.php
@@ -1,29 +1,23 @@
 <?php
-/**
- * DynamicPageList3
- * DPL List Class
- *
- * @license		GPL-2.0-or-later
- * @package		DynamicPageList3
- *
- */
+
 namespace DPL\Heading;
 
 use DPL\Article;
 use DPL\Lister\Lister;
 use DPL\Parameters;
+use Sanitizer;
 
 class Heading {
 	/**
 	 * Listing style for this class.
 	 *
-	 * @var constant
+	 * @var int|null
 	 */
 	public $style = null;
 
 	/**
 	 * List(Section) Start
-	 * Use %s for attribute placement.  Example: <div%s>
+	 * Use %s for attribute placement. Example: <div%s>
 	 *
 	 * @var string
 	 */
@@ -38,7 +32,7 @@ class Heading {
 
 	/**
 	 * Item Start
-	 * Use %s for attribute placement.  Example: <div%s>
+	 * Use %s for attribute placement. Example: <div%s>
 	 *
 	 * @var string
 	 */
@@ -54,14 +48,14 @@ class Heading {
 	/**
 	 * Extra list HTML attributes.
 	 *
-	 * @var array
+	 * @var string
 	 */
 	public $listAttributes = '';
 
 	/**
 	 * Extra item HTML attributes.
 	 *
-	 * @var array
+	 * @var string
 	 */
 	public $itemAttributes = '';
 
@@ -73,18 +67,14 @@ class Heading {
 	protected $showHeadingCount = false;
 
 	/**
-	 * \DPL\Parameters
+	 * Parameters
 	 *
-	 * @var object
+	 * @var Parameters
 	 */
-	protected $parameters = null;
+	protected $parameters;
 
 	/**
-	 * Main Constructor
-	 *
-	 * @access	public
-	 * @param	object	\DPL\Parameters
-	 * @return	void
+	 * @param Parameters $parameters
 	 */
 	public function __construct( Parameters $parameters ) {
 		$this->setListAttributes( $parameters->getParameter( 'hlistattr' ) );
@@ -96,17 +86,16 @@ public function __construct( Parameters $parameters ) {
 	/**
 	 * Get a new List subclass based on user selection.
 	 *
-	 * @access	public
-	 * @param	string	Heading style.
-	 * @param	object	\DPL\Parameters
-	 * @param	object	MediaWiki \Parser
-	 * @return	mixed	Heading subclass or null for a bad style.
+	 * @param string $style
+	 * @param Parameters $parameters
+	 * @return mixed
 	 */
-	public static function newFromStyle( $style, \DPL\Parameters $parameters ) {
+	public static function newFromStyle( $style, Parameters $parameters ) {
 		$style = strtolower( $style );
+
 		switch ( $style ) {
 			case 'definition':
-				$class = 'DefinitionHeading';
+				$class = DefinitionHeading::class;
 				break;
 			case 'h1':
 			case 'h2':
@@ -115,28 +104,25 @@ public static function newFromStyle( $style, \DPL\Parameters $parameters ) {
 			case 'h5':
 			case 'h6':
 			case 'header':
-				$class = 'TieredHeading';
+				$class = TieredHeading::class;
 				break;
 			case 'ordered':
-				$class = 'OrderedHeading';
+				$class = OrderedHeading::class;
 				break;
 			case 'unordered':
-				$class = 'UnorderedHeading';
+				$class = UnorderedHeading::class;
 				break;
 			default:
 				return null;
-				break;
 		}
-		$class = '\DPL\Heading\\' . $class;
 
 		return new $class( $parameters );
 	}
 
 	/**
-	 * Get the \DPL\Parameters object this object was constructed with.
+	 * Get the Parameters object this object was constructed with.
 	 *
-	 * @access	public
-	 * @return	object	\DPL\Parameters
+	 * @return Parameters
 	 */
 	public function getParameters() {
 		return $this->parameters;
@@ -145,31 +131,25 @@ public function getParameters() {
 	/**
 	 * Set extra list attributes.
 	 *
-	 * @access	public
-	 * @param	string	Tag soup attributes, example: this="that" thing="no"
-	 * @return	void
+	 * @param string $attributes
 	 */
 	public function setListAttributes( $attributes ) {
-		$this->listAttributes = \Sanitizer::fixTagAttributes( $attributes, 'ul' );
+		$this->listAttributes = Sanitizer::fixTagAttributes( $attributes, 'ul' );
 	}
 
 	/**
 	 * Set extra item attributes.
 	 *
-	 * @access	public
-	 * @param	string	Tag soup attributes, example: this="that" thing="no"
-	 * @return	void
+	 * @param string $attributes
 	 */
 	public function setItemAttributes( $attributes ) {
-		$this->itemAttributes = \Sanitizer::fixTagAttributes( $attributes, 'li' );
+		$this->itemAttributes = Sanitizer::fixTagAttributes( $attributes, 'li' );
 	}
 
 	/**
 	 * Set if the article count per heading should be shown.
 	 *
-	 * @access	public
-	 * @param	boolean	[Optional] Show Heading Count
-	 * @return	void
+	 * @param bool $show
 	 */
 	public function setShowHeadingCount( $show = false ) {
 		$this->showHeadingCount = boolval( $show );
@@ -178,8 +158,7 @@ public function setShowHeadingCount( $show = false ) {
 	/**
 	 * Return the list style.
 	 *
-	 * @access	public
-	 * @return	integer	List style constant.
+	 * @return int
 	 */
 	public function getStyle() {
 		return $this->style;
@@ -188,10 +167,9 @@ public function getStyle() {
 	/**
 	 * Format a list of articles into all lists with headings as needed.
 	 *
-	 * @access	public
-	 * @param	array	List of \DPL\Article
-	 * @param	object	List of \DPL\Lister\Lister
-	 * @return	string	Formatted list.
+	 * @param array $articles
+	 * @param Lister $lister
+	 * @return string
 	 */
 	public function format( $articles, Lister $lister ) {
 		$columns = $this->getParameters()->getParameter( 'columns' );
@@ -204,46 +182,57 @@ public function format( $articles, Lister $lister ) {
 
 		$headings = Article::getHeadings();
 		$output = '';
+
 		if ( !empty( $headings ) ) {
 			if ( $columns != 1 || $rows != 1 ) {
-				$hspace = 2; // the extra space for headings
+				$hspace = 2;
+
 				// repeat outer tags for each of the specified columns / rows in the output
 				// we assume that a heading roughly takes the space of two articles
 				$count = count( $articles ) + $hspace * count( $headings );
+
 				if ( $columns != 1 ) {
 					$iGroup = $columns;
 				} else {
 					$iGroup = $rows;
 				}
+
 				$nsize = floor( $count / $iGroup );
-				$rest  = $count - ( floor( $nsize ) * floor( $iGroup ) );
+				$rest = $count - ( floor( $nsize ) * floor( $iGroup ) );
+
 				if ( $rest > 0 ) {
 					$nsize += 1;
 				}
+
 				$output .= "{|" . $rowColFormat . "\n|\n";
+
 				if ( $nsize < $hspace + 1 ) {
-					$nsize = $hspace + 1; // correction for result sets with one entry
+					$nsize = $hspace + 1;
 				}
+
 				$output .= $this->getListStart();
 				$nstart = 0;
-				$greml  = $nsize; // remaining lines in current group
-				$g      = 0;
+				$greml = $nsize;
+				$g = 0;
 				$offset = 0;
 				foreach ( $headings as $headingCount ) {
 					$headingStart = $nstart - $offset;
 					$headingLink = $articles[$headingStart]->mParentHLink;
 					$output .= $this->getItemStart() . $headingLink . $this->getItemEnd();
+
 					if ( $this->showHeadingCount ) {
 						$output .= $this->articleCountMessage( $headingCount );
 					}
+
 					$offset += $hspace;
 					$nstart += $hspace;
 					$portion = $headingCount;
 					$greml -= $hspace;
 					$listOutput = '';
+
 					do {
 						$greml -= $portion;
-						// $output .= "nsize=$nsize, portion=$portion, greml=$greml";
+
 						if ( $greml > 0 ) {
 							$output .= $lister->formatList( $articles, $nstart - $offset, $portion );
 							$nstart += $portion;
@@ -253,85 +242,104 @@ public function format( $articles, Lister $lister ) {
 							$output .= $lister->formatList( $articles, $nstart - $offset, $portion + $greml );
 							$nstart += ( $portion + $greml );
 							$portion = ( -$greml );
+
 							if ( $columns != 1 ) {
 								$output .= "\n|valign=top|\n";
 							} else {
 								$output .= "\n|-\n|\n";
 							}
+
 							++$g;
-							// if ($rest != 0 && $g==$rest) $nsize -= 1;
+
 							if ( $nstart + $nsize > $count ) {
 								$nsize = $count - $nstart;
 							}
+
 							$greml = $nsize;
+
 							if ( $greml <= 0 ) {
 								break;
 							}
 						}
 					} while ( $portion > 0 );
+
 					$output .= $this->getItemEnd();
 				}
+
 				$output .= $this->listEnd;
 				$output .= "\n|}\n";
 			} else {
 				$output .= $this->getListStart();
 				$headingStart = 0;
+
 				foreach ( $headings as $headingCount ) {
 					$headingLink = $articles[$headingStart]->mParentHLink;
 					$output .= $this->formatItem( $headingStart, $headingCount, $headingLink, $articles, $lister );
 					$headingStart += $headingCount;
 				}
+
 				$output .= $this->listEnd;
 			}
 		} elseif ( $columns != 1 || $rows != 1 ) {
 			// repeat outer tags for each of the specified columns / rows in the output
 			$nstart = 0;
-			$count  = count( $articles );
+			$count = count( $articles );
+
 			if ( $columns != 1 ) {
 				$iGroup = $columns;
 			} else {
 				$iGroup = $rows;
 			}
+
 			$nsize = floor( $count / $iGroup );
-			$rest  = $count - ( floor( $nsize ) * floor( $iGroup ) );
+			$rest = $count - ( floor( $nsize ) * floor( $iGroup ) );
+
 			if ( $rest > 0 ) {
 				$nsize += 1;
 			}
+
 			$output .= "{|" . $rowColFormat . "\n|\n";
+
 			for ( $g = 0; $g < $iGroup; $g++ ) {
-				$output .= $lister->formatList( $articles, $nstart, $nsize );
+				$output .= $lister->formatList( $articles, $nstart, (int)$nsize );
+
 				if ( $columns != 1 ) {
 					$output .= "\n|valign=top|\n";
 				} else {
 					$output .= "\n|-\n|\n";
 				}
-				$nstart = $nstart + $nsize;
-				// if ($rest != 0 && $g+1==$rest) $nsize -= 1;
+
+				$nstart += $nsize;
+
 				if ( $nstart + $nsize > $count ) {
 					$nsize = $count - $nstart;
 				}
 			}
+
 			$output .= "\n|}\n";
 		} elseif ( $rowSize > 0 ) {
 			// repeat row header after n lines of output
 			$nstart = 0;
-			$nsize  = $rowSize;
-			$count  = count( $articles );
+			$nsize = $rowSize;
+			$count = count( $articles );
 			$output .= '{|' . $rowColFormat . "\n|\n";
+
 			do {
 				if ( $nstart + $nsize > $count ) {
 					$nsize = $count - $nstart;
 				}
-				$output .= $lister->formatList( $articles, $nstart, $nsize );
+
+				$output .= $lister->formatList( $articles, $nstart, (int)$nsize );
 				$output .= "\n|-\n|\n";
-				$nstart = $nstart + $nsize;
+				$nstart += $nsize;
 				if ( $nstart >= $count ) {
 					break;
 				}
 			} while ( true );
+
 			$output .= "\n|}\n";
 		} else {
-			//Even though the headingmode is not none there were no headings, but still results.  Output them anyway.
+			// Even though the headingmode is not none there were no headings, but still results. Output them anyway.
 			$output .= $lister->formatList( $articles, 0, count( $articles ) );
 		}
 
@@ -341,21 +349,22 @@ public function format( $articles, Lister $lister ) {
 	/**
 	 * Format a heading group.
 	 *
-	 * @access	public
-	 * @param	integer	Article start index for this heading.
-	 * @param	integer	Article count for this heading.
-	 * @param	string	Heading link/text display.
-	 * @param	array	List of \DPL\Article.
-	 * @param	object	List of \DPL\Lister\Lister
-	 * @return	string	Heading HTML
+	 * @param int $headingStart
+	 * @param int $headingCount
+	 * @param string $headingLink
+	 * @param array $articles
+	 * @param Lister $lister
+	 * @return string
 	 */
 	public function formatItem( $headingStart, $headingCount, $headingLink, $articles, Lister $lister ) {
 		$item = '';
 
 		$item .= $this->getItemStart() . $headingLink;
+
 		if ( $this->showHeadingCount ) {
 			$item .= $this->articleCountMessage( $headingCount );
 		}
+
 		$item .= $lister->formatList( $articles, $headingStart, $headingCount );
 		$item .= $this->getItemEnd();
 
@@ -365,8 +374,7 @@ public function formatItem( $headingStart, $headingCount, $headingLink, $article
 	/**
 	 * Return $this->listStart with attributes replaced.
 	 *
-	 * @access	public
-	 * @return	string	List Start
+	 * @return string
 	 */
 	public function getListStart() {
 		return sprintf( $this->listStart, $this->listAttributes );
@@ -375,8 +383,7 @@ public function getListStart() {
 	/**
 	 * Return $this->itemStart with attributes replaced.
 	 *
-	 * @access	public
-	 * @return	string	Item Start
+	 * @return string
 	 */
 	public function getItemStart() {
 		return sprintf( $this->itemStart, $this->itemAttributes );
@@ -385,8 +392,7 @@ public function getItemStart() {
 	/**
 	 * Return $this->itemEnd with attributes replaced.
 	 *
-	 * @access	public
-	 * @return	string	Item End
+	 * @return string
 	 */
 	public function getItemEnd() {
 		return $this->itemEnd;
@@ -395,17 +401,18 @@ public function getItemEnd() {
 	/**
 	 * Get the article count message appropriate for this list.
 	 *
-	 * @access	public
-	 * @param	integer	Count
-	 * @return	string	Message
+	 * @param int $count
+	 * @return string
 	 */
 	protected function articleCountMessage( $count ) {
 		$orderMethods = $this->getParameters()->getParameter( 'ordermethods' );
+
 		if ( isset( $orderMethods[0] ) && $orderMethods[0] === 'category' ) {
 			$message = 'categoryarticlecount';
 		} else {
 			$message = 'dpl_articlecount';
 		}
+
 		return '<p>' . wfMessage( $message, $count )->escaped() . '</p>';
 	}
 }
diff --git a/includes/heading/OrderedHeading.php b/includes/heading/OrderedHeading.php
index a2bd94fe..b8bd2106 100644
--- a/includes/heading/OrderedHeading.php
+++ b/includes/heading/OrderedHeading.php
@@ -1,12 +1,4 @@
 <?php
-/**
- * DynamicPageList3
- * DPL OrderedHeading Class
- *
- * @license		GPL-2.0-or-later
- * @package		DynamicPageList3
- *
- */
 
 namespace DPL\Heading;
 
diff --git a/includes/heading/TieredHeading.php b/includes/heading/TieredHeading.php
index 04d42565..02c90b8e 100644
--- a/includes/heading/TieredHeading.php
+++ b/includes/heading/TieredHeading.php
@@ -1,12 +1,4 @@
 <?php
-/**
- * DynamicPageList3
- * DPL TieredHeading Class
- *
- * @license		GPL-2.0-or-later
- * @package		DynamicPageList3
- *
- */
 
 namespace DPL\Heading;
 
@@ -50,35 +42,33 @@ class TieredHeading extends Heading {
 	private $tierLevel = 'eader';
 
 	/**
-	 * Main Constructor
-	 *
-	 * @access	public
-	 * @param	object	\DPL\Parameters
-	 * @return	void
+	 * @param Parameters $parameters
 	 */
 	public function __construct( Parameters $parameters ) {
 		parent::__construct( $parameters );
+
 		$this->tierLevel = substr( $parameters->getParameter( 'headingmode' ), 1 );
 	}
 
 	/**
 	 * Format a heading group.
 	 *
-	 * @access	public
-	 * @param	integer	Article start index for this heading.
-	 * @param	integer	Article count for this heading.
-	 * @param	string	Heading link/text display.
-	 * @param	array	List of \DPL\Article.
-	 * @param	object	List of \DPL\Lister\Lister
-	 * @return	string	Heading HTML
+	 * @param int $headingStart
+	 * @param int $headingCount
+	 * @param string $headingLink
+	 * @param array $articles
+	 * @param Lister $lister
+	 * @return string
 	 */
 	public function formatItem( $headingStart, $headingCount, $headingLink, $articles, Lister $lister ) {
 		$item = '';
 
 		$item .= $this->getItemStart() . $headingLink;
+
 		if ( $this->showHeadingCount ) {
 			$item .= $this->articleCountMessage( $headingCount );
 		}
+
 		$item .= $this->getItemEnd();
 		$item .= $lister->formatList( $articles, $headingStart, $headingCount );
 
@@ -88,8 +78,7 @@ public function formatItem( $headingStart, $headingCount, $headingLink, $article
 	/**
 	 * Return $this->listStart with attributes replaced.
 	 *
-	 * @access	public
-	 * @return	string	List Start
+	 * @return string
 	 */
 	public function getListStart() {
 		return sprintf( $this->listStart, $this->listAttributes );
@@ -98,8 +87,7 @@ public function getListStart() {
 	/**
 	 * Return $this->itemStart with attributes replaced.
 	 *
-	 * @access	public
-	 * @return	string	Item Start
+	 * @return string
 	 */
 	public function getItemStart() {
 		return sprintf( $this->itemStart, $this->itemAttributes, $this->tierLevel );
@@ -108,8 +96,7 @@ public function getItemStart() {
 	/**
 	 * Return $this->itemEnd with attributes replaced.
 	 *
-	 * @access	public
-	 * @return	string	Item End
+	 * @return string
 	 */
 	public function getItemEnd() {
 		return sprintf( $this->itemEnd, $this->itemAttributes, $this->tierLevel );
diff --git a/includes/heading/UnorderedHeading.php b/includes/heading/UnorderedHeading.php
index 9e56b263..9b3ae7e2 100644
--- a/includes/heading/UnorderedHeading.php
+++ b/includes/heading/UnorderedHeading.php
@@ -1,12 +1,4 @@
 <?php
-/**
- * DynamicPageList3
- * DPL UnorderedHeading Class
- *
- * @license		GPL-2.0-or-later
- * @package		DynamicPageList3
- *
- */
 
 namespace DPL\Heading;
 
diff --git a/includes/lister/CategoryList.php b/includes/lister/CategoryList.php
index b1262da3..6c0c045b 100644
--- a/includes/lister/CategoryList.php
+++ b/includes/lister/CategoryList.php
@@ -1,15 +1,8 @@
 <?php
-/**
- * DynamicPageList3
- * DPL CategoryList Class
- *
- * @license		GPL-2.0-or-later
- * @package		DynamicPageList3
- *
- */
 
 namespace DPL\Lister;
 
+use CategoryViewer;
 use DPL\Article;
 use DPL\Config;
 
@@ -17,45 +10,49 @@ class CategoryList extends Lister {
 	/**
 	 * Listing style for this class.
 	 *
-	 * @var constant
+	 * @var int
 	 */
 	public $style = parent::LIST_CATEGORY;
 
 	/**
 	 * Format the list of articles.
 	 *
-	 * @access	public
-	 * @param	array	List of \DPL\Article
-	 * @param	integer	Start position of the array to process.
-	 * @param	integer	Total objects from the array to process.
-	 * @return	string	Formatted list.
+	 * @param array $articles
+	 * @param int $start
+	 * @param int $count
+	 * @return string Formatted list.
 	 */
 	public function formatList( $articles, $start, $count ) {
+		$articleLinks = [];
+		$articleStartChars = [];
+
 		$filteredCount = 0;
+
 		for ( $i = $start; $i < $start + $count; $i++ ) {
 			$articleLinks[] = $articles[$i]->mLink;
 			$articleStartChars[] = $articles[$i]->mStartChar;
-			$filteredCount = $filteredCount + 1;
+
+			$filteredCount++;
 		}
 
 		$this->rowCount = $filteredCount;
 
 		if ( count( $articleLinks ) > Config::getSetting( 'categoryStyleListCutoff' ) ) {
-			return "__NOTOC____NOEDITSECTION__" . \CategoryViewer::columnList( $articleLinks, $articleStartChars );
+			return "__NOTOC____NOEDITSECTION__" . CategoryViewer::columnList( $articleLinks, $articleStartChars );
 		} elseif ( count( $articleLinks ) > 0 ) {
 			// for short lists of articles in categories.
-			return "__NOTOC____NOEDITSECTION__" . \CategoryViewer::shortList( $articleLinks, $articleStartChars );
+			return "__NOTOC____NOEDITSECTION__" . CategoryViewer::shortList( $articleLinks, $articleStartChars );
 		}
+
 		return '';
 	}
 
 	/**
 	 * Format a single item.
 	 *
-	 * @access	public
-	 * @param	object	DPL\Article
-	 * @param	string	[Optional] Page text to include.
-	 * @return	string	Item HTML
+	 * @param Article $article
+	 * @param string|null $pageText
+	 * @return string
 	 */
 	public function formatItem( Article $article, $pageText = null ) {
 		return '';
diff --git a/includes/lister/DefinitionList.php b/includes/lister/DefinitionList.php
index 42e1975f..f194a4a5 100644
--- a/includes/lister/DefinitionList.php
+++ b/includes/lister/DefinitionList.php
@@ -1,12 +1,4 @@
 <?php
-/**
- * DynamicPageList3
- * DPL DefinitionList Class
- *
- * @license		GPL-2.0-or-later
- * @package		DynamicPageList3
- *
- */
 
 namespace DPL\Lister;
 
@@ -14,7 +6,7 @@ class DefinitionList extends Lister {
 	/**
 	 * Listing style for this class.
 	 *
-	 * @var constant
+	 * @var int
 	 */
 	public $style = parent::LIST_DEFINITION;
 
diff --git a/includes/lister/GalleryList.php b/includes/lister/GalleryList.php
index 0271469a..afc7de1f 100644
--- a/includes/lister/GalleryList.php
+++ b/includes/lister/GalleryList.php
@@ -1,12 +1,4 @@
 <?php
-/**
- * DynamicPageList3
- * DPL GalleryList Class
- *
- * @license		GPL-2.0-or-later
- * @package		DynamicPageList3
- *
- */
 
 namespace DPL\Lister;
 
@@ -16,7 +8,7 @@ class GalleryList extends Lister {
 	/**
 	 * Listing style for this class.
 	 *
-	 * @var constant
+	 * @var int
 	 */
 	public $style = parent::LIST_GALLERY;
 
@@ -46,21 +38,20 @@ class GalleryList extends Lister {
 	 *
 	 * @var string
 	 */
-	public $itemEnd = "|";
+	public $itemEnd = '|';
 
 	/**
 	 * Format an item.
 	 *
-	 * @access	public
-	 * @param	object	DPL\Article
-	 * @param	string	[Optional] Page text to include.include.
-	 * @return	string	Item HTML
+	 * @param Article $article
+	 * @param string|null $pageText
+	 * @return string
 	 */
 	public function formatItem( Article $article, $pageText = null ) {
 		$item = $article->mTitle;
 
 		if ( $pageText !== null ) {
-			//Include parsed/processed wiki markup content after each item before the closing tag.
+			// Include parsed/processed wiki markup content after each item before the closing tag.
 			$item .= $pageText;
 		}
 
diff --git a/includes/lister/InlineList.php b/includes/lister/InlineList.php
index d2b5e75a..08c24238 100644
--- a/includes/lister/InlineList.php
+++ b/includes/lister/InlineList.php
@@ -1,20 +1,15 @@
 <?php
-/**
- * DynamicPageList3
- * DPL InlineList Class
- *
- * @license		GPL-2.0-or-later
- * @package		DynamicPageList3
- *
- */
 
 namespace DPL\Lister;
 
+use DPL\Parameters;
+use Parser;
+
 class InlineList extends Lister {
 	/**
 	 * Listing style for this class.
 	 *
-	 * @var constant
+	 * @var int
 	 */
 	public $style = parent::LIST_INLINE;
 
@@ -68,24 +63,20 @@ class InlineList extends Lister {
 	protected $textSeparator = '';
 
 	/**
-	 * Main Constructor
-	 *
-	 * @access	public
-	 * @param	object	\DPL\Parameters
-	 * @param	object	MediaWiki \Parser
-	 * @return	void
+	 * @param Parameters $parameters
+	 * @param Parser $parser
 	 */
-	public function __construct( \DPL\Parameters $parameters, \Parser $parser ) {
+	public function __construct( Parameters $parameters, Parser $parser ) {
 		parent::__construct( $parameters, $parser );
+
 		$this->textSeparator = $parameters->getParameter( 'inlinetext' );
 	}
 
 	/**
 	 * Join together items after being processed by formatItem().
 	 *
-	 * @access	public
-	 * @param	array	Items as formatted by formatItem().
-	 * @return	string	Imploded items.
+	 * @param array $items
+	 * @return string
 	 */
 	protected function implodeItems( $items ) {
 		return implode( $this->textSeparator, $items );
diff --git a/includes/lister/Lister.php b/includes/lister/Lister.php
index 8c02b2c2..4063886a 100644
--- a/includes/lister/Lister.php
+++ b/includes/lister/Lister.php
@@ -1,40 +1,43 @@
 <?php
-/**
- * DynamicPageList3
- * DPL List Class
- *
- * @license		GPL-2.0-or-later
- * @package		DynamicPageList3
- *
- */
 
 namespace DPL\Lister;
 
 use DPL\Article;
 use DPL\LST;
+use DPL\Parameters;
 use DPL\UpdateArticle;
 use MediaWiki\MediaWikiServices;
+use Parser;
+use Sanitizer;
+use Title;
 
 class Lister {
-	const LIST_DEFINITION = 1;
-	const LIST_GALLERY = 2;
-	const LIST_HEADING = 3;
-	const LIST_INLINE = 4;
-	const LIST_ORDERED = 5;
-	const LIST_UNORDERED = 6;
-	const LIST_CATEGORY = 7;
-	const LIST_USERFORMAT = 8;
+	public const LIST_DEFINITION = 1;
+
+	public const LIST_GALLERY = 2;
+
+	public const LIST_HEADING = 3;
+
+	public const LIST_INLINE = 4;
+
+	public const LIST_ORDERED = 5;
+
+	public const LIST_UNORDERED = 6;
+
+	public const LIST_CATEGORY = 7;
+
+	public const LIST_USERFORMAT = 8;
 
 	/**
 	 * Listing style for this class.
 	 *
-	 * @var constant
+	 * @var int|null
 	 */
 	public $style = null;
 
 	/**
 	 * Heading List Start
-	 * Use %s for attribute placement.  Example: <div%s>
+	 * Use %s for attribute placement. Example: <div%s>
 	 *
 	 * @var string
 	 */
@@ -49,7 +52,7 @@ class Lister {
 
 	/**
 	 * Heading List Start
-	 * Use %s for attribute placement.  Example: <div%s>
+	 * Use %s for attribute placement. Example: <div%s>
 	 *
 	 * @var string
 	 */
@@ -64,7 +67,7 @@ class Lister {
 
 	/**
 	 * List(Section) Start
-	 * Use %s for attribute placement.  Example: <div%s>
+	 * Use %s for attribute placement. Example: <div%s>
 	 *
 	 * @var string
 	 */
@@ -79,7 +82,7 @@ class Lister {
 
 	/**
 	 * Item Start
-	 * Use %s for attribute placement.  Example: <div%s>
+	 * Use %s for attribute placement. Example: <div%s>
 	 *
 	 * @var string
 	 */
@@ -95,28 +98,28 @@ class Lister {
 	/**
 	 * Extra head list HTML attributes.
 	 *
-	 * @var array
+	 * @var string
 	 */
 	public $headListAttributes = '';
 
 	/**
 	 * Extra head item HTML attributes.
 	 *
-	 * @var array
+	 * @var string
 	 */
 	public $headItemAttributes = '';
 
 	/**
 	 * Extra list HTML attributes.
 	 *
-	 * @var array
+	 * @var string
 	 */
 	public $listAttributes = '';
 
 	/**
 	 * Extra item HTML attributes.
 	 *
-	 * @var array
+	 * @var string
 	 */
 	public $itemAttributes = '';
 
@@ -151,14 +154,19 @@ class Lister {
 	/**
 	 * Index of the table column to sort by.
 	 *
-	 * @var int
+	 * @var int|null
 	 */
 	protected $tableSortColumn = null;
 
+	/**
+	 * @var string|null
+	 */
+	protected $tableSortMethod = null;
+
 	/**
 	 * Maximum title length.
 	 *
-	 * @var int
+	 * @var int|null
 	 */
 	protected $titleMaxLength = null;
 
@@ -186,7 +194,7 @@ class Lister {
 	/**
 	 * Maximum length before truncated included wiki text.
 	 *
-	 * @var int
+	 * @var int|null
 	 */
 	protected $includePageMaxLength = null;
 
@@ -195,21 +203,21 @@ class Lister {
 	 *
 	 * @var array
 	 */
-	protected $pageTextMatch = null;
+	protected $pageTextMatch;
 
 	/**
 	 * Array of regex text matches for page transclusion. (includematch)
 	 *
 	 * @var array
 	 */
-	protected $pageTextMatchRegex = null;
+	protected $pageTextMatchRegex;
 
 	/**
 	 * Array of not regex text matches for page transclusion. (includenotmatch)
 	 *
 	 * @var array
 	 */
-	protected $pageTextMatchNotRegex = null;
+	protected $pageTextMatchNotRegex;
 
 	/**
 	 * Parsed wiki text into HTML before running include/includematch/includenotmatch.
@@ -226,28 +234,24 @@ class Lister {
 	public $rowCount = 0;
 
 	/**
-	 * \DPL\Parameters
+	 * Parameters
 	 *
-	 * @var object
+	 * @var Parameters
 	 */
-	protected $parameters = null;
+	protected $parameters;
 
 	/**
 	 * Parser
 	 *
-	 * @var object
+	 * @var Parser
 	 */
-	protected $parser = null;
+	protected $parser;
 
 	/**
-	 * Main Constructor
-	 *
-	 * @access	public
-	 * @param	object	\DPL\Parameters
-	 * @param	object	MediaWiki \Parser
-	 * @return	void
+	 * @param Parameters $parameters
+	 * @param Parser $parser
 	 */
-	public function __construct( \DPL\Parameters $parameters, \Parser $parser ) {
+	public function __construct( Parameters $parameters, Parser $parser ) {
 		$this->setHeadListAttributes( $parameters->getParameter( 'hlistattr' ) );
 		$this->setHeadItemAttributes( $parameters->getParameter( 'hitemattr' ) );
 		$this->setListAttributes( $parameters->getParameter( 'listattr' ) );
@@ -256,7 +260,7 @@ public function __construct( \DPL\Parameters $parameters, \Parser $parser ) {
 		$this->setTemplateSuffix( $parameters->getParameter( 'defaulttemplatesuffix' ) );
 		$this->setTrimIncluded( $parameters->getParameter( 'includetrim' ) );
 		$this->setTableSortColumn( $parameters->getParameter( 'tablesortcol' ) );
-		$this->setTableSortMethod($parameters->getParameter('tablesortmethod'));
+		$this->setTableSortMethod( $parameters->getParameter( 'tablesortmethod' ) );
 		$this->setTitleMaxLength( $parameters->getParameter( 'titlemaxlen' ) );
 		$this->setEscapeLinks( $parameters->getParameter( 'escapelinks' ) );
 		$this->setSectionSeparators( $parameters->getParameter( 'secseparators' ) );
@@ -274,51 +278,49 @@ public function __construct( \DPL\Parameters $parameters, \Parser $parser ) {
 	/**
 	 * Get a new List subclass based on user selection.
 	 *
-	 * @access	public
-	 * @param	string	List style.
-	 * @param	object	\DPL\Parameters
-	 * @param	object	MediaWiki \Parser
-	 * @return	object	Lister subclass.
+	 * @param string $style
+	 * @param Parameters $parameters
+	 * @param Parser $parser
+	 * @return mixed
 	 */
-	public static function newFromStyle( $style, \DPL\Parameters $parameters, \Parser $parser ) {
+	public static function newFromStyle( $style, Parameters $parameters, Parser $parser ) {
 		$style = strtolower( $style );
+
 		switch ( $style ) {
 			case 'category':
-				$class = 'CategoryList';
+				$class = CategoryList::class;
 				break;
 			case 'definition':
-				$class = 'DefinitionList';
+				$class = DefinitionList::class;
 				break;
 			case 'gallery':
-				$class = 'GalleryList';
+				$class = GalleryList::class;
 				break;
 			case 'inline':
-				$class = 'InlineList';
+				$class = InlineList::class;
 				break;
 			case 'ordered':
-				$class = 'OrderedList';
+				$class = OrderedList::class;
 				break;
 			case 'subpage':
-				$class = 'SubPageList';
+				$class = SubPageList::class;
 				break;
 			default:
 			case 'unordered':
-				$class = 'UnorderedList';
+				$class = UnorderedList::class;
 				break;
 			case 'userformat':
-				$class = 'UserFormatList';
+				$class = UserFormatList::class;
 				break;
 		}
-		$class = '\DPL\Lister\\' . $class;
 
 		return new $class( $parameters, $parser );
 	}
 
 	/**
-	 * Get the \DPL\Parameters object this object was constructed with.
+	 * Get the Parameters object this object was constructed with.
 	 *
-	 * @access	public
-	 * @return	object	\DPL\Parameters
+	 * @return Parameters
 	 */
 	public function getParameters() {
 		return $this->parameters;
@@ -327,53 +329,43 @@ public function getParameters() {
 	/**
 	 * Set extra list attributes for header wraps.
 	 *
-	 * @access	public
-	 * @param	string	Tag soup attributes, example: this="that" thing="no"
-	 * @return	void
+	 * @param string $attributes
 	 */
 	public function setHeadListAttributes( $attributes ) {
-		$this->headListAttributes = \Sanitizer::fixTagAttributes( $attributes, 'ul' );
+		$this->headListAttributes = Sanitizer::fixTagAttributes( $attributes, 'ul' );
 	}
 
 	/**
 	 * Set extra item attributes for header items.
 	 *
-	 * @access	public
-	 * @param	string	Tag soup attributes, example: this="that" thing="no"
-	 * @return	void
+	 * @param string $attributes
 	 */
 	public function setHeadItemAttributes( $attributes ) {
-		$this->headItemAttributes = \Sanitizer::fixTagAttributes( $attributes, 'li' );
+		$this->headItemAttributes = Sanitizer::fixTagAttributes( $attributes, 'li' );
 	}
 
 	/**
 	 * Set extra list attributes.
 	 *
-	 * @access	public
-	 * @param	string	Tag soup attributes, example: this="that" thing="no"
-	 * @return	void
+	 * @param string $attributes
 	 */
 	public function setListAttributes( $attributes ) {
-		$this->listAttributes = \Sanitizer::fixTagAttributes( $attributes, 'ul' );
+		$this->listAttributes = Sanitizer::fixTagAttributes( $attributes, 'ul' );
 	}
 
 	/**
 	 * Set extra item attributes.
 	 *
-	 * @access	public
-	 * @param	string	Tag soup attributes, example: this="that" thing="no"
-	 * @return	void
+	 * @param string $attributes
 	 */
 	public function setItemAttributes( $attributes ) {
-		$this->itemAttributes = \Sanitizer::fixTagAttributes( $attributes, 'li' );
+		$this->itemAttributes = Sanitizer::fixTagAttributes( $attributes, 'li' );
 	}
 
 	/**
 	 * Set the count of items to trigger a section as dominant.
 	 *
-	 * @access	public
-	 * @param	integer	Count
-	 * @return	void
+	 * @param int $count
 	 */
 	public function setDominantSectionCount( $count = -1 ) {
 		$this->dominantSectionCount = intval( $count );
@@ -382,8 +374,7 @@ public function setDominantSectionCount( $count = -1 ) {
 	/**
 	 * Get the count of items to trigger a section as dominant.
 	 *
-	 * @access	public
-	 * @return	integer	Count
+	 * @return int
 	 */
 	public function getDominantSectionCount() {
 		return $this->dominantSectionCount;
@@ -392,8 +383,7 @@ public function getDominantSectionCount() {
 	/**
 	 * Return the list style.
 	 *
-	 * @access	public
-	 * @return	integer	List style constant.
+	 * @return int
 	 */
 	public function getStyle() {
 		return $this->style;
@@ -402,9 +392,7 @@ public function getStyle() {
 	/**
 	 * Set the template suffix for whatever the hell uses it.
 	 *
-	 * @access	public
-	 * @param	string	Template Suffix
-	 * @return	void
+	 * @param string $suffix
 	 */
 	public function setTemplateSuffix( $suffix = '.default' ) {
 		$this->templateSuffix = $suffix;
@@ -413,8 +401,7 @@ public function setTemplateSuffix( $suffix = '.default' ) {
 	/**
 	 * Get the template suffix for whatever the hell uses it.
 	 *
-	 * @access	public
-	 * @return	string
+	 * @return string
 	 */
 	public function getTemplateSuffix() {
 		return $this->templateSuffix;
@@ -423,9 +410,7 @@ public function getTemplateSuffix() {
 	/**
 	 * Set if included wiki text should be trimmed.
 	 *
-	 * @access	public
-	 * @param	boolean	[Optional] Trim
-	 * @return	void
+	 * @param bool $trim
 	 */
 	public function setTrimIncluded( $trim = false ) {
 		$this->trimIncluded = boolval( $trim );
@@ -434,8 +419,7 @@ public function setTrimIncluded( $trim = false ) {
 	/**
 	 * Get if included wiki text should be trimmed.
 	 *
-	 * @access	public
-	 * @return	boolean	Trim
+	 * @return bool
 	 */
 	public function getTrimIncluded() {
 		return $this->trimIncluded;
@@ -445,9 +429,7 @@ public function getTrimIncluded() {
 	 * Set if links should be escaped?
 	 * @todo The naming of this parameter is weird and I am not sure what it does.
 	 *
-	 * @access	public
-	 * @param	boolean	[Optional] Escape
-	 * @return	void
+	 * @param bool $escape
 	 */
 	public function setEscapeLinks( $escape = true ) {
 		$this->escapeLinks = boolval( $escape );
@@ -456,8 +438,7 @@ public function setEscapeLinks( $escape = true ) {
 	/**
 	 * Get if links should be escaped.
 	 *
-	 * @access	public
-	 * @return	boolean	Escape
+	 * @return bool
 	 */
 	public function getEscapeLinks() {
 		return $this->escapeLinks;
@@ -466,9 +447,7 @@ public function getEscapeLinks() {
 	/**
 	 * Set the index of the table column to sort by.
 	 *
-	 * @access	public
-	 * @param	mixed	[Optional] Integer index or null to disable.
-	 * @return	void
+	 * @param int|null $index
 	 */
 	public function setTableSortColumn( $index = null ) {
 		$this->tableSortColumn = $index === null ? null : intval( $index );
@@ -477,8 +456,7 @@ public function setTableSortColumn( $index = null ) {
 	/**
 	 * Get the index of the table column to sort by.
 	 *
-	 * @access	public
-	 * @return	mixed	Integer index or null to disable.
+	 * @return int|null
 	 */
 	public function getTableSortColumn() {
 		return $this->tableSortColumn;
@@ -487,19 +465,16 @@ public function getTableSortColumn() {
 	/**
 	 * Set the algorithm for table sorting
 	 *
-	 * @access	public
-	 * @param	string	Algorithm name
-	 * @return	void
+	 * @param string|null $method
 	 */
-	public function setTableSortMethod($method = null) {
+	public function setTableSortMethod( $method = null ) {
 		$this->tableSortMethod = $method === null ? 'standard' : $method;
 	}
 
 	/**
 	 * Get the algorithm for table sorting
 	 *
-	 * @access	public
-	 * @return	string	Algorithm name
+	 * @return string
 	 */
 	public function getTableSortMethod() {
 		return $this->tableSortMethod;
@@ -508,9 +483,7 @@ public function getTableSortMethod() {
 	/**
 	 * Set the maximum title length for display.
 	 *
-	 * @access	public
-	 * @param	mixed	[Optional] Integer length or null to disable.
-	 * @return	void
+	 * @param int|null $length
 	 */
 	public function setTitleMaxLength( $length = null ) {
 		$this->titleMaxLength = $length === null ? null : intval( $length );
@@ -519,8 +492,7 @@ public function setTitleMaxLength( $length = null ) {
 	/**
 	 * Get the maximum title length for display.
 	 *
-	 * @access	public
-	 * @return	mixed	Integer length or null to disable.
+	 * @return int|null
 	 */
 	public function getTitleMaxLength() {
 		return $this->titleMaxLength;
@@ -529,31 +501,25 @@ public function getTitleMaxLength() {
 	/**
 	 * Set the separators that separate sections of matched page text.
 	 *
-	 * @access	public
-	 * @param	array	[Optional] Array of section separators.
-	 * @return	void
+	 * @param ?array $separators
 	 */
 	public function setSectionSeparators( ?array $separators ) {
-		$this->sectionSeparators = (array)$separators ?? [];
+		$this->sectionSeparators = $separators ?? [];
 	}
 
 	/**
 	 * Set the separators that separate related sections of matched page text.
 	 *
-	 * @access	public
-	 * @param	array	[Optional] Array of section separators.
-	 * @return	void
+	 * @param ?array $separators
 	 */
 	public function setMultiSectionSeparators( ?array $separators ) {
-		$this->multiSectionSeparators = (array)$separators ?? [];
+		$this->multiSectionSeparators = $separators ?? [];
 	}
 
 	/**
 	 * Set if wiki text should be included in output.
 	 *
-	 * @access	public
-	 * @param	boolean	[Optional] Parse
-	 * @return	void
+	 * @param bool $include
 	 */
 	public function setIncludePageText( $include = false ) {
 		$this->includePageText = boolval( $include );
@@ -562,9 +528,7 @@ public function setIncludePageText( $include = false ) {
 	/**
 	 * Set the maximum included page text length before truncating.
 	 *
-	 * @access	public
-	 * @param	mixed	[Optional] Integer length or null to disable.
-	 * @return	void
+	 * @param int|null $length
 	 */
 	public function setIncludePageMaxLength( $length = null ) {
 		$this->includePageMaxLength = $length === null ? null : intval( $length );
@@ -573,42 +537,34 @@ public function setIncludePageMaxLength( $length = null ) {
 	/**
 	 * Set the plain string text matching for page transclusion.
 	 *
-	 * @access	public
-	 * @param	array	[Optional] Array of plain string matches.
-	 * @return	void
+	 * @param array	$pageTextMatch
 	 */
 	public function setPageTextMatch( array $pageTextMatch = [] ) {
-		$this->pageTextMatch = (array)$pageTextMatch;
+		$this->pageTextMatch = $pageTextMatch;
 	}
 
 	/**
 	 * Set the regex text matching for page transclusion.
 	 *
-	 * @access	public
-	 * @param	array	[Optional] Array of regexes.
-	 * @return	void
+	 * @param array	$pageTextMatchRegex
 	 */
 	public function setPageTextMatchRegex( array $pageTextMatchRegex = [] ) {
-		$this->pageTextMatchRegex = (array)$pageTextMatchRegex;
+		$this->pageTextMatchRegex = $pageTextMatchRegex;
 	}
 
 	/**
 	 * Set the not regex text matching for page transclusion.
 	 *
-	 * @access	public
-	 * @param	array	[Optional] Array of regexes.
-	 * @return	void
+	 * @param array	$pageTextMatchNotRegex
 	 */
 	public function setPageTextMatchNotRegex( array $pageTextMatchNotRegex = [] ) {
-		$this->pageTextMatchNotRegex = (array)$pageTextMatchNotRegex;
+		$this->pageTextMatchNotRegex = $pageTextMatchNotRegex;
 	}
 
 	/**
 	 * Set if included wiki text should be parsed before being matched against.
 	 *
-	 * @access	public
-	 * @param	boolean	[Optional] Parse
-	 * @return	void
+	 * @param bool $parse
 	 */
 	public function setIncludePageParsed( $parse = false ) {
 		$this->includePageParsed = boolval( $parse );
@@ -617,9 +573,8 @@ public function setIncludePageParsed( $parse = false ) {
 	/**
 	 * Shortcut to format all articles into a single formatted list.
 	 *
-	 * @access	public
-	 * @param	array	List of \DPL\Article
-	 * @return	string	Formatted list.
+	 * @param array $articles
+	 * @return string
 	 */
 	public function format( $articles ) {
 		return $this->formatList( $articles, 0, count( $articles ) );
@@ -628,17 +583,18 @@ public function format( $articles ) {
 	/**
 	 * Format a list of articles into a singular list.
 	 *
-	 * @access	public
-	 * @param	array	List of \DPL\Article
-	 * @param	integer	Start position of the array to process.
-	 * @param	integer	Total objects from the array to process.
-	 * @return	string	Formatted list.
+	 * @param array $articles
+	 * @param int $start
+	 * @param int $count
+	 * @return string
 	 */
 	public function formatList( $articles, $start, $count ) {
 		$filteredCount = 0;
 		$items = [];
+
 		for ( $i = $start; $i < $start + $count; $i++ ) {
 			$article = $articles[$i];
+
 			if ( empty( $article ) || empty( $article->mTitle ) ) {
 				continue;
 			}
@@ -663,20 +619,19 @@ public function formatList( $articles, $start, $count ) {
 	/**
 	 * Format a single item.
 	 *
-	 * @access	public
-	 * @param	object	DPL\Article
-	 * @param	string	[Optional] Page text to include.
-	 * @return	string	Item HTML
+	 * @param Article $article
+	 * @param string|null $pageText
+	 * @return string
 	 */
 	public function formatItem( Article $article, $pageText = null ) {
 		global $wgLang;
 
 		$item = '';
 
-		// DPL Article, not MediaWiki.
 		$date = $article->getDate();
 		if ( $date !== null ) {
 			$item .= $date . ' ';
+
 			if ( $article->mRevision !== null ) {
 				$item .= '[{{fullurl:' . $article->mTitle . '|oldid=' . $article->mRevision . '}} ' . htmlspecialchars( $article->mTitle ) . ']';
 			} else {
@@ -701,6 +656,7 @@ public function formatItem( Article $article, $pageText = null ) {
 
 		if ( $article->mUserLink !== null ) {
 			$item .= ' . . [[User:' . $article->mUser . '|' . $article->mUser . ']]';
+
 			if ( $article->mComment != '' ) {
 				$item .= ' { ' . $article->mComment . ' }';
 			}
@@ -719,7 +675,7 @@ public function formatItem( Article $article, $pageText = null ) {
 		}
 
 		if ( $pageText !== null ) {
-			//Include parsed/processed wiki markup content after each item before the closing tag.
+			// Include parsed/processed wiki markup content after each item before the closing tag.
 			$item .= $pageText;
 		}
 
@@ -733,8 +689,7 @@ public function formatItem( Article $article, $pageText = null ) {
 	/**
 	 * Return $this->headListStart with attributes replaced.
 	 *
-	 * @access	public
-	 * @return	string	Head List Start
+	 * @return string
 	 */
 	public function getHeadListStart() {
 		return sprintf( $this->headListStart, $this->headListAttributes );
@@ -743,8 +698,7 @@ public function getHeadListStart() {
 	/**
 	 * Return $this->headItemStart with attributes replaced.
 	 *
-	 * @access	public
-	 * @return	string	Head Item Start
+	 * @return string
 	 */
 	public function getHeadItemStart() {
 		return sprintf( $this->headItemStart, $this->headItemAttributes );
@@ -753,8 +707,7 @@ public function getHeadItemStart() {
 	/**
 	 * Return $this->headItemStart with attributes replaced.
 	 *
-	 * @access	public
-	 * @return	string	Head Item End
+	 * @return string
 	 */
 	public function getHeadItemEnd() {
 		return $this->headItemEnd;
@@ -763,8 +716,7 @@ public function getHeadItemEnd() {
 	/**
 	 * Return $this->listStart with attributes replaced.
 	 *
-	 * @access	public
-	 * @return	string	List Start
+	 * @return string
 	 */
 	public function getListStart() {
 		return sprintf( $this->listStart, $this->listAttributes );
@@ -773,8 +725,7 @@ public function getListStart() {
 	/**
 	 * Return $this->itemStart with attributes replaced.
 	 *
-	 * @access	public
-	 * @return	string	Item Start
+	 * @return string
 	 */
 	public function getItemStart() {
 		return sprintf( $this->itemStart, $this->itemAttributes );
@@ -783,8 +734,7 @@ public function getItemStart() {
 	/**
 	 * Return $this->itemEnd with attributes replaced.
 	 *
-	 * @access	public
-	 * @return	string	Item End
+	 * @return string
 	 */
 	public function getItemEnd() {
 		return $this->itemEnd;
@@ -793,9 +743,8 @@ public function getItemEnd() {
 	/**
 	 * Join together items after being processed by formatItem().
 	 *
-	 * @protected
-	 * @param	array	Items as formatted by formatItem().
-	 * @return	string	Imploded items.
+	 * @param array $items
+	 * @return string
 	 */
 	protected function implodeItems( $items ) {
 		return implode( '', $items );
@@ -804,10 +753,9 @@ protected function implodeItems( $items ) {
 	/**
 	 * Replace user tag parameters.
 	 *
-	 * @protected
-	 * @param	string	Text to perform replacements on.
-	 * @param	object	\DPL\Article
-	 * @return	string	Text with replacements performed.
+	 * @param string $tag
+	 * @param Article $article
+	 * @return string
 	 */
 	protected function replaceTagParameters( $tag, Article $article ) {
 		$contLang = MediaWikiServices::getInstance()->getContentLanguage();
@@ -827,7 +775,7 @@ protected function replaceTagParameters( $tag, Article $article ) {
 		}
 
 		$tag = str_replace( '%PAGE%', $pagename, $tag );
-		$tag = str_replace( '%PAGEID%', $article->mID, $tag );
+		$tag = str_replace( '%PAGEID%', (string)$article->mID, $tag );
 		$tag = str_replace( '%NAMESPACE%', $namespaces[$article->mNamespace], $tag );
 		$tag = str_replace( '%IMAGE%', $imageUrl, $tag );
 		$tag = str_replace( '%EXTERNALLINK%', $article->mExternalLink, $tag );
@@ -835,23 +783,26 @@ protected function replaceTagParameters( $tag, Article $article ) {
 
 		$title = $article->mTitle->getText();
 		$replaceInTitle = $this->getParameters()->getParameter( 'replaceintitle' );
+
 		if ( is_array( $replaceInTitle ) && count( $replaceInTitle ) === 2 ) {
 			$title = preg_replace( $replaceInTitle[0], $replaceInTitle[1], $title );
 		}
+
 		$titleMaxLength = $this->getTitleMaxLength();
 		if ( $titleMaxLength !== null && ( strlen( $title ) > $titleMaxLength ) ) {
 			$title = substr( $title, 0, $titleMaxLength ) . '...';
 		}
+
 		$tag = str_replace( '%TITLE%', $title, $tag );
 
-		$tag = str_replace( '%COUNT%', $article->mCounter, $tag );
-		$tag = str_replace( '%COUNTFS%', floor( log( $article->mCounter ) * 0.7 ), $tag );
-		$tag = str_replace( '%COUNTFS2%', floor( sqrt( log( $article->mCounter ) ) ), $tag );
-		$tag = str_replace( '%SIZE%', $article->mSize, $tag );
-		$tag = str_replace( '%SIZEFS%', floor( sqrt( log( $article->mSize ) ) * 2.5 - 5 ), $tag );
+		$tag = str_replace( '%COUNT%', (string)$article->mCounter, $tag );
+		$tag = str_replace( '%COUNTFS%', (string)( floor( log( $article->mCounter ) * 0.7 ) ), $tag );
+		$tag = str_replace( '%COUNTFS2%', (string)( floor( sqrt( log( $article->mCounter ) ) ) ), $tag );
+		$tag = str_replace( '%SIZE%', (string)$article->mSize, $tag );
+		$tag = str_replace( '%SIZEFS%', (string)( floor( sqrt( log( $article->mSize ) ) * 2.5 - 5 ) ), $tag );
 		$tag = str_replace( '%DATE%', $article->getDate(), $tag );
-		$tag = str_replace( '%REVISION%', $article->mRevision, $tag );
-		$tag = str_replace( '%CONTRIBUTION%', $article->mContribution, $tag );
+		$tag = str_replace( '%REVISION%', (string)$article->mRevision, $tag );
+		$tag = str_replace( '%CONTRIBUTION%', (string)$article->mContribution, $tag );
 		$tag = str_replace( '%CONTRIB%', $article->mContrib, $tag );
 		$tag = str_replace( '%CONTRIBUTOR%', $article->mContributor, $tag );
 		$tag = str_replace( '%USER%', $article->mUser, $tag );
@@ -863,6 +814,7 @@ protected function replaceTagParameters( $tag, Article $article ) {
 				$tag = str_replace( '%PAGESEL%', $namespaces[$article->mSelNamespace] . ':' . str_replace( '_', ' ', $article->mSelTitle ), $tag );
 			}
 		}
+
 		$tag = str_replace( '%IMAGESEL%', str_replace( '_', ' ', $article->mImageSelTitle ), $tag );
 
 		$tag = $this->replaceTagCategory( $tag, $article );
@@ -873,10 +825,9 @@ protected function replaceTagParameters( $tag, Article $article ) {
 	/**
 	 * Replace user tag parameters for categories.
 	 *
-	 * @protected
-	 * @param	string	Text to perform replacements on.
-	 * @param	object	\DPL\Article
-	 * @return	string	Text with replacements performed.
+	 * @param string $tag
+	 * @param Article $article
+	 * @return string
 	 */
 	protected function replaceTagCategory( $tag, Article $article ) {
 		if ( !empty( $article->mCategoryLinks ) ) {
@@ -895,66 +846,63 @@ protected function replaceTagCategory( $tag, Article $article ) {
 	/**
 	 * Replace the %NR%(current article sequence number) in text.
 	 *
-	 * @protected
-	 * @param	string	Text to perform replacements on.
-	 * @param	integer	The current article sequence number (starting from 1).
-	 * @return	string	Text with replacements performed.
+	 * @param string $tag
+	 * @param int $nr
+	 * @return string
 	 */
 	protected function replaceTagCount( $tag, $nr ) {
-		return str_replace( '%NR%', $nr, $tag );
+		return str_replace( '%NR%', (string)$nr, $tag );
 	}
 
-	//
-
 	/**
 	 * Format one single item of an entry in the output list (i.e. one occurence of one item from the include parameter).
-	 * @todo I am not exactly sure how this function differs from replaceTagParameters().  It has something to do with table row formatting.  --Alexia
 	 *
-	 * @private
-	 * @param	array	String pieces to perform replacements on.
-	 * @param	mixed	Index of the table row position.
-	 * @param	object	\DPL\Article
-	 * @return	void
+	 * @param array &$pieces
+	 * @param mixed $s Index of the table row position.
+	 * @param Article $article
 	 */
 	private function replaceTagTableRow( &$pieces, $s, Article $article ) {
 		$tableFormat = $this->getParameters()->getParameter( 'tablerow' );
 		$firstCall = true;
+
 		foreach ( $pieces as $key => $val ) {
 			if ( isset( $tableFormat[$s] ) ) {
 				if ( $s == 0 || $firstCall ) {
 					$pieces[$key] = str_replace( '%%', $val, $tableFormat[$s] );
 				} else {
 					$n = strpos( $tableFormat[$s], '|' );
+
 					if ( $n === false || !( strpos( substr( $tableFormat[$s], 0, $n ), '{' ) === false ) || !( strpos( substr( $tableFormat[$s], 0, $n ), '[' ) === false ) ) {
 						$pieces[$key] = str_replace( '%%', $val, $tableFormat[$s] );
 					} else {
 						$pieces[$key] = str_replace( '%%', $val, substr( $tableFormat[$s], $n + 1 ) );
 					}
 				}
+
 				$pieces[$key] = str_replace( '%IMAGE%', $this->parseImageUrlWithPath( $val ), $pieces[$key] );
 				$pieces[$key] = str_replace( '%PAGE%', $article->mTitle->getPrefixedText(), $pieces[$key] );
 
 				$pieces[$key] = $this->replaceTagCategory( $pieces[$key], $article );
 			}
+
 			$firstCall = false;
 		}
 	}
 
 	/**
-	 * Format one single template argument of one occurence of one item from the include parameter.  This is called via a backlink from LST::includeTemplate().
-	 * @todo Again, another poorly documented function with vague functionality.  --Alexia
+	 * Format one single template argument of one occurence of one item from the include parameter. This is called via a backlink from LST::includeTemplate().
 	 *
-	 * @access	public
-	 * @param	string	Argument to parse and replace.
-	 * @param	mixed	Index of the table row position.
-	 * @param	mixed	Other part of the index of the table row position?
-	 * @param	boolean	Is this the first time this function was called in this context?
-	 * @param	integer	Maximum text length allowed.
-	 * @param	object	\DPL\Article
-	 * @return	strig	Formatted text.
+	 * @param string $arg
+	 * @param mixed	$s Index of the table row position.
+	 * @param mixed $argNr Other part of the index of the table row position?
+	 * @param bool $firstCall
+	 * @param int $maxLength
+	 * @param Article $article
+	 * @return string
 	 */
 	public function formatTemplateArg( $arg, $s, $argNr, $firstCall, $maxLength, Article $article ) {
 		$tableFormat = $this->getParameters()->getParameter( 'tablerow' );
+
 		// we could try to format fields differently within the first call of a template
 		// currently we do not make such a difference
 
@@ -962,22 +910,28 @@ public function formatTemplateArg( $arg, $s, $argNr, $firstCall, $maxLength, Art
 		// a start of a new row (wiki table syntax)
 		if ( array_key_exists( "$s.$argNr", $tableFormat ) ) {
 			$n = -1;
+
 			if ( $s >= 1 && $argNr == 0 && !$firstCall ) {
 				$n = strpos( $tableFormat["$s.$argNr"], '|' );
 				if ( $n === false || !( strpos( substr( $tableFormat["$s.$argNr"], 0, $n ), '{' ) === false ) || !( strpos( substr( $tableFormat["$s.$argNr"], 0, $n ), '[' ) === false ) ) {
 					$n = -1;
 				}
 			}
+
 			$result = str_replace( '%%', $arg, substr( $tableFormat["$s.$argNr"], $n + 1 ) );
 			$result = str_replace( '%PAGE%', $article->mTitle->getPrefixedText(), $result );
-			$result = str_replace( '%IMAGE%', $this->parseImageUrlWithPath( $arg ), $result ); //@TODO: This just blindly passes the argument through hoping it is an image.  --Alexia
+
+			// @TODO: This just blindly passes the argument through hoping it is an image.
+			$result = str_replace( '%IMAGE%', $this->parseImageUrlWithPath( $arg ), $result );
 			$result = $this->cutAt( $maxLength, $result );
+
 			if ( strlen( $result ) > 0 && $result[0] == '-' ) {
 				return ' ' . $result;
 			} else {
 				return $result;
 			}
 		}
+
 		$result = $this->cutAt( $maxLength, $arg );
 		if ( strlen( $result ) > 0 && $result[0] == '-' ) {
 			return ' ' . $result;
@@ -992,50 +946,55 @@ public function formatTemplateArg( $arg, $s, $argNr, $firstCall, $maxLength, Art
 	 * ... it is balanced in terms of braces, brackets and tags
 	 * ... can be used as content of a wikitable field without spoiling the whole surrounding wikitext structure
 	 *
-	 * @private
-	 * @param  $lim     limit of character count for the result
-	 * @param  $text    the wikitext to be truncated
-	 * @return the truncated text; note that in some cases it may be slightly longer than the given limit
-	 *         if the text is alread shorter than the limit or if the limit is negative, the text
-	 *         will be returned without any checks for balance of tags
+	 * @param int $lim
+	 * @param string $text
+	 *
+	 * @return string the truncated text; note that in some cases it may be slightly longer than the given limit
+	 * if the text is alread shorter than the limit or if the limit is negative, the text
+	 * will be returned without any checks for balance of tags
 	 */
 	private function cutAt( $lim, $text ) {
 		if ( $lim < 0 ) {
 			return $text;
 		}
+
 		return LST::limitTranscludedText( $text, $lim );
 	}
 
 	/**
 	 * Prepends an image name with its hash path.
 	 *
-	 * @protected
-	 * @param 	mixed	\DPL\Article or string image name of the image (may start with Image: or File:).
-	 * @return	string	Image URL
+	 * @param Article|string $article
+	 * @return string
 	 */
 	protected function parseImageUrlWithPath( $article ) {
+		$repoGroup = MediaWikiServices::getInstance()->getRepoGroup();
+
 		$imageUrl = '';
-		if ( $article instanceof \DPL\Article ) {
+		if ( $article instanceof Article ) {
 			if ( $article->mNamespace == NS_FILE ) {
 				// calculate URL for existing images
-				// $img = Image::newFromName($article->mTitle->getText());
-				$img = wfFindFile( \Title::makeTitle( NS_FILE, $article->mTitle->getText() ) );
+				// $img = Image::newFromName( $article->mTitle->getText() );
+
+				$img = $repoGroup->findFile( Title::makeTitle( NS_FILE, $article->mTitle->getText() ) );
 				if ( $img && $img->exists() ) {
 					$imageUrl = $img->getURL();
 				} else {
-					$fileTitle = \Title::makeTitleSafe( NS_FILE, $article->mTitle->getDBKey() );
-					$imageUrl = \RepoGroup::singleton()->getLocalRepo()->newFile( $fileTitle )->getPath();
+					$fileTitle = Title::makeTitleSafe( NS_FILE, $article->mTitle->getDBKey() );
+					$imageUrl = $repoGroup->getLocalRepo()->newFile( $fileTitle )->getPath();
 				}
 			}
 		} else {
-			$title = \Title::newfromText( 'File:' . $article );
+			$title = Title::newfromText( 'File:' . $article );
+
 			if ( $title !== null ) {
-				$fileTitle   = \Title::makeTitleSafe( 6, $title->getDBKey() );
-				$imageUrl = \RepoGroup::singleton()->getLocalRepo()->newFile( $fileTitle )->getPath();
+				$fileTitle = Title::makeTitleSafe( 6, $title->getDBKey() );
+
+				$imageUrl = $repoGroup->getLocalRepo()->newFile( $fileTitle )->getPath();
 			}
 		}
 
-		//@TODO: Check this preg_replace.  Probably only works for stock file repositories.  --Alexia
+		// @TODO: Check this preg_replace. Probably only works for stock file repositories.
 		$imageUrl = preg_replace( '~^.*images/(.*)~', '\1', $imageUrl );
 
 		return $imageUrl;
@@ -1044,36 +1003,43 @@ protected function parseImageUrlWithPath( $article ) {
 	/**
 	 * Transclude a page contents.
 	 *
-	 * @access	public
-	 * @param	object	\DPL\Article
-	 * @param	integer	Filtered Article Count
-	 * @return	string	Page Text
+	 * @param Article $article
+	 * @param int &$filteredCount
+	 * @return string
 	 */
 	public function transcludePage( Article $article, &$filteredCount ) {
 		$matchFailed = false;
+		$septag = [];
+
 		if ( empty( $this->pageTextMatch ) || $this->pageTextMatch[0] == '*' ) { // include whole article
 			$title = $article->mTitle->getPrefixedText();
+
 			if ( $this->getStyle() == self::LIST_USERFORMAT ) {
 				$pageText = '';
 			} else {
 				$pageText = '<br/>';
 			}
-			$text = $this->parser->fetchTemplate( \Title::newFromText( $title ) );
-			if ( ( count( $this->pageTextMatchRegex ) <= 0 || $this->pageTextMatchRegex[0] == '' || !preg_match( $this->pageTextMatchRegex[0], $text ) == false ) && ( count( $this->pageTextMatchNotRegex ) <= 0 || $this->pageTextMatchNotRegex[0] == '' || preg_match( $this->pageTextMatchNotRegex[0], $text ) == false ) ) {
+
+			$text = $this->parser->fetchTemplateAndTitle( Title::newFromText( $title ) )[0];
+			if ( ( count( $this->pageTextMatchRegex ) <= 0 || $this->pageTextMatchRegex[0] == '' || !( !preg_match( $this->pageTextMatchRegex[0], $text ) ) ) && ( count( $this->pageTextMatchNotRegex ) <= 0 || $this->pageTextMatchNotRegex[0] == '' || preg_match( $this->pageTextMatchNotRegex[0], $text ) == false ) ) {
 				if ( $this->includePageMaxLength > 0 && ( strlen( $text ) > $this->includePageMaxLength ) ) {
 					$text = LST::limitTranscludedText( $text, $this->includePageMaxLength, ' [[' . $title . '|..]]' );
 				}
-				$filteredCount = $filteredCount + 1;
+
+				$filteredCount++;
 
 				// update article if include=* and updaterules are given
 				$updateRules = $this->getParameters()->getParameter( 'updaterules' );
 				$deleteRules = $this->getParameters()->getParameter( 'deleterules' );
+
 				if ( !empty( $updateRules ) ) {
 					$ruleOutput = UpdateArticle::updateArticleByRule( $title, $text, $updateRules );
+
 					// append update message to output
 					$pageText .= $ruleOutput;
 				} elseif ( !empty( $deleteRules ) ) {
 					$ruleOutput = UpdateArticle::deleteArticleByRule( $title, $text, $deleteRules );
+
 					// append delete message to output
 					$pageText .= $ruleOutput;
 				} else {
@@ -1083,6 +1049,7 @@ public function transcludePage( Article $article, &$filteredCount ) {
 						$pieces = [
 							0 => $text
 						];
+
 						$this->replaceTagTableRow( $pieces, 0, $article );
 						$pageText .= $pieces[0];
 					} else {
@@ -1094,17 +1061,20 @@ public function transcludePage( Article $article, &$filteredCount ) {
 			}
 		} else {
 			// identify section pieces
-			$secPiece       = [];
+			$secPiece = [];
 			$dominantPieces = false;
+
 			// ONE section can be marked as "dominant"; if this section contains multiple entries
 			// we will create a separate output row for each value of the dominant section
 			// the values of all other columns will be repeated
 
 			foreach ( $this->pageTextMatch as $s => $sSecLabel ) {
 				$sSecLabel = trim( $sSecLabel );
+
 				if ( $sSecLabel == '' ) {
 					break;
 				}
+
 				// if sections are identified by number we have a % at the beginning
 				if ( $sSecLabel[0] == '%' ) {
 					$sSecLabel = '#' . $sSecLabel;
@@ -1117,29 +1087,36 @@ public function transcludePage( Article $article, &$filteredCount ) {
 					$secPieces = [
 						''
 					];
+
 					$this->replaceTagTableRow( $secPieces, $s, $article );
 				} elseif ( $sSecLabel[0] != '{' ) {
-					$limpos      = strpos( $sSecLabel, '[' );
-					$cutLink     = 'default';
+					$limpos = strpos( $sSecLabel, '[' );
+					$cutLink = 'default';
 					$skipPattern = [];
+
 					if ( $limpos > 0 && $sSecLabel[strlen( $sSecLabel ) - 1] == ']' ) {
 						// regular expressions which define a skip pattern may precede the text
 						$fmtSec = explode( '~', substr( $sSecLabel, $limpos + 1, strlen( $sSecLabel ) - $limpos - 2 ) );
 						$sSecLabel = substr( $sSecLabel, 0, $limpos );
-						$cutInfo = explode( " ", $fmtSec[count( $fmtSec ) - 1], 2 );
+						$cutInfo = explode( ' ', $fmtSec[count( $fmtSec ) - 1], 2 );
 						$maxLength = intval( $cutInfo[0] );
+
 						if ( array_key_exists( '1', $cutInfo ) ) {
 							$cutLink = $cutInfo[1];
 						}
+
 						foreach ( $fmtSec as $skipKey => $skipPat ) {
 							if ( $skipKey == count( $fmtSec ) - 1 ) {
 								continue;
 							}
+
 							$skipPattern[] = $skipPat;
 						}
 					}
+
 					if ( $maxLength < 0 ) {
-						$maxLength = -1; // without valid limit include whole section
+						// without valid limit include whole section
+						$maxLength = -1;
 					}
 				}
 
@@ -1149,6 +1126,7 @@ public function transcludePage( Article $article, &$filteredCount ) {
 				} else {
 					$mustMatch = '';
 				}
+
 				if ( is_array( $this->pageTextMatchNotRegex ) && count( $this->pageTextMatchNotRegex ) > $s && !empty( $this->pageTextMatchNotRegex[$s] ) ) {
 					$mustNotMatch = $this->pageTextMatchNotRegex[$s];
 				} else {
@@ -1156,23 +1134,30 @@ public function transcludePage( Article $article, &$filteredCount ) {
 				}
 
 				// if chapters are selected by number, text or regexp we get the heading from LST::includeHeading
+				$sectionHeading = [];
 				$sectionHeading[0] = '';
+
 				if ( $sSecLabel == '-' ) {
 					$secPiece[$s] = $secPieces[0];
 				} elseif ( $sSecLabel[0] == '#' || $sSecLabel[0] == '@' ) {
 					$sectionHeading[0] = substr( $sSecLabel, 1 );
+
 					// Uses LST::includeHeading() from LabeledSectionTransclusion extension to include headings from the page
-					$secPieces = LST::includeHeading( $this->parser, $article->mTitle->getPrefixedText(), substr( $sSecLabel, 1 ), '', $sectionHeading, false, $maxLength, $cutLink, $this->getTrimIncluded(), $skipPattern );
+					$secPieces = LST::includeHeading( $this->parser, $article->mTitle->getPrefixedText(), substr( $sSecLabel, 1 ), '', $sectionHeading, false, $maxLength, $cutLink ?? 'default', $this->getTrimIncluded(), $skipPattern ?? [] );
+
 					if ( $mustMatch != '' || $mustNotMatch != '' ) {
 						$secPiecesTmp = $secPieces;
-						$offset       = 0;
+						$offset = 0;
+
 						foreach ( $secPiecesTmp as $nr => $onePiece ) {
 							if ( ( $mustMatch != '' && preg_match( $mustMatch, $onePiece ) == false ) || ( $mustNotMatch != '' && preg_match( $mustNotMatch, $onePiece ) != false ) ) {
 								array_splice( $secPieces, $nr - $offset, 1 );
+
 								$offset++;
 							}
 						}
 					}
+
 					// if maxlen was 0 we suppress all output; note that for matching we used the full text
 					if ( $maxLength == 0 ) {
 						$secPieces = [
@@ -1189,18 +1174,22 @@ public function transcludePage( Article $article, &$filteredCount ) {
 						}
 						break;
 					}
+
 					$secPiece[$s] = $secPieces[0];
 					for ( $sp = 1; $sp < count( $secPieces ); $sp++ ) {
 						if ( isset( $this->multiSectionSeparators[$s] ) ) {
-							$secPiece[$s] .= str_replace( '%SECTION%', $sectionHeading[$sp], $this->replaceTagCount( $this->multiSectionSeparators[$s], $filteredCount ) );
+							$secPiece[$s] .= str_replace( '%SECTION%', $sectionHeading[$sp] ?? '', $this->replaceTagCount( $this->multiSectionSeparators[$s], $filteredCount ) );
 						}
+
 						$secPiece[$s] .= $secPieces[$sp];
 					}
+
 					if ( $this->getDominantSectionCount() >= 0 && $s == $this->getDominantSectionCount() && count( $secPieces ) > 1 ) {
 						$dominantPieces = $secPieces;
 					}
+
 					if ( ( $mustMatch != '' || $mustNotMatch != '' ) && count( $secPieces ) <= 0 ) {
-						$matchFailed = true; // NOTHING MATCHED
+						$matchFailed = true;
 						break;
 					}
 
@@ -1209,28 +1198,34 @@ public function transcludePage( Article $article, &$filteredCount ) {
 					// primary syntax {template}suffix
 					$template1 = trim( substr( $sSecLabel, 1, strpos( $sSecLabel, '}' ) - 1 ) );
 					$template2 = trim( str_replace( '}', '', substr( $sSecLabel, 1 ) ) );
+
 					// alternate syntax: {template|surrogate}
 					if ( $template2 == $template1 && strpos( $template1, '|' ) > 0 ) {
 						$template1 = preg_replace( '/\|.*/', '', $template1 );
 						$template2 = preg_replace( '/^.+\|/', '', $template2 );
 					}
-					//Why the hell was defaultTemplateSuffix be passed all over the place for just fucking here?  --Alexia
-					$secPieces    = LST::includeTemplate( $this->parser, $this, $s, $article, $template1, $template2, $template2 . $this->getTemplateSuffix(), $mustMatch, $mustNotMatch, $this->includePageParsed, implode( ', ', $article->mCategoryLinks ) );
+
+					// Why was defaultTemplateSuffix passed all over the place for just here?
+					$secPieces = LST::includeTemplate( $this->parser, $this, $s, $article, $template1, $template2, $template2 . $this->getTemplateSuffix(), $mustMatch, $mustNotMatch, $this->includePageParsed, implode( ', ', $article->mCategoryLinks ) );
 					$secPiece[$s] = implode( isset( $this->multiSectionSeparators[$s] ) ? $this->replaceTagCount( $this->multiSectionSeparators[$s], $filteredCount ) : '', $secPieces );
+
 					if ( $this->getDominantSectionCount() >= 0 && $s == $this->getDominantSectionCount() && count( $secPieces ) > 1 ) {
 						$dominantPieces = $secPieces;
 					}
+
 					if ( ( $mustMatch != '' || $mustNotMatch != '' ) && count( $secPieces ) <= 1 && $secPieces[0] == '' ) {
-						$matchFailed = true; // NOTHING MATCHED
+						$matchFailed = true;
 						break;
 					}
 				} else {
 					// Uses LST::includeSection() from LabeledSectionTransclusion extension to include labeled sections from the page
-					$secPieces    = LST::includeSection( $this->parser, $article->mTitle->getPrefixedText(), $sSecLabel, '', false, $this->getTrimIncluded(), $skipPattern );
+					$secPieces = LST::includeSection( $this->parser, $article->mTitle->getPrefixedText(), $sSecLabel, '', false, $this->getTrimIncluded(), $skipPattern ?? [] );
 					$secPiece[$s] = implode( isset( $this->multiSectionSeparators[$s] ) ? $this->replaceTagCount( $this->multiSectionSeparators[$s], $filteredCount ) : '', $secPieces );
+
 					if ( $this->getDominantSectionCount() >= 0 && $s == $this->getDominantSectionCount() && count( $secPieces ) > 1 ) {
 						$dominantPieces = $secPieces;
 					}
+
 					if ( ( $mustMatch != '' && preg_match( $mustMatch, $secPiece[$s] ) == false ) || ( $mustNotMatch != '' && preg_match( $mustNotMatch, $secPiece[$s] ) != false ) ) {
 						$matchFailed = true;
 						break;
@@ -1246,6 +1241,7 @@ public function transcludePage( Article $article, &$filteredCount ) {
 				} else {
 					$septag[$s * 2] = '';
 				}
+
 				if ( isset( $this->sectionSeparators[$s * 2 + 1] ) ) {
 					$septag[$s * 2 + 1] = str_replace( '%SECTION%', $sectionHeading[0], $this->replaceTagCount( $this->sectionSeparators[$s * 2 + 1], $filteredCount ) );
 				} else {
@@ -1257,10 +1253,12 @@ public function transcludePage( Article $article, &$filteredCount ) {
 			if ( $matchFailed ) {
 				return '';
 			}
-			$filteredCount = $filteredCount + 1;
+
+			$filteredCount++;
 
 			// assemble parts with separators
 			$pageText = '';
+
 			if ( $dominantPieces != false ) {
 				foreach ( $dominantPieces as $dominantPiece ) {
 					foreach ( $secPiece as $s => $piece ) {
@@ -1277,17 +1275,17 @@ public function transcludePage( Article $article, &$filteredCount ) {
 				}
 			}
 		}
+
 		return $pageText;
 	}
 
 	/**
 	 * Wrap seciton pieces with start and end tags.
 	 *
-	 * @protected
-	 * @param	string	Piece to be wrapped.
-	 * @param	string	Text to prepend.
-	 * @param	string	Text to append.
-	 * @return	string	Wrapped text.
+	 * @param string $piece
+	 * @param string $start
+	 * @param string $end
+	 * @return string
 	 */
 	protected function joinSectionTagPieces( $piece, $start, $end ) {
 		return $start . $piece . $end;
@@ -1296,8 +1294,7 @@ protected function joinSectionTagPieces( $piece, $start, $end ) {
 	/**
 	 * Get the count of listed items after formatting, transcluding, and such.
 	 *
-	 * @access	public
-	 * @return	integer	Row Count
+	 * @return int
 	 */
 	public function getRowCount() {
 		return $this->rowCount;
diff --git a/includes/lister/OrderedList.php b/includes/lister/OrderedList.php
index aba636e3..d1de1ae0 100644
--- a/includes/lister/OrderedList.php
+++ b/includes/lister/OrderedList.php
@@ -1,12 +1,4 @@
 <?php
-/**
- * DynamicPageList3
- * DPL OrderedList Class
- *
- * @license		GPL-2.0-or-later
- * @package		DynamicPageList3
- *
- */
 
 namespace DPL\Lister;
 
@@ -14,7 +6,7 @@ class OrderedList extends UnorderedList {
 	/**
 	 * Listing style for this class.
 	 *
-	 * @var constant
+	 * @var int
 	 */
 	public $style = parent::LIST_ORDERED;
 
@@ -42,31 +34,30 @@ class OrderedList extends UnorderedList {
 	/**
 	 * Format the list of articles.
 	 *
-	 * @access	public
-	 * @param	array	List of \DPL\Article
-	 * @param	integer	Start position of the array to process.
-	 * @param	integer	Total objects from the array to process.
-	 * @return	string	Formatted list.
+	 * @param array $articles
+	 * @param int $start
+	 * @param int $count
+	 * @return string
 	 */
 	public function formatList( $articles, $start, $count ) {
 		$this->offsetCount = $count;
+
 		return parent::formatList( $articles, $start, $count );
 	}
 
 	/**
 	 * Return $this->listStart with attributes replaced.
 	 *
-	 * @access	public
-	 * @return	string	List Start
+	 * @return string
 	 */
 	public function getListStart() {
 		// increase start value of ordered lists at multi-column output
-		//The offset that comes from the URL parameter is zero based, but has to be +1'ed for display.
+		// The offset that comes from the URL parameter is zero based, but has to be +1'ed for display.
 		$offset = $this->getParameters()->getParameter( 'offset' ) + 1;
 
 		if ( $offset != 0 ) {
-			//@TODO: So this adds the total count of articles to the offset.  I have not found a case where this does not mess up the displayed count.  I am commenting this out for now.
-			//$offset += $this->offsetCount;
+			// @TODO: So this adds the total count of articles to the offset. I have not found a case where this does not mess up the displayed count. I am commenting this out for now.
+			// $offset += $this->offsetCount;
 		}
 
 		return sprintf( $this->listStart, $this->listAttributes . ' start="' . $offset . '"' );
diff --git a/includes/lister/SubPageList.php b/includes/lister/SubPageList.php
index b42e8c09..574acb21 100644
--- a/includes/lister/SubPageList.php
+++ b/includes/lister/SubPageList.php
@@ -1,12 +1,4 @@
 <?php
-/**
- * DynamicPageList3
- * DPL SubPageList Class
- *
- * @license		GPL-2.0-or-later
- * @package		DynamicPageList3
- *
- */
 
 namespace DPL\Lister;
 
@@ -14,7 +6,7 @@ class SubPageList extends UnorderedList {
 	/**
 	 * Listing style for this class.
 	 *
-	 * @var constant
+	 * @var int
 	 */
 	public $style = parent::LIST_UNORDERED;
 
@@ -49,17 +41,18 @@ class SubPageList extends UnorderedList {
 	/**
 	 * Format a list of articles into a singular list.
 	 *
-	 * @access	public
-	 * @param	array	List of \DPL\Article
-	 * @param	integer	Start position of the array to process.
-	 * @param	integer	Total objects from the array to process.
-	 * @return	string	Formatted list.
+	 * @param array $articles
+	 * @param int $start
+	 * @param int $count
+	 * @return string
 	 */
 	public function formatList( $articles, $start, $count ) {
 		$filteredCount = 0;
 		$items = [];
+
 		for ( $i = $start; $i < $start + $count; $i++ ) {
 			$article = $articles[$i];
+
 			if ( empty( $article ) || empty( $article->mTitle ) ) {
 				continue;
 			}
@@ -84,22 +77,26 @@ public function formatList( $articles, $start, $count ) {
 	/**
 	 * Nest items down to the proper level.
 	 *
-	 * @private
-	 * @param	array	Part levels to nest down to.
-	 * @param	array	Items holder to nest the item into.
-	 * @param	string	Formatted Item
-	 * @return	array	Nest Items
+	 * @param array &$parts
+	 * @param array $items
+	 * @param string $item
+	 * @return array
 	 */
 	private function nestItem( &$parts, $items, $item ) {
 		$firstPart = reset( $parts );
+
 		if ( count( $parts ) > 1 ) {
 			array_shift( $parts );
+
 			if ( !isset( $items[$firstPart] ) ) {
 				$items[$firstPart] = [];
 			}
+
 			$items[$firstPart] = $this->nestItem( $parts, $items[$firstPart], $item );
+
 			return $items;
 		}
+
 		$items[$firstPart][] = $item;
 
 		return $items;
@@ -108,21 +105,23 @@ private function nestItem( &$parts, $items, $item ) {
 	/**
 	 * Join together items after being processed by formatItem().
 	 *
-	 * @protected
-	 * @param	array	Items as formatted by formatItem().
-	 * @return	string	Imploded items.
+	 * @param array $items
+	 * @return string
 	 */
 	protected function implodeItems( $items ) {
 		$list = '';
+
 		foreach ( $items as $key => $item ) {
 			if ( is_string( $item ) ) {
 				$list .= $item;
 				continue;
 			}
+
 			if ( is_array( $item ) ) {
 				$list .= $this->getItemStart() . $key . $this->getListStart() . $this->implodeItems( $item ) . $this->listEnd . $this->getItemEnd();
 			}
 		}
+
 		return $list;
 	}
 }
diff --git a/includes/lister/UnorderedList.php b/includes/lister/UnorderedList.php
index 0c7c6e43..05d850fe 100644
--- a/includes/lister/UnorderedList.php
+++ b/includes/lister/UnorderedList.php
@@ -1,12 +1,4 @@
 <?php
-/**
- * DynamicPageList3
- * DPL UnorderedList Class
- *
- * @license		GPL-2.0-or-later
- * @package		DynamicPageList3
- *
- */
 
 namespace DPL\Lister;
 
@@ -14,7 +6,7 @@ class UnorderedList extends Lister {
 	/**
 	 * Listing style for this class.
 	 *
-	 * @var constant
+	 * @var int
 	 */
 	public $style = parent::LIST_UNORDERED;
 
diff --git a/includes/lister/UserFormatList.php b/includes/lister/UserFormatList.php
index 7aa8faff..7f379c92 100644
--- a/includes/lister/UserFormatList.php
+++ b/includes/lister/UserFormatList.php
@@ -1,22 +1,16 @@
 <?php
-/**
- * DynamicPageList3
- * DPL UserFormatList Class
- *
- * @license		GPL-2.0-or-later
- * @package		DynamicPageList3
- *
- */
 
 namespace DPL\Lister;
 
 use DPL\Article;
+use DPL\Parameters;
+use Parser;
 
 class UserFormatList extends Lister {
 	/**
 	 * Listing style for this class.
 	 *
-	 * @var constant
+	 * @var int
 	 */
 	public $style = parent::LIST_USERFORMAT;
 
@@ -28,26 +22,27 @@ class UserFormatList extends Lister {
 	protected $textSeparator = '';
 
 	/**
-	 * Main Constructor
-	 *
-	 * @access	public
-	 * @param	object	\DPL\Parameters
-	 * @param	object	MediaWiki \Parser
-	 * @return	void
+	 * @param Parameters $parameters
+	 * @param Parser $parser
 	 */
-	public function __construct( \DPL\Parameters $parameters, \Parser $parser ) {
+	public function __construct( Parameters $parameters, Parser $parser ) {
 		parent::__construct( $parameters, $parser );
+
 		$this->textSeparator = $parameters->getParameter( 'inlinetext' );
 		$listSeparators = $parameters->getParameter( 'listseparators' );
+
 		if ( isset( $listSeparators[0] ) ) {
 			$this->listStart = $listSeparators[0];
 		}
+
 		if ( isset( $listSeparators[1] ) ) {
 			$this->itemStart = $listSeparators[1];
 		}
+
 		if ( isset( $listSeparators[2] ) ) {
 			$this->itemEnd = $listSeparators[2];
 		}
+
 		if ( isset( $listSeparators[3] ) ) {
 			$this->listEnd = $listSeparators[3];
 		}
@@ -56,17 +51,18 @@ public function __construct( \DPL\Parameters $parameters, \Parser $parser ) {
 	/**
 	 * Format the list of articles.
 	 *
-	 * @access	public
-	 * @param	array	List of \DPL\Article
-	 * @param	integer	Start position of the array to process.
-	 * @param	integer	Total objects from the array to process.
-	 * @return	string	Formatted list.
+	 * @param array $articles
+	 * @param int $start
+	 * @param int $count
+	 * @return string
 	 */
 	public function formatList( $articles, $start, $count ) {
 		$filteredCount = 0;
 		$items = [];
+
 		for ( $i = $start; $i < $start + $count; $i++ ) {
 			$article = $articles[$i];
+
 			if ( empty( $article ) || empty( $article->mTitle ) ) {
 				continue;
 			}
@@ -86,13 +82,16 @@ public function formatList( $articles, $start, $count ) {
 		$this->rowCount = $filteredCount;
 
 		// if requested we sort the table by the contents of a given column
-		$sortColumn	= $this->getTableSortColumn();
+		$sortColumn = $this->getTableSortColumn();
 		if ( $sortColumn != 0 ) {
 			$rowsKey = [];
+
 			foreach ( $items as $index => $item ) {
 				$item = trim( $item );
+
 				if ( strpos( $item, '|-' ) === 0 ) {
 					$item = explode( '|-', $item, 2 );
+
 					if ( count( $item ) == 2 ) {
 						$item = $item[1];
 					} else {
@@ -100,25 +99,33 @@ public function formatList( $articles, $start, $count ) {
 						continue;
 					}
 				}
+
 				if ( strlen( $item ) > 0 ) {
 					$word = explode( "\n|", $item );
+
 					if ( isset( $word[0] ) && empty( $word[0] ) ) {
 						array_shift( $word );
 					}
+
 					if ( isset( $word[abs( $sortColumn ) - 1] ) ) {
 						$test = trim( $word[abs( $sortColumn ) - 1] );
+
 						if ( strpos( $test, '|' ) > 0 ) {
 							$test = trim( explode( '|', $test )[1] );
 						}
+
 						$rowsKey[$index] = $test;
 					}
 				}
 			}
-			$this->sort($rowsKey, $sortColumn);
+
+			$this->sort( $rowsKey, $sortColumn );
 			$newItems = [];
+
 			foreach ( $rowsKey as $index => $val ) {
 				$newItems[] = $items[$index];
 			}
+
 			$items = $newItems;
 		}
 
@@ -128,36 +135,34 @@ public function formatList( $articles, $start, $count ) {
 	/**
 	 * Sort the data of a table column in place. Preserves array keys.
 	 *
-	 * @access	public
-	 * @param	array	Table column data
-	 * @param	int		Index of the column to sort
-	 * @return	void
+	 * @param array	&$rowsKey
+	 * @param int $sortColumn
 	 */
-	protected function sort(&$rowsKey, $sortColumn) {
+	protected function sort( &$rowsKey, $sortColumn ) {
 		$sortMethod = $this->getTableSortMethod();
-	
-		if ($sortColumn < 0) {
-			switch ($sortMethod) {
+
+		if ( $sortColumn < 0 ) {
+			switch ( $sortMethod ) {
 				case 'natural':
 					// Reverse natsort()
-                    uasort($rowsKey, function($first, $second) {
-                    	return strnatcmp($second, $first);
-					});
+					uasort( $rowsKey, static function ( $first, $second ) {
+						return strnatcmp( $second, $first );
+					} );
 					break;
 				case 'standard':
 				default:
-					arsort($rowsKey);
+					arsort( $rowsKey );
 					break;
 			}
 		} else {
-			switch ($sortMethod) {
+			switch ( $sortMethod ) {
 				case 'natural':
-				natsort($rowsKey);
-				break;
-			case 'standard':
-			default:
-				asort($rowsKey);
-				break;
+					natsort( $rowsKey );
+					break;
+				case 'standard':
+				default:
+					asort( $rowsKey );
+					break;
 			}
 		}
 	}
@@ -165,16 +170,15 @@ protected function sort(&$rowsKey, $sortColumn) {
 	/**
 	 * Format a single item.
 	 *
-	 * @access	public
-	 * @param	object	DPL\Article
-	 * @param	string	[Optional] Page text to include.
-	 * @return	string	Item HTML
+	 * @param Article $article
+	 * @param string|null $pageText
+	 * @return string
 	 */
 	public function formatItem( Article $article, $pageText = null ) {
 		$item = '';
 
 		if ( $pageText !== null ) {
-			//Include parsed/processed wiki markup content after each item before the closing tag.
+			// Include parsed/processed wiki markup content after each item before the closing tag.
 			$item .= $pageText;
 		}
 
@@ -188,8 +192,7 @@ public function formatItem( Article $article, $pageText = null ) {
 	/**
 	 * Return $this->itemStart with attributes replaced.
 	 *
-	 * @access	public
-	 * @return	string	Item Start
+	 * @return string
 	 */
 	public function getItemStart() {
 		return $this->replaceTagCount( $this->itemStart, $this->getRowCount() );
@@ -198,8 +201,7 @@ public function getItemStart() {
 	/**
 	 * Return $this->itemEnd with attributes replaced.
 	 *
-	 * @access	public
-	 * @return	string	Item End
+	 * @return string
 	 */
 	public function getItemEnd() {
 		return $this->replaceTagCount( $this->itemEnd, $this->getRowCount() );
@@ -208,9 +210,8 @@ public function getItemEnd() {
 	/**
 	 * Join together items after being processed by formatItem().
 	 *
-	 * @access	public
-	 * @param	array	Items as formatted by formatItem().
-	 * @return	string	Imploded items.
+	 * @param array $items
+	 * @return string
 	 */
 	protected function implodeItems( $items ) {
 		return implode( $this->textSeparator, $items );
diff --git a/maintenance/createTemplate.php b/maintenance/createTemplate.php
index f4f30268..edde9cb3 100644
--- a/maintenance/createTemplate.php
+++ b/maintenance/createTemplate.php
@@ -1,21 +1,13 @@
 <?php
-/**
- * DynamicPageList3
- * CreateTemplate
- *
- * @license GPL-2.0-or-later
- * @package DynamicPageList3
- *
- */
 
 namespace DPL\Maintenance;
 
 use CommentStoreComment;
 use LoggedUpdateMaintenance;
+use MediaWiki\MediaWikiServices;
 use MediaWiki\Revision\SlotRecord;
 use Title;
 use User;
-use WikiPage;
 
 $IP = getenv( 'MW_INSTALL_PATH' );
 if ( $IP === false ) {
@@ -31,6 +23,7 @@ class CreateTemplate extends LoggedUpdateMaintenance {
 
 	public function __construct() {
 		parent::__construct();
+
 		$this->addDescription( 'Handle inserting DPL\'s necessary template for content inclusion.' );
 	}
 
@@ -62,11 +55,14 @@ protected function doDBUpdates() {
 
 		// Make sure template does not already exist
 		if ( !$title->exists() ) {
-			$wikipage = WikiPage::factory( $title );
-			$updater = $wikipage->newPageUpdater( User::newSystemUser( 'DynamicPageList3 extension' ) );
-			$content = $wikipage->getContentHandler()->makeContent( '<noinclude>This page was automatically created.  It serves as an anchor page for all \'\'\'[[Special:WhatLinksHere/Template:Extension_DPL|invocations]]\'\'\' of [https://www.mediawiki.org/wiki/Special:MyLanguage/Extension:DynamicPageList3 Extension:DynamicPageList3].</noinclude>', $title );
+			$wikiPageFactory = MediaWikiServices::getInstance()->getWikiPageFactory();
+
+			$page = $wikiPageFactory->newFromTitle( $title );
+			$updater = $page->newPageUpdater( User::newSystemUser( 'DynamicPageList3 extension' ) );
+			$content = $page->getContentHandler()->makeContent( '<noinclude>This page was automatically created. It serves as an anchor page for all \'\'\'[[Special:WhatLinksHere/Template:Extension_DPL|invocations]]\'\'\' of [https://www.mediawiki.org/wiki/Special:MyLanguage/Extension:DynamicPageList3 Extension:DynamicPageList3].</noinclude>', $title );
 			$updater->setContent( SlotRecord::MAIN, $content );
 			$comment = CommentStoreComment::newUnsavedComment( 'Autogenerated DPL\'s necessary template for content inclusion' );
+
 			$updater->saveRevision(
 				$comment,
 				EDIT_NEW | EDIT_FORCE_BOT
diff --git a/tests/phpunit/DPLIntegrationTestCase.php b/tests/phpunit/DPLIntegrationTestCase.php
new file mode 100644
index 00000000..e8a49d61
--- /dev/null
+++ b/tests/phpunit/DPLIntegrationTestCase.php
@@ -0,0 +1,158 @@
+<?php
+
+namespace DPL;
+
+use DOMDocument;
+use DOMXPath;
+use ImportStreamSource;
+use MediaWiki\Auth\AuthManager;
+use MediaWiki\MediaWikiServices;
+use MediaWiki\User\UserFactory;
+use MediaWikiTestCase;
+use ParserOptions;
+use RequestContext;
+use Title;
+use User;
+use WikiImporter;
+
+abstract class DPLIntegrationTestCase extends MediaWikiTestCase {
+	/**
+	 * Guard condition to ensure we only import seed data once per test suite run.
+	 * @var bool
+	 */
+	private static $wasSeedDataImported = false;
+
+	public function addDBData() {
+		if ( self::$wasSeedDataImported ) {
+			return;
+		}
+
+		$seedDataPath = __DIR__ . '/../seed-data.xml';
+		$this->seedTestUsers( $seedDataPath );
+		$importer = $this->getWikiImporter( $seedDataPath );
+		$importer->disableStatisticsUpdate();
+		// Ensure we actually create local user accounts in the DB
+		$importer->setUsernamePrefix( '', true );
+		$importer->doImport();
+
+		self::$wasSeedDataImported = true;
+	}
+
+	/**
+	 * Import test accounts from seed data so that DPL queries can refer to them.
+	 * @param string $seedDataPath - path to seed data to be loaded
+	 */
+	private function seedTestUsers( string $seedDataPath ): void {
+		$doc = new DOMDocument();
+		$doc->preserveWhiteSpace = false;
+		$doc->load( $seedDataPath );
+
+		$xpath = new DOMXPath( $doc );
+		$xpath->registerNamespace( 'mw', 'http://www.mediawiki.org/xml/export-0.11/' );
+
+		$userNodes = $xpath->query( '//mw:mediawiki/mw:page/mw:revision/mw:contributor/mw:username' );
+		$usersByName = [];
+
+		$authManager = $this->getAuthManager();
+
+		foreach ( $userNodes as $node ) {
+			$userName = $node->nodeValue;
+
+			// Already created
+			if ( isset( $usersByName[$userName] ) ) {
+				continue;
+			}
+
+			$usersByName[$userName] = true;
+			$user = $this->newUserFromName( $userName );
+
+			if ( !$user || $user->idForName() !== 0 ) {
+				return; // sanity
+			}
+
+			$status = $authManager->autoCreateUser(
+				$user,
+				$authManager::AUTOCREATE_SOURCE_MAINT,
+				false
+			);
+
+			if ( !$status->isOK() ) {
+				return;
+			}
+		}
+	}
+
+	private function getWikiImporter( string $seedDataPath ): WikiImporter {
+		$seedDataFile = fopen( $seedDataPath, 'rt' );
+		$source = new ImportStreamSource( $seedDataFile );
+		$services = MediaWikiServices::getInstance();
+
+		if ( $services->hasService( 'WikiImporterFactory' ) ) {
+			return $services->getWikiImporterFactory()->getWikiImporter( $source );
+		}
+
+		// MW 1.36
+		return new WikiImporter( $source, $services->getMainConfig() );
+	}
+
+	private function getAuthManager(): AuthManager {
+		$services = MediaWikiServices::getInstance();
+
+		return $services->getAuthManager();
+	}
+
+	private function newUserFromName( string $name ): ?User {
+		$services = MediaWikiServices::getInstance();
+
+		return $services->getUserFactory()->newFromName( $name, UserFactory::RIGOR_CREATABLE );
+	}
+
+	/**
+	 * Convenience function to return the list of page titles matching a DPL query
+	 * @param array $params - DPL invocation parameters
+	 * @return string[]
+	 */
+	protected function getDPLQueryResults( array $params, string $format = '%PAGE%' ): array {
+		$params += [
+			// Use a custom format for executing the query to allow easily extracting results
+			'format' => "<div id=\"dpl-test-query\">,$format,|,</div>"
+		];
+
+		$html = $this->runDPLQuery( $params );
+		$doc = new DOMDocument();
+		$doc->loadHTML( $html );
+		$queryResults = $doc->getElementById( 'dpl-test-query' );
+		if ( $queryResults ) {
+			return explode( "|", rtrim( $queryResults->textContent, "|" ) );
+		}
+
+		return [];
+	}
+
+	/**
+	 * Build and execute a DPL invocation using the given parameters and return the HTML output.
+	 * @param array $params
+	 * @return string
+	 */
+	protected function runDPLQuery( array $params ): string {
+		$invocation = '<dpl>';
+
+		foreach ( $params as $paramName => $values ) {
+			$values = (array)$values; // multi-value parameters
+			foreach ( $values as $value ) {
+				$invocation .= "$paramName=$value\n";
+			}
+		}
+
+		$invocation .= '</dpl>';
+
+		$parser = MediaWikiServices::getInstance()->getParser();
+		$title = Title::makeTitle( NS_MAIN, 'DPLQueryTest' );
+		$parserOptions = ParserOptions::newCanonical(
+			RequestContext::getMain()
+		);
+		$parserOutput = $parser->parse( $invocation, $title, $parserOptions );
+
+		return $parserOutput->getText();
+	}
+}
diff --git a/tests/phpunit/DPLQueryIntegrationTest.php b/tests/phpunit/DPLQueryIntegrationTest.php
new file mode 100644
index 00000000..dcd78536
--- /dev/null
+++ b/tests/phpunit/DPLQueryIntegrationTest.php
@@ -0,0 +1,350 @@
+<?php
+
+namespace DPL;
+
+/**
+ * @group DynamicPageList3
+ * @group Database
+ */
+class DPLQueryIntegrationTest extends DPLIntegrationTestCase {
+
+	public function testFindPagesInCategory(): void {
+		$this->assertArrayEquals(
+			[ 'DPLTestArticle 1', 'DPLTestArticle 2', 'DPLTestArticle 3', 'DPLTestArticleMultipleCategories' ],
+			$this->getDPLQueryResults( [ 'category' => 'DPLTestCategory' ] ),
+			true
+		);
+	}
+
+	public function testFindPagesInCategoryWithOrderAndLimit(): void {
+		$this->assertArrayEquals(
+			[ 'DPLTestArticleMultipleCategories', 'DPLTestArticle 3', ],
+			$this->getDPLQueryResults( [
+				'category' => 'DPLTestCategory',
+				'ordermethod' => 'sortkey',
+				'order' => 'descending',
+				'count' => '2'
+			] ),
+			true
+		);
+	}
+
+	public function testFindPagesNotInCategory(): void {
+		$results = $this->getDPLQueryResults( [
+			'namespace' => '', // NS_MAIN
+			'notcategory' => 'DPLTestCategory'
+		] );
+
+		$this->assertContains( 'DPLTestArticleNoCategory', $results );
+		foreach ( [ 'DPLTestArticle 1', 'DPLTestArticle 2', 'DPLTestArticle 3' ] as $pageInCat ) {
+			$this->assertNotContains( $pageInCat, $results );
+		}
+	}
+
+	public function testFindPagesNotInCategoryByPrefix(): void {
+		$results = $this->getDPLQueryResults( [
+			'namespace' => '', // NS_MAIN
+			'titlematch' => 'DPLTest%',
+			'notcategory' => 'DPLTestCategory'
+		] );
+
+		$this->assertArrayEquals(
+			[ 'DPLTestArticleNoCategory', 'DPLTestArticleOtherCategoryWithInfobox' ],
+			$results,
+			true
+		);
+	}
+
+	public function testFindPagesByPrefix(): void {
+		$results = $this->getDPLQueryResults( [
+			'namespace' => '', // NS_MAIN
+			'titlematch' => 'DPLTest%',
+		] );
+
+		$this->assertNotEmpty( $results );
+
+		foreach ( $results as $result ) {
+			$this->assertStringStartsWith( 'DPLTest', $result );
+		}
+	}
+
+	public function testFindPagesInCategoryIntersection(): void {
+		$this->assertArrayEquals(
+			[ 'DPLTestArticleMultipleCategories' ],
+			$this->getDPLQueryResults( [
+				'category' => [ 'DPLTestCategory', 'DPLTestOtherCategory' ]
+			] ),
+			true
+		);
+	}
+
+	public function testFindPagesUsingTemplate(): void {
+		$this->assertArrayEquals(
+			[ 'DPLTestArticle 1', 'DPLTestArticleOtherCategoryWithInfobox' ],
+			$this->getDPLQueryResults( [
+				'uses' => 'Template:DPLInfobox'
+			] ),
+			true
+		);
+	}
+
+	public function testFindPagesInCategoryUsingTemplate(): void {
+		$this->assertArrayEquals(
+			[ 'DPLTestArticleOtherCategoryWithInfobox' ],
+			$this->getDPLQueryResults( [
+				'category' => 'DPLTestOtherCategory',
+				'uses' => 'Template:DPLInfobox'
+			] ),
+			true
+		);
+	}
+
+	public function testFindPagesNotInCategoryUsingTemplate(): void {
+		$this->assertArrayEquals(
+			[ 'DPLTestArticle 1' ],
+			$this->getDPLQueryResults( [
+				'notcategory' => 'DPLTestOtherCategory',
+				'uses' => 'Template:DPLInfobox'
+			] ),
+			true
+		);
+	}
+
+	public function testFindTemplatesUsedByPage(): void {
+		$this->assertArrayEquals(
+			[ 'Template:DPLInfobox' ],
+			$this->getDPLQueryResults( [
+				'usedby' => 'DPLTestArticleOtherCategoryWithInfobox'
+			] ),
+			true
+		);
+	}
+
+	public function testFindPagesByTitleRegexpInNamespace(): void {
+		$this->assertArrayEquals(
+			[ 'DPLTestArticle 1', 'DPLTestArticle 2' ],
+			$this->getDPLQueryResults( [
+				'namespace' => '', // NS_MAIN
+				'titleregexp' => 'DPLTestArticle [12]'
+			] )
+		);
+	}
+
+	public function testFindPagesBeforeTitleInCategory(): void {
+		$this->assertArrayEquals(
+			[ 'DPLTestArticle 1', 'DPLTestArticle 2' ],
+			$this->getDPLQueryResults( [
+				'category' => 'DPLTestCategory',
+				'titlelt' => 'DPLTestArticle 3',
+				'count' => '2'
+			] )
+		);
+	}
+
+	public function testFindPagesInCategoryWithMaxRevisionLimit(): void {
+		$this->assertArrayEquals(
+			[ 'DPLTestArticle 2', 'DPLTestArticleMultipleCategories' ],
+			$this->getDPLQueryResults( [
+				'category' => 'DPLTestCategory',
+				'maxrevisions' => '1',
+			] ),
+			true
+		);
+	}
+
+	public function testFindPagesInCategoryWithMinRevisionLimit(): void {
+		$this->assertArrayEquals(
+			[ 'DPLTestArticle 1', 'DPLTestArticle 3' ],
+			$this->getDPLQueryResults( [
+				'category' => 'DPLTestCategory',
+				'minrevisions' => '2',
+			] ),
+			true
+		);
+	}
+
+	public function testFindPagesByCategoryMin(): void {
+		$this->assertArrayEquals(
+			[ 'DPLTestArticleMultipleCategories' ],
+			$this->getDPLQueryResults( [
+				'category' => 'DPLTestCategory',
+				'categoriesminmax' => '2',
+			] ),
+			true
+		);
+	}
+
+	public function testFindPagesByCategoryMinMax(): void {
+		$this->assertArrayEquals(
+			[ 'DPLTestArticle 1', 'DPLTestArticle 2', 'DPLTestArticle 3' ],
+			$this->getDPLQueryResults( [
+				'category' => 'DPLTestCategory',
+				'categoriesminmax' => '1,1',
+			] ),
+			true
+		);
+	}
+
+	public function testFindPagesNotModifiedByUserInCategory(): void {
+		$this->assertArrayEquals(
+			[ 'DPLTestArticle 2', 'DPLTestArticle 3', 'DPLTestArticleMultipleCategories' ],
+			$this->getDPLQueryResults( [
+				'category' => 'DPLTestCategory',
+				'notmodifiedby' => 'DPLTestUser',
+			] ),
+			true
+		);
+	}
+
+	public function testFindPagesCreatedByUserInCategory(): void {
+		$this->assertArrayEquals(
+			[ 'DPLTestArticleOtherCategoryWithInfobox' ],
+			$this->getDPLQueryResults( [
+				'category' => 'DPLTestOtherCategory',
+				'createdby' => 'DPLTestSystemUser',
+			] ),
+			true
+		);
+	}
+
+	public function testFindPagesLastModifiedByUserInCategory(): void {
+		$this->assertArrayEquals(
+			[ 'DPLTestArticle 1' ],
+			$this->getDPLQueryResults( [
+				'category' => 'DPLTestCategory',
+				'lastmodifiedby' => 'DPLTestUser',
+			] ),
+			true
+		);
+	}
+
+	public function testFindPagesNotLastModifiedByUserInCategory(): void {
+		$this->assertArrayEquals(
+			[ 'DPLTestArticle 2', 'DPLTestArticle 3', 'DPLTestArticleMultipleCategories' ],
+			$this->getDPLQueryResults( [
+				'category' => 'DPLTestCategory',
+				'notlastmodifiedby' => 'DPLTestUser',
+			] ),
+			true
+		);
+	}
+
+	public function testFindPagesEverModifiedByUserInCategory(): void {
+		$this->assertArrayEquals(
+			[ 'DPLTestArticle 1', 'DPLTestArticle 2', 'DPLTestArticle 3', 'DPLTestArticleMultipleCategories' ],
+			$this->getDPLQueryResults( [
+				'category' => 'DPLTestCategory',
+				'modifiedby' => 'DPLTestAdmin',
+			] ),
+			true
+		);
+	}
+
+	public function testFindPagesNotCreatedByUserInCategory(): void {
+		$this->assertArrayEquals(
+			[ 'DPLTestArticleMultipleCategories' ],
+			$this->getDPLQueryResults( [
+				'category' => 'DPLTestOtherCategory',
+				'notcreatedby' => 'DPLTestSystemUser',
+			] ),
+			true
+		);
+	}
+
+	public function testFindPagesViaUserFilterCombinations(): void {
+		$this->assertArrayEquals(
+			[ 'DPLUncategorizedPage' ],
+			$this->getDPLQueryResults( [
+				'modifiedby' => 'DPLTestUser',
+				'notcreatedby' => 'DPLTestAdmin',
+				'notlastmodifiedby' => 'DPLTestUser',
+			] ),
+			true
+		);
+	}
+
+	public function testFindPagesInCategoryOrderedByLastEdit(): void {
+		$results = $this->getDPLQueryResults( [
+			'category' => 'DPLTestCategory',
+			'ordermethod' => 'lastedit',
+			'order' => 'descending',
+		] );
+
+		$this->assertArrayEquals(
+			[
+				'DPLTestArticle 3',
+				'DPLTestArticle 2',
+				'DPLTestArticleMultipleCategories',
+				'DPLTestArticle 1',
+			],
+			$results,
+			true
+		);
+	}
+
+	public function testFindPagesInCategoryOrderedByFirstEdit(): void {
+		$results = $this->getDPLQueryResults( [
+			'category' => 'DPLTestCategory',
+			'ordermethod' => 'firstedit',
+			'order' => 'descending',
+		] );
+
+		$this->assertArrayEquals(
+			[
+				'DPLTestArticle 2',
+				'DPLTestArticleMultipleCategories',
+				'DPLTestArticle 1',
+				'DPLTestArticle 3',
+			],
+			$results,
+			true
+		);
+	}
+
+	public function testOrderByLastEditAndUser(): void {
+		$results = $this->getDPLQueryResults( [
+			'category' => 'DPLTestCategory',
+			'ordermethod' => 'lastedit,user',
+			'order' => 'descending',
+			'adduser' => 'true',
+			'createdby' => 'DPLTestAdmin'
+		], '%PAGE% %USER%' );
+
+		$this->assertEquals( [
+			'DPLTestArticle 3 DPLTestAdmin',
+			'DPLTestArticle 2 DPLTestAdmin',
+			'DPLTestArticleMultipleCategories DPLTestAdmin',
+			'DPLTestArticle 1 DPLTestUser',
+		], $results );
+	}
+
+	public function testGetPageAuthors(): void {
+		$results = $this->getDPLQueryResults( [
+			'category' => 'DPLTestCategory',
+			'addauthor' => 'true',
+			'order' => 'ascending',
+			'ordermethod' => 'title'
+		], '%PAGE% %USER%' );
+
+		$this->assertEquals( [
+			'DPLTestArticle 1 DPLTestAdmin',
+			'DPLTestArticle 2 DPLTestAdmin',
+			'DPLTestArticle 3 DPLTestAdmin',
+			'DPLTestArticleMultipleCategories DPLTestAdmin',
+		], $results );
+	}
+
+	public function testGetLastEditorsByPage(): void {
+		$results = $this->getDPLQueryResults( [
+			'category' => 'DPLTestCategory',
+			'addlasteditor' => 'true'
+		], '%PAGE% %USER%' );
+
+		$this->assertEquals( [
+			'DPLTestArticle 1 DPLTestUser',
+			'DPLTestArticle 2 DPLTestAdmin',
+			'DPLTestArticle 3 DPLTestAdmin',
+			'DPLTestArticleMultipleCategories DPLTestAdmin',
+		], $results );
+	}
+}
diff --git a/tests/seed-data.xml b/tests/seed-data.xml
new file mode 100644
index 00000000..58198584
--- /dev/null
+++ b/tests/seed-data.xml
@@ -0,0 +1,267 @@
+<mediawiki xmlns="http://www.mediawiki.org/xml/export-0.11/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.mediawiki.org/xml/export-0.11/ http://www.mediawiki.org/xml/export-0.11.xsd" version="0.11" xml:lang="en">
+	<siteinfo>
+		<sitename>MediaWiki</sitename>
+		<dbname>mwdev</dbname>
+		<base>http://localhost:8080/wiki/Main_Page</base>
+		<generator>MediaWiki 1.37.0-alpha</generator>
+		<case>first-letter</case>
+		<namespaces>
+			<namespace key="-2" case="first-letter">Media</namespace>
+			<namespace key="-1" case="first-letter">Special</namespace>
+			<namespace key="0" case="first-letter" />
+			<namespace key="1" case="first-letter">Talk</namespace>
+			<namespace key="2" case="first-letter">User</namespace>
+			<namespace key="3" case="first-letter">User talk</namespace>
+			<namespace key="4" case="first-letter">Project</namespace>
+			<namespace key="5" case="first-letter">Project talk</namespace>
+			<namespace key="6" case="first-letter">File</namespace>
+			<namespace key="7" case="first-letter">File talk</namespace>
+			<namespace key="8" case="first-letter">MediaWiki</namespace>
+			<namespace key="9" case="first-letter">MediaWiki talk</namespace>
+			<namespace key="10" case="first-letter">Template</namespace>
+			<namespace key="11" case="first-letter">Template talk</namespace>
+			<namespace key="12" case="first-letter">Help</namespace>
+			<namespace key="13" case="first-letter">Help talk</namespace>
+			<namespace key="14" case="first-letter">Category</namespace>
+			<namespace key="15" case="first-letter">Category talk</namespace>
+		</namespaces>
+	</siteinfo>
+	<page>
+		<title>Template:DPLInfobox</title>
+		<ns>10</ns>
+		<id>13</id>
+		<revision>
+			<id>13</id>
+			<timestamp>2017-09-07T10:45:24Z</timestamp>
+			<contributor>
+				<username>DPLTestSystemUser</username>
+			</contributor>
+			<comment>Test template</comment>
+			<origin>13</origin>
+			<model>wikitext</model>
+			<format>text/x-wiki</format>
+			<text xml:space="preserve" bytes="13">Test template</text>
+			<sha1 />
+		</revision>
+	</page>
+	<page>
+		<title>Category:DPLTestCategory</title>
+		<ns>14</ns>
+		<id>14</id>
+		<revision>
+			<id>17</id>
+			<timestamp>2021-09-02T14:42:11Z</timestamp>
+			<contributor>
+				<username>DPLTestAdmin</username>
+				<id>1</id>
+			</contributor>
+			<comment>Created page with "DPL Test category"</comment>
+			<origin>17</origin>
+			<model>wikitext</model>
+			<format>text/x-wiki</format>
+			<text bytes="17" sha1="7fvwcsar4s6wpu5l22vedd9yaek5js6" xml:space="preserve">DPL Test category</text>
+			<sha1>7fvwcsar4s6wpu5l22vedd9yaek5js6</sha1>
+		</revision>
+	</page>
+	<page>
+		<title>DPLTestArticle 1</title>
+		<ns>0</ns>
+		<id>15</id>
+		<revision>
+			<id>18</id>
+			<timestamp>2021-09-02T14:43:05Z</timestamp>
+			<contributor>
+				<username>DPLTestAdmin</username>
+				<id>1</id>
+			</contributor>
+			<comment>Initial page version</comment>
+			<origin>18</origin>
+			<model>wikitext</model>
+			<format>text/x-wiki</format>
+			<text xml:space="preserve">Donec non dolor ipsum.
+[[Category:DPLTestCategory]]</text>
+			<sha1 />
+		</revision>
+		<revision>
+			<id>19</id>
+			<parentid>18</parentid>
+			<timestamp>2021-09-02T14:43:16Z</timestamp>
+			<contributor>
+				<username>DPLTestUser</username>
+				<id>2</id>
+			</contributor>
+			<comment>Edited version</comment>
+			<origin>19</origin>
+			<model>wikitext</model>
+			<format>text/x-wiki</format>
+			<text xml:space="preserve">Sed mollis dignissim [[DPLTestArticle 2]] purus, auctor faucibus [[DPLTestArticleNoCategory]] purus tincidunt at. {{DPLInfobox}}
+[[Category:DPLTestCategory]]</text>
+			<sha1 />
+		</revision>
+	</page>
+	<page>
+		<title>DPLTestArticle 2</title>
+		<ns>0</ns>
+		<id>16</id>
+		<revision>
+			<id>20</id>
+			<timestamp>2021-09-02T14:44:02Z</timestamp>
+			<contributor>
+				<username>DPLTestAdmin</username>
+				<id>1</id>
+			</contributor>
+			<comment>Initial page version</comment>
+			<origin>20</origin>
+			<model>wikitext</model>
+			<format>text/x-wiki</format>
+			<text bytes="72" sha1="gykofop7mtvar8ajsyppok80uy6fiti" xml:space="preserve">Sed dapibus enim ac quam pharetra suscipit.
+[[Category:DPLTestCategory]]</text>
+			<sha1>gykofop7mtvar8ajsyppok80uy6fiti</sha1>
+		</revision>
+	</page>
+	<page>
+		<title>DPLTestArticle 3</title>
+		<ns>0</ns>
+		<id>17</id>
+		<revision>
+			<id>21</id>
+			<timestamp>2019-08-12T00:11:23Z</timestamp>
+			<contributor>
+				<username>DPLTestAdmin</username>
+				<id>1</id>
+			</contributor>
+			<comment>Initial page version</comment>
+			<origin>21</origin>
+			<model>wikitext</model>
+			<format>text/x-wiki</format>
+			<text bytes="95" sha1="og8hxtaxjfid8cinjh7nq5g2zxv0cdj" xml:space="preserve">Vestibulum a ante aliquet, vestibulum risus vitae, imperdiet sem.
+[[Category:DPLTestCategory]]</text>
+			<sha1>og8hxtaxjfid8cinjh7nq5g2zxv0cdj</sha1>
+		</revision>
+		<revision>
+			<id>22</id>
+			<parentid>21</parentid>
+			<timestamp>2021-09-02T14:44:47Z</timestamp>
+			<contributor>
+				<username>DPLTestAdmin</username>
+				<id>1</id>
+			</contributor>
+			<comment>Edited version</comment>
+			<origin>22</origin>
+			<model>wikitext</model>
+			<format>text/x-wiki</format>
+			<text bytes="73" sha1="9caafrpllg2n9zyk52h0ov4bajyxjpj" xml:space="preserve"> Duis vel dapibus tellus, eu vehicula metus.
+[[Category:DPLTestCategory]]</text>
+			<sha1>9caafrpllg2n9zyk52h0ov4bajyxjpj</sha1>
+		</revision>
+	</page>
+	<page>
+		<title>DPLTestArticleNoCategory</title>
+		<ns>0</ns>
+		<id>18</id>
+		<revision>
+			<id>23</id>
+			<timestamp>2021-09-03T00:12:20Z</timestamp>
+			<contributor>
+				<username>DPLTestUser</username>
+				<id>2</id>
+			</contributor>
+			<comment>Create test page without category</comment>
+			<origin>23</origin>
+			<model>wikitext</model>
+			<format>text/x-wiki</format>
+			<text bytes="40" xml:space="preserve">Urbem praeclaram statui, mea moenia vidi</text>
+			<sha1 />
+		</revision>
+	</page>
+	<page>
+		<title>Category:DPLTestOtherCategory</title>
+		<ns>14</ns>
+		<id>24</id>
+		<revision>
+			<id>24</id>
+			<timestamp>2021-09-02T14:42:11Z</timestamp>
+			<contributor>
+				<username>DPLTestAdmin</username>
+				<id>1</id>
+			</contributor>
+			<comment>Created page with "DPL Test category"</comment>
+			<origin>24</origin>
+			<model>wikitext</model>
+			<format>text/x-wiki</format>
+			<text bytes="18" xml:space="preserve">DPL other category</text>
+			<sha1 />
+		</revision>
+	</page>
+	<page>
+		<title>DPLTestArticleMultipleCategories</title>
+		<ns>0</ns>
+		<id>25</id>
+		<revision>
+			<id>25</id>
+			<timestamp>2021-09-02T14:44:01Z</timestamp>
+			<contributor>
+				<username>DPLTestAdmin</username>
+				<id>1</id>
+			</contributor>
+			<comment>Page with multiple categories</comment>
+			<origin>25</origin>
+			<model>wikitext</model>
+			<format>text/x-wiki</format>
+			<text bytes="117" xml:space="preserve">Quo usque tandem abutere, Catilina, patientia nostra?!
+[[Category:DPLTestOtherCategory]]
+[[Category:DPLTestCategory]]</text>
+			<sha1 />
+		</revision>
+	</page>
+	<page>
+		<title>DPLTestArticleOtherCategoryWithInfobox</title>
+		<ns>0</ns>
+		<id>26</id>
+		<revision>
+			<id>26</id>
+			<timestamp>2021-09-02T14:44:01Z</timestamp>
+			<contributor>
+				<username>DPLTestSystemUser</username>
+			</contributor>
+			<comment>Page with infobox</comment>
+			<origin>25</origin>
+			<model>wikitext</model>
+			<format>text/x-wiki</format>
+			<text xml:space="preserve">{{DPLInfobox}} some content
+[[Category:DPLTestOtherCategory]]]</text>
+			<sha1 />
+		</revision>
+	</page>
+	<page>
+		<title>DPLUncategorizedPage</title>
+		<ns>0</ns>
+		<id>27</id>
+		<revision>
+			<id>27</id>
+			<timestamp>2021-09-04T03:01:00Z</timestamp>
+			<contributor>
+				<username>DPLTestSystemUser</username>
+			</contributor>
+			<comment>Create test uncategorized page</comment>
+			<origin>27</origin>
+			<model>wikitext</model>
+			<format>text/x-wiki</format>
+			<text xml:space="preserve">Uncategorized test page</text>
+			<sha1 />
+		</revision>
+		<revision>
+			<id>28</id>
+			<timestamp>2021-09-04T03:01:00Z</timestamp>
+			<contributor>
+				<username>DPLTestUser</username>
+			</contributor>
+			<comment>Page edited</comment>
+			<origin>27</origin>
+			<model>wikitext</model>
+			<format>text/x-wiki</format>
+			<text xml:space="preserve">Uncategorized test page edit</text>
+			<sha1 />
+		</revision>
+	</page>
+</mediawiki>
