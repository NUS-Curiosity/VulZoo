diff --git a/elFinder.Net.Core/Demos/elFinder.Net.AdvancedDemo/Startup.cs b/elFinder.Net.Core/Demos/elFinder.Net.AdvancedDemo/Startup.cs
index 008ae77..d09d56d 100644
--- a/elFinder.Net.Core/Demos/elFinder.Net.AdvancedDemo/Startup.cs
+++ b/elFinder.Net.Core/Demos/elFinder.Net.AdvancedDemo/Startup.cs
@@ -39,7 +39,7 @@ public static string MapPath(string path, string basePath = null)
             }
 
             path = path.Replace("~/", "").TrimStart('/').Replace('/', '\\');
-            return PathHelper.GetFullPath(basePath, path);
+            return PathHelper.GetFullPath(Path.Combine(basePath, path));
         }
 
         public IConfiguration Configuration { get; }
diff --git a/elFinder.Net.Core/Demos/elFinder.Net.Demo31/Startup.cs b/elFinder.Net.Core/Demos/elFinder.Net.Demo31/Startup.cs
index 3605b02..b4e3154 100644
--- a/elFinder.Net.Core/Demos/elFinder.Net.Demo31/Startup.cs
+++ b/elFinder.Net.Core/Demos/elFinder.Net.Demo31/Startup.cs
@@ -9,6 +9,7 @@
 using Microsoft.Extensions.DependencyInjection;
 using Microsoft.Extensions.Hosting;
 using System.Collections.Generic;
+using System.IO;
 
 namespace elFinder.Net.Demo31
 {
@@ -30,7 +31,7 @@ public static string MapPath(string path, string basePath = null)
             }
 
             path = path.Replace("~/", "").TrimStart('/').Replace('/', '\\');
-            return PathHelper.GetFullPath(basePath, path);
+            return PathHelper.GetFullPath(Path.Combine(basePath, path));
         }
 
         public IConfiguration Configuration { get; }
diff --git a/elFinder.Net.Core/elFinder.Net.Core/Connector.cs b/elFinder.Net.Core/elFinder.Net.Core/Connector.cs
index a406205..5c247ed 100644
--- a/elFinder.Net.Core/elFinder.Net.Core/Connector.cs
+++ b/elFinder.Net.Core/elFinder.Net.Core/Connector.cs
@@ -374,6 +374,13 @@ public virtual async Task<ConnectorResult> ProcessAsync(ConnectorCommand cmd, Ca
                             if (targetPath.IsDirectory)
                                 throw new NotFileException();
 
+                            if (putCmd.Encoding == "hash")
+                            {
+                                putCmd.ContentPath = await ParsePathAsync(putCmd.Content, cancellationToken: cancellationToken);
+                                if (putCmd.ContentPath.IsDirectory)
+                                    throw new NotFileException();
+                            }
+
                             var putResp = await putCmd.TargetPath.Volume.Driver.PutAsync(putCmd, cancellationToken);
                             return ConnectorResult.Success(putResp);
                         }
diff --git a/elFinder.Net.Core/elFinder.Net.Core/Exceptions/InvalidDirNameException.cs b/elFinder.Net.Core/elFinder.Net.Core/Exceptions/InvalidDirNameException.cs
new file mode 100644
index 0000000..9306fb9
--- /dev/null
+++ b/elFinder.Net.Core/elFinder.Net.Core/Exceptions/InvalidDirNameException.cs
@@ -0,0 +1,15 @@
+﻿using elFinder.Net.Core.Models.Response;
+
+namespace elFinder.Net.Core.Exceptions
+{
+    public class InvalidDirNameException : ConnectorException
+    {
+        public InvalidDirNameException()
+        {
+            ErrorResponse = new ErrorResponse(this)
+            {
+                error = ErrorResponse.InvalidDirName
+            };
+        }
+    }
+}
diff --git a/elFinder.Net.Core/elFinder.Net.Core/Exceptions/InvalidFileNameException.cs b/elFinder.Net.Core/elFinder.Net.Core/Exceptions/InvalidFileNameException.cs
new file mode 100644
index 0000000..7c1080d
--- /dev/null
+++ b/elFinder.Net.Core/elFinder.Net.Core/Exceptions/InvalidFileNameException.cs
@@ -0,0 +1,15 @@
+﻿using elFinder.Net.Core.Models.Response;
+
+namespace elFinder.Net.Core.Exceptions
+{
+    public class InvalidFileNameException : ConnectorException
+    {
+        public InvalidFileNameException()
+        {
+            ErrorResponse = new ErrorResponse(this)
+            {
+                error = ErrorResponse.InvalidFileName
+            };
+        }
+    }
+}
diff --git a/elFinder.Net.Core/elFinder.Net.Core/Models/Command/PutCommand.cs b/elFinder.Net.Core/elFinder.Net.Core/Models/Command/PutCommand.cs
index 579f4f1..af5b907 100644
--- a/elFinder.Net.Core/elFinder.Net.Core/Models/Command/PutCommand.cs
+++ b/elFinder.Net.Core/elFinder.Net.Core/Models/Command/PutCommand.cs
@@ -4,5 +4,7 @@ public class PutCommand : TargetCommand
     {
         public string Content { get; set; }
         public string Encoding { get; set; }
+
+        public PathInfo ContentPath { get; set; }
     }
 }
diff --git a/elFinder.Net.Core/elFinder.Net.Core/Models/PathInfo.cs b/elFinder.Net.Core/elFinder.Net.Core/Models/PathInfo.cs
index 243f9de..f0ae1a8 100644
--- a/elFinder.Net.Core/elFinder.Net.Core/Models/PathInfo.cs
+++ b/elFinder.Net.Core/elFinder.Net.Core/Models/PathInfo.cs
@@ -1,4 +1,6 @@
-﻿namespace elFinder.Net.Core
+﻿using elFinder.Net.Core.Exceptions;
+
+namespace elFinder.Net.Core
 {
     public class PathInfo
     {
@@ -6,12 +8,16 @@ public PathInfo(string path, IVolume volume, IFile file, string hashedTarget) :
         {
             File = file;
             FileSystem = file;
+
+            if (!volume.Own(FileSystem)) throw new PermissionDeniedException("Volume must own this path");
         }
 
         public PathInfo(string path, IVolume volume, IDirectory dir, string hashedTarget) : this(path, volume, hashedTarget, true)
         {
             Directory = dir;
             FileSystem = dir;
+
+            if (!volume.Own(FileSystem)) throw new PermissionDeniedException("Volume must own this path");
         }
 
         private PathInfo(string path, IVolume volume, string hashedTarget, bool isDirectory)
diff --git a/elFinder.Net.Core/elFinder.Net.Core/Models/Response/ErrorResponse.cs b/elFinder.Net.Core/elFinder.Net.Core/Models/Response/ErrorResponse.cs
index 2b9876d..2f0d554 100644
--- a/elFinder.Net.Core/elFinder.Net.Core/Models/Response/ErrorResponse.cs
+++ b/elFinder.Net.Core/elFinder.Net.Core/Models/Response/ErrorResponse.cs
@@ -84,6 +84,8 @@ public static ErrorResponse Unknown(Exception ex)
         public const string CommandNoSupport = "errCmdNoSupport";
         public const string NotFile = "errNotFile";
         public const string UploadFile = "errUploadFile";
+        public const string InvalidFileName = "errInvName";
+        public const string InvalidDirName = "errInvDirname";
         #endregion
     }
 }
diff --git a/elFinder.Net.Core/elFinder.Net.Drivers.FileSystem/Extensions/IDirectoryExtensions.cs b/elFinder.Net.Core/elFinder.Net.Drivers.FileSystem/Extensions/IDirectoryExtensions.cs
index 25bc8a1..e461808 100644
--- a/elFinder.Net.Core/elFinder.Net.Drivers.FileSystem/Extensions/IDirectoryExtensions.cs
+++ b/elFinder.Net.Core/elFinder.Net.Drivers.FileSystem/Extensions/IDirectoryExtensions.cs
@@ -1,4 +1,5 @@
 ﻿using elFinder.Net.Core;
+using elFinder.Net.Drivers.FileSystem.Helpers;
 using System;
 using System.IO;
 using System.Linq;
@@ -22,7 +23,7 @@ public static class IDirectoryExtensions
             }
 
             string newName = $"{name}{suffix}";
-            if (!Directory.Exists(Path.Combine(directory.Parent.FullName, newName)))
+            if (!Directory.Exists(PathHelper.SafelyCombine(directory.Parent.FullName, directory.Parent.FullName, newName)))
                 return newName;
             else
             {
diff --git a/elFinder.Net.Core/elFinder.Net.Drivers.FileSystem/Extensions/IFileExtensions.cs b/elFinder.Net.Core/elFinder.Net.Drivers.FileSystem/Extensions/IFileExtensions.cs
index da49df9..3150e94 100644
--- a/elFinder.Net.Core/elFinder.Net.Drivers.FileSystem/Extensions/IFileExtensions.cs
+++ b/elFinder.Net.Core/elFinder.Net.Drivers.FileSystem/Extensions/IFileExtensions.cs
@@ -1,4 +1,5 @@
 ﻿using elFinder.Net.Core;
+using elFinder.Net.Drivers.FileSystem.Helpers;
 using System;
 using System.IO;
 using System.Linq;
@@ -23,7 +24,7 @@ public static class IFileExtensions
             }
 
             string newName = $"{name}{suffix}{extension}";
-            if (!File.Exists(Path.Combine(file.DirectoryName, newName)))
+            if (!File.Exists(PathHelper.SafelyCombine(file.DirectoryName, file.DirectoryName, newName)))
                 return newName;
             else
             {
diff --git a/elFinder.Net.Core/elFinder.Net.Drivers.FileSystem/FileSystemDirectory.cs b/elFinder.Net.Core/elFinder.Net.Drivers.FileSystem/FileSystemDirectory.cs
index ea8f376..78601e4 100644
--- a/elFinder.Net.Core/elFinder.Net.Drivers.FileSystem/FileSystemDirectory.cs
+++ b/elFinder.Net.Core/elFinder.Net.Drivers.FileSystem/FileSystemDirectory.cs
@@ -251,7 +251,7 @@ public virtual Task<IDirectory> RenameAsync(string newName, bool verify = true,
 
             if (verify && !this.CanRename()) throw new PermissionDeniedException();
 
-            var newPath = PathHelper.GetFullPath(Parent.FullName, newName);
+            var newPath = PathHelper.GetFullPath(PathHelper.SafelyCombine(Parent.FullName, Parent.FullName, newName));
             directoryInfo.MoveTo(newPath);
             return Task.FromResult<IDirectory>(new FileSystemDirectory(newPath, volume));
         }
diff --git a/elFinder.Net.Core/elFinder.Net.Drivers.FileSystem/FileSystemDriver.cs b/elFinder.Net.Core/elFinder.Net.Drivers.FileSystem/FileSystemDriver.cs
index f229cc2..0e26ced 100644
--- a/elFinder.Net.Core/elFinder.Net.Drivers.FileSystem/FileSystemDriver.cs
+++ b/elFinder.Net.Core/elFinder.Net.Drivers.FileSystem/FileSystemDriver.cs
@@ -29,6 +29,7 @@ namespace elFinder.Net.Drivers.FileSystem
     public class FileSystemDriver : IDriver
     {
         public const string DefaultThumbExt = ".png";
+        private static readonly char[] InvalidFileNameChars = Path.GetInvalidFileNameChars();
 
         protected readonly IPathParser pathParser;
         protected readonly IPictureEditor pictureEditor;
@@ -127,6 +128,9 @@ public virtual async Task<MkdirResponse> MkdirAsync(MkdirCommand cmd, Cancellati
         {
             cancellationToken.ThrowIfCancellationRequested();
 
+            if (!IsObjectNameValid(cmd.Name))
+                throw new InvalidDirNameException();
+
             var mkdirResp = new MkdirResponse();
             var targetPath = cmd.TargetPath;
             var volume = targetPath.Volume;
@@ -136,7 +140,8 @@ public virtual async Task<MkdirResponse> MkdirAsync(MkdirCommand cmd, Cancellati
 
             if (!string.IsNullOrEmpty(cmd.Name))
             {
-                var newDir = new FileSystemDirectory(Path.Combine(targetPath.Directory.FullName, cmd.Name), volume);
+                var newDir = new FileSystemDirectory(PathHelper.SafelyCombine(targetPath.Directory.FullName,
+                    targetPath.Directory.FullName, cmd.Name), volume);
 
                 OnBeforeMakeDir?.Invoke(this, newDir);
                 await newDir.CreateAsync(cancellationToken: cancellationToken);
@@ -149,7 +154,8 @@ public virtual async Task<MkdirResponse> MkdirAsync(MkdirCommand cmd, Cancellati
             foreach (string dir in cmd.Dirs)
             {
                 string dirName = dir.StartsWith("/") ? dir.Substring(1) : dir;
-                var newDir = new FileSystemDirectory(Path.Combine(targetPath.Directory.FullName, dirName), volume);
+                var newDir = new FileSystemDirectory(PathHelper.SafelyCombine(targetPath.Directory.FullName,
+                    targetPath.Directory.FullName, dirName), volume);
 
                 OnBeforeMakeDir?.Invoke(this, newDir);
                 await newDir.CreateAsync(cancellationToken: cancellationToken);
@@ -170,13 +176,17 @@ public virtual async Task<MkfileResponse> MkfileAsync(MkfileCommand cmd, Cancell
         {
             cancellationToken.ThrowIfCancellationRequested();
 
+            if (!IsObjectNameValid(cmd.Name))
+                throw new InvalidFileNameException();
+
             var targetPath = cmd.TargetPath;
             var volume = targetPath.Volume;
             var targetHash = targetPath.HashedTarget;
 
             if (!targetPath.Directory.CanCreateObject()) throw new PermissionDeniedException();
 
-            var newFile = new FileSystemFile(Path.Combine(targetPath.Directory.FullName, cmd.Name), volume);
+            var newFile = new FileSystemFile(PathHelper.SafelyCombine(targetPath.Directory.FullName,
+                targetPath.Directory.FullName, cmd.Name), volume);
 
             OnBeforeMakeFile?.Invoke(this, newFile);
             await newFile.CreateAsync(cancellationToken: cancellationToken);
@@ -355,6 +365,11 @@ public virtual async Task<RenameResponse> RenameAsync(RenameCommand cmd, Cancell
             var targetPath = cmd.TargetPath;
             var volume = targetPath.Volume;
 
+            if (!IsObjectNameValid(cmd.Name))
+                if (targetPath.IsDirectory)
+                    throw new InvalidDirNameException();
+                else throw new InvalidFileNameException();
+
             if (targetPath.IsDirectory)
             {
                 var prevName = targetPath.Directory.Name;
@@ -466,6 +481,15 @@ public virtual async Task<UploadResponse> UploadAsync(UploadCommand cmd, Cancell
         {
             cancellationToken.ThrowIfCancellationRequested();
 
+            if (cmd.Name.Any(name => !IsObjectNameValid(name)))
+                throw new InvalidFileNameException();
+
+            if (cmd.Renames.Any(name => !IsObjectNameValid(name)))
+                throw new InvalidFileNameException();
+
+            if (!IsObjectNameValid(cmd.Suffix))
+                throw new InvalidFileNameException();
+
             var uploadResp = new UploadResponse();
             var targetPath = cmd.TargetPath;
             var volume = targetPath.Volume;
@@ -513,7 +537,7 @@ public virtual async Task<UploadResponse> UploadAsync(UploadCommand cmd, Cancell
                     if (!dest.CanCreateObject())
                         throw new PermissionDeniedException($"Permission denied: {volume.GetRelativePath(dest)}");
 
-                    string uploadFullName = Path.Combine(dest.FullName, Path.GetFileName(formFile.FileName));
+                    string uploadFullName = PathHelper.SafelyCombine(dest.FullName, dest.FullName, Path.GetFileName(formFile.FileName));
                     var uploadFileInfo = new FileSystemFile(uploadFullName, volume);
                     var isOverwrite = false;
 
@@ -524,7 +548,7 @@ public virtual async Task<UploadResponse> UploadAsync(UploadCommand cmd, Cancell
                             var fileNameWithoutExt = Path.GetFileNameWithoutExtension(formFile.FileName);
                             var ext = Path.GetExtension(formFile.FileName);
                             var backupName = $"{fileNameWithoutExt}{cmd.Suffix}{ext}";
-                            var fullBakName = Path.Combine(uploadFileInfo.Parent.FullName, backupName);
+                            var fullBakName = PathHelper.SafelyCombine(uploadFileInfo.Parent.FullName, uploadFileInfo.Parent.FullName, backupName);
                             var bakFile = new FileSystemFile(fullBakName, volume);
 
                             if (await bakFile.ExistsAsync)
@@ -541,7 +565,7 @@ public virtual async Task<UploadResponse> UploadAsync(UploadCommand cmd, Cancell
                         else if (cmd.Overwrite == 0 || (cmd.Overwrite == null && !volume.UploadOverwrite))
                         {
                             string newName = await uploadFileInfo.GetCopyNameAsync(cmd.Suffix, cancellationToken: cancellationToken);
-                            uploadFullName = Path.Combine(uploadFileInfo.DirectoryName, newName);
+                            uploadFullName = PathHelper.SafelyCombine(uploadFileInfo.DirectoryName, uploadFileInfo.DirectoryName, newName);
                             uploadFileInfo = new FileSystemFile(uploadFullName, volume);
                             isOverwrite = false;
                         }
@@ -715,6 +739,12 @@ public virtual async Task<PasteResponse> PasteAsync(PasteCommand cmd, Cancellati
         {
             cancellationToken.ThrowIfCancellationRequested();
 
+            if (cmd.Renames.Any(name => !IsObjectNameValid(name)))
+                throw new InvalidFileNameException();
+
+            if (!IsObjectNameValid(cmd.Suffix))
+                throw new InvalidFileNameException();
+
             var pasteResp = new PasteResponse();
             var isCut = cmd.Cut == 1;
             var dstPath = cmd.DstPath;
@@ -726,14 +756,14 @@ public virtual async Task<PasteResponse> PasteAsync(PasteCommand cmd, Cancellati
                 if (src.IsDirectory)
                 {
                     IDirectory pastedDir;
-                    var newDest = Path.Combine(dstPath.Directory.FullName, src.Directory.Name);
+                    var newDest = PathHelper.SafelyCombine(dstPath.Directory.FullName, dstPath.Directory.FullName, src.Directory.Name);
                     var newDestDir = new FileSystemDirectory(newDest, dstPath.Volume);
                     var exists = await newDestDir.ExistsAsync;
 
                     if (exists && cmd.Renames.Contains(newDestDir.Name))
                     {
                         var backupName = $"{newDestDir.Name}{cmd.Suffix}";
-                        var fullBakName = Path.Combine(newDestDir.Parent.FullName, backupName);
+                        var fullBakName = PathHelper.SafelyCombine(newDestDir.Parent.FullName, newDestDir.Parent.FullName, backupName);
                         var bakDir = new FileSystemDirectory(fullBakName, newDestDir.Volume);
 
                         if (await bakDir.ExistsAsync)
@@ -790,7 +820,7 @@ public virtual async Task<PasteResponse> PasteAsync(PasteCommand cmd, Cancellati
                 {
                     IFile pastedFile;
                     var file = src.File;
-                    var newDest = Path.Combine(dstPath.Directory.FullName, file.Name);
+                    var newDest = PathHelper.SafelyCombine(dstPath.Directory.FullName, dstPath.Directory.FullName, file.Name);
                     var newDestFile = new FileSystemFile(newDest, dstPath.Volume);
                     var exists = await newDestFile.ExistsAsync;
 
@@ -799,7 +829,7 @@ public virtual async Task<PasteResponse> PasteAsync(PasteCommand cmd, Cancellati
                         var fileNameWithoutExt = Path.GetFileNameWithoutExtension(newDestFile.Name);
                         var ext = Path.GetExtension(newDestFile.Name);
                         var backupName = $"{fileNameWithoutExt}{cmd.Suffix}{ext}";
-                        var fullBakName = Path.Combine(newDestFile.Parent.FullName, backupName);
+                        var fullBakName = PathHelper.SafelyCombine(newDestFile.Parent.FullName, newDestFile.Parent.FullName, backupName);
                         var bakFile = new FileSystemFile(fullBakName, newDestFile.Volume);
 
                         if (await bakFile.ExistsAsync)
@@ -846,7 +876,7 @@ public virtual async Task<DuplicateResponse> DuplicateAsync(DuplicateCommand cmd
                 if (src.IsDirectory)
                 {
                     var newName = await src.Directory.GetCopyNameAsync(cancellationToken: cancellationToken);
-                    var newDest = Path.Combine(src.Directory.Parent.FullName, newName);
+                    var newDest = PathHelper.SafelyCombine(src.Directory.Parent.FullName, src.Directory.Parent.FullName, newName);
 
                     OnBeforeCopy?.Invoke(this, (src.Directory, newDest, true));
                     var dupDir = await CopyToAsync(src.Directory, newDest, dstVolume, copyOverwrite: false, cancellationToken: cancellationToken);
@@ -906,13 +936,16 @@ public virtual async Task<ArchiveResponse> ArchiveAsync(ArchiveCommand cmd, Canc
         {
             cancellationToken.ThrowIfCancellationRequested();
 
+            if (!IsObjectNameValid(cmd.Name))
+                throw new InvalidFileNameException();
+
             if (cmd.Type != MediaTypeNames.Application.Zip)
                 throw new ArchiveTypeException();
 
             var archiveResp = new ArchiveResponse();
             var targetPath = cmd.TargetPath;
             var volume = cmd.TargetPath.Volume;
-            var directoryInfo = targetPath.Directory;
+            var directory = targetPath.Directory;
 
             var filename = cmd.Name ?? targetPath.Directory.Name;
             var zipExt = $".{FileExtensions.Zip}";
@@ -920,7 +953,7 @@ public virtual async Task<ArchiveResponse> ArchiveAsync(ArchiveCommand cmd, Canc
             if (!filename.EndsWith(zipExt))
                 filename += zipExt;
 
-            var archivePath = Path.Combine(directoryInfo.FullName, filename);
+            var archivePath = PathHelper.SafelyCombine(directory.FullName, directory.FullName, filename);
             var newFile = new FileSystemFile(archivePath, volume);
 
             if (!await newFile.CanArchiveToAsync())
@@ -979,7 +1012,7 @@ public virtual async Task<ExtractResponse> ExtractAsync(ExtractCommand cmd, Canc
 
             if (makedir)
             {
-                fromPath = Path.Combine(fromPath, Path.GetFileNameWithoutExtension(targetPath.File.Name));
+                fromPath = PathHelper.SafelyCombine(fromPath, fromPath, Path.GetFileNameWithoutExtension(targetPath.File.Name));
                 fromDir = new FileSystemDirectory(fromPath, volume);
 
                 if (!await fromDir.CanExtractToAsync())
@@ -1005,7 +1038,8 @@ public virtual async Task<ExtractResponse> ExtractAsync(ExtractCommand cmd, Canc
             {
                 foreach (ZipArchiveEntry entry in archive.Entries)
                 {
-                    string fullName = PathHelper.GetFullPathNormalized(fromPath, entry.FullName);
+                    string fullName = PathHelper.GetFullPathNormalized(
+                        PathHelper.SafelyCombine(fromPath, fromPath, entry.FullName));
 
                     if (string.IsNullOrEmpty(entry.Name))
                     {
@@ -1101,6 +1135,17 @@ public virtual async Task<PutResponse> PutAsync(PutCommand cmd, CancellationToke
                     }
                 }
             }
+            else if (cmd.Encoding == "hash")
+            {
+                Func<Task<Stream>> openStreamFunc = async () => await cmd.ContentPath.File.OpenReadAsync(cancellationToken: cancellationToken);
+
+                OnBeforeWriteStream?.Invoke(this, (openStreamFunc, targetFile));
+                using (var readStream = await openStreamFunc())
+                {
+                    await targetFile.OverwriteAsync(readStream, cancellationToken: cancellationToken);
+                }
+                OnAfterWriteStream?.Invoke(this, (openStreamFunc, targetFile));
+            }
             else
             {
                 OnBeforeWriteContent?.Invoke(this, (cmd.Content, cmd.Encoding, targetFile));
@@ -1268,15 +1313,19 @@ public virtual async Task<FileResponse> ZipdlRawAsync(ZipdlCommand cmd, Cancella
         {
             cancellationToken.ThrowIfCancellationRequested();
 
+            if (!IsObjectNameValid(cmd.DownloadFileName))
+                throw new InvalidFileNameException();
+
             var archiveFile = await zipDownloadPathProvider.ParseArchiveFileKeyAsync(cmd.ArchiveFileKey);
             var tempFileInfo = new FileInfo(archiveFile);
-            var memStream = new MemoryStream();
 
+            if (!tempFileInfo.Exists) throw new PermissionDeniedException($"Malformed key");
+
+            var memStream = new MemoryStream();
             using (var fileStream = tempFileInfo.OpenRead())
             {
                 await fileStream.CopyToAsync(memStream, StreamConstants.DefaultBufferSize, cancellationToken: cancellationToken);
             }
-
             tempFileInfo.Delete();
             memStream.Position = 0;
 
@@ -1402,6 +1451,11 @@ public IDirectory CreateDirectory(string fullPath, IVolume volume)
             return new FileSystemDirectory(fullPath, volume);
         }
 
+        protected bool IsObjectNameValid(string name)
+        {
+            return name == null || !name.Any(ch => InvalidFileNameChars.Contains(ch));
+        }
+
         protected virtual async Task<IFile> SafeCopyToAsync(IFile file, string newDir,
             IVolume destVolume, bool copyOverwrite = true, string suffix = null,
             CancellationToken cancellationToken = default)
@@ -1410,7 +1464,7 @@ public IDirectory CreateDirectory(string fullPath, IVolume volume)
 
             if (!file.CanCopy()) throw new PermissionDeniedException();
 
-            string newPath = Path.Combine(newDir, file.Name);
+            string newPath = PathHelper.SafelyCombine(newDir, newDir, file.Name);
             IFile newFile = new FileSystemFile(newPath, destVolume);
             var isOverwrite = true;
 
@@ -1419,7 +1473,7 @@ public IDirectory CreateDirectory(string fullPath, IVolume volume)
                 if (!copyOverwrite)
                 {
                     var newName = await newFile.GetCopyNameAsync(suffix, cancellationToken: cancellationToken);
-                    newPath = Path.Combine(newDir, newName);
+                    newPath = PathHelper.SafelyCombine(newDir, newDir, newName);
                     isOverwrite = false;
                 }
             }
@@ -1439,7 +1493,7 @@ public IDirectory CreateDirectory(string fullPath, IVolume volume)
 
             if (!file.CanMove()) throw new PermissionDeniedException();
 
-            string newPath = Path.Combine(newDir, file.Name);
+            string newPath = PathHelper.SafelyCombine(newDir, newDir, file.Name);
             IFile newFile = new FileSystemFile(newPath, destVolume);
 
             if (await newFile.ExistsAsync)
@@ -1447,7 +1501,7 @@ public IDirectory CreateDirectory(string fullPath, IVolume volume)
                 if (!copyOverwrite)
                 {
                     var newName = await newFile.GetCopyNameAsync(suffix, cancellationToken: cancellationToken);
-                    newPath = Path.Combine(newDir, newName);
+                    newPath = PathHelper.SafelyCombine(newDir, newDir, newName);
                 }
                 else
                 {
@@ -1506,7 +1560,8 @@ public IDirectory CreateDirectory(string fullPath, IVolume volume)
 
                 foreach (var dir in await currentDir.GetDirectoriesAsync(cancellationToken: cancellationToken))
                 {
-                    var newDir = new FileSystemDirectory(Path.Combine(currentNewDest.FullName, dir.Name), directory.Volume);
+                    var newDir = new FileSystemDirectory(PathHelper.SafelyCombine(
+                        currentNewDest.FullName, currentNewDest.FullName, dir.Name), currentNewDest.Volume);
                     queue.Enqueue((dir, newDir));
                 }
 
@@ -1550,7 +1605,8 @@ public IDirectory CreateDirectory(string fullPath, IVolume volume)
 
                 foreach (var dir in await currentDir.GetDirectoriesAsync(cancellationToken: cancellationToken))
                 {
-                    var newDir = new FileSystemDirectory(Path.Combine(currentNewDest.FullName, dir.Name), srcDir.Volume);
+                    var newDir = new FileSystemDirectory(PathHelper.SafelyCombine(
+                        currentNewDest.FullName, currentNewDest.FullName, dir.Name), currentNewDest.Volume);
                     queue.Enqueue((dir, newDir));
                 }
 
diff --git a/elFinder.Net.Core/elFinder.Net.Drivers.FileSystem/FileSystemFile.cs b/elFinder.Net.Core/elFinder.Net.Drivers.FileSystem/FileSystemFile.cs
index 6dbbb9b..5d8d4d1 100644
--- a/elFinder.Net.Core/elFinder.Net.Drivers.FileSystem/FileSystemFile.cs
+++ b/elFinder.Net.Core/elFinder.Net.Drivers.FileSystem/FileSystemFile.cs
@@ -209,7 +209,7 @@ public virtual Task<IFile> RenameAsync(string newName, bool verify = true, Cance
 
             if (verify && !this.CanRename()) throw new PermissionDeniedException();
 
-            var newPath = PathHelper.GetFullPath(Parent.FullName, newName);
+            var newPath = PathHelper.GetFullPath(PathHelper.SafelyCombine(Parent.FullName, Parent.FullName, newName));
             fileInfo.MoveTo(newPath);
             return Task.FromResult<IFile>(new FileSystemFile(newPath, volume));
         }
diff --git a/elFinder.Net.Core/elFinder.Net.Drivers.FileSystem/Helpers/PathHelper.cs b/elFinder.Net.Core/elFinder.Net.Drivers.FileSystem/Helpers/PathHelper.cs
index 0460432..51c8cac 100644
--- a/elFinder.Net.Core/elFinder.Net.Drivers.FileSystem/Helpers/PathHelper.cs
+++ b/elFinder.Net.Core/elFinder.Net.Drivers.FileSystem/Helpers/PathHelper.cs
@@ -1,24 +1,38 @@
-﻿using System.IO;
+﻿using elFinder.Net.Core.Exceptions;
+using System.IO;
 
 namespace elFinder.Net.Drivers.FileSystem.Helpers
 {
     public static class PathHelper
     {
-        public static string GetFullPath(params string[] paths)
+        private static readonly char[] SeparatorChars = new[] { Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar };
+
+        public static string GetFullPath(string path)
         {
-            var fullPath = Path.GetFullPath(Path.Combine(paths));
+            var fullPath = Path.GetFullPath(path);
             return fullPath;
         }
 
-        public static string GetFullPathNormalized(params string[] paths)
+        public static string GetFullPathNormalized(string path)
         {
-            var fullPath = Path.GetFullPath(Path.Combine(paths)).TrimEnd(Path.DirectorySeparatorChar);
+            var fullPath = Path.GetFullPath(path).TrimEnd(SeparatorChars);
             return fullPath;
         }
 
         public static string NormalizePath(string fullPath)
         {
-            return fullPath.TrimEnd(Path.DirectorySeparatorChar);
+            return fullPath.TrimEnd(SeparatorChars);
+        }
+
+        public static string SafelyCombine(string fromParent, params string[] paths)
+        {
+            var finalPath = Path.GetFullPath(Path.Combine(paths))
+                .Replace(Path.AltDirectorySeparatorChar, Path.DirectorySeparatorChar);
+
+            if (!finalPath.StartsWith(fromParent.TrimEnd(SeparatorChars) + Path.DirectorySeparatorChar))
+                throw new PermissionDeniedException("Path must be inside parent");
+
+            return finalPath;
         }
     }
 }
diff --git a/elFinder.Net.Core/elFinder.Net.Drivers.FileSystem/IZipDownloadPathProvider.cs b/elFinder.Net.Core/elFinder.Net.Drivers.FileSystem/IZipDownloadPathProvider.cs
index 6f1b080..1b3bcb1 100644
--- a/elFinder.Net.Core/elFinder.Net.Drivers.FileSystem/IZipDownloadPathProvider.cs
+++ b/elFinder.Net.Core/elFinder.Net.Drivers.FileSystem/IZipDownloadPathProvider.cs
@@ -1,4 +1,8 @@
-﻿using System.IO;
+﻿using elFinder.Net.Core.Exceptions;
+using System;
+using System.IO;
+using System.Security.Cryptography;
+using System.Text;
 using System.Threading.Tasks;
 
 namespace elFinder.Net.Drivers.FileSystem
@@ -11,11 +15,15 @@ public interface IZipDownloadPathProvider
 
     public class TempZipDownloadPathProvider : IZipDownloadPathProvider
     {
+        private readonly HMAC _hmac = new HMACSHA256();
+        private static readonly string Postfix = '_' + nameof(elFinder);
+
         public Task<(string ArchiveFilePath, string ArchiveFileKey)> GetFileForArchivingAsync()
         {
-            var tempFile = Path.GetTempFileName();
+            var bytes = Encoding.UTF8.GetBytes(Path.GetTempFileName() + Guid.NewGuid().ToString());
+            var tempFile = Path.Combine(Path.GetTempPath(),
+                BitConverter.ToString(_hmac.ComputeHash(bytes)).Replace("-", string.Empty) + Postfix);
             var tempFileName = Path.GetFileName(tempFile);
-
             return Task.FromResult((tempFile, tempFileName));
         }
 
@@ -23,7 +31,18 @@ public Task<string> ParseArchiveFileKeyAsync(string archiveFileKey)
         {
             var tempDirPath = Path.GetTempPath();
 
-            return Task.FromResult(Path.Combine(tempDirPath, archiveFileKey));
+            if (Path.IsPathRooted(archiveFileKey)) throw new PermissionDeniedException("Malformed key");
+
+            var fullPath = Path.GetFullPath(Path.Combine(tempDirPath, archiveFileKey));
+            if (!fullPath.StartsWith(tempDirPath.EndsWith($"{Path.DirectorySeparatorChar}")
+                ? tempDirPath : (tempDirPath + Path.DirectorySeparatorChar)))
+                throw new PermissionDeniedException("Malformed key");
+
+            var fileName = Path.GetFileName(fullPath);
+            if (!fileName.EndsWith(Postfix))
+                throw new PermissionDeniedException("Malformed key");
+
+            return Task.FromResult(fullPath);
         }
     }
 }
