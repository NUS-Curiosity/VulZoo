diff --git a/in_toto/match.go b/in_toto/match.go
new file mode 100644
index 00000000..71e8d432
--- /dev/null
+++ b/in_toto/match.go
@@ -0,0 +1,228 @@
+// Copyright 2010 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found at https://golang.org/LICENSE.
+
+// this is a modified version of path.Match that removes handling of path separators
+
+package in_toto
+
+import (
+	"errors"
+	"unicode/utf8"
+)
+
+// errBadPattern indicates a pattern was malformed.
+var errBadPattern = errors.New("syntax error in pattern")
+
+// match reports whether name matches the shell pattern.
+// The pattern syntax is:
+//
+//	pattern:
+//		{ term }
+//	term:
+//		'*'         matches any sequence of non-/ characters
+//		'?'         matches any single non-/ character
+//		'[' [ '^' ] { character-range } ']'
+//		            character class (must be non-empty)
+//		c           matches character c (c != '*', '?', '\\', '[')
+//		'\\' c      matches character c
+//
+//	character-range:
+//		c           matches character c (c != '\\', '-', ']')
+//		'\\' c      matches character c
+//		lo '-' hi   matches character c for lo <= c <= hi
+//
+// Match requires pattern to match all of name, not just a substring.
+// The only possible returned error is ErrBadPattern, when pattern
+// is malformed.
+//
+func match(pattern, name string) (matched bool, err error) {
+Pattern:
+	for len(pattern) > 0 {
+		var star bool
+		var chunk string
+		star, chunk, pattern = scanChunk(pattern)
+		if star && chunk == "" {
+			// Trailing * matches everything
+			return true, nil
+		}
+		// Look for match at current position.
+		t, ok, err := matchChunk(chunk, name)
+		// if we're the last chunk, make sure we've exhausted the name
+		// otherwise we'll give a false result even if we could still match
+		// using the star
+		if ok && (len(t) == 0 || len(pattern) > 0) {
+			name = t
+			continue
+		}
+		if err != nil {
+			return false, err
+		}
+		if star {
+			// Look for match skipping i+1 bytes.
+			for i := 0; i < len(name); i++ {
+				t, ok, err := matchChunk(chunk, name[i+1:])
+				if ok {
+					// if we're the last chunk, make sure we exhausted the name
+					if len(pattern) == 0 && len(t) > 0 {
+						continue
+					}
+					name = t
+					continue Pattern
+				}
+				if err != nil {
+					return false, err
+				}
+			}
+		}
+		// Before returning false with no error,
+		// check that the remainder of the pattern is syntactically valid.
+		for len(pattern) > 0 {
+			_, chunk, pattern = scanChunk(pattern)
+			if _, _, err := matchChunk(chunk, ""); err != nil {
+				return false, err
+			}
+		}
+		return false, nil
+	}
+	return len(name) == 0, nil
+}
+
+// scanChunk gets the next segment of pattern, which is a non-star string
+// possibly preceded by a star.
+func scanChunk(pattern string) (star bool, chunk, rest string) {
+	for len(pattern) > 0 && pattern[0] == '*' {
+		pattern = pattern[1:]
+		star = true
+	}
+	inrange := false
+	var i int
+Scan:
+	for i = 0; i < len(pattern); i++ {
+		switch pattern[i] {
+		case '\\':
+			// error check handled in matchChunk: bad pattern.
+			if i+1 < len(pattern) {
+				i++
+			}
+		case '[':
+			inrange = true
+		case ']':
+			inrange = false
+		case '*':
+			if !inrange {
+				break Scan
+			}
+		}
+	}
+	return star, pattern[0:i], pattern[i:]
+}
+
+// matchChunk checks whether chunk matches the beginning of s.
+// If so, it returns the remainder of s (after the match).
+// Chunk is all single-character operators: literals, char classes, and ?.
+func matchChunk(chunk, s string) (rest string, ok bool, err error) {
+	// failed records whether the match has failed.
+	// After the match fails, the loop continues on processing chunk,
+	// checking that the pattern is well-formed but no longer reading s.
+	failed := false
+	for len(chunk) > 0 {
+		if !failed && len(s) == 0 {
+			failed = true
+		}
+		switch chunk[0] {
+		case '[':
+			// character class
+			var r rune
+			if !failed {
+				var n int
+				r, n = utf8.DecodeRuneInString(s)
+				s = s[n:]
+			}
+			chunk = chunk[1:]
+			// possibly negated
+			negated := false
+			if len(chunk) > 0 && chunk[0] == '^' {
+				negated = true
+				chunk = chunk[1:]
+			}
+			// parse all ranges
+			match := false
+			nrange := 0
+			for {
+				if len(chunk) > 0 && chunk[0] == ']' && nrange > 0 {
+					chunk = chunk[1:]
+					break
+				}
+				var lo, hi rune
+				if lo, chunk, err = getEsc(chunk); err != nil {
+					return "", false, err
+				}
+				hi = lo
+				if chunk[0] == '-' {
+					if hi, chunk, err = getEsc(chunk[1:]); err != nil {
+						return "", false, err
+					}
+				}
+				if lo <= r && r <= hi {
+					match = true
+				}
+				nrange++
+			}
+			if match == negated {
+				failed = true
+			}
+
+		case '?':
+			if !failed {
+				_, n := utf8.DecodeRuneInString(s)
+				s = s[n:]
+			}
+			chunk = chunk[1:]
+
+		case '\\':
+			chunk = chunk[1:]
+			if len(chunk) == 0 {
+				return "", false, errBadPattern
+			}
+			fallthrough
+
+		default:
+			if !failed {
+				if chunk[0] != s[0] {
+					failed = true
+				}
+				s = s[1:]
+			}
+			chunk = chunk[1:]
+		}
+	}
+	if failed {
+		return "", false, nil
+	}
+	return s, true, nil
+}
+
+// getEsc gets a possibly-escaped character from chunk, for a character class.
+func getEsc(chunk string) (r rune, nchunk string, err error) {
+	if len(chunk) == 0 || chunk[0] == '-' || chunk[0] == ']' {
+		err = errBadPattern
+		return
+	}
+	if chunk[0] == '\\' {
+		chunk = chunk[1:]
+		if len(chunk) == 0 {
+			err = errBadPattern
+			return
+		}
+	}
+	r, n := utf8.DecodeRuneInString(chunk)
+	if r == utf8.RuneError && n == 1 {
+		err = errBadPattern
+	}
+	nchunk = chunk[n:]
+	if len(nchunk) == 0 {
+		err = errBadPattern
+	}
+	return
+}
diff --git a/in_toto/match_test.go b/in_toto/match_test.go
new file mode 100644
index 00000000..998aac9a
--- /dev/null
+++ b/in_toto/match_test.go
@@ -0,0 +1,85 @@
+// Copyright 2009 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found at https://golang.org/LICENSE.
+
+// this is a modified version of path.Match that removes handling of path separators
+
+package in_toto
+
+import "testing"
+
+type MatchTest struct {
+	pattern, s string
+	match      bool
+	err        error
+}
+
+var matchTests = []MatchTest{
+	{"*", "foo/bar", true, nil},
+	{"abc", "abc", true, nil},
+	{"*", "abc", true, nil},
+	{"*c", "abc", true, nil},
+	{"a*", "a", true, nil},
+	{"a*", "abc", true, nil},
+	{"a*", "ab/c", true, nil},
+	{"a*/b", "abc/b", true, nil},
+	{"a*/b", "a/c/b", true, nil},
+	{"a*b*c*d*e*/f", "axbxcxdxe/f", true, nil},
+	{"a*b*c*d*e*/f", "axbxcxdxexxx/f", true, nil},
+	{"a*b*c*d*e*/f", "axbxcxdxe/xxx/f", true, nil},
+	{"a*b*c*d*e*/f", "axbxcxdxexxx/fff", false, nil},
+	{"a*b?c*x", "abxbbxdbxebxczzx", true, nil},
+	{"a*b?c*x", "abxbbxdbxebxczzy", false, nil},
+	{"ab[c]", "abc", true, nil},
+	{"ab[b-d]", "abc", true, nil},
+	{"ab[e-g]", "abc", false, nil},
+	{"ab[^c]", "abc", false, nil},
+	{"ab[^b-d]", "abc", false, nil},
+	{"ab[^e-g]", "abc", true, nil},
+	{"a\\*b", "a*b", true, nil},
+	{"a\\*b", "ab", false, nil},
+	{"a?b", "a☺b", true, nil},
+	{"a[^a]b", "a☺b", true, nil},
+	{"a???b", "a☺b", false, nil},
+	{"a[^a][^a][^a]b", "a☺b", false, nil},
+	{"[a-ζ]*", "α", true, nil},
+	{"*[a-ζ]", "A", false, nil},
+	{"a?b", "a/b", true, nil},
+	{"a*b", "a/b", true, nil},
+	{"[\\]a]", "]", true, nil},
+	{"[\\-]", "-", true, nil},
+	{"[x\\-]", "x", true, nil},
+	{"[x\\-]", "-", true, nil},
+	{"[x\\-]", "z", false, nil},
+	{"[\\-x]", "x", true, nil},
+	{"[\\-x]", "-", true, nil},
+	{"[\\-x]", "a", false, nil},
+	{"[]a]", "]", false, errBadPattern},
+	{"[-]", "-", false, errBadPattern},
+	{"[x-]", "x", false, errBadPattern},
+	{"[x-]", "-", false, errBadPattern},
+	{"[x-]", "z", false, errBadPattern},
+	{"[-x]", "x", false, errBadPattern},
+	{"[-x]", "-", false, errBadPattern},
+	{"[-x]", "a", false, errBadPattern},
+	{"\\", "a", false, errBadPattern},
+	{"[a-b-c]", "a", false, errBadPattern},
+	{"[", "a", false, errBadPattern},
+	{"[^", "a", false, errBadPattern},
+	{"[^bc", "a", false, errBadPattern},
+	{"a[", "a", false, errBadPattern},
+	{"a[", "ab", false, errBadPattern},
+	{"a[", "x", false, errBadPattern},
+	{"a/b[", "x", false, errBadPattern},
+	{"a[\\", "x", false, errBadPattern},
+	{"*x", "xxx", true, nil},
+}
+
+func TestMatch(t *testing.T) {
+	for _, tt := range matchTests {
+		ok, err := match(tt.pattern, tt.s)
+		if ok != tt.match || err != tt.err {
+			t.Errorf("Match(%#q, %#q) = %v, %v want %v, %v", tt.pattern, tt.s, ok, err, tt.match, tt.err)
+		}
+	}
+}
diff --git a/in_toto/util.go b/in_toto/util.go
index a21d73f9..59cba86e 100644
--- a/in_toto/util.go
+++ b/in_toto/util.go
@@ -2,7 +2,6 @@ package in_toto
 
 import (
 	"fmt"
-	"path/filepath"
 )
 
 /*
@@ -89,7 +88,7 @@ non-match plus a warning is printed.
 func (s Set) Filter(pattern string) Set {
 	res := NewSet()
 	for elem := range s {
-		matched, err := filepath.Match(pattern, elem)
+		matched, err := match(pattern, elem)
 		if err != nil {
 			fmt.Printf("WARNING: %s, pattern was '%s'\n", err, pattern)
 			continue
diff --git a/in_toto/verifylib.go b/in_toto/verifylib.go
index 4f85315b..3ac5d065 100644
--- a/in_toto/verifylib.go
+++ b/in_toto/verifylib.go
@@ -11,6 +11,7 @@ import (
 	"fmt"
 	"io"
 	"os"
+	"path"
 	osPath "path"
 	"path/filepath"
 	"reflect"
@@ -94,17 +95,35 @@ func verifyMatchRule(ruleData map[string]string,
 	switch ruleData["dstType"] {
 	case "materials":
 		dstArtifacts = dstLinkMb.Signed.(Link).Materials
-
 	case "products":
 		dstArtifacts = dstLinkMb.Signed.(Link).Products
 	}
 
+	// cleanup paths in pattern and artifact maps
+	if ruleData["pattern"] != "" {
+		ruleData["pattern"] = path.Clean(ruleData["pattern"])
+	}
+	for k := range srcArtifacts {
+		if path.Clean(k) != k {
+			srcArtifacts[path.Clean(k)] = srcArtifacts[k]
+			delete(srcArtifacts, k)
+		}
+	}
+	for k := range dstArtifacts {
+		if path.Clean(k) != k {
+			dstArtifacts[path.Clean(k)] = dstArtifacts[k]
+			delete(dstArtifacts, k)
+		}
+	}
+
 	// Normalize optional source and destination prefixes, i.e. if
 	// there is a prefix, then add a trailing slash if not there yet
 	for _, prefix := range []string{"srcPrefix", "dstPrefix"} {
-		if ruleData[prefix] != "" &&
-			!strings.HasSuffix(ruleData[prefix], "/") {
-			ruleData[prefix] += "/"
+		if ruleData[prefix] != "" {
+			ruleData[prefix] = path.Clean(ruleData[prefix])
+			if !strings.HasSuffix(ruleData[prefix], "/") {
+				ruleData[prefix] += "/"
+			}
 		}
 	}
 	// Iterate over queue and mark consumed artifacts
@@ -114,14 +133,14 @@ func verifyMatchRule(ruleData map[string]string,
 		srcBasePath := strings.TrimPrefix(srcPath, ruleData["srcPrefix"])
 
 		// Ignore artifacts not matched by rule pattern
-		matched, err := filepath.Match(ruleData["pattern"], srcBasePath)
+		matched, err := match(ruleData["pattern"], srcBasePath)
 		if err != nil || !matched {
 			continue
 		}
 
 		// Construct corresponding destination artifact path, i.e.
 		// an optional destination prefix plus the source base path
-		dstPath := osPath.Join(ruleData["dstPrefix"], srcBasePath)
+		dstPath := path.Clean(osPath.Join(ruleData["dstPrefix"], srcBasePath))
 
 		// Try to find the corresponding destination artifact
 		dstArtifact, exists := dstArtifacts[dstPath]
@@ -202,8 +221,14 @@ func VerifyArtifacts(items []interface{},
 		// All other rules only require the material or product paths (without
 		// hashes). We extract them from the corresponding maps and store them as
 		// sets for convenience in further processing
-		materialPaths := NewSet(InterfaceKeyStrings(materials)...)
-		productPaths := NewSet(InterfaceKeyStrings(products)...)
+		materialPaths := NewSet()
+		for _, p := range InterfaceKeyStrings(materials) {
+			materialPaths.Add(path.Clean(p))
+		}
+		productPaths := NewSet()
+		for _, p := range InterfaceKeyStrings(products) {
+			productPaths.Add(path.Clean(p))
+		}
 
 		// For `create`, `delete` and `modify` rules we prepare sets of artifacts
 		// (without hashes) that were created, deleted or modified in the current
@@ -269,7 +294,7 @@ func VerifyArtifacts(items []interface{},
 
 				// Apply rule pattern to filter queued artifacts that are up for rule
 				// specific consumption
-				filtered := queue.Filter(ruleData["pattern"])
+				filtered := queue.Filter(path.Clean(ruleData["pattern"]))
 
 				var consumed Set
 				switch ruleData["type"] {
diff --git a/in_toto/verifylib_test.go b/in_toto/verifylib_test.go
index 94eb21c0..3f67c9b2 100644
--- a/in_toto/verifylib_test.go
+++ b/in_toto/verifylib_test.go
@@ -253,191 +253,355 @@ func TestRunInspections(t *testing.T) {
 	}
 }
 
-func TestVerifyArtifacts(t *testing.T) {
-	items := []interface{}{
-		Step{
-			SupplyChainItem: SupplyChainItem{
-				Name: "foo",
-				ExpectedMaterials: [][]string{
-					{"DELETE", "foo-delete"},
-					{"MODIFY", "foo-modify"},
-					{"MATCH", "foo-match", "WITH", "MATERIALS", "FROM", "foo"}, // not-modify
-					{"ALLOW", "foo-allow"},
-					{"DISALLOW", "*"},
+func TestVerifyArtifact(t *testing.T) {
+	var testCases = []struct {
+		name      string
+		item      []interface{}
+		metadata  map[string]Metablock
+		expectErr string
+	}{
+		{
+			name: "Verify artifacts",
+			item: []interface{}{
+				Step{
+					SupplyChainItem: SupplyChainItem{
+						Name: "foo",
+						ExpectedMaterials: [][]string{
+							{"DELETE", "foo-delete"},
+							{"MODIFY", "foo-modify"},
+							{"MATCH", "foo-match", "WITH", "MATERIALS", "FROM", "foo"}, // not-modify
+							{"ALLOW", "foo-allow"},
+							{"DISALLOW", "*"},
+						},
+						ExpectedProducts: [][]string{
+							{"CREATE", "foo-create"},
+							{"MODIFY", "foo-modify"},
+							{"MATCH", "foo-match", "WITH", "MATERIALS", "FROM", "foo"}, // not-modify
+							{"REQUIRE", "foo-allow"},
+							{"ALLOW", "foo-allow"},
+							{"DISALLOW", "*"},
+						},
+					},
 				},
-				ExpectedProducts: [][]string{
-					{"CREATE", "foo-create"},
-					{"MODIFY", "foo-modify"},
-					{"MATCH", "foo-match", "WITH", "MATERIALS", "FROM", "foo"}, // not-modify
-					{"REQUIRE", "foo-allow"},
-					{"ALLOW", "foo-allow"},
-					{"DISALLOW", "*"},
+			},
+			metadata: map[string]Metablock{
+				"foo": {
+					Signed: Link{
+						Name: "foo",
+						Materials: map[string]interface{}{
+							"foo-delete": map[string]interface{}{"sha265": "abc"},
+							"foo-modify": map[string]interface{}{"sha265": "abc"},
+							"foo-match":  map[string]interface{}{"sha265": "abc"},
+							"foo-allow":  map[string]interface{}{"sha265": "abc"},
+						},
+						Products: map[string]interface{}{
+							"foo-create": map[string]interface{}{"sha265": "abc"},
+							"foo-modify": map[string]interface{}{"sha265": "abcdef"},
+							"foo-match":  map[string]interface{}{"sha265": "abc"},
+							"foo-allow":  map[string]interface{}{"sha265": "abc"},
+						},
+					},
 				},
 			},
+			expectErr: "",
 		},
-	}
-
-	itemsMetadata := map[string]Metablock{
-		"foo": {
-			Signed: Link{
-				Name: "foo",
-				Materials: map[string]interface{}{
-					"foo-delete": map[string]interface{}{"sha265": "abc"},
-					"foo-modify": map[string]interface{}{"sha265": "abc"},
-					"foo-match":  map[string]interface{}{"sha265": "abc"},
-					"foo-allow":  map[string]interface{}{"sha265": "abc"},
+		{
+			name: "Verify match with relative paths",
+			item: []interface{}{
+				Step{
+					SupplyChainItem: SupplyChainItem{
+						Name: "foo",
+						ExpectedMaterials: [][]string{
+							{"MATCH", "*", "WITH", "PRODUCTS", "FROM", "bar"},
+							{"DISALLOW", "*"},
+						},
+					},
+				},
+			},
+			metadata: map[string]Metablock{
+				"foo": {
+					Signed: Link{
+						Name: "foo",
+						Materials: map[string]interface{}{
+							"./foo.d/foo.py": map[string]interface{}{"sha265": "abc"},
+							"bar.d/bar.py":   map[string]interface{}{"sha265": "abc"},
+						},
+					},
+				},
+				"bar": {
+					Signed: Link{
+						Name: "bar",
+						Products: map[string]interface{}{
+							"foo.d/foo.py":          map[string]interface{}{"sha265": "abc"},
+							"./baz/../bar.d/bar.py": map[string]interface{}{"sha265": "abc"},
+						},
+					},
+				},
+			},
+			expectErr: "",
+		},
+		{
+			name: "Verify match detection of hash mismatch",
+			item: []interface{}{
+				Step{
+					SupplyChainItem: SupplyChainItem{
+						Name: "foo",
+						ExpectedMaterials: [][]string{
+							{"MATCH", "*", "WITH", "PRODUCTS", "FROM", "bar"},
+							{"DISALLOW", "*"},
+						},
+					},
+				},
+			},
+			metadata: map[string]Metablock{
+				"foo": {
+					Signed: Link{
+						Name: "foo",
+						Materials: map[string]interface{}{
+							"foo.d/foo.py": map[string]interface{}{"sha265": "abc"},
+							"bar.d/bar.py": map[string]interface{}{"sha265": "def"}, // modified by mitm
+						},
+					},
 				},
-				Products: map[string]interface{}{
-					"foo-create": map[string]interface{}{"sha265": "abc"},
-					"foo-modify": map[string]interface{}{"sha265": "abcdef"},
-					"foo-match":  map[string]interface{}{"sha265": "abc"},
-					"foo-allow":  map[string]interface{}{"sha265": "abc"},
+				"bar": {
+					Signed: Link{
+						Name: "bar",
+						Products: map[string]interface{}{
+							"foo.d/foo.py": map[string]interface{}{"sha265": "abc"},
+							"bar.d/bar.py": map[string]interface{}{"sha265": "abc"},
+						},
+					},
 				},
 			},
+			expectErr: "materials [bar.d/bar.py] disallowed by rule",
+		},
+		{
+			name:      "Item must be one of step or inspection",
+			item:      []interface{}{nil},
+			metadata:  map[string]Metablock{},
+			expectErr: "item of invalid type",
+		},
+		{
+			name:      "Can't find link metadata for step",
+			item:      []interface{}{Step{SupplyChainItem: SupplyChainItem{Name: "foo"}}},
+			metadata:  map[string]Metablock{},
+			expectErr: "could not find metadata",
+		},
+		{
+			name:      "Can't find link metadata for inspection",
+			item:      []interface{}{Inspection{SupplyChainItem: SupplyChainItem{Name: "foo"}}},
+			metadata:  map[string]Metablock{},
+			expectErr: "could not find metadata",
+		},
+		{
+			name:      "Wrong step expected material",
+			item:      []interface{}{Step{SupplyChainItem: SupplyChainItem{Name: "foo", ExpectedMaterials: [][]string{{"INVALID", "rule"}}}}},
+			metadata:  map[string]Metablock{"foo": {Signed: Link{Name: "foo"}}},
+			expectErr: "rule format",
+		},
+		{
+			name:      "Wrong step expected product",
+			item:      []interface{}{Step{SupplyChainItem: SupplyChainItem{Name: "foo", ExpectedProducts: [][]string{{"INVALID", "rule"}}}}},
+			metadata:  map[string]Metablock{"foo": {Signed: Link{Name: "foo"}}},
+			expectErr: "rule format",
+		},
+		{
+			name:      "Wrong inspection expected material",
+			item:      []interface{}{Inspection{SupplyChainItem: SupplyChainItem{Name: "foo", ExpectedMaterials: [][]string{{"INVALID", "rule"}}}}},
+			metadata:  map[string]Metablock{"foo": {Signed: Link{Name: "foo"}}},
+			expectErr: "rule format",
+		},
+		{
+			name:      "Wrong inspection expected product",
+			item:      []interface{}{Inspection{SupplyChainItem: SupplyChainItem{Name: "foo", ExpectedProducts: [][]string{{"INVALID", "rule"}}}}},
+			metadata:  map[string]Metablock{"foo": {Signed: Link{Name: "foo"}}},
+			expectErr: "rule format",
+		},
+		{
+			name:      "Disallowed material in step",
+			item:      []interface{}{Step{SupplyChainItem: SupplyChainItem{Name: "foo", ExpectedMaterials: [][]string{{"DISALLOW", "*"}}}}},
+			metadata:  map[string]Metablock{"foo": {Signed: Link{Name: "foo", Materials: map[string]interface{}{"foo.py": map[string]interface{}{"sha265": "abc"}}}}},
+			expectErr: "materials [foo.py] disallowed by rule",
+		},
+		{
+			name:      "Disallowed product in step",
+			item:      []interface{}{Step{SupplyChainItem: SupplyChainItem{Name: "foo", ExpectedProducts: [][]string{{"DISALLOW", "*"}}}}},
+			metadata:  map[string]Metablock{"foo": {Signed: Link{Name: "foo", Products: map[string]interface{}{"foo.py": map[string]interface{}{"sha265": "abc"}}}}},
+			expectErr: "products [foo.py] disallowed by rule",
+		},
+		{
+			name:      "Disallowed material in inspection",
+			item:      []interface{}{Inspection{SupplyChainItem: SupplyChainItem{Name: "foo", ExpectedMaterials: [][]string{{"DISALLOW", "*"}}}}},
+			metadata:  map[string]Metablock{"foo": {Signed: Link{Name: "foo", Materials: map[string]interface{}{"foo.py": map[string]interface{}{"sha265": "abc"}}}}},
+			expectErr: "materials [foo.py] disallowed by rule",
+		},
+		{
+			name:      "Disallowed product in inspection",
+			item:      []interface{}{Inspection{SupplyChainItem: SupplyChainItem{Name: "foo", ExpectedProducts: [][]string{{"DISALLOW", "*"}}}}},
+			metadata:  map[string]Metablock{"foo": {Signed: Link{Name: "foo", Products: map[string]interface{}{"foo.py": map[string]interface{}{"sha265": "abc"}}}}},
+			expectErr: "products [foo.py] disallowed by rule",
+		},
+		{
+			name:      "Required but missing material in step",
+			item:      []interface{}{Step{SupplyChainItem: SupplyChainItem{Name: "foo", ExpectedMaterials: [][]string{{"REQUIRE", "foo"}}}}},
+			metadata:  map[string]Metablock{"foo": {Signed: Link{Name: "foo", Materials: map[string]interface{}{"foo.py": map[string]interface{}{"sha265": "abc"}}}}},
+			expectErr: "materials in REQUIRE 'foo'",
+		},
+		{
+			name:      "Required but missing product in step",
+			item:      []interface{}{Step{SupplyChainItem: SupplyChainItem{Name: "foo", ExpectedProducts: [][]string{{"REQUIRE", "foo"}}}}},
+			metadata:  map[string]Metablock{"foo": {Signed: Link{Name: "foo", Products: map[string]interface{}{"foo.py": map[string]interface{}{"sha265": "abc"}}}}},
+			expectErr: "products in REQUIRE 'foo'",
+		},
+		{
+			name:      "Required but missing material in inspection",
+			item:      []interface{}{Inspection{SupplyChainItem: SupplyChainItem{Name: "foo", ExpectedMaterials: [][]string{{"REQUIRE", "foo"}}}}},
+			metadata:  map[string]Metablock{"foo": {Signed: Link{Name: "foo", Materials: map[string]interface{}{"foo.py": map[string]interface{}{"sha265": "abc"}}}}},
+			expectErr: "materials in REQUIRE 'foo'",
+		},
+		{
+			name:      "Required but missing product in inspection",
+			item:      []interface{}{Inspection{SupplyChainItem: SupplyChainItem{Name: "foo", ExpectedProducts: [][]string{{"REQUIRE", "foo"}}}}},
+			metadata:  map[string]Metablock{"foo": {Signed: Link{Name: "foo", Products: map[string]interface{}{"foo.py": map[string]interface{}{"sha265": "abc"}}}}},
+			expectErr: "products in REQUIRE 'foo'",
+		},
+		{
+			name:      "Disallowed subdirectory material in step",
+			item:      []interface{}{Step{SupplyChainItem: SupplyChainItem{Name: "foo", ExpectedMaterials: [][]string{{"DISALLOW", "*"}}}}},
+			metadata:  map[string]Metablock{"foo": {Signed: Link{Name: "foo", Materials: map[string]interface{}{"dir/foo.py": map[string]interface{}{"sha265": "abc"}}}}},
+			expectErr: "materials [dir/foo.py] disallowed by rule",
+		},
+		{
+			name:      "Disallowed subdirectory product in step",
+			item:      []interface{}{Step{SupplyChainItem: SupplyChainItem{Name: "foo", ExpectedProducts: [][]string{{"DISALLOW", "*"}}}}},
+			metadata:  map[string]Metablock{"foo": {Signed: Link{Name: "foo", Products: map[string]interface{}{"dir/foo.py": map[string]interface{}{"sha265": "abc"}}}}},
+			expectErr: "products [dir/foo.py] disallowed by rule",
+		},
+		{
+			name:      "Disallowed subdirectory material in inspection",
+			item:      []interface{}{Inspection{SupplyChainItem: SupplyChainItem{Name: "foo", ExpectedMaterials: [][]string{{"DISALLOW", "*"}}}}},
+			metadata:  map[string]Metablock{"foo": {Signed: Link{Name: "foo", Materials: map[string]interface{}{"dir/foo.py": map[string]interface{}{"sha265": "abc"}}}}},
+			expectErr: "materials [dir/foo.py] disallowed by rule",
+		},
+		{
+			name:      "Disallowed subdirectory product in inspection",
+			item:      []interface{}{Inspection{SupplyChainItem: SupplyChainItem{Name: "foo", ExpectedProducts: [][]string{{"DISALLOW", "*"}}}}},
+			metadata:  map[string]Metablock{"foo": {Signed: Link{Name: "foo", Products: map[string]interface{}{"dir/foo.py": map[string]interface{}{"sha265": "abc"}}}}},
+			expectErr: "products [dir/foo.py] disallowed by rule",
+		},
+		{
+			name:      "Consuming filename material in step",
+			item:      []interface{}{Step{SupplyChainItem: SupplyChainItem{Name: "foo", ExpectedMaterials: [][]string{{"ALLOW", "foo.py"}, {"DISALLOW", "*"}}}}},
+			metadata:  map[string]Metablock{"foo": {Signed: Link{Name: "foo", Materials: map[string]interface{}{"./bar/..//foo.py": map[string]interface{}{"sha265": "abc"}}}}},
+			expectErr: "",
+		},
+		{
+			name:      "Consuming filename product in step",
+			item:      []interface{}{Step{SupplyChainItem: SupplyChainItem{Name: "foo", ExpectedProducts: [][]string{{"ALLOW", "foo.py"}, {"DISALLOW", "*"}}}}},
+			metadata:  map[string]Metablock{"foo": {Signed: Link{Name: "foo", Products: map[string]interface{}{"./bar/..//foo.py": map[string]interface{}{"sha265": "abc"}}}}},
+			expectErr: "",
+		},
+		{
+			name:      "Consuming filename material in inspection",
+			item:      []interface{}{Inspection{SupplyChainItem: SupplyChainItem{Name: "foo", ExpectedMaterials: [][]string{{"ALLOW", "foo.py"}, {"DISALLOW", "*"}}}}},
+			metadata:  map[string]Metablock{"foo": {Signed: Link{Name: "foo", Materials: map[string]interface{}{"./bar/..//foo.py": map[string]interface{}{"sha265": "abc"}}}}},
+			expectErr: "",
+		},
+		{
+			name:      "Consuming filename product in inspection",
+			item:      []interface{}{Inspection{SupplyChainItem: SupplyChainItem{Name: "foo", ExpectedProducts: [][]string{{"ALLOW", "foo.py"}, {"DISALLOW", "*"}}}}},
+			metadata:  map[string]Metablock{"foo": {Signed: Link{Name: "foo", Products: map[string]interface{}{"./bar/..//foo.py": map[string]interface{}{"sha265": "abc"}}}}},
+			expectErr: "",
 		},
 	}
 
-	err := VerifyArtifacts(items, itemsMetadata)
-	if err != nil {
-		t.Errorf("VerifyArtifacts returned '%s', expected no error", err)
+	for _, tt := range testCases {
+		t.Run(tt.name, func(t *testing.T) {
+			err := VerifyArtifacts(tt.item, tt.metadata)
+			if (err == nil && tt.expectErr != "") ||
+				(err != nil && tt.expectErr == "") ||
+				(err != nil && !strings.Contains(err.Error(), tt.expectErr)) {
+				t.Errorf("VerifyArtifacts returned '%s', expected '%s' error",
+					err, tt.expectErr)
+			}
+		})
 	}
 }
 
-func TestVerifyArtifactErrors(t *testing.T) {
-	// Test error cases for combinations of Step and Inspection items and
-	// material and product rules:
-	// - Item must be one of step or inspection
-	// - Can't find link metadata for step
-	// - Can't find link metadata for inspection
-	// - Wrong step expected material
-	// - Wrong step expected product
-	// - Wrong inspection expected material
-	// - Wrong inspection expected product
-	// - Disallowed material in step
-	// - Disallowed product in step
-	// - Disallowed material in inspection
-	// - Disallowed product in inspection
-	// - Required but missing material in step
-	// - Required but missing product in step
-	// - Required but missing material in inspection
-	// - Required but missing product in inspection
-	items := [][]interface{}{
-		{nil},
-		{Step{SupplyChainItem: SupplyChainItem{Name: "foo"}}},
-		{Inspection{SupplyChainItem: SupplyChainItem{Name: "foo"}}},
-		{Step{SupplyChainItem: SupplyChainItem{Name: "foo", ExpectedMaterials: [][]string{{"INVALID", "rule"}}}}},
-		{Step{SupplyChainItem: SupplyChainItem{Name: "foo", ExpectedProducts: [][]string{{"INVALID", "rule"}}}}},
-		{Inspection{SupplyChainItem: SupplyChainItem{Name: "foo", ExpectedMaterials: [][]string{{"INVALID", "rule"}}}}},
-		{Inspection{SupplyChainItem: SupplyChainItem{Name: "foo", ExpectedProducts: [][]string{{"INVALID", "rule"}}}}},
-		{Step{SupplyChainItem: SupplyChainItem{Name: "foo", ExpectedMaterials: [][]string{{"DISALLOW", "*"}}}}},
-		{Step{SupplyChainItem: SupplyChainItem{Name: "foo", ExpectedProducts: [][]string{{"DISALLOW", "*"}}}}},
-		{Inspection{SupplyChainItem: SupplyChainItem{Name: "foo", ExpectedMaterials: [][]string{{"DISALLOW", "*"}}}}},
-		{Inspection{SupplyChainItem: SupplyChainItem{Name: "foo", ExpectedProducts: [][]string{{"DISALLOW", "*"}}}}},
-		{Step{SupplyChainItem: SupplyChainItem{Name: "foo", ExpectedMaterials: [][]string{{"REQUIRE", "foo"}}}}},
-		{Step{SupplyChainItem: SupplyChainItem{Name: "foo", ExpectedProducts: [][]string{{"REQUIRE", "foo"}}}}},
-		{Inspection{SupplyChainItem: SupplyChainItem{Name: "foo", ExpectedMaterials: [][]string{{"REQUIRE", "foo"}}}}},
-		{Inspection{SupplyChainItem: SupplyChainItem{Name: "foo", ExpectedProducts: [][]string{{"REQUIRE", "foo"}}}}},
-	}
-	itemsMetadata := []map[string]Metablock{
-		{},
-		{},
-		{},
-		{"foo": {Signed: Link{Name: "foo"}}},
-		{"foo": {Signed: Link{Name: "foo"}}},
-		{"foo": {Signed: Link{Name: "foo"}}},
-		{"foo": {Signed: Link{Name: "foo"}}},
-		{"foo": {Signed: Link{Name: "foo", Materials: map[string]interface{}{"foo.py": map[string]interface{}{"sha265": "abc"}}}}},
-		{"foo": {Signed: Link{Name: "foo", Products: map[string]interface{}{"foo.py": map[string]interface{}{"sha265": "abc"}}}}},
-		{"foo": {Signed: Link{Name: "foo", Materials: map[string]interface{}{"foo.py": map[string]interface{}{"sha265": "abc"}}}}},
-		{"foo": {Signed: Link{Name: "foo", Products: map[string]interface{}{"foo.py": map[string]interface{}{"sha265": "abc"}}}}},
-		{"foo": {Signed: Link{Name: "foo", Materials: map[string]interface{}{"foo.py": map[string]interface{}{"sha265": "abc"}}}}},
-		{"foo": {Signed: Link{Name: "foo", Products: map[string]interface{}{"foo.py": map[string]interface{}{"sha265": "abc"}}}}},
-		{"foo": {Signed: Link{Name: "foo", Materials: map[string]interface{}{"foo.py": map[string]interface{}{"sha265": "abc"}}}}},
-		{"foo": {Signed: Link{Name: "foo", Products: map[string]interface{}{"foo.py": map[string]interface{}{"sha265": "abc"}}}}},
-	}
-	errorPart := []string{
-		"item of invalid type",
-		"could not find metadata",
-		"could not find metadata",
-		"rule format",
-		"rule format",
-		"rule format",
-		"rule format",
-		"materials [foo.py] disallowed by rule",
-		"products [foo.py] disallowed by rule",
-		"materials [foo.py] disallowed by rule",
-		"products [foo.py] disallowed by rule",
-		"materials in REQUIRE 'foo'",
-		"products in REQUIRE 'foo'",
-		"materials in REQUIRE 'foo'",
-		"products in REQUIRE 'foo'",
-	}
-
-	for i := 0; i < len(items); i++ {
-		err := VerifyArtifacts(items[i], itemsMetadata[i])
-		if err == nil || !strings.Contains(err.Error(), errorPart[i]) {
-			t.Errorf("VerifyArtifacts returned '%s', expected '%s' error",
-				err, errorPart[i])
-		}
+func TestVerifyMatchRule(t *testing.T) {
+	var testCases = []struct {
+		name        string
+		rule        map[string]string
+		srcArtifact map[string]interface{}
+		item        map[string]Metablock
+		expectSet   Set
+	}{
+		{
+			name:        "Can't find destination link (invalid rule)",
+			rule:        map[string]string{},
+			srcArtifact: map[string]interface{}{},
+			item:        map[string]Metablock{},
+			expectSet:   NewSet(),
+		},
+		{
+			name:        "Can't find destination link (empty metadata map)",
+			rule:        map[string]string{"pattern": "*", "dstName": "foo", "dstType": "materials"},
+			srcArtifact: map[string]interface{}{"foo.py": map[string]interface{}{"sha265": "abc"}},
+			item:        map[string]Metablock{},
+			expectSet:   NewSet(),
+		},
+		{
+			name:        "Match material foo.py",
+			rule:        map[string]string{"pattern": "*", "dstName": "foo", "dstType": "materials"},
+			srcArtifact: map[string]interface{}{"foo.py": map[string]interface{}{"sha265": "abc"}},
+			item:        map[string]Metablock{"foo": {Signed: Link{Name: "foo", Materials: map[string]interface{}{"foo.py": map[string]interface{}{"sha265": "abc"}}}}},
+			expectSet:   NewSet("foo.py"),
+		},
+		{
+			name:        "Match material foo.py with foo.d/foo.py",
+			rule:        map[string]string{"pattern": "*", "dstName": "foo", "dstType": "materials", "dstPrefix": "foo.d"},
+			srcArtifact: map[string]interface{}{"foo.py": map[string]interface{}{"sha265": "abc"}},
+			item:        map[string]Metablock{"foo": {Signed: Link{Name: "foo", Materials: map[string]interface{}{"foo.d/foo.py": map[string]interface{}{"sha265": "abc"}}}}},
+			expectSet:   NewSet("foo.py"),
+		},
+		{
+			name:        "Match material foo.d/foo.py with foo.py",
+			rule:        map[string]string{"pattern": "*", "dstName": "foo", "dstType": "materials", "srcPrefix": "foo.d"},
+			srcArtifact: map[string]interface{}{"foo.d/foo.py": map[string]interface{}{"sha265": "abc"}},
+			item:        map[string]Metablock{"foo": {Signed: Link{Name: "foo", Materials: map[string]interface{}{"foo.py": map[string]interface{}{"sha265": "abc"}}}}},
+			expectSet:   NewSet("foo.d/foo.py"),
+		},
+		{
+			name:        "Don't match material (different name)",
+			rule:        map[string]string{"pattern": "*", "dstName": "foo", "dstType": "materials"},
+			srcArtifact: map[string]interface{}{"bar.py": map[string]interface{}{"sha265": "abc"}},
+			item:        map[string]Metablock{"foo": {Signed: Link{Name: "foo", Materials: map[string]interface{}{"foo.py": map[string]interface{}{"sha265": "abc"}}}}},
+			expectSet:   NewSet(),
+		},
+		{
+			name:        "Don't match material (different hash)",
+			rule:        map[string]string{"pattern": "*", "dstName": "foo", "dstType": "materials"},
+			srcArtifact: map[string]interface{}{"foo.py": map[string]interface{}{"sha265": "dead"}},
+			item:        map[string]Metablock{"foo": {Signed: Link{Name: "foo", Materials: map[string]interface{}{"foo.py": map[string]interface{}{"sha265": "abc"}}}}},
+			expectSet:   NewSet(),
+		},
+		{
+			name:        "Match material in sub-directories dir/foo.py",
+			rule:        map[string]string{"pattern": "*", "dstName": "foo", "dstType": "materials"},
+			srcArtifact: map[string]interface{}{"bar/foo.py": map[string]interface{}{"sha265": "abc"}},
+			item:        map[string]Metablock{"foo": {Signed: Link{Name: "foo", Materials: map[string]interface{}{"bar/foo.py": map[string]interface{}{"sha265": "abc"}}}}},
+			expectSet:   NewSet("bar/foo.py"),
+		},
 	}
-}
 
-func TestVerifyMatchRule(t *testing.T) {
-	// Test MatchRule queue processing:
-	// - Can't find destination link (invalid rule) -> queue unmodified (empty)
-	// - Can't find destination link (empty metadata map) -> queue unmodified
-	// - Match material foo.py -> remove from queue
-	// - Match material foo.py with foo.d/foo.py -> remove from queue
-	// - Match material foo.d/foo.py with foo.py -> remove from queue
-	// - Don't match material (different name) -> queue unmodified
-	// - Don't match material (different hash) -> queue unmodified
-	ruleData := []map[string]string{
-		{},
-		{"pattern": "*", "dstName": "foo", "dstType": "materials"},
-		{"pattern": "*", "dstName": "foo", "dstType": "materials"},
-		{"pattern": "*", "dstName": "foo", "dstType": "materials", "dstPrefix": "foo.d"},
-		{"pattern": "*", "dstName": "foo", "dstType": "materials", "srcPrefix": "foo.d"},
-		{"pattern": "*", "dstName": "foo", "dstType": "materials"},
-		{"pattern": "*", "dstName": "foo", "dstType": "materials"},
-	}
-	srcArtifacts := []map[string]interface{}{
-		{},
-		{"foo.py": map[string]interface{}{"sha265": "abc"}},
-		{"foo.py": map[string]interface{}{"sha265": "abc"}},
-		{"foo.py": map[string]interface{}{"sha265": "abc"}},
-		{"foo.d/foo.py": map[string]interface{}{"sha265": "abc"}},
-		{"foo.py": map[string]interface{}{"sha265": "dead"}},
-		{"bar.py": map[string]interface{}{"sha265": "abc"}},
-	}
-	// queue[i] = InterfaceKeyStrings(srcArtifacts[i])
-	itemsMetadata := []map[string]Metablock{
-		{},
-		{},
-		{"foo": {Signed: Link{Name: "foo", Materials: map[string]interface{}{"foo.py": map[string]interface{}{"sha265": "abc"}}}}},
-		{"foo": {Signed: Link{Name: "foo", Materials: map[string]interface{}{"foo.d/foo.py": map[string]interface{}{"sha265": "abc"}}}}},
-		{"foo": {Signed: Link{Name: "foo", Materials: map[string]interface{}{"foo.py": map[string]interface{}{"sha265": "abc"}}}}},
-		{"foo": {Signed: Link{Name: "foo", Materials: map[string]interface{}{"foo.py": map[string]interface{}{"sha265": "abc"}}}}},
-		{"foo": {Signed: Link{Name: "foo", Materials: map[string]interface{}{"foo.py": map[string]interface{}{"sha265": "abc"}}}}},
-	}
-	expected := []Set{
-		NewSet(),
-		NewSet(),
-		NewSet("foo.py"),
-		NewSet("foo.py"),
-		NewSet("foo.d/foo.py"),
-		NewSet(),
-		NewSet(),
-	}
-
-	for i := 0; i < len(ruleData); i++ {
-
-		queue := NewSet(InterfaceKeyStrings(srcArtifacts[i])...)
-		result := verifyMatchRule(ruleData[i], srcArtifacts[i], queue,
-			itemsMetadata[i])
-		if !reflect.DeepEqual(result, expected[i]) {
-			t.Errorf("verifyMatchRule returned '%s', expected '%s'", result,
-				expected[i])
-		}
+	for _, tt := range testCases {
+		t.Run(tt.name, func(t *testing.T) {
+			queue := NewSet(InterfaceKeyStrings(tt.srcArtifact)...)
+			result := verifyMatchRule(tt.rule, tt.srcArtifact, queue, tt.item)
+			if !reflect.DeepEqual(result, tt.expectSet) {
+				t.Errorf("verifyMatchRule returned '%s', expected '%s'", result, tt.expectSet)
+			}
+		})
 	}
 }
 
