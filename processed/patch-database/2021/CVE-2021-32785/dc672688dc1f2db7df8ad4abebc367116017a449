diff --git a/ChangeLog b/ChangeLog
index 93e0b79e..d8e41f27 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,6 @@
+07/22/2021
+- use redisvCommand to avoid crash with crafted key when using Redis without encryption; thanks @thomas-chauchefoin-sonarsource
+
 07/15/2021
 - verify that "alg" is not none in logout_token explicitly
 - make session not found on backchannel logout produce a log warning instead of error
diff --git a/Dockerfile b/Dockerfile
index a85ff863..fcf5d466 100644
--- a/Dockerfile
+++ b/Dockerfile
@@ -8,7 +8,7 @@ RUN apt-get update && apt-get install -y autoconf automake libtool
 RUN apt-get update && apt-get install -y libssl-dev libjansson-dev libcurl4-openssl-dev check
 RUN apt-get update && apt-get install -y apache2 apache2-dev
 RUN apt-get update && apt-get install -y libpcre3-dev zlib1g-dev
-RUN apt-get update && apt-get install -y libapache2-mod-php 
+RUN apt-get update && apt-get install -y libapache2-mod-php libhiredis-dev
 
 RUN wget https://mod-auth-openidc.org/download/libcjose0_0.6.1.5-1~bionic+1_amd64.deb
 RUN wget https://mod-auth-openidc.org/download/libcjose-dev_0.6.1.5-1~bionic+1_amd64.deb
diff --git a/openidc.conf b/openidc.conf
index ea16069e..95cc095d 100644
--- a/openidc.conf
+++ b/openidc.conf
@@ -26,6 +26,9 @@ OIDCInfoHook iat access_token access_token_expires id_token userinfo refresh_tok
 
 OIDCScope "openid email profile"
 
+OIDCCacheType redis
+OIDCRedisCacheServer host.docker.internal
+
 <Location /protected>
   AuthType openid-connect
   Require valid-user
diff --git a/src/cache/redis.c b/src/cache/redis.c
index 2810a0db..7a2f3fc7 100644
--- a/src/cache/redis.c
+++ b/src/cache/redis.c
@@ -265,10 +265,12 @@ static apr_status_t oidc_cache_redis_connect(request_rec *r,
  * execute Redis command and deal with return value
  */
 static redisReply* oidc_cache_redis_command(request_rec *r,
-		oidc_cache_cfg_redis_t *context, const char *command) {
+		oidc_cache_cfg_redis_t *context, const char *format, ...) {
 
 	redisReply *reply = NULL;
 	int i = 0;
+	va_list ap;
+	va_start(ap, format);
 
 	/* try to execute a command at max 2 times while reconnecting */
 	for (i = 0; i < OIDC_REDIS_MAX_TRIES; i++) {
@@ -278,7 +280,7 @@ static redisReply* oidc_cache_redis_command(request_rec *r,
 			break;
 
 		/* execute the actual command */
-		reply = redisCommand(context->ctx, command);
+		reply = redisvCommand(context->ctx, format, ap);
 
 		/* check for errors, need to return error replies for cache miss case REDIS_REPLY_NIL */
 		if ((reply != NULL) && (reply->type != REDIS_REPLY_ERROR))
@@ -298,6 +300,8 @@ static redisReply* oidc_cache_redis_command(request_rec *r,
 		oidc_cache_redis_free(context);
 	}
 
+	va_end(ap);
+
 	return reply;
 }
 
@@ -318,9 +322,8 @@ static apr_byte_t oidc_cache_redis_get(request_rec *r, const char *section,
 		return FALSE;
 
 	/* get */
-	reply = oidc_cache_redis_command(r, context,
-			apr_psprintf(r->pool, "GET %s",
-					oidc_cache_redis_get_key(r->pool, section, key)));
+	reply =
+			oidc_cache_redis_command(r, context, "GET %s", oidc_cache_redis_get_key(r->pool, section, key));
 
 	if (reply == NULL)
 		goto end;
@@ -384,9 +387,8 @@ static apr_byte_t oidc_cache_redis_set(request_rec *r, const char *section,
 	if (value == NULL) {
 
 		/* delete it */
-		reply = oidc_cache_redis_command(r, context,
-				apr_psprintf(r->pool, "DEL %s",
-						oidc_cache_redis_get_key(r->pool, section, key)));
+		reply =
+				oidc_cache_redis_command(r, context, "DEL %s", oidc_cache_redis_get_key(r->pool, section, key));
 
 	} else {
 
@@ -394,10 +396,8 @@ static apr_byte_t oidc_cache_redis_set(request_rec *r, const char *section,
 		timeout = apr_time_sec(expiry - apr_time_now());
 
 		/* store it */
-		reply = oidc_cache_redis_command(r, context,
-				apr_psprintf(r->pool, "SETEX %s %d %s",
-						oidc_cache_redis_get_key(r->pool, section, key),
-						timeout, value));
+		reply =
+				oidc_cache_redis_command(r, context, "SETEX %s %d %s", oidc_cache_redis_get_key(r->pool, section, key), timeout, value);
 
 	}
 
