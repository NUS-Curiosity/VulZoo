diff --git a/build.sbt b/build.sbt
index 248ead7fc..e7c7fa062 100644
--- a/build.sbt
+++ b/build.sbt
@@ -15,7 +15,7 @@ lazy val commonSettings = Seq(
   description := "NIO Framework for Scala",
   crossScalaVersions := Seq("2.11.12", "2.12.12", "2.13.3"),
   scalaVersion := crossScalaVersions.value.filter(_.startsWith("2.")).last,
-  scalacOptions in Test ~= (_.filterNot(Set("-Ywarn-dead-code", "-Wdead-code"))), // because mockito
+  scalacOptions in Test ~= (_.filterNot(Set("-Ywarn-dead-code", "-Wdead-code", "-Xfatal-warnings"))), // because mockito
   scalacOptions in (Compile, doc) += "-no-link-warnings",
   unmanagedSourceDirectories in Compile ++= {
     (unmanagedSourceDirectories in Compile).value.map { dir =>
@@ -79,7 +79,11 @@ lazy val core = Project("blaze-core", file("core"))
       scalaVersion,
       git.gitHeadCommit
     ),
-    buildInfoOptions += BuildInfoOption.BuildTime
+    buildInfoOptions += BuildInfoOption.BuildTime,
+    mimaBinaryIssueFilters ++= Seq(
+      // private constructor for which there are no sensible defaults
+      ProblemFilters.exclude[DirectMissingMethodProblem]("org.http4s.blaze.channel.nio1.NIO1SocketServerGroup.this")
+    )
   )
 
 lazy val http = Project("blaze-http", file("http"))
diff --git a/core/src/main/scala-2.11-2.12/org/http4s/blaze/internal/compat.scala b/core/src/main/scala-2.11-2.12/org/http4s/blaze/internal/compat.scala
index 62604256f..d9e31e9fd 100644
--- a/core/src/main/scala-2.11-2.12/org/http4s/blaze/internal/compat.scala
+++ b/core/src/main/scala-2.11-2.12/org/http4s/blaze/internal/compat.scala
@@ -1,7 +1,17 @@
 /*
- * Copyright 2014-2020 http4s.org
+ * Copyright 2014 http4s.org
  *
- * SPDX-License-Identifier: Apache-2.0
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
 package org.http4s.blaze.internal
diff --git a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1ClientChannel.scala b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1ClientChannel.scala
new file mode 100644
index 000000000..adaab34d7
--- /dev/null
+++ b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1ClientChannel.scala
@@ -0,0 +1,69 @@
+/*
+ * Copyright 2014 http4s.org
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.http4s.blaze.channel.nio1
+
+import org.http4s.blaze.channel.{ChannelOptions, OptionValue}
+
+import java.net.SocketAddress
+import java.nio.ByteBuffer
+import java.nio.channels.{SelectableChannel, SocketChannel}
+import java.util.concurrent.atomic.AtomicBoolean
+
+private[blaze] final class NIO1ClientChannel(
+    private[this] val underlying: SocketChannel,
+    private[this] val onClose: () => Unit)
+    extends NIO1Channel {
+
+  private[this] val closed = new AtomicBoolean(false)
+
+  override val selectableChannel: SelectableChannel = underlying
+
+  def configureBlocking(block: Boolean): Unit = {
+    underlying.configureBlocking(block)
+    ()
+  }
+
+  def getRemoteAddress: SocketAddress =
+    underlying.getRemoteAddress
+
+  def getLocalAddress: SocketAddress =
+    underlying.getLocalAddress
+
+  def configureOptions(options: ChannelOptions): Unit =
+    options.options.foreach { case OptionValue(k, v) =>
+      underlying.setOption(k, v)
+    }
+
+  def read(dst: ByteBuffer): Int =
+    underlying.read(dst)
+
+  def write(src: ByteBuffer): Int =
+    underlying.write(src)
+
+  def write(srcs: Array[ByteBuffer]): Long =
+    underlying.write(srcs)
+
+  def isOpen: Boolean =
+    underlying.isOpen
+
+  override def close(): Unit =
+    try underlying.close()
+    finally if (closed.compareAndSet(false, true)) {
+      onClose()
+    }
+
+}
diff --git a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1HeadStage.scala b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1HeadStage.scala
index b6cd53262..30dbf9992 100644
--- a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1HeadStage.scala
+++ b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1HeadStage.scala
@@ -20,7 +20,6 @@ import java.io.IOException
 import java.nio.ByteBuffer
 import java.nio.channels._
 import java.util.concurrent.RejectedExecutionException
-
 import org.http4s.blaze.channel.ChannelHead
 import org.http4s.blaze.pipeline.Command.{Disconnected, EOF}
 import org.http4s.blaze.util
@@ -46,7 +45,7 @@ private[nio1] object NIO1HeadStage {
     * @return a `Try` representing successfully loading data into `scratch`, or
     *         the failure cause.
     */
-  private def performRead(ch: SocketChannel, scratch: ByteBuffer, size: Int): Try[Unit] =
+  private def performRead(ch: NIO1ClientChannel, scratch: ByteBuffer, size: Int): Try[Unit] =
     try {
       scratch.clear()
       if (size >= 0 && size < scratch.remaining)
@@ -69,7 +68,7 @@ private[nio1] object NIO1HeadStage {
     * @return a WriteResult that is one of Complete, Incomplete or WriteError(e: Exception)
     */
   private def performWrite(
-      ch: SocketChannel,
+      ch: NIO1ClientChannel,
       scratch: ByteBuffer,
       buffers: Array[ByteBuffer]): WriteResult =
     try if (BufferTools.areDirectOrEmpty(buffers)) {
@@ -116,13 +115,26 @@ private[nio1] object NIO1HeadStage {
 }
 
 private[nio1] final class NIO1HeadStage(
-    ch: SocketChannel,
+    ch: NIO1ClientChannel,
     selectorLoop: SelectorLoop,
     key: SelectionKey
 ) extends ChannelHead
     with Selectable {
   import NIO1HeadStage._
 
+  @deprecated(
+    "Binary compatibility shim. This one can leak connection acceptance permits.",
+    "0.14.15")
+  private[NIO1HeadStage] def this(
+      ch: SocketChannel,
+      selectorLoop: SelectorLoop,
+      key: SelectionKey
+  ) = this(
+    new NIO1ClientChannel(ch, () => ()),
+    selectorLoop: SelectorLoop,
+    key
+  )
+
   override def name: String = "NIO1 ByteBuffer Head Stage"
 
   // State of the HeadStage. These should only be accessed from the SelectorLoop thread
diff --git a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketConnection.scala b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketConnection.scala
index c7f434bff..d4349d0f6 100644
--- a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketConnection.scala
+++ b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketConnection.scala
@@ -36,6 +36,14 @@ object NIO1Connection {
           override def isOpen: Boolean = connection.isOpen
         }
     }
+
+  private[blaze] def apply(channel: NIO1ClientChannel): SocketConnection =
+    new SocketConnection {
+      override def remote: SocketAddress = channel.getRemoteAddress
+      override def local: SocketAddress = channel.getLocalAddress
+      override def isOpen: Boolean = channel.isOpen
+      override def close(): Unit = channel.close()
+    }
 }
 
 private case class NIO1SocketConnection(connection: SocketChannel) extends SocketConnection {
diff --git a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketServerGroup.scala b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketServerGroup.scala
index 8197f3c04..7f3de832b 100644
--- a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketServerGroup.scala
+++ b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketServerGroup.scala
@@ -22,16 +22,16 @@ import java.net.InetSocketAddress
 import java.nio.ByteBuffer
 import java.util.concurrent.{RejectedExecutionException, ThreadFactory}
 import java.util.concurrent.atomic.{AtomicBoolean, AtomicInteger}
-
 import org.http4s.blaze.channel.{
   ChannelOptions,
+  DefaultMaxConnections,
   DefaultPoolSize,
   ServerChannel,
   ServerChannelGroup,
   SocketPipelineBuilder
 }
 import org.http4s.blaze.pipeline.Command
-import org.http4s.blaze.util.BasicThreadFactory
+import org.http4s.blaze.util.{BasicThreadFactory, Connections}
 import org.log4s._
 
 import scala.annotation.tailrec
@@ -44,11 +44,17 @@ object NIO1SocketServerGroup {
   /** Default size of buffer to use in a [[SelectorLoop]] */
   private[this] val DefaultBufferSize: Int = 64 * 1024
 
-  private[this] val factoryNumber = new AtomicInteger(0)
-  // Default `ThreadFactory` implementation for selector threads
-  private[this] def defaultAcceptThreadFactory: ThreadFactory = {
-    val id = factoryNumber.getAndIncrement()
-    BasicThreadFactory(prefix = s"blaze-selector-$id", daemonThreads = false)
+  private[this] val acceptorNumber = new AtomicInteger(0)
+  private[this] val workerNumber = new AtomicInteger(0)
+
+  private[this] def defaultAcceptorThreadFactory: ThreadFactory = {
+    val id = acceptorNumber.getAndIncrement()
+    BasicThreadFactory(prefix = s"blaze-acceptor-$id", daemonThreads = false)
+  }
+
+  private[this] def defaultWorkerThreadFactory: ThreadFactory = {
+    val id = workerNumber.getAndIncrement()
+    BasicThreadFactory(prefix = s"blaze-worker-$id", daemonThreads = false)
   }
 
   /** Create a new [[NIO1SocketServerGroup]] from the [[SelectorLoopPool]].
@@ -56,25 +62,41 @@ object NIO1SocketServerGroup {
     * @note The worker pool is not owned by the group and therefore not
     *       shutdown when the group is shutdown.
     */
+  def create(
+      acceptorPool: SelectorLoopPool,
+      workerPool: SelectorLoopPool,
+      channelOptions: ChannelOptions = ChannelOptions.DefaultOptions,
+      maxConnections: Int = DefaultMaxConnections
+  ): ServerChannelGroup =
+    new NIO1SocketServerGroup(acceptorPool, workerPool, channelOptions, maxConnections)
+
+  @deprecated(
+    "Use `create` instead. This uses the same pool for both worker and acceptor",
+    "0.14.15")
   def apply(
       workerPool: SelectorLoopPool,
       channelOptions: ChannelOptions = ChannelOptions.DefaultOptions
   ): ServerChannelGroup =
-    new NIO1SocketServerGroup(workerPool, channelOptions)
+    create(workerPool, workerPool, channelOptions, DefaultMaxConnections)
 
-  /** Create a new [[NIO1SocketServerGroup]] with a fresh [[FixedSelectorPool]]
+  /** Create a new [[NIO1SocketServerGroup]] with a fresh [[FixedSelectorPool]
+    * ]
     *
     * The resulting [[ServerChannelGroup]] takes ownership of the created pool,
     * shutting it down when the group is shutdown.
     */
-  def fixedGroup(
+  def fixed(
       workerThreads: Int = DefaultPoolSize,
       bufferSize: Int = DefaultBufferSize,
       channelOptions: ChannelOptions = ChannelOptions.DefaultOptions,
-      selectorThreadFactory: ThreadFactory = defaultAcceptThreadFactory
+      selectorThreadFactory: ThreadFactory = defaultWorkerThreadFactory,
+      acceptorThreads: Int = 1,
+      acceptorThreadFactory: ThreadFactory = defaultAcceptorThreadFactory,
+      maxConnections: Int = DefaultMaxConnections
   ): ServerChannelGroup = {
-    val pool = new FixedSelectorPool(workerThreads, bufferSize, selectorThreadFactory)
-    val underlying = apply(pool, channelOptions)
+    val acceptorPool = new FixedSelectorPool(acceptorThreads, 1, acceptorThreadFactory)
+    val workerPool = new FixedSelectorPool(workerThreads, bufferSize, selectorThreadFactory)
+    val underlying = create(acceptorPool, workerPool, channelOptions, maxConnections)
 
     // Proxy to the underlying group. `close` calls also close
     // the worker pools since we were the ones that created it.
@@ -86,7 +108,8 @@ object NIO1SocketServerGroup {
         // shutdown since they cleanup pending tasks before dying
         // themselves.
         underlying.closeGroup()
-        pool.close()
+        workerPool.close()
+        acceptorPool.close()
       }
 
       override def bind(
@@ -96,17 +119,35 @@ object NIO1SocketServerGroup {
         underlying.bind(address, service)
     }
   }
+
+  @deprecated("Use `fixed` instead", "0.14.15")
+  def fixedGroup(
+      workerThreads: Int = DefaultPoolSize,
+      bufferSize: Int = DefaultBufferSize,
+      channelOptions: ChannelOptions = ChannelOptions.DefaultOptions,
+      selectorThreadFactory: ThreadFactory = defaultWorkerThreadFactory
+  ): ServerChannelGroup =
+    fixed(
+      workerThreads,
+      bufferSize,
+      channelOptions,
+      selectorThreadFactory,
+      1,
+      defaultAcceptorThreadFactory,
+      DefaultMaxConnections)
 }
 
 /** A thread resource group for NIO1 network operations
   *
-  * @param selectorPool [[SelectorLoopPool]] that will belong to this group. The group
+  * @param workerPool [[SelectorLoopPool]] that will belong to this group. The group
   *                    assumes responsibility for shutting it down. Shutting down the
   *                    pool after giving it to this group will result in undefined behavior.
   */
 private final class NIO1SocketServerGroup private (
-    selectorPool: SelectorLoopPool,
-    channelOptions: ChannelOptions)
+    acceptorPool: SelectorLoopPool,
+    workerPool: SelectorLoopPool,
+    channelOptions: ChannelOptions,
+    maxConnections: Int)
     extends ServerChannelGroup {
   private[this] val logger = getLogger
   // Also acts as our intrinsic lock.
@@ -114,6 +155,8 @@ private final class NIO1SocketServerGroup private (
   // protected by synchronization on the intrinsic lock.
   private[this] var isClosed = false
 
+  private[this] val connections: Connections = Connections(maxConnections)
+
   // Closing delegates to the `ServerChannelImpl` which
   // ensures only-once behavior and attempts to close the
   // channel within the `SelectorLoop`, if it's still running.
@@ -128,12 +171,13 @@ private final class NIO1SocketServerGroup private (
     private[this] val closed = new AtomicBoolean(false)
 
     override def opsReady(unused: ByteBuffer): Unit =
-      if (key.isAcceptable)
+      if (key.isAcceptable) {
         try acceptNewConnections()
         catch {
           case ex: IOException =>
             close(Some(ex))
         }
+      }
 
     override def close(cause: Option[Throwable]): Unit =
       if (closed.compareAndSet(false, true) && !ch.channelClosed) {
@@ -155,10 +199,14 @@ private final class NIO1SocketServerGroup private (
     private[this] def acceptNewConnections(): Unit = {
       // We go in a loop just in case we have more than one.
       // Once we're out, the `.accept()` method will return `null`.
+      connections.acquire()
       val child = ch.selectableChannel.accept()
       if (child != null) {
-        handleClientChannel(child, service)
+        val channel = new NIO1ClientChannel(child, () => connections.release())
+        handleClientChannel(channel, service)
         acceptNewConnections()
+      } else {
+        connections.release()
       }
     }
   }
@@ -193,7 +241,7 @@ private final class NIO1SocketServerGroup private (
         try selectableChannel.close()
         catch {
           case NonFatal(t) => logger.warn(t)("Failure during channel close.")
-        }
+        } finally connections.close() // allow the acceptor thread through
       }
 
       try
@@ -234,12 +282,13 @@ private final class NIO1SocketServerGroup private (
     Try {
       val ch = ServerSocketChannel.open().bind(address)
       ch.configureBlocking(false)
-      val loop = selectorPool.nextLoop()
+      val loop = acceptorPool.nextLoop()
 
       val serverChannel = new ServerChannelImpl(ch, loop)
       val closed = listeningSet.synchronized {
-        if (isClosed) true
-        else {
+        if (isClosed) {
+          true
+        } else {
           listeningSet += serverChannel
           false
         }
@@ -270,15 +319,15 @@ private final class NIO1SocketServerGroup private (
   }
 
   private[this] def handleClientChannel(
-      clientChannel: SocketChannel,
+      clientChannel: NIO1ClientChannel,
       service: SocketPipelineBuilder
   ): Unit =
     try {
       clientChannel.configureBlocking(false)
-      channelOptions.applyToChannel(clientChannel)
+      clientChannel.configureOptions(channelOptions)
 
       val address = clientChannel.getRemoteAddress
-      val loop = selectorPool.nextLoop()
+      val loop = workerPool.nextLoop()
       val conn = NIO1Connection(clientChannel)
 
       // From within the selector loop, constructs a pipeline or
@@ -300,7 +349,7 @@ private final class NIO1SocketServerGroup private (
         head
       }
 
-      loop.initChannel(NIO1Channel(clientChannel), fromKey)
+      loop.initChannel(clientChannel, fromKey)
     } catch {
       case NonFatal(t) =>
         logger.error(t)("Error handling client channel. Closing.")
diff --git a/core/src/main/scala/org/http4s/blaze/channel/nio1/SelectorLoop.scala b/core/src/main/scala/org/http4s/blaze/channel/nio1/SelectorLoop.scala
index 7b0aa53d3..59ff099d5 100644
--- a/core/src/main/scala/org/http4s/blaze/channel/nio1/SelectorLoop.scala
+++ b/core/src/main/scala/org/http4s/blaze/channel/nio1/SelectorLoop.scala
@@ -49,31 +49,6 @@ final class SelectorLoop(
     with ExecutionContext {
   require(bufferSize > 0, s"Invalid buffer size: $bufferSize")
 
-  /** A Runnable that will only execute in this selector loop and provides
-    * access to the `SelectorLoop`s scratch buffer.
-    */
-  abstract class LoopRunnable extends Runnable {
-
-    /** Execute the task with the borrowed scratch `ByteBuffer`
-      *
-      * @param scratch a `ByteBuffer` that is owned by the parent
-      *                `SelectorLoop`, and as such, the executing task
-      *                _must not_ retain a refer to it.
-      */
-    def run(scratch: ByteBuffer): Unit
-
-    final override def run(): Unit = {
-      val currentThread = Thread.currentThread
-      if (currentThread == thread) run(scratch)
-      else {
-        val msg = "Task rejected: executed RunWithScratch in incorrect " +
-          s"thread: $currentThread. Expected thread: $thread."
-        val ex = new IllegalStateException(msg)
-        logger.error(ex)(msg)
-      }
-    }
-  }
-
   @volatile
   private[this] var isClosed = false
   private[this] val scratch = ByteBuffer.allocateDirect(bufferSize)
@@ -137,7 +112,7 @@ final class SelectorLoop(
   override def execute(runnable: Runnable): Unit = enqueueTask(runnable)
 
   override def reportFailure(cause: Throwable): Unit =
-    logger.info(cause)(s"Exception executing task in selector loop $threadName")
+    logger.error(cause)(s"Exception executing task in selector loop $threadName")
 
   /** Initialize a new `Selectable` channel
     *
@@ -152,9 +127,10 @@ final class SelectorLoop(
       mkStage: SelectionKey => Selectable
   ): Unit =
     enqueueTask(new Runnable {
-      def run(): Unit =
-        if (!selector.isOpen) ch.close()
-        else
+      override def run(): Unit =
+        if (!selector.isOpen) {
+          ch.close()
+        } else {
           try {
             // We place all this noise in the `try` since pretty
             // much every method on the `SelectableChannel` can throw.
@@ -168,6 +144,7 @@ final class SelectorLoop(
               logger.error(t)("Caught error during channel init.")
               ch.close()
           }
+        }
     })
 
   // Main thread method. The loop will break if the Selector loop is closed
@@ -184,8 +161,9 @@ final class SelectorLoop(
       taskQueue.executeTasks()
 
       // We have some new I/O operations waiting for us. Process them.
-      if (selected > 0)
+      if (selected > 0) {
         processKeys(scratch, selector.selectedKeys)
+      }
     } catch {
       case e: ClosedSelectorException =>
         logger.error(e)("Selector unexpectedly closed")
@@ -212,16 +190,16 @@ final class SelectorLoop(
       it.remove()
 
       val selectable = getAttachment(k)
-      try if (k.isValid)
-        if (selectable != null)
+      try if (k.isValid) {
+        if (selectable != null) {
           selectable.opsReady(scratch)
-        else {
+        } else {
           k.cancel()
           logger.error("Illegal state: selector key had null attachment.")
         }
-      else if (selectable != null)
+      } else if (selectable != null) {
         selectable.close(None)
-      catch {
+      } catch {
         case t @ (NonFatal(_) | _: ControlThrowable) =>
           logger.error(t)("Error performing channel operations. Closing channel.")
           try selectable.close(Some(t))
@@ -266,4 +244,29 @@ final class SelectorLoop(
         logger.error(ex)(ex.getMessage)
         throw ex
     }
+
+  /** A Runnable that will only execute in this selector loop and provides
+    * access to the `SelectorLoop`s scratch buffer.
+    */
+  abstract class LoopRunnable extends Runnable {
+
+    /** Execute the task with the borrowed scratch `ByteBuffer`
+      *
+      * @param scratch a `ByteBuffer` that is owned by the parent
+      *                `SelectorLoop`, and as such, the executing task
+      *                _must not_ retain a refer to it.
+      */
+    def run(scratch: ByteBuffer): Unit
+
+    final override def run(): Unit = {
+      val currentThread = Thread.currentThread
+      if (currentThread == thread) run(scratch)
+      else {
+        val msg = "Task rejected: executed RunWithScratch in incorrect " +
+          s"thread: $currentThread. Expected thread: $thread."
+        val ex = new IllegalStateException(msg)
+        logger.error(ex)(msg)
+      }
+    }
+  }
 }
diff --git a/core/src/main/scala/org/http4s/blaze/channel/nio2/NIO2SocketServerGroup.scala b/core/src/main/scala/org/http4s/blaze/channel/nio2/NIO2SocketServerGroup.scala
index 00ea29ba5..a6d9db614 100644
--- a/core/src/main/scala/org/http4s/blaze/channel/nio2/NIO2SocketServerGroup.scala
+++ b/core/src/main/scala/org/http4s/blaze/channel/nio2/NIO2SocketServerGroup.scala
@@ -29,6 +29,7 @@ import org.log4s.getLogger
 import scala.util.{Failure, Success, Try}
 import scala.util.control.NonFatal
 
+@deprecated("Prefer NIO1 over NIO2", "0.14.15")
 object NIO2SocketServerGroup {
 
   /** Create a new fixed size NIO2 SocketServerGroup
diff --git a/core/src/main/scala/org/http4s/blaze/channel/package.scala b/core/src/main/scala/org/http4s/blaze/channel/package.scala
index b73ec672d..b86cfc473 100644
--- a/core/src/main/scala/org/http4s/blaze/channel/package.scala
+++ b/core/src/main/scala/org/http4s/blaze/channel/package.scala
@@ -30,4 +30,9 @@ package object channel {
     */
   val DefaultPoolSize: Int =
     math.max(4, Runtime.getRuntime.availableProcessors() + 1)
+
+  /** Default max number of connections that can be active at any time.
+    * A negative number means that there is no max.
+    */
+  val DefaultMaxConnections: Int = 512
 }
diff --git a/core/src/main/scala/org/http4s/blaze/util/Connections.scala b/core/src/main/scala/org/http4s/blaze/util/Connections.scala
new file mode 100644
index 000000000..df934e56d
--- /dev/null
+++ b/core/src/main/scala/org/http4s/blaze/util/Connections.scala
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2014 http4s.org
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.http4s.blaze.util
+
+import java.util.concurrent.Semaphore
+
+private[blaze] sealed trait Connections {
+  def acquire(): Unit
+  def release(): Unit
+  def close(): Unit = release()
+}
+
+private[blaze] object Connections {
+
+  def apply(maxConnections: Int): Connections =
+    if (maxConnections < 0) Unbounded else new Bounded(maxConnections)
+
+  private[this] object Unbounded extends Connections {
+    override def acquire(): Unit = ()
+    override def release(): Unit = ()
+  }
+
+  private[this] final class Bounded(maxConnections: Int) extends Connections {
+    val semaphore = new Semaphore(maxConnections)
+    override def acquire(): Unit = semaphore.acquire()
+    override def release(): Unit = semaphore.release()
+  }
+
+}
diff --git a/core/src/test/scala/org/http4s/blaze/channel/ChannelSpec.scala b/core/src/test/scala/org/http4s/blaze/channel/ChannelSpec.scala
index 4b54ee1a2..eac2e5566 100644
--- a/core/src/test/scala/org/http4s/blaze/channel/ChannelSpec.scala
+++ b/core/src/test/scala/org/http4s/blaze/channel/ChannelSpec.scala
@@ -29,7 +29,7 @@ import scala.concurrent.duration._
 
 class NIO1ChannelSpec extends BaseChannelSpec {
   override protected def bind(f: SocketPipelineBuilder): ServerPair = {
-    val factory = NIO1SocketServerGroup.fixedGroup(workerThreads = 2)
+    val factory = NIO1SocketServerGroup.fixed(workerThreads = 2)
 
     val channel = factory.bind(new InetSocketAddress(0), f).get // will throw if failed to bind
     ServerPair(factory, channel)
diff --git a/examples/src/main/scala/org/http4s/blaze/examples/Http1ServerExample.scala b/examples/src/main/scala/org/http4s/blaze/examples/Http1ServerExample.scala
index 9eecd4529..7370ab387 100644
--- a/examples/src/main/scala/org/http4s/blaze/examples/Http1ServerExample.scala
+++ b/examples/src/main/scala/org/http4s/blaze/examples/Http1ServerExample.scala
@@ -59,7 +59,7 @@ class Http1ServerExample(factory: ServerChannelGroup, port: Int)(
 object NIO1HttpServer {
   def main(args: Array[String]): Unit = {
     val f =
-      NIO1SocketServerGroup.fixedGroup(workerThreads = channel.DefaultPoolSize)
+      NIO1SocketServerGroup.fixed(workerThreads = channel.DefaultPoolSize)
     new Http1ServerExample(f, 8080)()
       .run()
       .join()
@@ -83,7 +83,7 @@ object SSLHttpServer {
   def main(args: Array[String]): Unit = {
     val sslContext = ExampleKeystore.sslContext()
     val f =
-      NIO1SocketServerGroup.fixedGroup(workerThreads = channel.DefaultPoolSize)
+      NIO1SocketServerGroup.fixed(workerThreads = channel.DefaultPoolSize)
     new Http1ServerExample(f, 4430)({ builder =>
       val eng = sslContext.createSSLEngine()
       eng.setUseClientMode(false)
@@ -99,7 +99,7 @@ object ClientAuthSSLHttpServer {
   def main(args: Array[String]): Unit = {
     val sslContext = ExampleKeystore.clientAuthSslContext()
     val f =
-      NIO1SocketServerGroup.fixedGroup(workerThreads = channel.DefaultPoolSize)
+      NIO1SocketServerGroup.fixed(workerThreads = channel.DefaultPoolSize)
     new Http1ServerExample(f, 4430)({ builder =>
       val eng = sslContext.createSSLEngine()
       eng.setUseClientMode(false)
diff --git a/examples/src/main/scala/org/http4s/blaze/examples/http2/Http2ServerExample.scala b/examples/src/main/scala/org/http4s/blaze/examples/http2/Http2ServerExample.scala
index 0f345a2e9..b72051103 100644
--- a/examples/src/main/scala/org/http4s/blaze/examples/http2/Http2ServerExample.scala
+++ b/examples/src/main/scala/org/http4s/blaze/examples/http2/Http2ServerExample.scala
@@ -51,7 +51,7 @@ class Http2ServerExample(port: Int) {
   }
 
   private val factory =
-    NIO1SocketServerGroup.fixedGroup(workerThreads = channel.DefaultPoolSize)
+    NIO1SocketServerGroup.fixed(workerThreads = channel.DefaultPoolSize)
 
   def run(): ServerChannel =
     factory
diff --git a/http/src/main/scala/org/http4s/blaze/http/http1/server/Http1Server.scala b/http/src/main/scala/org/http4s/blaze/http/http1/server/Http1Server.scala
index 53548d1c6..283c2df2a 100644
--- a/http/src/main/scala/org/http4s/blaze/http/http1/server/Http1Server.scala
+++ b/http/src/main/scala/org/http4s/blaze/http/http1/server/Http1Server.scala
@@ -33,6 +33,7 @@ object Http1Server {
   case class GroupAndChannel(group: ServerChannelGroup, channel: ServerChannel)
 
   /** Create a new Http1Server */
+  @deprecated("Prefer NIO1 over NIO2. Use nio1 constructor method.", "0.14.15")
   def apply(
       service: SocketConnection => Future[HttpService],
       address: InetSocketAddress,
@@ -52,4 +53,20 @@ object Http1Server {
     if (channel.isFailure) group.closeGroup()
     channel.map(GroupAndChannel(group, _))
   }
+
+  def nio1(
+      service: SocketConnection => Future[HttpService],
+      address: InetSocketAddress,
+      config: HttpServerStageConfig,
+      workerThreads: Int = channel.DefaultPoolSize): Try[GroupAndChannel] = {
+    val group: ServerChannelGroup = NIO1SocketServerGroup.fixed(workerThreads = workerThreads)
+
+    val builder = service(_: SocketConnection).map { service =>
+      LeafBuilder(new Http1ServerStage(service, config))
+    }(Execution.directec)
+
+    val channel = group.bind(address, builder)
+    if (channel.isFailure) group.closeGroup()
+    channel.map(GroupAndChannel(group, _))
+  }
 }
