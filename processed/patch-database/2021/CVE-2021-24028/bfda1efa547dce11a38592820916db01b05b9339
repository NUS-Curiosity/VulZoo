diff --git a/thrift/lib/cpp2/protocol/TableBasedSerializer.cpp b/thrift/lib/cpp2/protocol/TableBasedSerializer.cpp
index 58cfbf1e626..844f59ca1ab 100644
--- a/thrift/lib/cpp2/protocol/TableBasedSerializer.cpp
+++ b/thrift/lib/cpp2/protocol/TableBasedSerializer.cpp
@@ -186,9 +186,11 @@ const FieldInfo* FOLLY_NULLABLE findFieldInfo(
   return nullptr;
 }
 
-const FieldID& activeUnionMemberId(const void* object, ptrdiff_t offset) {
-  return *reinterpret_cast<const FieldID*>(
-      offset + static_cast<const char*>(object));
+// Returns a reference to the data member that holds the active field id for a
+// Thrift union object.
+const int& getActiveId(const void* object, const StructInfo& info) {
+  return *reinterpret_cast<const int*>(
+      static_cast<const char*>(object) + info.unionExt->unionTypeOffset);
 }
 
 const bool& fieldIsSet(const void* object, ptrdiff_t offset) {
@@ -591,16 +593,15 @@ void read(Protocol_* iprot, const StructInfo& structInfo, void* object) {
       readState.readStructEnd(iprot);
       return;
     }
-    const auto* fieldInfo = findFieldInfo(iprot, readState, structInfo);
-    // Found it.
-    if (fieldInfo) {
-      void* unionVal = getMember(*fieldInfo, object);
-      // Default construct and placement new into the member union.
-      structInfo.unionExt->initMember[fieldInfo - structInfo.fieldInfos](
-          unionVal);
-      read(iprot, *fieldInfo->typeInfo, readState, unionVal);
-      const_cast<FieldID&>(activeUnionMemberId(
-          object, structInfo.unionExt->unionTypeOffset)) = fieldInfo->id;
+    if (const auto* fieldInfo = findFieldInfo(iprot, readState, structInfo)) {
+      auto& activeId = const_cast<int&>(getActiveId(object, structInfo));
+      if (activeId != 0) {
+        structInfo.unionExt->clear(object);
+      }
+      void* value = getMember(*fieldInfo, object);
+      structInfo.unionExt->initMember[fieldInfo - structInfo.fieldInfos](value);
+      read(iprot, *fieldInfo->typeInfo, readState, value);
+      activeId = fieldInfo->id;
     } else {
       skip(iprot, readState);
     }
@@ -671,14 +672,13 @@ write(Protocol_* iprot, const StructInfo& structInfo, const void* object) {
   size_t written = iprot->writeStructBegin(structInfo.name);
   if (UNLIKELY(structInfo.unionExt != nullptr)) {
     const FieldInfo* end = structInfo.fieldInfos + structInfo.numFields;
-    const auto& unionId =
-        activeUnionMemberId(object, structInfo.unionExt->unionTypeOffset);
+    const auto& activeId = getActiveId(object, structInfo);
     const FieldInfo* found = std::lower_bound(
         structInfo.fieldInfos,
         end,
-        unionId,
+        activeId,
         [](const FieldInfo& lhs, FieldID rhs) { return lhs.id < rhs; });
-    if (found < end && found->id == unionId) {
+    if (found < end && found->id == activeId) {
       const OptionalThriftValue value = getValue(*found->typeInfo, object);
       if (value.hasValue()) {
         written += writeField(iprot, *found, value.value());
diff --git a/thrift/test/tablebased/SerializerTest.cpp b/thrift/test/tablebased/SerializerTest.cpp
index 7fdb0c21aa9..9f146885cbf 100644
--- a/thrift/test/tablebased/SerializerTest.cpp
+++ b/thrift/test/tablebased/SerializerTest.cpp
@@ -356,3 +356,25 @@ TEST(SerializerTest, UnionValueOffsetIsZero) {
   u.set_fieldB({});
   EXPECT_EQ(static_cast<void*>(&u), &*u.fieldB_ref());
 }
+
+TEST(SerializerTest, DuplicateUnionData) {
+  // Test that we can handle invalid serialized input with duplicate and
+  // incomplete union data.
+  const char data[] =
+      "\x0c" // type = TType::T_STRUCT
+      "\x00\x01" // fieldId = 1 (unionField)
+      "\x0b" // type = TType::T_STRING
+      "\x00\x01" // fieldId = 1 (stringField)
+      "\x00\x00\x00\x00" // size = 0
+      "\x00" // end of unionField
+
+      "\x0c" // type = TType::T_STRUCT
+      "\x00\x01" // fieldId = 1 (unionField)
+      "\x13" // type = TType::T_FLOAT
+      "\x00\x02"; // fieldId = 2 (floatField), value is missing
+
+  EXPECT_THROW(
+      BinarySerializer::deserialize<tablebased::TestStructWithUnion>(
+          folly::StringPiece(data, sizeof(data))),
+      std::out_of_range);
+}
diff --git a/thrift/test/tablebased/thrift_tablebased.thrift b/thrift/test/tablebased/thrift_tablebased.thrift
index 604f15adafc..16dc17b02e5 100644
--- a/thrift/test/tablebased/thrift_tablebased.thrift
+++ b/thrift/test/tablebased/thrift_tablebased.thrift
@@ -79,3 +79,12 @@ union UnionWithRef {
   3: StructA fieldC (cpp2.ref_type = "shared_const");
   4: StructA fieldD (cpp2.ref_type = "shared");
 }
+
+union TestUnion {
+  1: string stringField;
+  2: float floatField;
+}
+
+struct TestStructWithUnion {
+  1: TestUnion unionField;
+}
