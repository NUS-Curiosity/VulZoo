diff --git a/build.sbt b/build.sbt
index 75017d4a7e1..0a7f8224cba 100644
--- a/build.sbt
+++ b/build.sbt
@@ -63,6 +63,14 @@ lazy val server = libraryProject("server")
   .settings(
     description := "Base library for building http4s servers"
   )
+  .settings(BuildInfoPlugin.buildInfoScopedSettings(Test))
+  .settings(BuildInfoPlugin.buildInfoDefaultSettings)
+  .settings(
+    buildInfoKeys := Seq[BuildInfoKey](
+      resourceDirectory in Test,
+    ),
+    buildInfoPackage := "org.http4s.server.test"
+  )
   .dependsOn(core, testing % "test->test", theDsl % "test->compile")
 
 lazy val serverMetrics = libraryProject("server-metrics")
diff --git a/project/build.properties b/project/build.properties
index 0cd8b07982e..a919a9b5f46 100644
--- a/project/build.properties
+++ b/project/build.properties
@@ -1 +1 @@
-sbt.version=1.2.3
+sbt.version=1.3.8
diff --git a/project/plugins.sbt b/project/plugins.sbt
index ee7e76916d9..d84becc3978 100644
--- a/project/plugins.sbt
+++ b/project/plugins.sbt
@@ -4,7 +4,7 @@ addSbtPlugin("com.earldouglas"     %  "xsbt-web-plugin"       % "4.0.2")
 addSbtPlugin("com.github.tkawachi" %  "sbt-doctest"           % "0.7.2")
 addSbtPlugin("com.lucidchart"      %  "sbt-scalafmt-coursier" % "1.15")
 addSbtPlugin("org.scalastyle"      %% "scalastyle-sbt-plugin" % "1.0.0")
-addSbtPlugin("com.typesafe"        %  "sbt-mima-plugin"       % "0.1.18")
+addSbtPlugin("com.typesafe"        %  "sbt-mima-plugin"       % "0.7.0")
 addSbtPlugin("com.typesafe.sbt"    %  "sbt-native-packager"   % "1.3.3")
 addSbtPlugin("com.typesafe.sbt"    %  "sbt-twirl"             % "1.3.15")
 addSbtPlugin("io.gatling"          %  "gatling-sbt"           % "2.2.2")
diff --git a/server/src/main/scala/org/http4s/server/staticcontent/FileService.scala b/server/src/main/scala/org/http4s/server/staticcontent/FileService.scala
index 0a39b34ef31..4c81265dff6 100644
--- a/server/src/main/scala/org/http4s/server/staticcontent/FileService.scala
+++ b/server/src/main/scala/org/http4s/server/staticcontent/FileService.scala
@@ -4,12 +4,22 @@ package staticcontent
 
 import cats.data._
 import cats.effect._
+import cats.implicits._
 import java.io.File
+import java.nio.file.{LinkOption, Paths}
 import org.http4s.headers.Range.SubRange
 import org.http4s.headers._
+import org.http4s.server.middleware.TranslateUri
+import org.http4s.util.UrlCodingUtils.urlDecode
+import org.log4s.getLogger
 import scala.concurrent.ExecutionContext
+import scala.util.control.NoStackTrace
+import scala.util.{Failure, Success, Try}
+import java.nio.file.NoSuchFileException
 
 object FileService {
+  private[this] val logger = getLogger
+
   type PathCollector[F[_]] = (File, Config[F], Request[F]) => OptionT[F, Response[F]]
 
   /** [[org.http4s.server.staticcontent.FileService]] configuration
@@ -42,14 +52,46 @@ object FileService {
   }
 
   /** Make a new [[org.http4s.HttpService]] that serves static files. */
-  private[staticcontent] def apply[F[_]](config: Config[F])(implicit F: Effect[F]): HttpService[F] =
-    Kleisli {
-      case request if request.pathInfo.startsWith(config.pathPrefix) =>
-        getFile(s"${config.systemPath}/${getSubPath(request.pathInfo, config.pathPrefix)}")
-          .flatMap(f => config.pathCollector(f, config, request))
-          .semiflatMap(config.cacheStrategy.cache(request.pathInfo, _))
-      case _ => OptionT.none
+  private[staticcontent] def apply[F[_]](config: Config[F])(
+      implicit F: Effect[F]): HttpService[F] = {
+    object BadTraversal extends Exception with NoStackTrace
+    Try(Paths.get(config.systemPath).toRealPath()) match {
+      case Success(rootPath) =>
+        TranslateUri(config.pathPrefix)(Kleisli {
+          case request =>
+            request.pathInfo.split("/") match {
+              case Array(head, segments @ _*) if head.isEmpty =>
+                OptionT
+                  .liftF(F.catchNonFatal {
+                    segments.foldLeft(rootPath) {
+                      case (_, "" | "." | "..") => throw BadTraversal
+                      case (path, segment) =>
+                        path.resolve(urlDecode(segment, plusIsSpace = true))
+                    }
+                  })
+                  .semiflatMap(path => F.delay(path.toRealPath(LinkOption.NOFOLLOW_LINKS)))
+                  .collect { case path if path.startsWith(rootPath) => path.toFile }
+                  .flatMap(f => config.pathCollector(f, config, request))
+                  .semiflatMap(config.cacheStrategy.cache(request.pathInfo, _))
+                  .recoverWith {
+                    case _: NoSuchFileException => OptionT.none
+                    case BadTraversal => OptionT.some(Response(Status.BadRequest))
+                  }
+              case _ => OptionT.none
+            }
+        })
+
+      case Failure(_: NoSuchFileException) =>
+        logger.error(
+          s"Could not find root path from FileService config: systemPath = ${config.systemPath}, pathPrefix = ${config.pathPrefix}. All requests will return none.")
+        Kleisli(_ => OptionT.none)
+
+      case Failure(e) =>
+        logger.error(e)(
+          s"Could not resolve root path from FileService config: systemPath = ${config.systemPath}, pathPrefix = ${config.pathPrefix}. All requests will fail with a 500.")
+        Kleisli(_ => OptionT.pure(Response(Status.InternalServerError)))
     }
+  }
 
   private def filesOnly[F[_]](file: File, config: Config[F], req: Request[F])(
       implicit F: Sync[F]): OptionT[F, Response[F]] =
@@ -95,12 +137,4 @@ object FileService {
 
       case _ => OptionT.none
     }
-
-  // Attempts to sanitize the file location and retrieve the file. Returns None if the file doesn't exist.
-  private def getFile[F[_]](unsafePath: String)(implicit F: Sync[F]): OptionT[F, File] =
-    OptionT(F.delay {
-      val f = new File(PathNormalizer.removeDotSegments(unsafePath))
-      if (f.exists()) Some(f)
-      else None
-    })
 }
diff --git a/server/src/main/scala/org/http4s/server/staticcontent/ResourceService.scala b/server/src/main/scala/org/http4s/server/staticcontent/ResourceService.scala
index 1d5553fe76e..35b0e3743be 100644
--- a/server/src/main/scala/org/http4s/server/staticcontent/ResourceService.scala
+++ b/server/src/main/scala/org/http4s/server/staticcontent/ResourceService.scala
@@ -4,9 +4,17 @@ package staticcontent
 
 import cats.data.{Kleisli, OptionT}
 import cats.effect._
+import cats.implicits._
+import java.nio.file.Paths
+import org.http4s.server.middleware.TranslateUri
+import org.http4s.util.UrlCodingUtils.urlDecode
+import org.log4s.getLogger
 import scala.concurrent.ExecutionContext
+import scala.util.{Failure, Success, Try}
+import scala.util.control.NoStackTrace
 
 object ResourceService {
+  private[this] val logger = getLogger
 
   /** [[org.http4s.server.staticcontent.ResourceService]] configuration
     *
@@ -26,17 +34,48 @@ object ResourceService {
       preferGzipped: Boolean = false)
 
   /** Make a new [[org.http4s.HttpService]] that serves static files. */
-  private[staticcontent] def apply[F[_]: Effect](config: Config[F]): HttpService[F] =
-    Kleisli {
-      case request if request.pathInfo.startsWith(config.pathPrefix) =>
-        StaticFile
-          .fromResource(
-            PathNormalizer.removeDotSegments(
-              s"${config.basePath}/${getSubPath(request.pathInfo, config.pathPrefix)}"),
-            Some(request),
-            preferGzipped = config.preferGzipped
-          )
-          .semiflatMap(config.cacheStrategy.cache(request.pathInfo, _))
-      case _ => OptionT.none
+  private[staticcontent] def apply[F[_]](config: Config[F])(
+      implicit F: Effect[F]): HttpService[F] = {
+    val basePath = if (config.basePath.isEmpty) "/" else config.basePath
+    object BadTraversal extends Exception with NoStackTrace
+
+    Try(Paths.get(basePath)) match {
+      case Success(rootPath) =>
+        TranslateUri(config.pathPrefix)(Kleisli {
+          case request =>
+            request.pathInfo.split("/") match {
+              case Array(head, segments @ _*) if head.isEmpty =>
+                OptionT
+                  .liftF(F.catchNonFatal {
+                    segments.foldLeft(rootPath) {
+                      case (_, "" | "." | "..") => throw BadTraversal
+                      case (path, segment) =>
+                        path.resolve(urlDecode(segment, plusIsSpace = true))
+                    }
+                  })
+                  .collect {
+                    case path if path.startsWith(rootPath) => path
+                  }
+                  .flatMap { path =>
+                    StaticFile.fromResource(
+                      path.toString,
+                      Some(request),
+                      preferGzipped = config.preferGzipped
+                    )
+                  }
+                  .semiflatMap(config.cacheStrategy.cache(request.pathInfo, _))
+                  .recoverWith {
+                    case BadTraversal => OptionT.some(Response(Status.BadRequest))
+                  }
+              case _ =>
+                OptionT.none
+            }
+        })
+
+      case Failure(e) =>
+        logger.error(e)(
+          s"Could not get root path from ResourceService config: basePath = ${config.basePath}, pathPrefix = ${config.pathPrefix}. All requests will fail.")
+        Kleisli(_ => OptionT.pure(Response(Status.InternalServerError)))
     }
+  }
 }
diff --git a/server/src/main/scala/org/http4s/server/staticcontent/WebjarService.scala b/server/src/main/scala/org/http4s/server/staticcontent/WebjarService.scala
index fe561e008f5..3ee8eaecc21 100644
--- a/server/src/main/scala/org/http4s/server/staticcontent/WebjarService.scala
+++ b/server/src/main/scala/org/http4s/server/staticcontent/WebjarService.scala
@@ -4,6 +4,10 @@ package staticcontent
 
 import cats.data.{Kleisli, OptionT}
 import cats.effect.Effect
+import cats.implicits._
+import java.nio.file.{Path, Paths}
+import org.http4s.util.UrlCodingUtils.urlDecode
+import scala.util.control.NoStackTrace
 
 /**
   * Constructs new services to serve assets from Webjars
@@ -51,16 +55,32 @@ object WebjarService {
     * @param config The configuration for this service
     * @return The HttpService
     */
-  def apply[F[_]: Effect](config: Config[F]): HttpService[F] = Kleisli {
-    // Intercepts the routes that match webjar asset names
-    case request if request.method == Method.GET =>
-      OptionT
-        .pure[F](request.pathInfo)
-        .map(PathNormalizer.removeDotSegments)
-        .subflatMap(toWebjarAsset)
-        .filter(config.filter)
-        .flatMap(serveWebjarAsset(config, request)(_))
-    case _ => OptionT.none
+  def apply[F[_]](config: Config[F])(implicit F: Effect[F]): HttpService[F] = {
+    object BadTraversal extends Exception with NoStackTrace
+    val Root = Paths.get("")
+    Kleisli {
+      // Intercepts the routes that match webjar asset names
+      case request if request.method == Method.GET =>
+        request.pathInfo.split("/") match {
+          case Array(head, segments @ _*) if head.isEmpty =>
+            OptionT
+              .liftF(F.catchNonFatal {
+                segments.foldLeft(Root) {
+                  case (_, "" | "." | "..") => throw BadTraversal
+                  case (path, segment) =>
+                    path.resolve(urlDecode(segment, plusIsSpace = true))
+                }
+              })
+              .subflatMap(toWebjarAsset)
+              .filter(config.filter)
+              .flatMap(serveWebjarAsset(config, request)(_))
+              .recover {
+                case BadTraversal => Response(Status.BadRequest)
+              }
+          case _ => OptionT.none
+        }
+      case _ => OptionT.none
+    }
   }
 
   /**
@@ -69,14 +89,17 @@ object WebjarService {
     * @param subPath The request path without the prefix
     * @return The WebjarAsset, or None if it couldn't be mapped
     */
-  private def toWebjarAsset(subPath: String): Option[WebjarAsset] =
-    Option(subPath)
-      .map(_.split("/", 4))
-      .collect {
-        case Array("", library, version, asset)
-            if library.nonEmpty && version.nonEmpty && asset.nonEmpty =>
-          WebjarAsset(library, version, asset)
-      }
+  private def toWebjarAsset(p: Path): Option[WebjarAsset] = {
+    val count = p.getNameCount
+    if (count > 2) {
+      val library = p.getName(0).toString
+      val version = p.getName(1).toString
+      val asset = p.subpath(2, count)
+      Some(WebjarAsset(library, version, asset.toString))
+    } else {
+      None
+    }
+  }
 
   /**
     * Returns an asset that matched the request if it's found in the webjar path
diff --git a/server/src/test/resources/Dir/partial-prefix.txt b/server/src/test/resources/Dir/partial-prefix.txt
new file mode 100644
index 00000000000..6508103a460
--- /dev/null
+++ b/server/src/test/resources/Dir/partial-prefix.txt
@@ -0,0 +1 @@
+I am useful to test leaks from prefix paths.
diff --git a/server/src/test/resources/META-INF/resources/webjars/deep purple/machine head/space truckin'.txt b/server/src/test/resources/META-INF/resources/webjars/deep purple/machine head/space truckin'.txt
new file mode 100644
index 00000000000..88e1e0dadba
--- /dev/null
+++ b/server/src/test/resources/META-INF/resources/webjars/deep purple/machine head/space truckin'.txt	
@@ -0,0 +1,5 @@
+Come on
+Come on
+Come on
+Let's go
+Space truckin'
diff --git a/server/src/test/resources/space truckin'.txt b/server/src/test/resources/space truckin'.txt
new file mode 100644
index 00000000000..88e1e0dadba
--- /dev/null
+++ b/server/src/test/resources/space truckin'.txt	
@@ -0,0 +1,5 @@
+Come on
+Come on
+Come on
+Let's go
+Space truckin'
diff --git a/server/src/test/resources/symlink b/server/src/test/resources/symlink
new file mode 120000
index 00000000000..6fbc0d7126f
--- /dev/null
+++ b/server/src/test/resources/symlink
@@ -0,0 +1 @@
+../scala
\ No newline at end of file
diff --git a/server/src/test/resources/test/keep.txt b/server/src/test/resources/test/keep.txt
new file mode 100644
index 00000000000..9c558e357c4
--- /dev/null
+++ b/server/src/test/resources/test/keep.txt
@@ -0,0 +1 @@
+.
diff --git a/server/src/test/scala/org/http4s/server/staticcontent/FileServiceSpec.scala b/server/src/test/scala/org/http4s/server/staticcontent/FileServiceSpec.scala
index 9f0c18e2d2c..9887c4b044a 100644
--- a/server/src/test/scala/org/http4s/server/staticcontent/FileServiceSpec.scala
+++ b/server/src/test/scala/org/http4s/server/staticcontent/FileServiceSpec.scala
@@ -4,11 +4,12 @@ package staticcontent
 
 import cats.effect._
 import fs2._
-import java.io.File
+import java.nio.file._
 import org.http4s.server.middleware.TranslateUri
 
 class FileServiceSpec extends Http4sSpec with StaticContentShared {
-  val s = fileService(FileService.Config[IO](new File(getClass.getResource("/").toURI).getPath))
+  val defaultSystemPath = test.BuildInfo.test_resourceDirectory.getAbsolutePath
+  val s = fileService(FileService.Config[IO](defaultSystemPath))
 
   "FileService" should {
 
@@ -16,25 +17,122 @@ class FileServiceSpec extends Http4sSpec with StaticContentShared {
       val s2 = TranslateUri("/foo")(s)
 
       {
-        val req = Request[IO](uri = uri("foo/testresource.txt"))
+        val req = Request[IO](uri = uri("/foo/testresource.txt"))
         s2.orNotFound(req) must returnBody(testResource)
         s2.orNotFound(req) must returnStatus(Status.Ok)
       }
 
       {
-        val req = Request[IO](uri = uri("testresource.txt"))
+        val req = Request[IO](uri = uri("/testresource.txt"))
         s2.orNotFound(req) must returnStatus(Status.NotFound)
       }
     }
 
     "Return a 200 Ok file" in {
-      val req = Request[IO](uri = uri("testresource.txt"))
+      val req = Request[IO](uri = uri("/testresource.txt"))
       s.orNotFound(req) must returnBody(testResource)
       s.orNotFound(req) must returnStatus(Status.Ok)
     }
 
+    "Decodes path segments" in {
+      val req = Request[IO](uri = uri("/space+truckin%27.txt"))
+      s.orNotFound(req) must returnStatus(Status.Ok)
+    }
+
+    "Respect the path prefix" in {
+      val relativePath = "testresource.txt"
+      val s0 = fileService(
+        FileService.Config[IO](
+          systemPath = defaultSystemPath,
+          pathPrefix = "/path-prefix"
+        ))
+      val file = Paths.get(defaultSystemPath).resolve(relativePath).toFile
+      file.exists() must beTrue
+      val uri = Uri.unsafeFromString("/path-prefix/" + relativePath)
+      val req = Request[IO](uri = uri)
+      s0.orNotFound(req) must returnStatus(Status.Ok)
+    }
+
+    "Return a 400 if the request tries to escape the context" in {
+      val relativePath = "../testresource.txt"
+      val systemPath = Paths.get(defaultSystemPath).resolve("testDir")
+      val file = systemPath.resolve(relativePath).toFile
+      file.exists() must beTrue
+
+      val uri = Uri.unsafeFromString("/" + relativePath)
+      val req = Request[IO](uri = uri)
+      val s0 = fileService(
+        FileService.Config[IO](
+          systemPath = systemPath.toString
+        ))
+      s0.orNotFound(req) must returnStatus(Status.BadRequest)
+    }
+
+    "Return a 400 on path traversal, even if it's inside the context" in {
+      val relativePath = "testDir/../testresource.txt"
+      val file = Paths.get(defaultSystemPath).resolve(relativePath).toFile
+      file.exists() must beTrue
+
+      val uri = Uri.unsafeFromString("/" + relativePath)
+      val req = Request[IO](uri = uri)
+      s.orNotFound(req) must returnStatus(Status.BadRequest)
+    }
+
+    "Return a 404 Not Found if the request tries to escape the context with a partial system path prefix match" in {
+      val relativePath = "Dir/partial-prefix.txt"
+      val file = Paths.get(defaultSystemPath).resolve(relativePath).toFile
+      file.exists() must beTrue
+
+      val uri = Uri.unsafeFromString("/test" + relativePath)
+      val req = Request[IO](uri = uri)
+      val s0 = fileService(
+        FileService.Config[IO](
+          systemPath = Paths.get(defaultSystemPath).resolve("test").toString
+        ))
+      s0.orNotFound(req) must returnStatus(Status.NotFound)
+    }
+
+    "Return a 404 Not Found if the request tries to escape the context with a partial path-prefix match" in {
+      val relativePath = "Dir/partial-prefix.txt"
+      val file = Paths.get(defaultSystemPath).resolve(relativePath).toFile
+      file.exists() must beTrue
+
+      val uri = Uri.unsafeFromString("/prefix" + relativePath)
+      val req = Request[IO](uri = uri)
+      val s0 = fileService(
+        FileService.Config[IO](
+          systemPath = defaultSystemPath,
+          pathPrefix = "/prefix"
+        ))
+      s0.orNotFound(req) must returnStatus(Status.NotFound)
+    }
+
+    "Return a 400 if the request tries to escape the context with /" in {
+      val absPath = Paths.get(defaultSystemPath).resolve("testresource.txt")
+      val file = absPath.toFile
+      file.exists() must beTrue
+
+      val uri = Uri.unsafeFromString("///" + absPath)
+      val req = Request[IO](uri = uri)
+      s.orNotFound(req) must returnStatus(Status.BadRequest)
+    }
+
+    "return files included via symlink" in {
+      val relativePath = "symlink/org/http4s/server/staticcontent/FileServiceSpec.scala"
+      val path = Paths.get(defaultSystemPath).resolve(relativePath)
+      val file = path.toFile
+      Files.isSymbolicLink(Paths.get(defaultSystemPath).resolve("symlink")) must beTrue
+      file.exists() must beTrue
+      val bytes = Chunk.bytes(Files.readAllBytes(path))
+
+      val uri = Uri.unsafeFromString("/" + relativePath)
+      val req = Request[IO](uri = uri)
+      s.orNotFound(req) must returnStatus(Status.Ok)
+      s.orNotFound(req) must returnBody(bytes)
+    }
+
     "Return index.html if request points to a directory" in {
-      val req = Request[IO](uri = uri("testDir/"))
+      val req = Request[IO](uri = uri("/testDir/"))
       val rb = runReq(req)
 
       rb._2.as[String] must returnValue("<html>Hello!</html>")
@@ -42,20 +140,20 @@ class FileServiceSpec extends Http4sSpec with StaticContentShared {
     }
 
     "Not find missing file" in {
-      val req = Request[IO](uri = uri("testresource.txtt"))
+      val req = Request[IO](uri = uri("/missing.txt"))
       s.orNotFound(req) must returnStatus(Status.NotFound)
     }
 
     "Return a 206 PartialContent file" in {
       val range = headers.Range(4)
-      val req = Request[IO](uri = uri("testresource.txt")).replaceAllHeaders(range)
+      val req = Request[IO](uri = uri("/testresource.txt")).replaceAllHeaders(range)
       s.orNotFound(req) must returnStatus(Status.PartialContent)
       s.orNotFound(req) must returnBody(Chunk.bytes(testResource.toArray.splitAt(4)._2))
     }
 
     "Return a 206 PartialContent file" in {
       val range = headers.Range(-4)
-      val req = Request[IO](uri = uri("testresource.txt")).replaceAllHeaders(range)
+      val req = Request[IO](uri = uri("/testresource.txt")).replaceAllHeaders(range)
       s.orNotFound(req) must returnStatus(Status.PartialContent)
       s.orNotFound(req) must returnBody(
         Chunk.bytes(testResource.toArray.splitAt(testResource.size - 4)._2))
@@ -63,7 +161,7 @@ class FileServiceSpec extends Http4sSpec with StaticContentShared {
 
     "Return a 206 PartialContent file" in {
       val range = headers.Range(2, 4)
-      val req = Request[IO](uri = uri("testresource.txt")).replaceAllHeaders(range)
+      val req = Request[IO](uri = uri("/testresource.txt")).replaceAllHeaders(range)
       s.orNotFound(req) must returnStatus(Status.PartialContent)
       s.orNotFound(req) must returnBody(Chunk.bytes(testResource.toArray.slice(2, 4 + 1))) // the end number is inclusive in the Range header
     }
@@ -76,12 +174,26 @@ class FileServiceSpec extends Http4sSpec with StaticContentShared {
         headers.Range(200, 201),
         headers.Range(-200)
       )
-      val reqs = ranges.map(r => Request[IO](uri = uri("testresource.txt")).replaceAllHeaders(r))
+      val reqs = ranges.map(r => Request[IO](uri = uri("/testresource.txt")).replaceAllHeaders(r))
       forall(reqs) { req =>
         s.orNotFound(req) must returnStatus(Status.Ok)
         s.orNotFound(req) must returnBody(testResource)
       }
     }
-  }
 
+    "doesn't crash on /" in {
+      s.orNotFound(Request[IO](uri = uri("/"))) must returnStatus(Status.NotFound)
+    }
+
+    "handle a relative system path" in {
+      val s = fileService(FileService.Config[IO]("."))
+      Paths.get(".").resolve("build.sbt").toFile.exists() must beTrue
+      s.orNotFound(Request[IO](uri = uri("/build.sbt"))) must returnStatus(Status.Ok)
+    }
+
+    "404 if system path is not found" in {
+      val s = fileService(FileService.Config[IO]("./does-not-exist"))
+      s.orNotFound(Request[IO](uri = uri("/build.sbt"))) must returnStatus(Status.NotFound)
+    }
+  }
 }
diff --git a/server/src/test/scala/org/http4s/server/staticcontent/ResourceServiceSpec.scala b/server/src/test/scala/org/http4s/server/staticcontent/ResourceServiceSpec.scala
index 4d02dc24bce..5e7b1e65fe2 100644
--- a/server/src/test/scala/org/http4s/server/staticcontent/ResourceServiceSpec.scala
+++ b/server/src/test/scala/org/http4s/server/staticcontent/ResourceServiceSpec.scala
@@ -3,12 +3,14 @@ package server
 package staticcontent
 
 import cats.effect._
+import java.nio.file.Paths
 import org.http4s.headers.{`Accept-Encoding`, `If-Modified-Since`}
 import org.http4s.server.middleware.TranslateUri
 
 class ResourceServiceSpec extends Http4sSpec with StaticContentShared {
 
   val config = ResourceService.Config[IO]("", executionContext = Http4sSpec.TestExecutionContext)
+  val defaultBase = getClass.getResource("/").getPath.toString
   val s = resourceService(config)
 
   "ResourceService" should {
@@ -17,28 +19,115 @@ class ResourceServiceSpec extends Http4sSpec with StaticContentShared {
       val s2 = TranslateUri("/foo")(s)
 
       {
-        val req = Request[IO](uri = uri("foo/testresource.txt"))
+        val req = Request[IO](uri = uri("/foo/testresource.txt"))
         s2.orNotFound(req) must returnBody(testResource)
         s2.orNotFound(req) must returnStatus(Status.Ok)
       }
 
       {
-        val req = Request[IO](uri = uri("testresource.txt"))
+        val req = Request[IO](uri = uri("/testresource.txt"))
         s2.orNotFound(req) must returnStatus(Status.NotFound)
       }
     }
 
     "Serve available content" in {
-      val req = Request[IO](uri = Uri.fromString("testresource.txt").yolo)
+      val req = Request[IO](uri = Uri.fromString("/testresource.txt").yolo)
       val rb = s.orNotFound(req)
 
       rb must returnBody(testResource)
       rb must returnStatus(Status.Ok)
     }
 
+    "Decodes path segments" in {
+      val req = Request[IO](uri = uri("/space+truckin%27.txt"))
+      s.orNotFound(req) must returnStatus(Status.Ok)
+    }
+
+    "Respect the path prefix" in {
+      val relativePath = "testresource.txt"
+      val s0 = resourceService(
+        ResourceService.Config[IO](
+          basePath = "",
+          pathPrefix = "/path-prefix"
+        ))
+      val file = Paths.get(defaultBase).resolve(relativePath).toFile
+      file.exists() must beTrue
+      val uri = Uri.unsafeFromString("/path-prefix/" + relativePath)
+      val req = Request[IO](uri = uri)
+      s0.orNotFound(req) must returnStatus(Status.Ok)
+    }
+
+    "Return a 400 if the request tries to escape the context" in {
+      val relativePath = "../testresource.txt"
+      val basePath = Paths.get(defaultBase).resolve("testDir")
+      val file = basePath.resolve(relativePath).toFile
+      file.exists() must beTrue
+
+      val uri = Uri.unsafeFromString("/" + relativePath)
+      val req = Request[IO](uri = uri)
+      val s0 = resourceService(
+        ResourceService.Config[IO](
+          basePath = "/testDir"
+        ))
+      s0.orNotFound(req) must returnStatus(Status.BadRequest)
+    }
+
+    "Return a 400 on path traversal, even if it's inside the context" in {
+      val relativePath = "testDir/../testresource.txt"
+      val file = Paths.get(defaultBase).resolve(relativePath).toFile
+      file.exists() must beTrue
+
+      val uri = Uri.unsafeFromString("/" + relativePath)
+      val req = Request[IO](uri = uri)
+      s.orNotFound(req) must returnStatus(Status.BadRequest)
+    }
+
+    "Return a 404 Not Found if the request tries to escape the context with a partial base path prefix match" in {
+      val relativePath = "Dir/partial-prefix.txt"
+      val file = Paths.get(defaultBase).resolve(relativePath).toFile
+      file.exists() must beTrue
+
+      val uri = Uri.unsafeFromString("/test" + relativePath)
+      val req = Request[IO](uri = uri)
+      val s0 = resourceService(
+        ResourceService.Config[IO](
+          basePath = ""
+        ))
+      s0.orNotFound(req) must returnStatus(Status.NotFound)
+    }
+
+    "Return a 404 Not Found if the request tries to escape the context with a partial path-prefix match" in {
+      val relativePath = "Dir/partial-prefix.txt"
+      val file = Paths.get(defaultBase).resolve(relativePath).toFile
+      file.exists() must beTrue
+
+      val uri = Uri.unsafeFromString("/test" + relativePath)
+      val req = Request[IO](uri = uri)
+      val s0 = resourceService(
+        ResourceService.Config[IO](
+          basePath = "",
+          pathPrefix = "/test"
+        ))
+      s0.orNotFound(req) must returnStatus(Status.NotFound)
+    }
+
+    "Return a 400 Not Found if the request tries to escape the context with /" in {
+      val absPath = Paths.get(defaultBase).resolve("testresource.txt")
+      val file = absPath.toFile
+      file.exists() must beTrue
+
+      val uri = Uri.unsafeFromString("///" + absPath)
+      val req = Request[IO](uri = uri)
+      val s0 = resourceService(
+        ResourceService.Config[IO](
+          basePath = "/testDir"
+        ))
+      s0.orNotFound(req) must returnStatus(Status.BadRequest)
+    }
+
     "Try to serve pre-gzipped content if asked to" in {
       val req = Request[IO](
-        uri = Uri.fromString("testresource.txt").yolo,
+        uri = Uri.fromString("/testresource.txt").yolo,
         headers = Headers(`Accept-Encoding`(ContentCoding.gzip))
       )
       val rb = resourceService(config.copy(preferGzipped = true)).orNotFound(req)
@@ -51,7 +140,7 @@ class ResourceServiceSpec extends Http4sSpec with StaticContentShared {
 
     "Fallback to un-gzipped file if pre-gzipped version doesn't exist" in {
       val req = Request[IO](
-        uri = Uri.fromString("testresource2.txt").yolo,
+        uri = Uri.fromString("/testresource2.txt").yolo,
         headers = Headers(`Accept-Encoding`(ContentCoding.gzip))
       )
       val rb = resourceService(config.copy(preferGzipped = true)).orNotFound(req)
@@ -63,15 +152,19 @@ class ResourceServiceSpec extends Http4sSpec with StaticContentShared {
     }
 
     "Generate non on missing content" in {
-      val req = Request[IO](uri = Uri.fromString("testresource.txtt").yolo)
+      val req = Request[IO](uri = Uri.fromString("/testresource.txtt").yolo)
       s.orNotFound(req) must returnStatus(Status.NotFound)
     }
 
     "Not send unmodified files" in {
-      val req = Request[IO](uri = uri("testresource.txt"))
+      val req = Request[IO](uri = uri("/testresource.txt"))
         .putHeaders(`If-Modified-Since`(HttpDate.MaxValue))
 
       runReq(req)._2.status must_== Status.NotModified
     }
+
+    "doesn't crash on /" in {
+      s.orNotFound(Request[IO](uri = uri("/"))) must returnStatus(Status.NotFound)
+    }
   }
 }
diff --git a/server/src/test/scala/org/http4s/server/staticcontent/WebjarServiceSpec.scala b/server/src/test/scala/org/http4s/server/staticcontent/WebjarServiceSpec.scala
index d72bf3f0121..345be54523b 100644
--- a/server/src/test/scala/org/http4s/server/staticcontent/WebjarServiceSpec.scala
+++ b/server/src/test/scala/org/http4s/server/staticcontent/WebjarServiceSpec.scala
@@ -3,12 +3,15 @@ package server
 package staticcontent
 
 import cats.effect._
+import java.nio.file.Paths
 import org.http4s.Method.{GET, POST}
 import org.http4s.server.staticcontent.WebjarService.Config
 
 object WebjarServiceSpec extends Http4sSpec with StaticContentShared {
 
   def s: HttpService[IO] = webjarService(Config[IO]())
+  val defaultBase =
+    test.BuildInfo.test_resourceDirectory.toPath.resolve("META-INF/resources/webjars").toString
 
   "The WebjarService" should {
 
@@ -28,6 +31,41 @@ object WebjarServiceSpec extends Http4sSpec with StaticContentShared {
       rb._2.status must_== Status.Ok
     }
 
+    "Decodes path segments" in {
+      val req = Request[IO](uri = uri("/deep+purple/machine+head/space+truckin%27.txt"))
+      s.orNotFound(req) must returnStatus(Status.Ok)
+    }
+
+    "Return a 400 on a relative link even if it's inside the context" in {
+      val relativePath = "test-lib/1.0.0/sub/../testresource.txt"
+      val file = Paths.get(defaultBase).resolve(relativePath).toFile
+      file.exists() must beTrue
+
+      val uri = Uri.unsafeFromString("/" + relativePath)
+      val req = Request[IO](uri = uri)
+      s.orNotFound(req) must returnStatus(Status.BadRequest)
+    }
+
+    "Return a 400 if the request tries to escape the context" in {
+      val relativePath = "../../../testresource.txt"
+      val file = Paths.get(defaultBase).resolve(relativePath).toFile
+      file.exists() must beTrue
+
+      val uri = Uri.unsafeFromString("/" + relativePath)
+      val req = Request[IO](uri = uri)
+      s.orNotFound(req) must returnStatus(Status.BadRequest)
+    }
+
+    "Return a 400 if the request tries to escape the context with /" in {
+      val absPath = Paths.get(defaultBase).resolve("test-lib/1.0.0/testresource.txt")
+      val file = absPath.toFile
+      file.exists() must beTrue
+
+      val uri = Uri.unsafeFromString("///" + absPath)
+      val req = Request[IO](uri = uri)
+      s.orNotFound(req) must returnStatus(Status.BadRequest)
+    }
+
     "Not find missing file" in {
       val req = Request[IO](uri = uri("/test-lib/1.0.0/doesnotexist.txt"))
       s.apply(req).value must returnValue(None)
@@ -38,12 +76,12 @@ object WebjarServiceSpec extends Http4sSpec with StaticContentShared {
       s.apply(req).value must returnValue(None)
     }
 
-    "Not find missing version" in {
+    "Return bad request on missing version" in {
       val req = Request[IO](uri = uri("/test-lib//doesnotexist.txt"))
-      s.apply(req).value must returnValue(None)
+      s.orNotFound(req) must returnStatus(Status.BadRequest)
     }
 
-    "Not find missing asset" in {
+    "Not find blank asset" in {
       val req = Request[IO](uri = uri("/test-lib/1.0.0/"))
       s.apply(req).value must returnValue(None)
     }
diff --git a/version.sbt b/version.sbt
index d4a7efe392e..92daa5e4794 100644
--- a/version.sbt
+++ b/version.sbt
@@ -1 +1 @@
-version in ThisBuild := "0.18.26-SNAPSHOT"
+version in ThisBuild := "0.18.27-SNAPSHOT"
diff --git a/website/src/hugo/content/changelog.md b/website/src/hugo/content/changelog.md
index 9c431aa2206..4fa6e868092 100644
--- a/website/src/hugo/content/changelog.md
+++ b/website/src/hugo/content/changelog.md
@@ -8,6 +8,15 @@ Maintenance branches are merged before each new release. This change log is
 ordered chronologically, so each release contains all changes described below
 it.
 
+# v0.18.26
+
+This release is fully backward compatible with 0.18.25.
+
+## Security fixes
+* [GHSA-66q9-f7ff-mmx6](https://github.com/http4s/http4s/security/advisories/GHSA-66q9-f7ff-mmx6): Fixes a local file inclusion vulnerability in `FileService`, `ResourceService`, and `WebjarService`.
+  * Request paths with `.`, `..`, or empty segments will now return a 400 in all three services.  Combinations of these could formerly be used to escape the configured roots and expose arbitrary local resources.
+  * Request path segments are now percent-decoded to support resources with reserved characters in the name.
+  
 # v0.18.25 (2020-01-21)
 
 ## Bug fixes
