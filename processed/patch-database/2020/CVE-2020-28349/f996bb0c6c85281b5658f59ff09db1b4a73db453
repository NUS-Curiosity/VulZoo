diff --git a/internal/backend/gateway/mqtt/backend.go b/internal/backend/gateway/mqtt/backend.go
index 7436bd2d..6e7b3286 100644
--- a/internal/backend/gateway/mqtt/backend.go
+++ b/internal/backend/gateway/mqtt/backend.go
@@ -5,7 +5,6 @@ import (
 	"crypto/tls"
 	"crypto/x509"
 	"encoding/base64"
-	"encoding/hex"
 	"fmt"
 	"io/ioutil"
 	"strings"
@@ -249,20 +248,6 @@ func (b *Backend) rxPacketHandler(c paho.Client, msg paho.Message) {
 		"gateway_id": gatewayID,
 	}).Info("gateway/mqtt: uplink frame received")
 
-	// Since with MQTT all subscribers will receive the uplink messages sent
-	// by all the gateways, the first instance receiving the message must lock it,
-	// so that other instances can ignore the same message (from the same gw).
-	key := fmt.Sprintf("lora:ns:uplink:lock:%s:%d:%d:%d:%s", gatewayID, uplinkFrame.TxInfo.Frequency, uplinkFrame.RxInfo.Board, uplinkFrame.RxInfo.Antenna, hex.EncodeToString(uplinkFrame.PhyPayload))
-	if locked, err := b.isLocked(key); err != nil || locked {
-		if err != nil {
-			log.WithError(err).WithFields(log.Fields{
-				"uplink_id": uplinkID,
-				"key":       key,
-			}).Error("gateway/mqtt: acquire lock error")
-		}
-		return
-	}
-
 	b.rxPacketChan <- uplinkFrame
 }
 
diff --git a/internal/uplink/collect.go b/internal/uplink/collect.go
index 1612109b..f70d7d70 100644
--- a/internal/uplink/collect.go
+++ b/internal/uplink/collect.go
@@ -19,8 +19,8 @@ import (
 
 // Templates used for generating Redis keys
 const (
-	CollectKeyTempl     = "lora:ns:rx:collect:%s"
-	CollectLockKeyTempl = "lora:ns:rx:collect:%s:lock"
+	CollectKeyTempl     = "lora:ns:rx:collect:%s:%s"
+	CollectLockKeyTempl = "lora:ns:rx:collect:%s:%s:lock"
 )
 
 // collectAndCallOnce collects the package, sleeps the configured duraction and
@@ -33,8 +33,14 @@ const (
 // unique set per gateway MAC and packet MIC.
 func collectAndCallOnce(rxPacket gw.UplinkFrame, callback func(packet models.RXPacket) error) error {
 	phyKey := hex.EncodeToString(rxPacket.PhyPayload)
-	key := fmt.Sprintf(CollectKeyTempl, phyKey)
-	lockKey := fmt.Sprintf(CollectLockKeyTempl, phyKey)
+	txInfoB, err := proto.Marshal(rxPacket.TxInfo)
+	if err != nil {
+		return errors.Wrap(err, "marshal protobuf error")
+	}
+	txInfoHEX := hex.EncodeToString(txInfoB)
+
+	key := fmt.Sprintf(CollectKeyTempl, txInfoHEX, phyKey)
+	lockKey := fmt.Sprintf(CollectLockKeyTempl, txInfoHEX, phyKey)
 
 	// this way we can set a really low DeduplicationDelay for testing, without
 	// the risk that the set already expired in redis on read
