diff --git a/TODO b/TODO
index 4a6c8d3512d4e..d26b1be4089a4 100644
--- a/TODO
+++ b/TODO
@@ -328,7 +328,7 @@ Features:
 
 * the a-posteriori stopping of units bound to units that disappeared logic
   should be reworked: there should be a queue of units, and we should only
-  enqeue stop jobs from a defer event that processes queue instead of
+  enqueue stop jobs from a defer event that processes queue instead of
   right-away when we find a unit that is bound to one that doesn't exist
   anymore. (similar to how the stop-unneeded queue has been reworked the same
   way)
diff --git a/man/sd_bus_enqueue_for_read.xml b/man/sd_bus_enqueue_for_read.xml
index 30ccee2ef25f0..3318a3031bc66 100644
--- a/man/sd_bus_enqueue_for_read.xml
+++ b/man/sd_bus_enqueue_for_read.xml
@@ -47,7 +47,7 @@
 
     <para>This call is primarily useful for dealing with incoming method calls that may be processed only
     after an additional asynchronous operation completes. One example are PolicyKit authorization requests
-    that are determined to be necessary to autorize a newly incoming method call: when the PolicyKit response
+    that are determined to be necessary to authorize a newly incoming method call: when the PolicyKit response
     is received the original method call may be re-enqueued to process it again, this time with the
     authorization result known.</para>
   </refsect1>
diff --git a/src/libsystemd/libsystemd.sym b/src/libsystemd/libsystemd.sym
index 08b915cf7c553..8b6ebbcf8bf6c 100644
--- a/src/libsystemd/libsystemd.sym
+++ b/src/libsystemd/libsystemd.sym
@@ -685,7 +685,7 @@ global:
 
 LIBSYSTEMD_245 {
 global:
-        sd_bus_enqeue_for_read;
+        sd_bus_enqueue_for_read;
         sd_bus_message_dump;
         sd_bus_message_sensitive;
         sd_event_add_child_pidfd;
diff --git a/src/libsystemd/sd-bus/sd-bus.c b/src/libsystemd/sd-bus/sd-bus.c
index c1db48f47a445..7ad03680f48d8 100644
--- a/src/libsystemd/sd-bus/sd-bus.c
+++ b/src/libsystemd/sd-bus/sd-bus.c
@@ -4208,7 +4208,7 @@ _public_ int sd_bus_get_close_on_exit(sd_bus *bus) {
         return bus->close_on_exit;
 }
 
-_public_ int sd_bus_enqeue_for_read(sd_bus *bus, sd_bus_message *m) {
+_public_ int sd_bus_enqueue_for_read(sd_bus *bus, sd_bus_message *m) {
         int r;
 
         assert_return(bus, -EINVAL);
@@ -4220,9 +4220,9 @@ _public_ int sd_bus_enqeue_for_read(sd_bus *bus, sd_bus_message *m) {
         if (!BUS_IS_OPEN(bus->state))
                 return -ENOTCONN;
 
-        /* Re-enqeue a message for reading. This is primarily useful for PolicyKit-style authentication,
-         * where we want accept a message, then determine we need to interactively authenticate the user, and
-         * when we have that process the message again. */
+        /* Re-enqueue a message for reading. This is primarily useful for PolicyKit-style authentication,
+         * where we accept a message, then determine we need to interactively authenticate the user, and then
+         * we want to process the message again. */
 
         r = bus_rqueue_make_room(bus);
         if (r < 0)
diff --git a/src/shared/bus-polkit.c b/src/shared/bus-polkit.c
index bd88e337b7bd7..0dbf3f60c8c21 100644
--- a/src/shared/bus-polkit.c
+++ b/src/shared/bus-polkit.c
@@ -234,7 +234,7 @@ static int async_polkit_callback(sd_bus_message *reply, void *userdata, sd_bus_e
         if (r < 0)
                 goto fail;
 
-        r = sd_bus_enqeue_for_read(sd_bus_message_get_bus(q->request), q->request);
+        r = sd_bus_enqueue_for_read(sd_bus_message_get_bus(q->request), q->request);
         if (r < 0)
                 goto fail;
 
diff --git a/src/systemd/sd-bus.h b/src/systemd/sd-bus.h
index 821b06ea9268d..e6f3298745722 100644
--- a/src/systemd/sd-bus.h
+++ b/src/systemd/sd-bus.h
@@ -207,7 +207,7 @@ int sd_bus_process(sd_bus *bus, sd_bus_message **r);
 int sd_bus_process_priority(sd_bus *bus, int64_t max_priority, sd_bus_message **r);
 int sd_bus_wait(sd_bus *bus, uint64_t timeout_usec);
 int sd_bus_flush(sd_bus *bus);
-int sd_bus_enqeue_for_read(sd_bus *bus, sd_bus_message *m);
+int sd_bus_enqueue_for_read(sd_bus *bus, sd_bus_message *m);
 
 sd_bus_slot* sd_bus_get_current_slot(sd_bus *bus);
 sd_bus_message* sd_bus_get_current_message(sd_bus *bus);
