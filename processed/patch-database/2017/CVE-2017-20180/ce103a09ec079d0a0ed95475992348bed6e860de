diff --git a/CoinSpend.cpp b/CoinSpend.cpp
index 7187e85..ae1b31a 100644
--- a/CoinSpend.cpp
+++ b/CoinSpend.cpp
@@ -29,6 +29,11 @@ CoinSpend::CoinSpend(const Params* p, const PrivateCoin& coin,
 		throw ZerocoinException("Accumulator witness does not verify");
 	}
 
+	// The serial # needs to be within the specified range our else it can be incremented by the modulus and create another valid proof
+	if (!HasValidSerial()) {
+		throw ZerocoinException("Invalid serial # range");
+	}
+
 	// 1: Generate two separate commitments to the public coin (C), each under
 	// a different set of public parameters. We do this because the RSA accumulator
 	// has specific requirements for the commitment parameters that are not
@@ -79,4 +84,9 @@ const uint256 CoinSpend::signatureHash(const SpendMetaData &m) const {
 	return h.GetHash();
 }
 
+bool CoinSpend::HasValidSerial() const
+{
+	return coinSerialNumber > 0 && coinSerialNumber < params->coinCommitmentGroup.groupOrder;
+}
+
 } /* namespace libzerocoin */
diff --git a/CoinSpend.h b/CoinSpend.h
index 51a4664..5bd52fa 100644
--- a/CoinSpend.h
+++ b/CoinSpend.h
@@ -76,6 +76,7 @@ class CoinSpend {
 	 */
 	const CoinDenomination getDenomination();
 
+	bool HasValidSerial() const;
 	bool Verify(const Accumulator& a, const SpendMetaData &metaData) const;
 
 	IMPLEMENT_SERIALIZE
