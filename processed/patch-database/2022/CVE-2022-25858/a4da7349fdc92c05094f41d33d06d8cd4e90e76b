diff --git a/lib/compress/evaluate.js b/lib/compress/evaluate.js
index 9cb432de7..21d1c4a7f 100644
--- a/lib/compress/evaluate.js
+++ b/lib/compress/evaluate.js
@@ -46,7 +46,8 @@ import {
     makePredicate,
     return_this,
     string_template,
-    regexp_source_fix
+    regexp_source_fix,
+    regexp_is_safe,
 } from "../utils/index.js";
 import {
     AST_Array,
@@ -129,7 +130,7 @@ def_eval(AST_BigInt, return_this);
 
 def_eval(AST_RegExp, function (compressor) {
     let evaluated = compressor.evaluated_regexps.get(this.value);
-    if (evaluated === undefined) {
+    if (evaluated === undefined && regexp_is_safe(this.value.source)) {
         try {
             const { source, flags } = this.value;
             evaluated = new RegExp(source, flags);
diff --git a/lib/compress/index.js b/lib/compress/index.js
index 1f7529c41..651b44064 100644
--- a/lib/compress/index.js
+++ b/lib/compress/index.js
@@ -158,6 +158,7 @@ import {
     return_true,
     regexp_source_fix,
     has_annotation,
+    regexp_is_safe,
 } from "../utils/index.js";
 import { first_in_statement } from "../utils/first_in_statement.js";
 import { equivalent_to } from "../equivalent-to.js";
@@ -2140,6 +2141,7 @@ def_optimize(AST_Call, function(self, compressor) {
                     params.push(value);
                     return arg !== value;
                 })
+                && regexp_is_safe(params[0])
             ) {
                 let [ source, flags ] = params;
                 source = regexp_source_fix(new RegExp(source).source);
diff --git a/lib/utils/index.js b/lib/utils/index.js
index df8646460..3a995c2e4 100644
--- a/lib/utils/index.js
+++ b/lib/utils/index.js
@@ -249,7 +249,15 @@ function regexp_source_fix(source) {
         return (escaped ? "" : "\\") + lineTerminatorEscape[match];
     });
 }
-const all_flags = "gimuy";
+
+// Subset of regexps that is not going to cause regexp based DDOS
+// https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS
+const re_safe_regexp = /^[\\/|\0\s\w^$.[\]()]*$/;
+
+/** Check if the regexp is safe for Terser to create without risking a RegExp DOS */
+export const regexp_is_safe = (source) => re_safe_regexp.test(source);
+
+const all_flags = "dgimsuy";
 function sort_regexp_flags(flags) {
     const existing_flags = new Set(flags.split(""));
     let out = "";
diff --git a/test/compress/regexp.js b/test/compress/regexp.js
index fe01fb8bc..af31aaa85 100644
--- a/test/compress/regexp.js
+++ b/test/compress/regexp.js
@@ -30,10 +30,10 @@ regexp_2: {
         unsafe: true,
     }
     input: {
-        console.log(JSON.stringify("COMPASS? Overpass.".match(new RegExp("([Sap]+)", "ig"))));
+        console.log(JSON.stringify("COMPASS? Overpass.".match(new RegExp("(pass)", "ig"))));
     }
     expect: {
-        console.log(JSON.stringify("COMPASS? Overpass.".match(/([Sap]+)/gi)));
+        console.log(JSON.stringify("COMPASS? Overpass.".match(/(pass)/gi)));
     }
     expect_stdout: '["PASS","pass"]'
 }
@@ -44,10 +44,10 @@ unsafe_slashes: {
         unsafe: true
     }
     input: {
-        console.log(new RegExp("^https://"))
+        console.log(new RegExp("^https//"))
     }
     expect: {
-        console.log(/^https:\/\//)
+        console.log(/^https\/\//)
     }
 }
 unsafe_nul_byte: {
@@ -75,3 +75,16 @@ inline_script: {
     }
     expect_exact: '/* <\\/script> */\n/[<\\/script>]/;'
 }
+
+regexp_no_ddos: {
+    options = { unsafe: true, evaluate: true }
+    input: {
+        console.log(/(b+)b+/.test("bbb"))
+        console.log(RegExp("(b+)b+").test("bbb"))
+    }
+    expect: {
+        console.log(/(b+)b+/.test("bbb"))
+        console.log(RegExp("(b+)b+").test("bbb"))
+    }
+    expect_stdout: ["true", "true"]
+}
