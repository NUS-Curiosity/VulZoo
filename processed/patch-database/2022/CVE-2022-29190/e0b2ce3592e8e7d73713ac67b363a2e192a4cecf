diff --git a/fragment_buffer.go b/fragment_buffer.go
index 02749939..8a00ee7e 100644
--- a/fragment_buffer.go
+++ b/fragment_buffer.go
@@ -76,7 +76,7 @@ func (f *fragmentBuffer) pop() (content []byte, epoch uint16) {
 		for _, f := range frags {
 			if f.handshakeHeader.FragmentOffset == targetOffset {
 				fragmentEnd := (f.handshakeHeader.FragmentOffset + f.handshakeHeader.FragmentLength)
-				if fragmentEnd != f.handshakeHeader.Length {
+				if fragmentEnd != f.handshakeHeader.Length && f.handshakeHeader.FragmentLength != 0 {
 					if !appendMessage(fragmentEnd) {
 						return false
 					}
diff --git a/fragment_buffer_test.go b/fragment_buffer_test.go
index 62c7ead3..0f49c758 100644
--- a/fragment_buffer_test.go
+++ b/fragment_buffer_test.go
@@ -73,6 +73,20 @@ func TestFragmentBuffer(t *testing.T) {
 			},
 			Epoch: 0,
 		},
+		// Assert that a zero length fragment doesn't cause the fragmentBuffer to enter an infinite loop
+		{
+			Name: "Zero Length Fragment",
+			In: [][]byte{
+				{
+					0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00,
+					0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+				},
+			},
+			Expected: [][]byte{
+				{0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00},
+			},
+			Epoch: 0,
+		},
 	} {
 		fragmentBuffer := newFragmentBuffer()
 		for _, frag := range test.In {
