diff --git a/package.json b/package.json
index db5718ed..da9c677f 100644
--- a/package.json
+++ b/package.json
@@ -12,7 +12,7 @@
     "package_name": "{node_abi}-{platform}-{arch}.tar.gz"
   },
   "description": "libxml bindings for v8 javascript engine",
-  "version": "0.19.7",
+  "version": "0.19.8",
   "scripts": {
     "install": "node-pre-gyp install --fallback-to-build --loglevel http",
     "test": "node --expose_gc ./node_modules/.bin/nodeunit test"
@@ -38,4 +38,4 @@
     "nodeunit": "~0.11.2",
     "semver": "~5.5.0"
   }
-}
+}
\ No newline at end of file
diff --git a/src/xml_document.cc b/src/xml_document.cc
index cb281e2b..8e4f8251 100644
--- a/src/xml_document.cc
+++ b/src/xml_document.cc
@@ -375,16 +375,18 @@ NAN_METHOD(XmlDocument::FromHtml)
         opts |= HTML_PARSE_NOIMPLIED | HTML_PARSE_NODEFDTD;
 
     htmlDocPtr doc;
-    if (!node::Buffer::HasInstance(info[0])) {
+    if (info[0]->IsString()) {
         // Parse a string
         Nan::Utf8String str(Nan::To<v8::String>(info[0]).ToLocalChecked());
         doc = htmlReadMemory(*str, str.length(), baseUrl, encoding, opts);
     }
-    else {
+    else if (node::Buffer::HasInstance(info[0])) {
         // Parse a buffer
         v8::Local<v8::Object> buf = Nan::To<v8::Object>(info[0]).ToLocalChecked();
         doc = htmlReadMemory(node::Buffer::Data(buf), node::Buffer::Length(buf),
                             baseUrl, encoding, opts);
+    } else {
+        return Nan::ThrowError("XML must be a string or buffer");
     }
 
     xmlSetStructuredErrorFunc(NULL, NULL);
@@ -439,16 +441,18 @@ NAN_METHOD(XmlDocument::FromXml)
 
     int opts = (int) getParserOptions(options);
     xmlDocPtr doc;
-    if (!node::Buffer::HasInstance(info[0])) {
+    if (info[0]->IsString()) {
       // Parse a string
       Nan::Utf8String str(Nan::To<v8::String>(info[0]).ToLocalChecked());
       doc = xmlReadMemory(*str, str.length(), baseUrl, "UTF-8", opts);
     }
-    else {
+    else if (node::Buffer::HasInstance(info[0])) {
       // Parse a buffer
       v8::Local<v8::Object> buf = Nan::To<v8::Object>(info[0]).ToLocalChecked();
       doc = xmlReadMemory(node::Buffer::Data(buf), node::Buffer::Length(buf),
                           baseUrl, encoding, opts);
+    } else {
+        return Nan::ThrowError("XML must be a string or buffer");
     }
 
     xmlSetStructuredErrorFunc(NULL, NULL);
diff --git a/test/html_parser.js b/test/html_parser.js
index 15261232..bde64eab 100644
--- a/test/html_parser.js
+++ b/test/html_parser.js
@@ -32,6 +32,17 @@ module.exports.parse = function(assert) {
     assert.done();
 };
 
+module.exports.invalid_input = function(assert) {
+    try {
+        libxml.parseHtml({object: true});
+        assert.ok(false);
+    } catch(err) {
+        assert.ok(true)
+    }
+
+    assert.done();
+};
+
 // Although libxml defaults to a utf-8 encoding, if not specifically specified
 // it will guess the encoding based on meta http-equiv tags available
 // This test shows that the "guessed" encoding can be overridden
diff --git a/test/xml_parser.js b/test/xml_parser.js
index e7ea8312..ca4bb60e 100644
--- a/test/xml_parser.js
+++ b/test/xml_parser.js
@@ -21,6 +21,17 @@ module.exports.parse = function(assert) {
     assert.done();
 };
 
+module.exports.invalid_input = function(assert) {
+    try {
+        libxml.parseXml({object: true});
+        assert.ok(false);
+    } catch(err) {
+        assert.ok(true)
+    }
+
+    assert.done();
+};
+
 module.exports.parse_buffer = function(assert) {
     var filename = __dirname + '/fixtures/parser-utf16.xml';
     var buf = fs.readFileSync(filename);
