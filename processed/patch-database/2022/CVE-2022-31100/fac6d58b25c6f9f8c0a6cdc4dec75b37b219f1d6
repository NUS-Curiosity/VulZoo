diff --git a/rulex-lib/src/parse/parsers.rs b/rulex-lib/src/parse/parsers.rs
index 7d14d3d..116012c 100644
--- a/rulex-lib/src/parse/parsers.rs
+++ b/rulex-lib/src/parse/parsers.rs
@@ -594,26 +594,33 @@ fn parse_quoted_text(input: &str) -> Result<Cow<'_, str>, ParseErrorKind> {
 
             loop {
                 let mut chars = s.chars();
+                let char_len;
                 match chars.next() {
-                    Some('\\') => match chars.next() {
-                        Some('\\') => {
-                            buf.push('\\');
-                            s = &s[1..];
+                    Some('\\') => {
+                        char_len = 1;
+                        match chars.next() {
+                            Some('\\') => {
+                                buf.push('\\');
+                                s = &s[1..];
+                            }
+                            Some('"') => {
+                                buf.push('"');
+                                s = &s[1..];
+                            }
+                            _ => {
+                                return Err(ParseErrorKind::InvalidEscapeInStringAt(
+                                    input.len() - s.len(),
+                                ));
+                            }
                         }
-                        Some('"') => {
-                            buf.push('"');
-                            s = &s[1..];
-                        }
-                        _ => {
-                            return Err(ParseErrorKind::InvalidEscapeInStringAt(
-                                input.len() - s.len(),
-                            ));
-                        }
-                    },
-                    Some(c) => buf.push(c),
+                    }
+                    Some(c) => {
+                        char_len = c.len_utf8();
+                        buf.push(c)
+                    }
                     None => break,
                 }
-                s = &s[1..];
+                s = &s[char_len..];
             }
             Cow::Owned(buf)
         }
diff --git a/rulex-lib/src/parse/tokenize.rs b/rulex-lib/src/parse/tokenize.rs
index 36de633..ec1d2e6 100644
--- a/rulex-lib/src/parse/tokenize.rs
+++ b/rulex-lib/src/parse/tokenize.rs
@@ -161,8 +161,8 @@ pub(crate) fn tokenize(mut input: &str) -> Vec<(Token, Span)> {
                                 Some(len) => (len + 4, Token::ErrorMsg(ParseErrorMsg::BackslashK)),
                                 _ => (2, Token::ErrorMsg(ParseErrorMsg::Backslash)),
                             }
-                        } else if input.len() >= 2 {
-                            (2, Token::ErrorMsg(ParseErrorMsg::Backslash))
+                        } else if let Some(next) = input.chars().nth(1) {
+                            (1 + next.len_utf8(), Token::ErrorMsg(ParseErrorMsg::Backslash))
                         } else {
                             (1, Token::Error)
                         }
diff --git a/rulex-lib/tests/testcases/basics/6.txt b/rulex-lib/tests/testcases/basics/6.txt
new file mode 100644
index 0000000..c7955bc
--- /dev/null
+++ b/rulex-lib/tests/testcases/basics/6.txt
@@ -0,0 +1,5 @@
+# unicode strings
+
+'√§ ≈¶ ü§¶üèº‚Äç‚ôÇÔ∏è'
+-----
+\xE4 ≈¶ \x{1F926}\x{1F3FC}\x{200D}\x{2642}\x{FE0F}
\ No newline at end of file
diff --git a/rulex-lib/tests/testcases/basics/7.txt b/rulex-lib/tests/testcases/basics/7.txt
new file mode 100644
index 0000000..8d7e7b8
--- /dev/null
+++ b/rulex-lib/tests/testcases/basics/7.txt
@@ -0,0 +1,7 @@
+#! expect=error
+# this mustn't panic when tokenizing
+
+C ÿæ\ ÿæ \u{ÿæ} U+ÿæ Uÿæ' ÿæ'
+-----
+ERROR: Backslash escapes are not supported
+SPAN: 42..44
\ No newline at end of file
