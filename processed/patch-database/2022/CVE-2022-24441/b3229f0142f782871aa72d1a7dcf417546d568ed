diff --git a/.goreleaser.yaml b/.goreleaser.yaml
index 3b689dfa0..3e1d7d3d3 100644
--- a/.goreleaser.yaml
+++ b/.goreleaser.yaml
@@ -60,4 +60,4 @@ dist: build
 env:
   - GO111MODULE=on
   - CGO_ENABLED=0
-  - LS_PROTOCOL_VERSION=3
+  - LS_PROTOCOL_VERSION=4
diff --git a/Makefile b/Makefile
index 502543102..c670d755c 100644
--- a/Makefile
+++ b/Makefile
@@ -37,7 +37,7 @@ tools:
 	@echo "==> Installing go-licenses"
 	@go install github.com/google/go-licenses@latest
 ifeq (,$(wildcard ./.bin/golangci-lint*))
-	@curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s -- -b .bin/ v1.48.0
+	@curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s -- -b .bin/ v1.50.0
 else
 	@echo "==> golangci-lint is already installed"
 endif
diff --git a/README.md b/README.md
index 20a9e2438..3134ed5e5 100644
--- a/README.md
+++ b/README.md
@@ -75,6 +75,15 @@ Right now the language server supports the following actions:
   }
   ```
 
+- Trust Notification
+  - method: `$/snyk.addTrustedFolders`
+  - payload:
+  ```json
+  {
+    "trustedFolders": ["/a/path/to/trust"]
+  }
+  ```
+
 ## Installation
 
 ### Download
@@ -132,12 +141,37 @@ within `initializationOptions?: LSPAny;` we support the following settings:
   "organization": "a string", // The name of your organization, e.g. the output of: curl -H "Authorization: token $(snyk config get api)"  https://snyk.io/api/cli-config/settings/sast | jq .org
   "enableTelemetry":  "true", // Whether or not user analytics can be tracked
   "manageBinariesAutomatically": "true", // Whether or not CLI/LS binaries will be downloaded & updated automatically
-  "cliPath":  "/a/patch/snyk-cli" // The path where the CLI can be found, or where it should be downloaded to
-  "token":  "secret-token" // The Snyk token, e.g.: snyk config get api
-  "automaticAuthentication": "true" // Whether or not LS will automatically authenticate on scan start (default: true)
+  "cliPath":  "/a/patch/snyk-cli", // The path where the CLI can be found, or where it should be downloaded to
+  "token":  "secret-token", // The Snyk token, e.g.: snyk config get api
+  "automaticAuthentication": "true", // Whether or not LS will automatically authenticate on scan start (default: true)
+  "enableTrustedFoldersFeature": "true", // Whether or not LS will prompt to trust a folder (default: true)
+  "trustedFolders": ["/a/trusted/path", "/another/trusted/path"], // An array of folder that should be trusted
 }
 ```
 
+#### Workspace Trust
+
+As part of examining the codebase for vulnerabilities, Snyk may automatically execute code on your computer to obtain
+additional data for analysis. For example, this includes invoking the package manager (e.g., pip, gradle, maven, yarn,
+npm, etc.)
+to get dependency information for Snyk Open Source. Invoking these programs on untrusted code that has malicious
+configurations may expose your system to malicious code execution and exploits.
+
+To safeguard from using the language server on untrusted folders, our language server will ask for folder trust
+before running scans against these folders. When in doubt, do not grant trust.
+
+The trust feature is enabled by default. When a folder is trusted, all sub-folders are also trusted. After a folder
+is trusted, Snyk Language Server notifies the Language Server Client with the custom `$/snyk.addTrustedFolders`
+notification,
+which contains a list of currently trusted folder paths. Based on this, a client can then implement logic to intercept
+this notification and persist the decision and trust in the IDE or Editor storage mechanism.
+
+Trust dialogs can be disabled by setting `enableTrustedFoldersFeature` to `false` in the initialization options. This
+will disable all trust prompts and checks.
+
+An initial set of trusted folders can be provided by setting `trustedFolders` to an array of paths in the
+`initializationOptions`. These folders will be trusted on startup and will not prompt the user to trust them.
+
 #### Environment variables
 
 Snyk LS and Snyk CLI support and need certain environment variables to function:
diff --git a/application/config/config.go b/application/config/config.go
index 38df763b9..c47f9ad10 100644
--- a/application/config/config.go
+++ b/application/config/config.go
@@ -119,33 +119,35 @@ func (c *CliSettings) DefaultBinaryInstallPath() string {
 }
 
 type Config struct {
-	configLoaded                concurrency.AtomicBool
-	cliSettings                 *CliSettings
-	configFile                  string
-	format                      string
-	isErrorReportingEnabled     concurrency.AtomicBool
-	isSnykCodeEnabled           concurrency.AtomicBool
-	isSnykOssEnabled            concurrency.AtomicBool
-	isSnykIacEnabled            concurrency.AtomicBool
-	isSnykContainerEnabled      concurrency.AtomicBool
-	isSnykAdvisorEnabled        concurrency.AtomicBool
-	isTelemetryEnabled          concurrency.AtomicBool
-	manageBinariesAutomatically concurrency.AtomicBool
-	logPath                     string
-	organization                string
-	snykCodeAnalysisTimeout     time.Duration
-	snykApiUrl                  string
-	snykCodeApiUrl              string
-	token                       string
-	deviceId                    string
-	clientCapabilities          lsp.ClientCapabilities
-	m                           sync.Mutex
-	path                        string
-	defaultDirs                 []string
-	integrationName             string
-	integrationVersion          string
-	automaticAuthentication     bool
-	tokenChangeChannels         []chan string
+	configLoaded                 concurrency.AtomicBool
+	cliSettings                  *CliSettings
+	configFile                   string
+	format                       string
+	isErrorReportingEnabled      concurrency.AtomicBool
+	isSnykCodeEnabled            concurrency.AtomicBool
+	isSnykOssEnabled             concurrency.AtomicBool
+	isSnykIacEnabled             concurrency.AtomicBool
+	isSnykContainerEnabled       concurrency.AtomicBool
+	isSnykAdvisorEnabled         concurrency.AtomicBool
+	isTelemetryEnabled           concurrency.AtomicBool
+	manageBinariesAutomatically  concurrency.AtomicBool
+	logPath                      string
+	organization                 string
+	snykCodeAnalysisTimeout      time.Duration
+	snykApiUrl                   string
+	snykCodeApiUrl               string
+	token                        string
+	deviceId                     string
+	clientCapabilities           lsp.ClientCapabilities
+	m                            sync.Mutex
+	path                         string
+	defaultDirs                  []string
+	integrationName              string
+	integrationVersion           string
+	automaticAuthentication      bool
+	tokenChangeChannels          []chan string
+	trustedFolders               []string
+	trustedFoldersFeatureEnabled bool
 }
 
 func CurrentConfig() *Config {
@@ -185,6 +187,7 @@ func New() *Config {
 	c.snykCodeApiUrl = defaultDeeproxyApiUrl
 	c.snykCodeAnalysisTimeout = snykCodeAnalysisTimeoutFromEnv()
 	c.token = ""
+	c.trustedFoldersFeatureEnabled = true
 	c.clientSettingsFromEnv()
 	c.deviceId = c.determineDeviceId()
 	c.addDefaults()
@@ -211,6 +214,16 @@ func (c *Config) determineDeviceId() string {
 	}
 }
 
+func (c *Config) IsTrustedFolderFeatureEnabled() bool {
+	return c.trustedFoldersFeatureEnabled
+}
+
+func (c *Config) SetTrustedFolderFeatureEnabled(enabled bool) {
+	c.m.Lock()
+	defer c.m.Unlock()
+	c.trustedFoldersFeatureEnabled = enabled
+}
+
 func (c *Config) Load() {
 	files := c.configFiles()
 	for _, fileName := range files {
@@ -538,3 +551,15 @@ func (c *Config) SetIntegrationName(integrationName string) {
 func (c *Config) SetIntegrationVersion(integrationVersion string) {
 	c.integrationVersion = integrationVersion
 }
+
+func (c *Config) TrustedFolders() []string {
+	c.m.Lock()
+	defer c.m.Unlock()
+	return c.trustedFolders
+}
+
+func (c *Config) SetTrustedFolders(folderPaths []string) {
+	c.m.Lock()
+	defer c.m.Unlock()
+	c.trustedFolders = folderPaths
+}
diff --git a/application/config/config_test.go b/application/config/config_test.go
index c6b283042..1be26f94d 100644
--- a/application/config/config_test.go
+++ b/application/config/config_test.go
@@ -45,6 +45,7 @@ func TestConfigDefaults(t *testing.T) {
 	assert.True(t, c.IsSnykIacEnabled(), "Snyk IaC should be enabled by default")
 	assert.Equal(t, "", c.LogPath(), "Logpath should be empty by default")
 	assert.Equal(t, "md", c.Format(), "Output format should be md by default")
+	assert.Empty(t, c.trustedFolders)
 }
 
 func Test_TokenChanged_ChannelsInformed(t *testing.T) {
diff --git a/application/server/configuration.go b/application/server/configuration.go
index ae7b7588b..deade6615 100644
--- a/application/server/configuration.go
+++ b/application/server/configuration.go
@@ -19,6 +19,7 @@ package server
 import (
 	"context"
 	"os"
+	"reflect"
 	"strconv"
 	"strings"
 
@@ -37,7 +38,7 @@ func WorkspaceDidChangeConfiguration(srv *jrpc2.Server) jrpc2.Handler {
 		defer log.Info().Str("method", "WorkspaceDidChangeConfiguration").Interface("params", params).Msg("DONE")
 
 		emptySettings := lsp.Settings{}
-		if params.Settings != emptySettings {
+		if !reflect.DeepEqual(params.Settings, emptySettings) {
 			// client used settings push
 			UpdateSettings(ctx, params.Settings)
 			return true, nil
@@ -65,7 +66,7 @@ func WorkspaceDidChangeConfiguration(srv *jrpc2.Server) jrpc2.Handler {
 			return false, err
 		}
 
-		if fetchedSettings[0] != emptySettings {
+		if !reflect.DeepEqual(fetchedSettings[0], emptySettings) {
 			UpdateSettings(ctx, fetchedSettings[0])
 			return true, nil
 		}
@@ -86,7 +87,7 @@ func UpdateSettings(ctx context.Context, settings lsp.Settings) {
 
 func writeSettings(ctx context.Context, settings lsp.Settings, initialize bool) {
 	emptySettings := lsp.Settings{}
-	if settings == emptySettings {
+	if reflect.DeepEqual(settings, emptySettings) {
 		return
 	}
 	updateToken(settings.Token)
@@ -98,6 +99,20 @@ func writeSettings(ctx context.Context, settings lsp.Settings, initialize bool)
 	updateTelemetry(settings)
 	updateOrganization(settings)
 	manageBinariesAutomatically(settings)
+	updateTrustedFolders(settings)
+}
+
+func updateTrustedFolders(settings lsp.Settings) {
+	trustedFoldersFeatureEnabled, err := strconv.ParseBool(settings.EnableTrustedFoldersFeature)
+	if err == nil {
+		config.CurrentConfig().SetTrustedFolderFeatureEnabled(trustedFoldersFeatureEnabled)
+	} else {
+		config.CurrentConfig().SetTrustedFolderFeatureEnabled(true)
+	}
+
+	if settings.TrustedFolders != nil {
+		config.CurrentConfig().SetTrustedFolders(settings.TrustedFolders)
+	}
 }
 
 func updateAutoAuthentication(settings lsp.Settings) {
diff --git a/application/server/configuration_test.go b/application/server/configuration_test.go
index d31d3fe4b..6f3da8560 100644
--- a/application/server/configuration_test.go
+++ b/application/server/configuration_test.go
@@ -71,7 +71,7 @@ func Test_WorkspaceDidChangeConfiguration_Push(t *testing.T) {
 	assert.Equal(t, "token", config.CurrentConfig().Token())
 }
 
-func callBackMock(ctx context.Context, request *jrpc2.Request) (interface{}, error) {
+func callBackMock(_ context.Context, request *jrpc2.Request) (interface{}, error) {
 	jsonRPCRecorder.Record(*request)
 	if request.Method() == "workspace/configuration" {
 		return []lsp.Settings{sampleSettings}, nil
@@ -151,6 +151,7 @@ func Test_UpdateSettings(t *testing.T) {
 			ManageBinariesAutomatically: "false",
 			CliPath:                     "C:\\Users\\CliPath\\snyk-ls.exe",
 			Token:                       "a fancy token",
+			TrustedFolders:              []string{"trustedPath1", "trustedPath2"},
 		}
 
 		UpdateSettings(context.Background(), settings)
@@ -171,6 +172,8 @@ func Test_UpdateSettings(t *testing.T) {
 		assert.False(t, c.ManageBinariesAutomatically())
 		assert.Equal(t, "C:\\Users\\CliPath\\snyk-ls.exe", c.CliSettings().Path())
 		assert.Equal(t, "a fancy token", c.Token())
+		assert.Contains(t, c.TrustedFolders(), "trustedPath1")
+		assert.Contains(t, c.TrustedFolders(), "trustedPath2")
 	})
 
 	t.Run("blank organisation is ignored", func(t *testing.T) {
@@ -209,6 +212,15 @@ func Test_UpdateSettings(t *testing.T) {
 		assert.Empty(t, os.Getenv("b"))
 		assert.Empty(t, os.Getenv(";"))
 	})
+	t.Run("trusted folders", func(t *testing.T) {
+		config.SetCurrentConfig(config.New())
+
+		UpdateSettings(context.Background(), lsp.Settings{TrustedFolders: []string{"/a/b", "/b/c"}})
+
+		c := config.CurrentConfig()
+		assert.Contains(t, c.TrustedFolders(), "/a/b")
+		assert.Contains(t, c.TrustedFolders(), "/b/c")
+	})
 
 	t.Run("manage binaries automatically", func(t *testing.T) {
 		t.Run("true", func(t *testing.T) {
diff --git a/application/server/execute_command.go b/application/server/execute_command.go
index a017a26b1..fa78baa3b 100644
--- a/application/server/execute_command.go
+++ b/application/server/execute_command.go
@@ -25,7 +25,9 @@ import (
 	"github.com/rs/zerolog/log"
 	sglsp "github.com/sourcegraph/go-lsp"
 
+	"github.com/snyk/snyk-ls/application/config"
 	"github.com/snyk/snyk-ls/application/di"
+	"github.com/snyk/snyk-ls/application/server/lsp"
 	"github.com/snyk/snyk-ls/domain/ide/command"
 	"github.com/snyk/snyk-ls/domain/ide/workspace"
 	"github.com/snyk/snyk-ls/domain/snyk"
@@ -49,10 +51,18 @@ func ExecuteCommandHandler(srv *jrpc2.Server) jrpc2.Handler {
 			}
 			navigateToLocation(srv, args)
 		case snyk.WorkspaceScanCommand:
-			workspace.Get().ClearIssues(bgCtx)
-			workspace.Get().ScanWorkspace(bgCtx)
+			w := workspace.Get()
+			w.ClearIssues(bgCtx)
+			w.ScanWorkspace(bgCtx)
+			handleUntrustedFolders(bgCtx, srv)
 		case snyk.OpenBrowserCommand:
 			command.OpenBrowser(params.Arguments[0].(string))
+		case snyk.TrustWorkspaceFoldersCommand:
+			err := TrustWorkspaceFolders()
+			if err != nil {
+				log.Err(err).Msgf("Error on %s command", snyk.TrustWorkspaceFoldersCommand)
+				notification.SendError(err)
+			}
 		case snyk.LoginCommand:
 			authenticator := di.Authenticator()
 			_, err := authenticator.Authenticate(context.Background())
@@ -75,3 +85,19 @@ func ExecuteCommandHandler(srv *jrpc2.Server) jrpc2.Handler {
 		return nil, nil
 	})
 }
+
+func TrustWorkspaceFolders() error {
+	if !config.CurrentConfig().IsTrustedFolderFeatureEnabled() {
+		return nil
+	}
+
+	trustedFolderPaths := config.CurrentConfig().TrustedFolders()
+	_, untrusted := workspace.Get().GetFolderTrust()
+	for _, folder := range untrusted {
+		trustedFolderPaths = append(trustedFolderPaths, folder.Path())
+	}
+
+	config.CurrentConfig().SetTrustedFolders(trustedFolderPaths)
+	notification.Send(lsp.SnykTrustedFoldersParams{TrustedFolders: trustedFolderPaths})
+	return nil
+}
diff --git a/application/server/execute_command_test.go b/application/server/execute_command_test.go
index 28c4a4e65..7afb5ec27 100644
--- a/application/server/execute_command_test.go
+++ b/application/server/execute_command_test.go
@@ -25,6 +25,7 @@ import (
 
 	"github.com/atotto/clipboard"
 
+	"github.com/snyk/snyk-ls/application/config"
 	"github.com/snyk/snyk-ls/application/di"
 	"github.com/snyk/snyk-ls/domain/ide/workspace"
 	"github.com/snyk/snyk-ls/domain/snyk"
@@ -47,6 +48,24 @@ func Test_executeWorkspaceScanCommand_shouldStartWorkspaceScanOnCommandReceipt(t
 	}, 2*time.Second, time.Millisecond)
 }
 
+func Test_executeWorkspaceScanCommand_shouldAskForTrust(t *testing.T) {
+	loc := setupServer(t)
+
+	scanner := &snyk.TestScanner{}
+	workspace.Get().AddFolder(workspace.NewFolder("dummy", "dummy", scanner, di.HoverService()))
+	// explicitly enable folder trust which is disabled by default in tests
+	config.CurrentConfig().SetTrustedFolderFeatureEnabled(true)
+
+	params := lsp.ExecuteCommandParams{Command: snyk.WorkspaceScanCommand}
+	_, err := loc.Client.Call(ctx, "workspace/executeCommand", params)
+	if err != nil {
+		t.Fatal(err)
+	}
+	assert.Eventually(t, func() bool {
+		return scanner.Calls() == 0 && checkTrustMessageRequest()
+	}, 2*time.Second, time.Millisecond)
+}
+
 func Test_loginCommand_StartsAuthentication(t *testing.T) {
 	// Arrange
 	loc := setupServer(t)
@@ -84,3 +103,50 @@ func Test_executeCommand_shouldCopyAuthURLToClipboard(t *testing.T) {
 
 	assert.Equal(t, authenticationMock.ExpectedAuthURL, actualURL)
 }
+
+func Test_TrustWorkspaceFolders(t *testing.T) {
+	t.Run("Doesn't mutate trusted folders, if trusted folders disabled", func(t *testing.T) {
+		loc := setupServer(t)
+		workspace.Get().AddFolder(workspace.NewFolder("/path/to/folder1", "dummy", nil, di.HoverService()))
+
+		params := lsp.ExecuteCommandParams{Command: snyk.TrustWorkspaceFoldersCommand}
+		_, err := loc.Client.Call(ctx, "workspace/executeCommand", params)
+		if err != nil {
+			t.Fatal(err)
+		}
+
+		assert.Len(t, config.CurrentConfig().TrustedFolders(), 0)
+	})
+
+	t.Run("Updates trusted workspace folders", func(t *testing.T) {
+		loc := setupServer(t)
+		workspace.Get().AddFolder(workspace.NewFolder("/path/to/folder1", "dummy", nil, di.HoverService()))
+		workspace.Get().AddFolder(workspace.NewFolder("/path/to/folder2", "dummy", nil, di.HoverService()))
+		config.CurrentConfig().SetTrustedFolderFeatureEnabled(true)
+
+		params := lsp.ExecuteCommandParams{Command: snyk.TrustWorkspaceFoldersCommand}
+		_, err := loc.Client.Call(ctx, "workspace/executeCommand", params)
+		if err != nil {
+			t.Fatal(err)
+		}
+
+		assert.Len(t, config.CurrentConfig().TrustedFolders(), 2)
+		assert.Contains(t, config.CurrentConfig().TrustedFolders(), "/path/to/folder1", "/path/to/folder2")
+	})
+
+	t.Run("Existing trusted workspace folders are not removed", func(t *testing.T) {
+		loc := setupServer(t)
+		workspace.Get().AddFolder(workspace.NewFolder("/path/to/folder1", "dummy", nil, di.HoverService()))
+		config.CurrentConfig().SetTrustedFolderFeatureEnabled(true)
+		config.CurrentConfig().SetTrustedFolders([]string{"/path/to/folder2"})
+
+		params := lsp.ExecuteCommandParams{Command: snyk.TrustWorkspaceFoldersCommand}
+		_, err := loc.Client.Call(ctx, "workspace/executeCommand", params)
+		if err != nil {
+			t.Fatal(err)
+		}
+
+		assert.Len(t, config.CurrentConfig().TrustedFolders(), 2)
+		assert.Contains(t, config.CurrentConfig().TrustedFolders(), "/path/to/folder1", "/path/to/folder2")
+	})
+}
diff --git a/application/server/lsp/message_types.go b/application/server/lsp/message_types.go
index ccd3308ae..0bffff3dc 100644
--- a/application/server/lsp/message_types.go
+++ b/application/server/lsp/message_types.go
@@ -233,24 +233,26 @@ type WorkspaceFoldersChangeEvent struct {
 
 // Settings is the struct that is parsed from the InitializationParams.InitializationOptions field
 type Settings struct {
-	ActivateSnykOpenSource      string `json:"activateSnykOpenSource,omitempty"`
-	ActivateSnykCode            string `json:"activateSnykCode,omitempty"`
-	ActivateSnykIac             string `json:"activateSnykIac,omitempty"`
-	Insecure                    string `json:"insecure,omitempty"`
-	Endpoint                    string `json:"endpoint,omitempty"`
-	AdditionalParams            string `json:"additionalParams,omitempty"`
-	AdditionalEnv               string `json:"additionalEnv,omitempty"`
-	Path                        string `json:"path,omitempty"`
-	SendErrorReports            string `json:"sendErrorReports,omitempty"`
-	Organization                string `json:"organization,omitempty"`
-	EnableTelemetry             string `json:"enableTelemetry,omitempty"`
-	ManageBinariesAutomatically string `json:"manageBinariesAutomatically,omitempty"`
-	CliPath                     string `json:"cliPath,omitempty"`
-	Token                       string `json:"token,omitempty"`
-	IntegrationName             string `json:"integrationName,omitempty"`
-	IntegrationVersion          string `json:"integrationVersion,omitempty"`
-	AutomaticAuthentication     string `json:"automaticAuthentication,omitempty"`
-	DeviceId                    string `json:"deviceId,omitempty"`
+	ActivateSnykOpenSource      string   `json:"activateSnykOpenSource,omitempty"`
+	ActivateSnykCode            string   `json:"activateSnykCode,omitempty"`
+	ActivateSnykIac             string   `json:"activateSnykIac,omitempty"`
+	Insecure                    string   `json:"insecure,omitempty"`
+	Endpoint                    string   `json:"endpoint,omitempty"`
+	AdditionalParams            string   `json:"additionalParams,omitempty"`
+	AdditionalEnv               string   `json:"additionalEnv,omitempty"`
+	Path                        string   `json:"path,omitempty"`
+	SendErrorReports            string   `json:"sendErrorReports,omitempty"`
+	Organization                string   `json:"organization,omitempty"`
+	EnableTelemetry             string   `json:"enableTelemetry,omitempty"`
+	ManageBinariesAutomatically string   `json:"manageBinariesAutomatically,omitempty"`
+	CliPath                     string   `json:"cliPath,omitempty"`
+	Token                       string   `json:"token,omitempty"`
+	IntegrationName             string   `json:"integrationName,omitempty"`
+	IntegrationVersion          string   `json:"integrationVersion,omitempty"`
+	AutomaticAuthentication     string   `json:"automaticAuthentication,omitempty"`
+	DeviceId                    string   `json:"deviceId,omitempty"`
+	EnableTrustedFoldersFeature string   `json:"enableTrustedFoldersFeature,omitempty"`
+	TrustedFolders              []string `json:"trustedFolders,omitempty"`
 }
 
 type DidChangeConfigurationParams struct {
@@ -607,3 +609,24 @@ type ShowDocumentParams struct {
 	 */
 	Selection sglsp.Range `json:"selection"`
 }
+
+type MessageActionItem struct {
+	Title string `json:"title"`
+}
+
+type ShowMessageRequestParams struct {
+	Type    MessageType         `json:"type"`
+	Message string              `json:"message"`
+	Actions []MessageActionItem `json:"actions"`
+}
+
+type MessageType int
+
+const Error MessageType = 1
+const Warning MessageType = 2
+const Info MessageType = 3
+const Log MessageType = 4
+
+type SnykTrustedFoldersParams struct {
+	TrustedFolders []string `json:"trustedFolders"`
+}
diff --git a/application/server/server.go b/application/server/server.go
index c46f1f82f..31012c657 100644
--- a/application/server/server.go
+++ b/application/server/server.go
@@ -90,7 +90,7 @@ func initHandlers(srv *jrpc2.Server, handlers *handler.Map) {
 	(*handlers)["textDocument/willSaveWaitUntil"] = NoOpHandler()
 	(*handlers)["shutdown"] = Shutdown()
 	(*handlers)["exit"] = Exit(srv)
-	(*handlers)["workspace/didChangeWorkspaceFolders"] = WorkspaceDidChangeWorkspaceFoldersHandler()
+	(*handlers)["workspace/didChangeWorkspaceFolders"] = WorkspaceDidChangeWorkspaceFoldersHandler(srv)
 	(*handlers)["workspace/didChangeConfiguration"] = WorkspaceDidChangeConfiguration(srv)
 	(*handlers)["window/workDoneProgress/cancel"] = WindowWorkDoneProgressCancelHandler()
 	(*handlers)["workspace/executeCommand"] = ExecuteCommandHandler(srv)
@@ -145,7 +145,7 @@ func CodeActionHandler() jrpc2.Handler {
 	})
 }
 
-func WorkspaceDidChangeWorkspaceFoldersHandler() jrpc2.Handler {
+func WorkspaceDidChangeWorkspaceFoldersHandler(srv *jrpc2.Server) jrpc2.Handler {
 	return handler.New(func(ctx context.Context, params lsp.DidChangeWorkspaceFoldersParams) (interface{}, error) {
 		// The context provided by the JSON-RPC server is cancelled once a new message is being processed,
 		// so we don't want to propagate it to functions that start background operations
@@ -153,7 +153,8 @@ func WorkspaceDidChangeWorkspaceFoldersHandler() jrpc2.Handler {
 
 		log.Info().Str("method", "WorkspaceDidChangeWorkspaceFoldersHandler").Msg("RECEIVING")
 		defer log.Info().Str("method", "WorkspaceDidChangeWorkspaceFoldersHandler").Msg("SENDING")
-		workspace.Get().ProcessFolderChange(bgCtx, params)
+		workspace.Get().AddAndRemoveFoldersAndTriggerScan(bgCtx, params)
+		handleUntrustedFolders(bgCtx, srv)
 		return nil, nil
 	})
 }
@@ -183,24 +184,7 @@ func InitializeHandler(srv *jrpc2.Server) handler.Func {
 			os.Exit(0)
 		}()
 
-		if len(params.WorkspaceFolders) > 0 {
-			for _, workspaceFolder := range params.WorkspaceFolders {
-				log.Info().Str("method", method).Msgf("Adding workspaceFolder %v", workspaceFolder)
-				f := workspace.NewFolder(
-					uri.PathFromUri(workspaceFolder.Uri),
-					workspaceFolder.Name,
-					di.Scanner(),
-					di.HoverService(),
-				)
-				w.AddFolder(f)
-			}
-		} else {
-			if params.RootURI != "" {
-				w.AddFolder(workspace.NewFolder(uri.PathFromUri(params.RootURI), params.ClientInfo.Name, di.Scanner(), di.HoverService()))
-			} else if params.RootPath != "" {
-				w.AddFolder(workspace.NewFolder(params.RootPath, params.ClientInfo.Name, di.Scanner(), di.HoverService()))
-			}
-		}
+		addWorkspaceFolders(params, w)
 
 		return lsp.InitializeResult{
 			ServerInfo: lsp.ServerInfo{
@@ -232,6 +216,7 @@ func InitializeHandler(srv *jrpc2.Server) handler.Func {
 						snyk.LoginCommand,
 						snyk.CopyAuthLinkCommand,
 						snyk.LogoutCommand,
+						snyk.TrustWorkspaceFoldersCommand,
 					},
 				},
 			},
@@ -241,10 +226,37 @@ func InitializeHandler(srv *jrpc2.Server) handler.Func {
 func InitializedHandler(srv *jrpc2.Server) handler.Func {
 	return handler.New(func(ctx context.Context, params lsp.InitializedParams) (interface{}, error) {
 		workspace.Get().ScanWorkspace(context.Background())
+		if config.CurrentConfig().AutomaticAuthentication() || config.CurrentConfig().NonEmptyToken() {
+			go handleUntrustedFolders(context.Background(), srv)
+		}
 		return nil, nil
 	})
 }
 
+func addWorkspaceFolders(params lsp.InitializeParams, w *workspace.Workspace) {
+	const method = "addWorkspaceFolders"
+	if len(params.WorkspaceFolders) > 0 {
+		for _, workspaceFolder := range params.WorkspaceFolders {
+			log.Info().Str("method", method).Msgf("Adding workspaceFolder %v", workspaceFolder)
+			f := workspace.NewFolder(
+				uri.PathFromUri(workspaceFolder.Uri),
+				workspaceFolder.Name,
+				di.Scanner(),
+				di.HoverService(),
+			)
+			w.AddFolder(f)
+		}
+	} else {
+		if params.RootURI != "" {
+			f := workspace.NewFolder(uri.PathFromUri(params.RootURI), params.ClientInfo.Name, di.Scanner(), di.HoverService())
+			w.AddFolder(f)
+		} else if params.RootPath != "" {
+			f := workspace.NewFolder(params.RootPath, params.ClientInfo.Name, di.Scanner(), di.HoverService())
+			w.AddFolder(f)
+		}
+	}
+}
+
 func setClientInformation(initParams lsp.InitializeParams) {
 	var integrationName, integrationVersion string
 	if initParams.InitializationOptions.IntegrationName != "" {
@@ -400,6 +412,12 @@ func registerNotifier(srv *jrpc2.Server) {
 				Interface("source", source).
 				Interface("diagnosticCount", len(params.Diagnostics)).
 				Msg("publishing diagnostics")
+		case lsp.SnykTrustedFoldersParams:
+			notifier(srv, "$/snyk.addTrustedFolders", params)
+			log.Info().
+				Str("method", "registerNotifier").
+				Interface("trustedPaths", params.TrustedFolders).
+				Msg("sending trusted Folders to client")
 		default:
 			log.Warn().
 				Str("method", "registerNotifier").
diff --git a/application/server/server_test.go b/application/server/server_test.go
index e7621219f..a454763e8 100644
--- a/application/server/server_test.go
+++ b/application/server/server_test.go
@@ -230,7 +230,6 @@ func Test_initialize_shouldSupportCodeLenses(t *testing.T) {
 
 func Test_TextDocumentCodeLenses_shouldReturnCodeLenses(t *testing.T) {
 	loc := setupServer(t)
-
 	didOpenParams, dir := didOpenTextParams(t)
 
 	clientParams := lsp.InitializeParams{
@@ -243,6 +242,7 @@ func Test_TextDocumentCodeLenses_shouldReturnCodeLenses(t *testing.T) {
 			Token:                       "xxx",
 			ManageBinariesAutomatically: "true",
 			CliPath:                     "",
+			EnableTrustedFoldersFeature: "false",
 		},
 	}
 	_, err := loc.Client.Call(ctx, "initialize", clientParams)
@@ -468,6 +468,72 @@ func Test_initialize_autoAuthenticateSetCorrectly(t *testing.T) {
 	})
 }
 
+func Test_initialize_handlesUntrustedFoldersWhenAutomaticAuthentication(t *testing.T) {
+	loc := setupServer(t)
+	initializationOptions := lsp.Settings{
+		EnableTrustedFoldersFeature: "true",
+	}
+	params := lsp.InitializeParams{
+		InitializationOptions: initializationOptions,
+		WorkspaceFolders:      []lsp.WorkspaceFolder{{Uri: uri.PathToUri("/untrusted/dummy"), Name: "dummy"}}}
+	_, err := loc.Client.Call(ctx, "initialize", params)
+	if err != nil {
+		t.Fatal(err, "couldn't send initialized")
+	}
+
+	_, err = loc.Client.Call(ctx, "initialized", nil)
+	if err != nil {
+		t.Fatal(err, "couldn't send initialized")
+	}
+
+	assert.Nil(t, err)
+	assert.Eventually(t, func() bool { return checkTrustMessageRequest() }, time.Second, time.Millisecond)
+}
+
+func Test_initialize_handlesUntrustedFoldersWhenAuthenticated(t *testing.T) {
+	loc := setupServer(t)
+	initializationOptions := lsp.Settings{
+		EnableTrustedFoldersFeature: "true",
+		Token:                       "token",
+	}
+	params := lsp.InitializeParams{
+		InitializationOptions: initializationOptions,
+		WorkspaceFolders:      []lsp.WorkspaceFolder{{Uri: uri.PathToUri("/untrusted/dummy"), Name: "dummy"}}}
+	_, err := loc.Client.Call(ctx, "initialize", params)
+	if err != nil {
+		t.Fatal(err, "couldn't send initialized")
+	}
+
+	_, err = loc.Client.Call(ctx, "initialized", nil)
+	if err != nil {
+		t.Fatal(err, "couldn't send initialized")
+	}
+
+	assert.Nil(t, err)
+	assert.Eventually(t, func() bool { return checkTrustMessageRequest() }, time.Second, time.Millisecond)
+}
+
+func Test_initialize_doesnotHandleUntrustedFolders(t *testing.T) {
+	loc := setupServer(t)
+	initializationOptions := lsp.Settings{
+		EnableTrustedFoldersFeature: "true",
+	}
+	params := lsp.InitializeParams{
+		InitializationOptions: initializationOptions,
+		WorkspaceFolders:      []lsp.WorkspaceFolder{{Uri: uri.PathToUri("/untrusted/dummy"), Name: "dummy"}}}
+	_, err := loc.Client.Call(ctx, "initialize", params)
+	if err != nil {
+		t.Fatal(err, "couldn't send initialized")
+	}
+	_, err = loc.Client.Call(ctx, "initialized", nil)
+	if err != nil {
+		t.Fatal(err, "couldn't send initialized")
+	}
+
+	assert.Nil(t, err)
+	assert.Eventually(t, func() bool { return checkTrustMessageRequest() }, time.Second, time.Millisecond)
+}
+
 func Test_textDocumentDidOpenHandler_shouldAcceptDocumentItemAndPublishDiagnostics(t *testing.T) {
 	loc := setupServer(t)
 	didOpenParams, dir := didOpenTextParams(t)
@@ -480,8 +546,9 @@ func Test_textDocumentDidOpenHandler_shouldAcceptDocumentItemAndPublishDiagnosti
 			ActivateSnykIac:             "false",
 			Organization:                "fancy org",
 			Token:                       "xxx",
-			ManageBinariesAutomatically: "true",
+			ManageBinariesAutomatically: "false",
 			CliPath:                     "",
+			EnableTrustedFoldersFeature: "false",
 		},
 	}
 	_, err := loc.Client.Call(ctx, "initialize", clientParams)
@@ -489,6 +556,11 @@ func Test_textDocumentDidOpenHandler_shouldAcceptDocumentItemAndPublishDiagnosti
 		t.Fatal(err, "couldn't initialize")
 	}
 
+	_, err = loc.Client.Call(ctx, "initialized", nil)
+	if err != nil {
+		t.Fatal(err, "couldn't send initialized")
+	}
+
 	_, err = loc.Client.Call(ctx, "textDocument/didOpen", didOpenParams)
 	if err != nil {
 		t.Fatal(err)
@@ -688,8 +760,9 @@ func runSmokeTest(repo string, commit string, file1 string, file2 string, t *tes
 	clientParams := lsp.InitializeParams{
 		WorkspaceFolders: []lsp.WorkspaceFolder{folder},
 		InitializationOptions: lsp.Settings{
-			Endpoint: os.Getenv("SNYK_API"),
-			Token:    os.Getenv("SNYK_TOKEN"),
+			Endpoint:                    os.Getenv("SNYK_API"),
+			Token:                       os.Getenv("SNYK_TOKEN"),
+			EnableTrustedFoldersFeature: "false",
 		},
 	}
 
diff --git a/application/server/trust.go b/application/server/trust.go
new file mode 100644
index 000000000..f417227a7
--- /dev/null
+++ b/application/server/trust.go
@@ -0,0 +1,88 @@
+/*
+ * Copyright 2022 Snyk Ltd.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package server
+
+import (
+	"context"
+	"fmt"
+
+	"github.com/creachadair/jrpc2"
+	"github.com/pkg/errors"
+	"github.com/rs/zerolog/log"
+
+	"github.com/snyk/snyk-ls/application/server/lsp"
+	"github.com/snyk/snyk-ls/domain/ide/workspace"
+)
+
+const doTrust = "Trust folders and continue"
+const dontTrust = "Don't trust folders"
+
+func handleUntrustedFolders(ctx context.Context, srv *jrpc2.Server) {
+	w := workspace.Get()
+	// debounce requests from overzealous clients (Eclipse, I'm looking at you)
+	if w.IsTrustRequestOngoing() {
+		return
+	}
+	w.StartRequestTrustCommunication()
+	defer w.EndRequestTrustCommunication()
+
+	_, untrusted := w.GetFolderTrust()
+	if len(untrusted) > 0 {
+
+		decision, err := showTrustDialog(srv, untrusted, doTrust, dontTrust)
+		if err != nil {
+			return
+		}
+
+		if decision.Title == doTrust {
+			w.TrustFoldersAndScan(ctx, untrusted)
+		}
+	}
+}
+
+func showTrustDialog(srv *jrpc2.Server, untrusted []*workspace.Folder, dontTrust string, doTrust string) (lsp.MessageActionItem, error) {
+	method := "showTrustDialog"
+	result, err := srv.Callback(context.Background(), "window/showMessageRequest", lsp.ShowMessageRequestParams{
+		Type:    lsp.Warning,
+		Message: getTrustMessage(untrusted),
+		Actions: []lsp.MessageActionItem{{Title: dontTrust}, {Title: doTrust}},
+	})
+	if err != nil {
+		log.Err(errors.Wrap(err, "couldn't show trust message")).Str("method", method).Send()
+		return lsp.MessageActionItem{Title: dontTrust}, err
+	}
+
+	var trust lsp.MessageActionItem
+	if result != nil {
+		err = result.UnmarshalResult(&trust)
+		if err != nil {
+			log.Err(errors.Wrap(err, "couldn't unmarshal trust message")).Str("method", method).Send()
+			return lsp.MessageActionItem{Title: dontTrust}, err
+		}
+	}
+	return trust, err
+}
+
+func getTrustMessage(untrusted []*workspace.Folder) string {
+	var untrustedFolderString string
+	for _, folder := range untrusted {
+		untrustedFolderString += folder.Path() + "\n"
+	}
+	return fmt.Sprintf("When scanning for vulnerabilities, Snyk may automatically execute code such as invoking "+
+		"the package manager to get dependency information. You should only scan folders you trust."+
+		"\n\nUntrusted Folders: \n%s\n\n", untrustedFolderString)
+}
diff --git a/application/server/trust_test.go b/application/server/trust_test.go
new file mode 100644
index 000000000..db3654fb1
--- /dev/null
+++ b/application/server/trust_test.go
@@ -0,0 +1,145 @@
+/*
+ * Copyright 2022 Snyk Ltd.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package server
+
+import (
+	"context"
+	"testing"
+	"time"
+
+	"github.com/creachadair/jrpc2"
+	"github.com/stretchr/testify/assert"
+
+	"github.com/snyk/snyk-ls/application/config"
+	"github.com/snyk/snyk-ls/application/di"
+	"github.com/snyk/snyk-ls/application/server/lsp"
+	"github.com/snyk/snyk-ls/domain/ide/workspace"
+	"github.com/snyk/snyk-ls/domain/snyk"
+	"github.com/snyk/snyk-ls/internal/uri"
+)
+
+func Test_handleUntrustedFolders_shouldTriggerTrustRequestAndNotScan(t *testing.T) {
+	loc := setupServer(t)
+	w := workspace.Get()
+	scanner := &snyk.TestScanner{}
+	config.CurrentConfig().SetTrustedFolderFeatureEnabled(true)
+	w.AddFolder(workspace.NewFolder("dummy", "dummy", scanner, di.HoverService()))
+	handleUntrustedFolders(context.Background(), loc.Server)
+
+	assert.True(t, checkTrustMessageRequest())
+	assert.Equal(t, scanner.Calls(), 0)
+}
+
+func Test_handleUntrustedFolders_shouldNotTriggerTrustRequestWhenAlreadyRequesting(t *testing.T) {
+	loc := setupServer(t)
+	w := workspace.Get()
+	scanner := &snyk.TestScanner{}
+	config.CurrentConfig().SetTrustedFolderFeatureEnabled(true)
+	w.AddFolder(workspace.NewFolder("dummy", "dummy", scanner, di.HoverService()))
+	w.StartRequestTrustCommunication()
+
+	handleUntrustedFolders(context.Background(), loc.Server)
+
+	assert.Len(t, jsonRPCRecorder.FindCallbacksByMethod("window/showMessageRequest"), 0)
+	assert.Equal(t, scanner.Calls(), 0)
+}
+
+func Test_handleUntrustedFolders_shouldTriggerTrustRequestAndScanAfterConfirmation(t *testing.T) {
+	loc := setupCustomServer(t, func(_ context.Context, _ *jrpc2.Request) (interface{}, error) {
+		return lsp.MessageActionItem{
+			Title: doTrust,
+		}, nil
+	})
+	registerNotifier(loc.Server)
+
+	w := workspace.Get()
+	scanner := &snyk.TestScanner{}
+	config.CurrentConfig().SetTrustedFolderFeatureEnabled(true)
+	w.AddFolder(workspace.NewFolder("/trusted/dummy", "dummy", scanner, di.HoverService()))
+
+	handleUntrustedFolders(context.Background(), loc.Server)
+
+	assert.Eventually(t, func() bool {
+		addTrustedSent := len(jsonRPCRecorder.FindNotificationsByMethod("$/snyk.addTrustedFolders")) == 1
+		return scanner.Calls() == 1 && addTrustedSent
+	}, time.Second, time.Millisecond)
+}
+
+func Test_handleUntrustedFolders_shouldTriggerTrustRequestAndNotScanAfterNegativeConfirmation(t *testing.T) {
+	loc := setupCustomServer(t, func(_ context.Context, _ *jrpc2.Request) (interface{}, error) {
+		return lsp.MessageActionItem{
+			Title: dontTrust,
+		}, nil
+	})
+	registerNotifier(loc.Server)
+	w := workspace.Get()
+	scanner := &snyk.TestScanner{}
+	w.AddFolder(workspace.NewFolder("/trusted/dummy", "dummy", scanner, di.HoverService()))
+	config.CurrentConfig().SetTrustedFolderFeatureEnabled(true)
+
+	handleUntrustedFolders(context.Background(), loc.Server)
+
+	assert.Equal(t, scanner.Calls(), 0)
+}
+
+func Test_initializeHandler_shouldCallHandleUntrustedFolders(t *testing.T) {
+	loc := setupServer(t)
+	config.CurrentConfig().SetTrustedFolderFeatureEnabled(true)
+
+	_, err := loc.Client.Call(context.Background(), "initialize", lsp.InitializeParams{
+		RootURI: uri.PathToUri("/untrusted/dummy"),
+	})
+	if err != nil {
+		t.Fatal(err, "couldn't send initialized")
+	}
+
+	_, err = loc.Client.Call(ctx, "initialized", nil)
+	if err != nil {
+		t.Fatal(err, "couldn't send initialized")
+	}
+
+	assert.NoError(t, err)
+	assert.Eventually(t, func() bool { return checkTrustMessageRequest() }, time.Second, time.Millisecond)
+}
+
+func Test_DidWorkspaceFolderChange_shouldCallHandleUntrustedFolders(t *testing.T) {
+	loc := setupServer(t)
+	config.CurrentConfig().SetTrustedFolderFeatureEnabled(true)
+
+	_, err := loc.Client.Call(context.Background(), "workspace/didChangeWorkspaceFolders", lsp.DidChangeWorkspaceFoldersParams{
+		Event: lsp.WorkspaceFoldersChangeEvent{
+			Added: []lsp.WorkspaceFolder{
+				{Uri: uri.PathToUri("/untrusted/dummy"), Name: "dummy"},
+			},
+			Removed: []lsp.WorkspaceFolder{},
+		},
+	})
+
+	assert.NoError(t, err)
+	assert.Eventually(t, func() bool { return checkTrustMessageRequest() }, time.Second, time.Millisecond)
+}
+
+func checkTrustMessageRequest() bool {
+	callbacks := jsonRPCRecorder.FindCallbacksByMethod("window/showMessageRequest")
+	if len(callbacks) == 0 {
+		return false
+	}
+	var params lsp.ShowMessageRequestParams
+	_ = callbacks[0].UnmarshalParams(&params)
+	_, untrusted := workspace.Get().GetFolderTrust()
+	return params.Type == lsp.Warning && params.Message == getTrustMessage(untrusted)
+}
diff --git a/domain/ide/workspace/folder.go b/domain/ide/workspace/folder.go
index 2fc862e4e..4593f8524 100644
--- a/domain/ide/workspace/folder.go
+++ b/domain/ide/workspace/folder.go
@@ -18,10 +18,12 @@ package workspace
 
 import (
 	"context"
+	"strings"
 	"sync"
 
 	"github.com/rs/zerolog/log"
 
+	"github.com/snyk/snyk-ls/application/config"
 	"github.com/snyk/snyk-ls/application/server/lsp"
 	"github.com/snyk/snyk-ls/domain/ide/converter"
 	"github.com/snyk/snyk-ls/domain/ide/hover"
@@ -64,6 +66,7 @@ func NewFolder(path string, name string, scanner snyk.Scanner, hoverService hove
 	folder.productAttributes[snyk.ProductInfrastructureAsCode] = snyk.ProductAttributes{}
 	folder.productAttributes[snyk.ProductOpenSource] = snyk.ProductAttributes{}
 	folder.documentDiagnosticCache = concurrency.AtomicMap{}
+
 	return &folder
 }
 
@@ -115,9 +118,14 @@ func (f *Folder) ClearDiagnosticsCache(filePath string) {
 }
 
 func (f *Folder) scan(ctx context.Context, path string) {
+	const method = "domain.ide.workspace.folder.scan"
+	if !f.IsTrusted() {
+		log.Warn().Str("path", path).Str("method", method).Msg("skipping scan of untrusted path")
+		return
+	}
 	issuesSlice := f.DocumentDiagnosticsFromCache(path)
 	if issuesSlice != nil {
-		log.Info().Str("method", "domain.ide.workspace.folder.scan").Msgf("Cached results found: Skipping scan for %s", path)
+		log.Info().Str("method", method).Msgf("Cached results found: Skipping scan for %s", path)
 		f.processResults(issuesSlice)
 		return
 	}
@@ -228,3 +236,16 @@ func (f *Folder) ClearDiagnostics() {
 
 	f.documentDiagnosticCache.ClearAll()
 }
+
+func (f *Folder) IsTrusted() bool {
+	if !config.CurrentConfig().IsTrustedFolderFeatureEnabled() {
+		return true
+	}
+
+	for _, path := range config.CurrentConfig().TrustedFolders() {
+		if strings.HasPrefix(f.path, path) {
+			return true
+		}
+	}
+	return false
+}
diff --git a/domain/ide/workspace/folder_test.go b/domain/ide/workspace/folder_test.go
index 8bb228483..22e53c81c 100644
--- a/domain/ide/workspace/folder_test.go
+++ b/domain/ide/workspace/folder_test.go
@@ -24,6 +24,7 @@ import (
 
 	"github.com/stretchr/testify/assert"
 
+	"github.com/snyk/snyk-ls/application/config"
 	"github.com/snyk/snyk-ls/application/server/lsp"
 	"github.com/snyk/snyk-ls/domain/ide/hover"
 	"github.com/snyk/snyk-ls/domain/snyk"
@@ -71,7 +72,7 @@ func Test_Scan_WhenCachedResultsButNoIssues_shouldNotReScan(t *testing.T) {
 	assert.Equal(t, 1, scannerRecorder.Calls())
 }
 
-func TestProcessResults_SendsDiagnosticsAndHovers(t *testing.T) {
+func Test_ProcessResults_SendsDiagnosticsAndHovers(t *testing.T) {
 	t.Skipf("test this once we have uniform abstractions for hover & diagnostics")
 	testutil.UnitTest(t)
 	hoverService := hover.NewFakeHoverService()
@@ -86,7 +87,7 @@ func TestProcessResults_SendsDiagnosticsAndHovers(t *testing.T) {
 	// assert.hoverService.GetAll()
 }
 
-func TestProcessResults_whenDifferentPaths_AddsToCache(t *testing.T) {
+func Test_ProcessResults_whenDifferentPaths_AddsToCache(t *testing.T) {
 	testutil.UnitTest(t)
 	f := NewFolder("dummy", "dummy", snyk.NewTestScanner(), hover.NewFakeHoverService())
 
@@ -102,7 +103,7 @@ func TestProcessResults_whenDifferentPaths_AddsToCache(t *testing.T) {
 	assert.Len(t, f.documentDiagnosticCache.Get("path2"), 1)
 }
 
-func TestProcessResults_whenSamePaths_AddsToCache(t *testing.T) {
+func Test_ProcessResults_whenSamePaths_AddsToCache(t *testing.T) {
 	testutil.UnitTest(t)
 	f := NewFolder("dummy", "dummy", snyk.NewTestScanner(), hover.NewFakeHoverService())
 
@@ -116,7 +117,7 @@ func TestProcessResults_whenSamePaths_AddsToCache(t *testing.T) {
 	assert.Len(t, f.documentDiagnosticCache.Get("path1"), 2)
 }
 
-func TestProcessResults_whenDifferentPaths_AccumulatesIssues(t *testing.T) {
+func Test_ProcessResults_whenDifferentPaths_AccumulatesIssues(t *testing.T) {
 	testutil.UnitTest(t)
 	f := NewFolder("dummy", "dummy", snyk.NewTestScanner(), hover.NewFakeHoverService())
 
@@ -132,7 +133,7 @@ func TestProcessResults_whenDifferentPaths_AccumulatesIssues(t *testing.T) {
 	assert.NotNil(t, f.documentDiagnosticCache.Get("path3"))
 }
 
-func TestProcessResults_whenSamePaths_AccumulatesIssues(t *testing.T) {
+func Test_ProcessResults_whenSamePaths_AccumulatesIssues(t *testing.T) {
 	testutil.UnitTest(t)
 	f := NewFolder("dummy", "dummy", snyk.NewTestScanner(), hover.NewFakeHoverService())
 
@@ -147,7 +148,7 @@ func TestProcessResults_whenSamePaths_AccumulatesIssues(t *testing.T) {
 	assert.Len(t, f.documentDiagnosticCache.Get("path1"), 3)
 }
 
-func TestProcessResults_whenSamePathsAndDuplicateIssues_DeDuplicates(t *testing.T) {
+func Test_ProcessResults_whenSamePathsAndDuplicateIssues_DeDuplicates(t *testing.T) {
 	testutil.UnitTest(t)
 	f := NewFolder("dummy", "dummy", snyk.NewTestScanner(), hover.NewFakeHoverService())
 
@@ -200,3 +201,50 @@ func Test_ClearDiagnostics(t *testing.T) {
 		10*time.Millisecond,
 	)
 }
+
+func Test_IsTrusted_shouldReturnFalseByDefault(t *testing.T) {
+	testutil.UnitTest(t)
+	config.CurrentConfig().SetTrustedFolderFeatureEnabled(true)
+	f := NewFolder("dummy", "dummy", snyk.NewTestScanner(), hover.NewFakeHoverService())
+	assert.False(t, f.IsTrusted())
+}
+
+func Test_IsTrusted_shouldReturnTrueForPathContainedInTrustedFolders(t *testing.T) {
+	testutil.UnitTest(t)
+	config.CurrentConfig().SetTrustedFolderFeatureEnabled(true)
+	config.CurrentConfig().SetTrustedFolders([]string{"dummy"})
+	f := NewFolder("dummy", "dummy", snyk.NewTestScanner(), hover.NewFakeHoverService())
+	assert.True(t, f.IsTrusted())
+}
+
+func Test_IsTrusted_shouldReturnTrueForSubfolderOfTrustedFolders_Linux(t *testing.T) {
+	testutil.IntegTest(t)
+	testutil.NotOnWindows(t, "Unix/macOS file paths are incompatible with Windows")
+	config.CurrentConfig().SetTrustedFolderFeatureEnabled(true)
+	config.CurrentConfig().SetTrustedFolders([]string{"/dummy"})
+	f := NewFolder("/dummy/dummyF", "dummy", snyk.NewTestScanner(), hover.NewFakeHoverService())
+	assert.True(t, f.IsTrusted())
+}
+
+func Test_IsTrusted_shouldReturnFalseForDifferentFolder(t *testing.T) {
+	testutil.UnitTest(t)
+	config.CurrentConfig().SetTrustedFolderFeatureEnabled(true)
+	config.CurrentConfig().SetTrustedFolders([]string{"/dummy"})
+	f := NewFolder("/UntrustedPath", "dummy", snyk.NewTestScanner(), hover.NewFakeHoverService())
+	assert.False(t, f.IsTrusted())
+}
+
+func Test_IsTrusted_shouldReturnTrueForSubfolderOfTrustedFolders(t *testing.T) {
+	testutil.IntegTest(t)
+	testutil.OnlyOnWindows(t, "Windows specific test")
+	config.CurrentConfig().SetTrustedFolderFeatureEnabled(true)
+	config.CurrentConfig().SetTrustedFolders([]string{"c:\\dummy"})
+	f := NewFolder("c:\\dummy\\dummyF", "dummy", snyk.NewTestScanner(), hover.NewFakeHoverService())
+	assert.True(t, f.IsTrusted())
+}
+
+func Test_IsTrusted_shouldReturnTrueIfTrustFeatureDisabled(t *testing.T) {
+	testutil.UnitTest(t) // disables trust feature
+	f := NewFolder("c:\\dummy\\dummyF", "dummy", snyk.NewTestScanner(), hover.NewFakeHoverService())
+	assert.True(t, f.IsTrusted())
+}
diff --git a/domain/ide/workspace/workspace.go b/domain/ide/workspace/workspace.go
index 463d4e388..2221564bf 100644
--- a/domain/ide/workspace/workspace.go
+++ b/domain/ide/workspace/workspace.go
@@ -20,10 +20,14 @@ import (
 	"context"
 	"sync"
 
+	"github.com/rs/zerolog/log"
+
+	"github.com/snyk/snyk-ls/application/config"
 	"github.com/snyk/snyk-ls/application/server/lsp"
 	"github.com/snyk/snyk-ls/domain/ide/hover"
 	"github.com/snyk/snyk-ls/domain/observability/performance"
 	"github.com/snyk/snyk-ls/domain/snyk"
+	"github.com/snyk/snyk-ls/internal/notification"
 	"github.com/snyk/snyk-ls/internal/uri"
 )
 
@@ -33,11 +37,13 @@ var mutex = &sync.Mutex{}
 
 // Workspace represents the highest entity in an IDE that contains code. A workspace may contain multiple folders
 type Workspace struct {
-	mutex        sync.Mutex
-	folders      map[string]*Folder
-	instrumentor performance.Instrumentor
-	scanner      snyk.Scanner
-	hoverService hover.Service
+	mutex               sync.Mutex
+	folders             map[string]*Folder
+	instrumentor        performance.Instrumentor
+	scanner             snyk.Scanner
+	hoverService        hover.Service
+	trustMutex          sync.Mutex
+	trustRequestOngoing bool // for debouncing
 }
 
 func New(instrumentor performance.Instrumentor, scanner snyk.Scanner, hoverService hover.Service) *Workspace {
@@ -62,7 +68,7 @@ func Set(w *Workspace) {
 	instance = w
 }
 
-func (w *Workspace) DeleteFolder(folder string) {
+func (w *Workspace) RemoveFolder(folder string) {
 	w.mutex.Lock()
 	defer w.mutex.Unlock()
 	delete(w.folders, folder)
@@ -87,14 +93,16 @@ func (w *Workspace) GetFolderContaining(path string) (folder *Folder) {
 }
 
 func (w *Workspace) ScanWorkspace(ctx context.Context) {
-	for _, folder := range w.folders {
+	trusted, _ := w.GetFolderTrust()
+
+	for _, folder := range trusted {
 		go folder.ScanFolder(ctx)
 	}
 }
 
-func (w *Workspace) ProcessFolderChange(ctx context.Context, params lsp.DidChangeWorkspaceFoldersParams) {
+func (w *Workspace) AddAndRemoveFoldersAndTriggerScan(ctx context.Context, params lsp.DidChangeWorkspaceFoldersParams) {
 	for _, folder := range params.Event.Removed {
-		w.DeleteFolder(uri.PathFromUri(folder.Uri))
+		w.RemoveFolder(uri.PathFromUri(folder.Uri))
 		// TODO: check if we need to clean up the reported diagnostics, if folder was removed?
 	}
 	for _, folder := range params.Event.Added {
@@ -104,7 +112,7 @@ func (w *Workspace) ProcessFolderChange(ctx context.Context, params lsp.DidChang
 	w.ScanWorkspace(ctx)
 }
 
-func (w *Workspace) ClearIssues(ctx context.Context) {
+func (w *Workspace) ClearIssues(_ context.Context) {
 	for _, folder := range w.folders {
 		folder.ClearScannedStatus()
 		folder.ClearDiagnostics()
@@ -112,3 +120,28 @@ func (w *Workspace) ClearIssues(ctx context.Context) {
 
 	w.hoverService.ClearAllHovers()
 }
+
+func (w *Workspace) TrustFoldersAndScan(ctx context.Context, foldersToBeTrusted []*Folder) {
+	currentConfig := config.CurrentConfig()
+	trustedFolderPaths := currentConfig.TrustedFolders()
+	for _, f := range foldersToBeTrusted {
+		// we need to append and set the trusted path to the config before the scan, as the scan is checking for trust
+		trustedFolderPaths = append(trustedFolderPaths, f.Path())
+		currentConfig.SetTrustedFolders(trustedFolderPaths)
+		go f.ScanFolder(ctx)
+	}
+	notification.Send(lsp.SnykTrustedFoldersParams{TrustedFolders: trustedFolderPaths})
+}
+
+func (w *Workspace) GetFolderTrust() (trusted []*Folder, untrusted []*Folder) {
+	for _, folder := range w.folders {
+		if folder.IsTrusted() {
+			trusted = append(trusted, folder)
+			log.Info().Str("folder", folder.Path()).Msg("Trusted folder")
+		} else {
+			untrusted = append(untrusted, folder)
+			log.Info().Str("folder", folder.Path()).Msg("Untrusted folder")
+		}
+	}
+	return trusted, untrusted
+}
diff --git a/domain/ide/workspace/workspace_test.go b/domain/ide/workspace/workspace_test.go
new file mode 100644
index 000000000..92843b8b2
--- /dev/null
+++ b/domain/ide/workspace/workspace_test.go
@@ -0,0 +1,117 @@
+/*
+ * Copyright 2022 Snyk Ltd.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package workspace
+
+import (
+	"context"
+	"testing"
+	"time"
+
+	"github.com/stretchr/testify/assert"
+
+	"github.com/snyk/snyk-ls/application/config"
+	"github.com/snyk/snyk-ls/application/server/lsp"
+	"github.com/snyk/snyk-ls/domain/observability/performance"
+	"github.com/snyk/snyk-ls/domain/snyk"
+	"github.com/snyk/snyk-ls/internal/testutil"
+	"github.com/snyk/snyk-ls/internal/uri"
+)
+
+func Test_GetFolderTrust_shouldReturnTrustedAndUntrustedFolders(t *testing.T) {
+	testutil.UnitTest(t)
+	const trustedDummy = "trustedDummy"
+	const untrustedDummy = "untrustedDummy"
+	scanner := &snyk.TestScanner{}
+	w := New(performance.NewTestInstrumentor(), scanner, nil)
+	config.CurrentConfig().SetTrustedFolderFeatureEnabled(true)
+	config.CurrentConfig().SetTrustedFolders([]string{trustedDummy})
+	w.AddFolder(NewFolder(trustedDummy, trustedDummy, scanner, nil))
+	w.AddFolder(NewFolder(untrustedDummy, untrustedDummy, scanner, nil))
+
+	trusted, untrusted := w.GetFolderTrust()
+
+	assert.Equal(t, trustedDummy, trusted[0].path)
+	assert.Equal(t, untrustedDummy, untrusted[0].path)
+}
+
+func Test_TrustFoldersAndScan_shouldAddFoldersToTrustedFoldersAndTriggerScan(t *testing.T) {
+	testutil.UnitTest(t)
+	const trustedDummy = "trustedDummy"
+	const untrustedDummy = "untrustedDummy"
+	scanner := &snyk.TestScanner{}
+	w := New(performance.NewTestInstrumentor(), scanner, nil)
+	config.CurrentConfig().SetTrustedFolderFeatureEnabled(true)
+	trustedFolder := NewFolder(trustedDummy, trustedDummy, scanner, nil)
+	w.AddFolder(trustedFolder)
+	untrustedFolder := NewFolder(untrustedDummy, untrustedDummy, scanner, nil)
+	w.AddFolder(untrustedFolder)
+
+	w.TrustFoldersAndScan(context.Background(), []*Folder{trustedFolder})
+
+	assert.Contains(t, config.CurrentConfig().TrustedFolders(), trustedFolder.path)
+	assert.NotContains(t, config.CurrentConfig().TrustedFolders(), untrustedFolder.path)
+	assert.Eventually(t, func() bool {
+		return scanner.Calls() == 1
+	}, time.Second, time.Millisecond, "scanner should be called after trust is granted")
+}
+
+func Test_AddAndRemoveFoldersAndTriggerScan(t *testing.T) {
+	testutil.UnitTest(t)
+	const trustedDummy = "trustedDummy"
+	const untrustedDummy = "untrustedDummy"
+	const toBeRemoved = "toBeRemoved"
+	trustedPathAfterConversions := uri.PathFromUri(uri.PathToUri(trustedDummy))
+	toBeRemovedAbsolutePathAfterConversions := uri.PathFromUri(uri.PathToUri(toBeRemoved))
+
+	scanner := &snyk.TestScanner{}
+	w := New(performance.NewTestInstrumentor(), scanner, nil)
+	toBeRemovedFolder := NewFolder(toBeRemovedAbsolutePathAfterConversions, toBeRemoved, scanner, nil)
+	w.AddFolder(toBeRemovedFolder)
+
+	config.CurrentConfig().SetTrustedFolderFeatureEnabled(true)
+	config.CurrentConfig().SetTrustedFolders([]string{trustedPathAfterConversions})
+
+	params := lsp.DidChangeWorkspaceFoldersParams{Event: lsp.WorkspaceFoldersChangeEvent{
+		Added: []lsp.WorkspaceFolder{
+			{Name: trustedDummy, Uri: uri.PathToUri(trustedDummy)},
+			{Name: untrustedDummy, Uri: uri.PathToUri(untrustedDummy)},
+		},
+		Removed: []lsp.WorkspaceFolder{
+			{Name: toBeRemoved, Uri: uri.PathToUri(toBeRemoved)},
+		},
+	}}
+
+	w.AddAndRemoveFoldersAndTriggerScan(context.Background(), params)
+
+	assert.Nil(t, w.GetFolderContaining(toBeRemoved))
+
+	// one call for one trusted folder
+	assert.Eventually(t, func() bool {
+		return scanner.Calls() == 1
+	}, time.Second, time.Millisecond, "scanner should be called after trust is granted")
+}
+
+func Test_Get(t *testing.T) {
+	New(nil, nil, nil)
+	assert.Equal(t, instance, Get())
+}
+
+func Test_Set(t *testing.T) {
+	w := New(nil, nil, nil)
+	Set(w)
+	assert.Equal(t, w, instance)
+}
diff --git a/domain/ide/workspace/workspace_trust.go b/domain/ide/workspace/workspace_trust.go
new file mode 100644
index 000000000..af3f2bf93
--- /dev/null
+++ b/domain/ide/workspace/workspace_trust.go
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2022 Snyk Ltd.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package workspace
+
+func (w *Workspace) StartRequestTrustCommunication() {
+	w.trustMutex.Lock()
+	w.trustRequestOngoing = true
+	w.trustMutex.Unlock()
+}
+
+func (w *Workspace) EndRequestTrustCommunication() {
+	w.trustMutex.Lock()
+	w.trustRequestOngoing = false
+	w.trustMutex.Unlock()
+}
+
+func (w *Workspace) IsTrustRequestOngoing() bool {
+	w.trustMutex.Lock()
+	defer w.trustMutex.Unlock()
+	return w.trustRequestOngoing
+}
diff --git a/domain/ide/workspace/workspace_trust_test.go b/domain/ide/workspace/workspace_trust_test.go
new file mode 100644
index 000000000..c21534f1f
--- /dev/null
+++ b/domain/ide/workspace/workspace_trust_test.go
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2022 Snyk Ltd.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package workspace
+
+import (
+	"testing"
+
+	"github.com/stretchr/testify/assert"
+
+	"github.com/snyk/snyk-ls/internal/testutil"
+)
+
+func TestWorkspace_TrustRequests(t *testing.T) {
+	testutil.UnitTest(t)
+	w := New(nil, nil, nil)
+	w.StartRequestTrustCommunication()
+	w.IsTrustRequestOngoing()
+	assert.True(t, w.IsTrustRequestOngoing())
+	w.EndRequestTrustCommunication()
+	assert.False(t, w.IsTrustRequestOngoing())
+}
diff --git a/domain/snyk/command.go b/domain/snyk/command.go
index 6f422452e..145945a77 100644
--- a/domain/snyk/command.go
+++ b/domain/snyk/command.go
@@ -17,12 +17,13 @@
 package snyk
 
 const (
-	NavigateToRangeCommand = "snyk.navigateToRange"
-	WorkspaceScanCommand   = "snyk.workspace.scan"
-	OpenBrowserCommand     = "snyk.openBrowser"
-	LoginCommand           = "snyk.login"
-	CopyAuthLinkCommand    = "snyk.copyAuthLink"
-	LogoutCommand          = "snyk.logout"
+	NavigateToRangeCommand       = "snyk.navigateToRange"
+	WorkspaceScanCommand         = "snyk.workspace.scan"
+	OpenBrowserCommand           = "snyk.openBrowser"
+	LoginCommand                 = "snyk.login"
+	CopyAuthLinkCommand          = "snyk.copyAuthLink"
+	LogoutCommand                = "snyk.logout"
+	TrustWorkspaceFoldersCommand = "snyk.trustWorkspaceFolders"
 )
 
 type Command struct {
diff --git a/internal/testutil/test_setup.go b/internal/testutil/test_setup.go
index 88527f7a2..f0be289cc 100644
--- a/internal/testutil/test_setup.go
+++ b/internal/testutil/test_setup.go
@@ -45,6 +45,7 @@ func UnitTest(t *testing.T) {
 	c := config.New()
 	c.SetManageBinariesAutomatically(false)
 	c.SetToken("00000000-0000-0000-0000-000000000001")
+	c.SetTrustedFolderFeatureEnabled(false)
 	config.SetCurrentConfig(c)
 	CLIDownloadLockFileCleanUp(t)
 }
@@ -123,6 +124,7 @@ func prepareTestHelper(t *testing.T, envVar string) {
 	c.SetToken(GetEnvironmentToken())
 	c.SetErrorReportingEnabled(false)
 	c.SetTelemetryEnabled(false)
+	c.SetTrustedFolderFeatureEnabled(false)
 	config.SetCurrentConfig(c)
 
 	CLIDownloadLockFileCleanUp(t)
