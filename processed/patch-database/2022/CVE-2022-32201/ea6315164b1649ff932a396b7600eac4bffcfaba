diff --git a/codestream/entropyparser.cpp b/codestream/entropyparser.cpp
index 196cc00..5b3858c 100644
--- a/codestream/entropyparser.cpp
+++ b/codestream/entropyparser.cpp
@@ -43,7 +43,7 @@
 ** This class represents the interface for parsing the
 ** entropy coded data in JPEG as part of a single scan.
 **
-** $Id: entropyparser.cpp,v 1.24 2021/09/08 10:30:06 thor Exp $
+** $Id: entropyparser.cpp,v 1.25 2022/05/30 14:05:58 thor Exp $
 **
 */
 
@@ -62,7 +62,7 @@ EntropyParser::EntropyParser(class Frame *frame,class Scan *scan)
 {
   m_ucCount = scan->ComponentsInScan();
 
-  // The residual scan uses all components here, not just for, but
+  // The residual scan uses all components here, not just four, but
   // it does not require the component count either.
   for(volatile UBYTE i = 0;i < m_ucCount && i < 4;i++) {
     JPG_TRY {
diff --git a/marker/scan.cpp b/marker/scan.cpp
index b8e52e8..f85aac7 100644
--- a/marker/scan.cpp
+++ b/marker/scan.cpp
@@ -42,7 +42,7 @@
 **
 ** Represents all data in a single scan, and hence is the SOS marker.
 **
-** $Id: scan.cpp,v 1.117 2021/11/15 07:39:43 thor Exp $
+** $Id: scan.cpp,v 1.118 2022/05/30 14:06:11 thor Exp $
 **
 */
 
@@ -338,6 +338,14 @@ void Scan::CreateParser(void)
   //
   assert(m_pParser == NULL);
   //
+  // Check whether all components are there.
+  for(UBYTE i = 0;i < m_ucCount && i < 4;i++) {
+    if (ComponentOf(i) == NULL) {
+      JPG_THROW(MALFORMED_STREAM,"Scan::CreateParser",
+                "found a component ID in a scan that does not exist");
+    }
+  }
+  //
   switch(type) {
   case Baseline:
     m_pParser = new(m_pEnviron) class SequentialScan(m_pFrame,this,
