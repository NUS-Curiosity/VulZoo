diff --git a/pjlib/include/pj/types.h b/pjlib/include/pj/types.h
index 8c9f78238f..e9a60758c0 100644
--- a/pjlib/include/pj/types.h
+++ b/pjlib/include/pj/types.h
@@ -31,6 +31,7 @@
  * @{
  */
 #include <pj/config.h>
+#include <pj/limits.h>
 
 PJ_BEGIN_DECL
 
@@ -361,6 +362,13 @@ PJ_INLINE(pj_int32_t) pj_swap32(pj_int32_t val32)
     return val32;
 }
 
+/* This is to check if uint32 var will overflow if converted to signed long */
+#define PJ_CHECK_OVERFLOW_UINT32_TO_LONG(uint32_var, exec_on_overflow) \
+	do { \
+	    if (uint32_var > PJ_MAXLONG) { \
+		exec_on_overflow; \
+	    } \
+	} while (0)
 
 /**
  * @}
diff --git a/pjlib/src/pj/file_io_ansi.c b/pjlib/src/pj/file_io_ansi.c
index d7a68cd649..0570b81c7a 100644
--- a/pjlib/src/pj/file_io_ansi.c
+++ b/pjlib/src/pj/file_io_ansi.c
@@ -20,6 +20,7 @@
 #include <pj/file_io.h>
 #include <pj/assert.h>
 #include <pj/errno.h>
+#include <pj/limits.h>
 #include <stdio.h>
 #include <errno.h>
 
@@ -124,6 +125,12 @@ PJ_DEF(pj_status_t) pj_file_setpos( pj_oshandle_t fd,
 {
     int mode;
 
+    if ((sizeof(pj_off_t) > sizeof(long)) &&
+        (offset > PJ_MAXLONG || offset < PJ_MINLONG)) 
+    {
+        return PJ_ENOTSUP;
+    }
+
     switch (whence) {
     case PJ_SEEK_SET:
         mode = SEEK_SET; break;
diff --git a/pjmedia/src/pjmedia/avi_player.c b/pjmedia/src/pjmedia/avi_player.c
index e22a148119..5690562e6d 100644
--- a/pjmedia/src/pjmedia/avi_player.c
+++ b/pjmedia/src/pjmedia/avi_player.c
@@ -282,7 +282,7 @@ pjmedia_avi_player_create_streams(pj_pool_t *pool,
     /* Read the headers of each stream. */
     for (i = 0; i < avi_hdr.avih_hdr.num_streams; i++) {
         pj_size_t elem = 0;
-        pj_ssize_t size_to_read;
+        pj_off_t size_to_read;
 
         /* Read strl header */
         status = file_read(fport[0]->fd, &avi_hdr.strl_hdr[i],
@@ -335,6 +335,7 @@ pjmedia_avi_player_create_streams(pj_pool_t *pool,
     do {
         pjmedia_avi_subchunk ch;
         int read = 0;
+        pj_off_t size_to_read;
 
         status = file_read(fport[0]->fd, &ch, sizeof(pjmedia_avi_subchunk));
         if (status != PJ_SUCCESS) {
@@ -349,7 +350,15 @@ pjmedia_avi_player_create_streams(pj_pool_t *pool,
                 break;
         }
 
-        status = pj_file_setpos(fport[0]->fd, ch.len-read, PJ_SEEK_CUR);
+        if (ch.len < read) {
+            status = PJ_EINVAL;
+            goto on_error;
+        }
+        PJ_CHECK_OVERFLOW_UINT32_TO_LONG(ch.len - read, 
+                                         status = PJ_EINVAL; goto on_error;);
+        size_to_read = (pj_off_t)ch.len - read;
+
+        status = pj_file_setpos(fport[0]->fd, size_to_read, PJ_SEEK_CUR);
         if (status != PJ_SUCCESS) {
             goto on_error;
         }
@@ -775,6 +784,8 @@ static pj_status_t avi_get_frame(pjmedia_port *this_port,
         /* Read new chunk data */
         if (fport->size_left == 0) {
             pj_off_t pos;
+            pj_off_t ch_len;
+
             pj_file_getpos(fport->fd, &pos);
 
             /* Data is padded to the nearest WORD boundary */
@@ -788,6 +799,10 @@ static pj_status_t avi_get_frame(pjmedia_port *this_port,
                 size_read = 0;
                 goto on_error2;
             }
+            
+            PJ_CHECK_OVERFLOW_UINT32_TO_LONG(ch.len, 
+                                         status = PJ_EINVAL;  goto on_error2;);
+            ch_len = ch.len;
 
             cid = (char *)&ch.id;
             if (cid[0] >= '0' && cid[0] <= '9' &&
@@ -814,8 +829,7 @@ static pj_status_t avi_get_frame(pjmedia_port *this_port,
                     goto on_error2;
                 }
 
-                status = pj_file_setpos(fport->fd, ch.len,
-                                        PJ_SEEK_CUR);
+                status = pj_file_setpos(fport->fd, ch_len, PJ_SEEK_CUR);
                 continue;
             }
             fport->size_left = ch.len;
diff --git a/pjmedia/src/pjmedia/wav_player.c b/pjmedia/src/pjmedia/wav_player.c
index 2bd38bdbf3..8053bdc117 100644
--- a/pjmedia/src/pjmedia/wav_player.c
+++ b/pjmedia/src/pjmedia/wav_player.c
@@ -188,7 +188,8 @@ PJ_DEF(pj_status_t) pjmedia_wav_player_port_create( pj_pool_t *pool,
 						     pjmedia_port **p_port )
 {
     pjmedia_wave_hdr wave_hdr;
-    pj_ssize_t size_to_read, size_read;
+    pj_ssize_t size_read;
+    pj_off_t size_to_read;
     struct file_reader_port *fport;
     pjmedia_audio_format_detail *ad;
     pj_off_t pos;
@@ -234,7 +235,7 @@ PJ_DEF(pj_status_t) pjmedia_wav_player_port_create( pj_pool_t *pool,
 	return status;
 
     /* Read the file header plus fmt header only. */
-    size_read = size_to_read = sizeof(wave_hdr) - 8;
+    size_to_read = size_read = sizeof(wave_hdr) - 8;
     status = pj_file_read( fport->fd, &wave_hdr, &size_read);
     if (status != PJ_SUCCESS) {
 	pj_file_close(fport->fd);
@@ -297,7 +298,9 @@ PJ_DEF(pj_status_t) pjmedia_wav_player_port_create( pj_pool_t *pool,
      * fmt header data.
      */
     if (wave_hdr.fmt_hdr.len > 16) {
-	size_to_read = wave_hdr.fmt_hdr.len - 16;
+	PJ_CHECK_OVERFLOW_UINT32_TO_LONG(wave_hdr.fmt_hdr.len - 16,
+		      pj_file_close(fport->fd); return PJMEDIA_ENOTVALIDWAVE;);
+	size_to_read = (pj_off_t)wave_hdr.fmt_hdr.len - 16;
 	status = pj_file_setpos(fport->fd, size_to_read, PJ_SEEK_CUR);
 	if (status != PJ_SUCCESS) {
 	    pj_file_close(fport->fd);
@@ -326,7 +329,10 @@ PJ_DEF(pj_status_t) pjmedia_wav_player_port_create( pj_pool_t *pool,
 	}
 
 	/* Otherwise skip the chunk contents */
+	PJ_CHECK_OVERFLOW_UINT32_TO_LONG(subchunk.len, 
+		      pj_file_close(fport->fd); return PJMEDIA_ENOTVALIDWAVE;);
 	size_to_read = subchunk.len;
+
 	status = pj_file_setpos(fport->fd, size_to_read, PJ_SEEK_CUR);
 	if (status != PJ_SUCCESS) {
 	    pj_file_close(fport->fd);
diff --git a/pjmedia/src/pjmedia/wav_playlist.c b/pjmedia/src/pjmedia/wav_playlist.c
index b74eed39df..4e2c31e0c2 100644
--- a/pjmedia/src/pjmedia/wav_playlist.c
+++ b/pjmedia/src/pjmedia/wav_playlist.c
@@ -419,7 +419,8 @@ PJ_DEF(pj_status_t) pjmedia_wav_playlist_create(pj_pool_t *pool,
     for (index=file_count-1; index>=0; index--) {
 
 	pjmedia_wave_hdr wavehdr;
-	pj_ssize_t size_to_read, size_read;
+	pj_ssize_t size_read;
+	pj_off_t size_to_read;
 
 	/* we end with the last one so we are good to go if still in function*/
 	pj_memcpy(filename, file_list[index].ptr, file_list[index].slen);
@@ -442,7 +443,7 @@ PJ_DEF(pj_status_t) pjmedia_wav_playlist_create(pj_pool_t *pool,
 	    goto on_error;
 	
 	/* Read the file header plus fmt header only. */
-	size_read = size_to_read = sizeof(wavehdr) - 8;
+	size_to_read = size_read = sizeof(wavehdr) - 8;	
 	status = pj_file_read( fport->fd_list[index], &wavehdr, &size_read);
 	if (status != PJ_SUCCESS) {
 	    goto on_error;
@@ -492,7 +493,9 @@ PJ_DEF(pj_status_t) pjmedia_wav_playlist_create(pj_pool_t *pool,
 	 * fmt header data.
 	 */
 	if (wavehdr.fmt_hdr.len > 16) {
-	    size_to_read = wavehdr.fmt_hdr.len - 16;
+	    PJ_CHECK_OVERFLOW_UINT32_TO_LONG(wavehdr.fmt_hdr.len-16,
+			       status = PJMEDIA_ENOTVALIDWAVE; goto on_error;);
+	    size_to_read = (pj_off_t)wavehdr.fmt_hdr.len - 16;
 	    status = pj_file_setpos(fport->fd_list[index], size_to_read, 
 				    PJ_SEEK_CUR);
 	    if (status != PJ_SUCCESS) {
@@ -522,7 +525,10 @@ PJ_DEF(pj_status_t) pjmedia_wav_playlist_create(pj_pool_t *pool,
 	    }
 	    
 	    /* Otherwise skip the chunk contents */
+	    PJ_CHECK_OVERFLOW_UINT32_TO_LONG(subchunk.len, 
+			       status = PJMEDIA_ENOTVALIDWAVE; goto on_error;);
 	    size_to_read = subchunk.len;
+
 	    status = pj_file_setpos(fport->fd_list[index], size_to_read, 
 				    PJ_SEEK_CUR);
 	    if (status != PJ_SUCCESS) {
