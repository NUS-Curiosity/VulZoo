diff --git a/hphp/runtime/ext/apc/ext_apc.cpp b/hphp/runtime/ext/apc/ext_apc.cpp
index 482275b636fdd..97b9678b9b8b7 100644
--- a/hphp/runtime/ext/apc/ext_apc.cpp
+++ b/hphp/runtime/ext/apc/ext_apc.cpp
@@ -95,6 +95,11 @@ ConcurrentTableSharedStore& apc_store() {
   return *static_cast<ConcurrentTableSharedStore*>(vpStore);
 }
 
+bool isKeyInvalid(const String &key) {
+  // T39154441 - check if invalid chars exist
+  return key.find('\0') != -1;
+}
+
 }
 
 //////////////////////////////////////////////////////////////////////
@@ -307,9 +312,14 @@ Variant HHVM_FUNCTION(apc_store,
         return Variant(false);
       }
       Variant v = iter.second();
-      apc_store().set(key.toString(), v, ttl);
-    }
 
+      auto const& strKey = key.toCStrRef();
+      if (isKeyInvalid(strKey)) {
+        throw_invalid_argument("apc key: (contains invalid characters)");
+        return Variant(false);
+      }
+      apc_store().set(strKey, v, ttl);
+    }
     return Variant(ArrayData::Create());
   }
 
@@ -318,6 +328,11 @@ Variant HHVM_FUNCTION(apc_store,
     return Variant(false);
   }
   String strKey = key_or_array.toString();
+
+  if (isKeyInvalid(strKey)) {
+    throw_invalid_argument("apc key: (contains invalid characters)");
+    return Variant(false);
+  }
   apc_store().set(strKey, var, ttl);
   return Variant(true);
 }
@@ -330,6 +345,10 @@ bool HHVM_FUNCTION(apc_store_as_primed_do_not_use,
                    const String& key,
                    const Variant& var) {
   if (!apcExtension::Enable) return false;
+  if (isKeyInvalid(key)) {
+    throw_invalid_argument("apc key: (contains invalid characters)");
+    return false;
+  }
   apc_store().setWithoutTTL(key, var);
   return true;
 }
@@ -353,8 +372,15 @@ Variant HHVM_FUNCTION(apc_add,
         return false;
       }
       Variant v = iter.second();
-      if (!apc_store().add(key.toString(), v, ttl)) {
-        errors.add(key, -1);
+
+      auto const& strKey = key.toCStrRef();
+      if (isKeyInvalid(strKey)) {
+        throw_invalid_argument("apc key: (contains invalid characters)");
+        return false;
+      }
+
+      if (!apc_store().add(strKey, v, ttl)) {
+        errors.add(strKey, -1);
       }
     }
     return errors.toVariant();
@@ -365,6 +391,10 @@ Variant HHVM_FUNCTION(apc_add,
     return false;
   }
   String strKey = key_or_array.toString();
+  if (isKeyInvalid(strKey)) {
+    throw_invalid_argument("apc key: (contains invalid characters)");
+    return false;
+  }
   return apc_store().add(strKey, var, ttl);
 }
 
diff --git a/hphp/test/quick/apc.php b/hphp/test/quick/apc.php
index adf16fc5cc28f..0fa55bc07c4a3 100644
--- a/hphp/test/quick/apc.php
+++ b/hphp/test/quick/apc.php
@@ -61,6 +61,16 @@ function testKeyTypes() {
   }
 }
 
+function testInvalidKeys() {
+    // Reject keys with null bytes
+    apc_add("bar\x00baz", 10);
+    apc_store("test\x00xyz", "hello");
+    apc_store(array("validkey" => "validvalue", "invalid\x00key" => "value"));
+    foreach (array('bar', 'test', 'validkey', 'invalid') as $k) {
+        var_dump(__hhvm_intrinsics\apc_fetch_no_check($k));
+    }
+}
+
 <<__EntryPoint>> function main(): void {
   testApc(array(7, 4, 1776));
   testApc(array("sv0", "sv1"));
@@ -73,4 +83,5 @@ function testKeyTypes() {
   var_dump($b);
 
   testKeyTypes();
+  testInvalidKeys();
 }
diff --git a/hphp/test/quick/apc.php.expectf b/hphp/test/quick/apc.php.expectf
index 8a126229e6915..5e7e322bcb6f6 100644
--- a/hphp/test/quick/apc.php.expectf
+++ b/hphp/test/quick/apc.php.expectf
@@ -72,3 +72,13 @@ string(3) "two"
 Undefined index: 3
 Undefined index: 2
 string(5) "three"
+
+Warning: Invalid argument: apc key: (contains invalid characters)%S
+
+Warning: Invalid argument: apc key: (contains invalid characters)%S
+
+Warning: Invalid argument: apc key: (contains invalid characters)%S
+bool(false)
+bool(false)
+string(10) "validvalue"
+bool(false)
