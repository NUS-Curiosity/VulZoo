diff --git a/.vscode/settings.json b/.vscode/settings.json
new file mode 100644
index 0000000..3948809
--- /dev/null
+++ b/.vscode/settings.json
@@ -0,0 +1,5 @@
+{
+    "files.associations": {
+        "*.json": "jsonc"
+    }
+}
\ No newline at end of file
diff --git a/README.md b/README.md
index 4c25284..29036f1 100644
--- a/README.md
+++ b/README.md
@@ -32,10 +32,14 @@ The following examples are provided in the examples directory:
 
 ## Change Log
 
+### 1.0.1
+- add ts linting to the project
+- add example for using gs++ as validation source
+
 ### 1.0.0
 - ported validator from slpjs 0.21.3
 - store cached transactions as buffer instead of a string
-- Add max cache size parameters in ValidatorType1 constructor
+- add max cache size parameters in ValidatorType1 constructor
 
 
 
diff --git a/lib/crypto.ts b/lib/crypto.ts
index 1bc8d35..0243425 100644
--- a/lib/crypto.ts
+++ b/lib/crypto.ts
@@ -1,9 +1,9 @@
-import * as crypto from 'crypto';
+import * as crypto from "crypto";
 
 export class Crypto {
-    static hash256(message: Buffer): Buffer { 
-        let hash1 = crypto.createHash('sha256');
-        let hash2 = crypto.createHash('sha256');
+    public static hash256(message: Buffer): Buffer {
+        const hash1 = crypto.createHash("sha256");
+        const hash2 = crypto.createHash("sha256");
         hash1.update(message);
         hash2.update(hash1.digest());
         return Buffer.from(hash2.digest().toJSON().data.reverse());
diff --git a/lib/script.ts b/lib/script.ts
index 8c6e72f..49d283e 100644
--- a/lib/script.ts
+++ b/lib/script.ts
@@ -5,7 +5,7 @@ export class Script {
         OP_PUSHDATA1: 76,
         OP_PUSHDATA2: 77,
         OP_PUSHDATA4: 78,
-        OP_1NEGATE : 79,
+        OP_1NEGATE: 79,
         OP_RETURN: 106,
     }
 }
\ No newline at end of file
diff --git a/lib/slp.ts b/lib/slp.ts
index c524443..f1fcb90 100644
--- a/lib/slp.ts
+++ b/lib/slp.ts
@@ -1,17 +1,17 @@
-import { Script } from './script';
+import { Script } from "./script";
 
-import Big from 'big.js';
+import Big from "big.js";
 
 export enum SlpTransactionType {
-    "GENESIS" = "GENESIS", 
-    "MINT" = "MINT", 
-    "SEND" = "SEND"
+    "GENESIS" = "GENESIS",
+    "MINT" = "MINT",
+    "SEND" = "SEND",
 }
 
 export enum SlpVersionType {
     "TokenVersionType1" = 1,
     "TokenVersionType1_NFT_Child" = 65,
-    "TokenVersionType1_NFT_Parent" = 129
+    "TokenVersionType1_NFT_Parent" = 129,
 }
 
 export interface SlpTransactionDetails {
@@ -21,7 +21,7 @@ export interface SlpTransactionDetails {
     timestamp?: string;
     symbol: string;
     name: string;
-    documentUri: string|Buffer; 
+    documentUri: string|Buffer;
     documentSha256: Buffer|null;
     decimals: number;
     containsBaton: boolean;
@@ -31,142 +31,153 @@ export interface SlpTransactionDetails {
 }
 
 export interface PushDataOperation {
-    opcode: number, 
-    data: Buffer|null
+    opcode: number;
+    data: Buffer|null;
 }
 
 export class Slp {
 
-    static get lokadIdHex() { return "534c5000" }
+    static get lokadIdHex() { return "534c5000"; }
 
     // get list of data chunks resulting from data push operations
-    static parseOpReturnToChunks(script: Buffer, allow_op_0=false, allow_op_number=false) {
+    public static parseOpReturnToChunks(script: Buffer, allowOP_0= false, allowOP_number= false) {
         // """Extract pushed bytes after opreturn. Returns list of bytes() objects,
         // one per push.
         let ops: PushDataOperation[];
-    
+
         // Strict refusal of non-push opcodes; bad scripts throw OpreturnError."""
         try {
             ops = this.getScriptOperations(script);
-        } catch(e) {
-            //console.log(e);
-            throw Error('Script error');
+        } catch (e) {
+            // console.log(e);
+            throw Error("Script error");
         }
 
-        if(ops[0].opcode !== Script.opcodes.OP_RETURN)
-            throw Error('No OP_RETURN');
-        let chunks: (Buffer|null)[] = [];
+        if (ops[0].opcode !== Script.opcodes.OP_RETURN) {
+            throw Error("No OP_RETURN");
+        }
+        const chunks: Array<Buffer|null> = [];
         ops.slice(1).forEach(opitem => {
-            if(opitem.opcode > Script.opcodes.OP_16)
+            if (opitem.opcode > Script.opcodes.OP_16) {
                 throw Error("Non-push opcode");
-            if(opitem.opcode > Script.opcodes.OP_PUSHDATA4) {
-                if(opitem.opcode === 80)
-                    throw Error('Non-push opcode');
-                if(!allow_op_number)
-                    throw Error('OP_1NEGATE to OP_16 not allowed');
-                if(opitem.opcode === Script.opcodes.OP_1NEGATE)
+            }
+            if (opitem.opcode > Script.opcodes.OP_PUSHDATA4) {
+                if (opitem.opcode === 80) {
+                    throw Error("Non-push opcode");
+                }
+                if (!allowOP_number) {
+                    throw Error("OP_1NEGATE to OP_16 not allowed");
+                }
+                if (opitem.opcode === Script.opcodes.OP_1NEGATE) {
                     opitem.data = Buffer.from([0x81]);
-                else // OP_1 - OP_16
+                } else { // OP_1 - OP_16
                     opitem.data = Buffer.from([opitem.opcode - 80]);
+                }
             }
-            if(opitem.opcode === Script.opcodes.OP_0 && !allow_op_0){
-                throw Error('OP_0 not allowed');
+            if (opitem.opcode === Script.opcodes.OP_0 && !allowOP_0) {
+                throw Error("OP_0 not allowed");
             }
-            chunks.push(opitem.data)
+            chunks.push(opitem.data);
         });
-        //console.log(chunks);
-        return chunks
-    }
-
-    static parseChunkToInt(intBytes: Buffer, minByteLen: number, maxByteLen: number, raise_on_Null = false) {
-        // # Parse data as unsigned-big-endian encoded integer.
-        // # For empty data different possibilities may occur:
-        // #      minByteLen <= 0 : return 0
-        // #      raise_on_Null == False and minByteLen > 0: return None
-        // #      raise_on_Null == True and minByteLen > 0:  raise SlpInvalidOutputMessage
-        if(intBytes.length >= minByteLen && intBytes.length <= maxByteLen)
-            return intBytes.readUIntBE(0, intBytes.length)
-        if(intBytes.length === 0 && !raise_on_Null)
-            return null;
-        throw Error('Field has wrong length');
+        // console.log(chunks);
+        return chunks;
     }
 
-    static parseSlpOutputScript(outputScript: Buffer): SlpTransactionDetails {
-        let slpMsg = <SlpTransactionDetails>{};
-        let chunks: (Buffer|null)[];
+    public static parseSlpOutputScript(outputScript: Buffer): SlpTransactionDetails {
+        const slpMsg = {} as SlpTransactionDetails;
+        let chunks: Array<Buffer|null>;
         try {
             chunks = this.parseOpReturnToChunks(outputScript);
-        } catch(e) {
-            throw Error('Bad OP_RETURN');
+        } catch (e) {
+            throw Error("Bad OP_RETURN");
+        }
+        if (chunks.length === 0) {
+            throw Error("Empty OP_RETURN");
+        }
+        if (!chunks[0]) {
+            throw Error("Not SLP");
         }
-        if(chunks.length === 0)
-            throw Error('Empty OP_RETURN');
-        if(!chunks[0])
-            throw Error("Not SLP")
-        if(!chunks[0]!.equals(Buffer.from(this.lokadIdHex, 'hex')))
-            throw Error('Not SLP');
-        if(chunks.length === 1)
+        if (!chunks[0]!.equals(Buffer.from(this.lokadIdHex, "hex"))) {
+            throw Error("Not SLP");
+        }
+        if (chunks.length === 1) {
             throw Error("Missing token versionType");
+        }
         // # check if the token version is supported
-        if(!chunks[1])
-            throw Error("Bad versionType buffer")
-        slpMsg.versionType = <SlpVersionType>Slp.parseChunkToInt(chunks[1]!, 1, 2, true);
-        let supportedTypes = [   
-                SlpVersionType.TokenVersionType1, 
+        if (!chunks[1]) {
+            throw Error("Bad versionType buffer");
+        }
+        slpMsg.versionType = (Slp.parseChunkToInt(chunks[1]!, 1, 2, true) as SlpVersionType);
+        const supportedTypes = [
+                SlpVersionType.TokenVersionType1,
                 SlpVersionType.TokenVersionType1_NFT_Parent,
                 SlpVersionType.TokenVersionType1_NFT_Child ];
-        if(!supportedTypes.includes(slpMsg.versionType))
-            throw Error('Unsupported token type: ' + slpMsg.versionType);
-        if(chunks.length === 2)
-            throw Error('Missing SLP transaction type');
+        if (!supportedTypes.includes(slpMsg.versionType)) {
+            throw Error("Unsupported token type: " + slpMsg.versionType);
+        }
+        if (chunks.length === 2) {
+            throw Error("Missing SLP transaction type");
+        }
         try {
-            let msgType: string = chunks[2]!.toString('ascii')
-            slpMsg.transactionType = SlpTransactionType[msgType as keyof typeof SlpTransactionType]
-        } catch(_){
-            throw Error('Bad transaction type');
+            const msgType: string = chunks[2]!.toString("latin1");
+            slpMsg.transactionType = SlpTransactionType[msgType as keyof typeof SlpTransactionType];
+        } catch (_) {
+            throw Error("Bad transaction type");
         }
-        if(slpMsg.transactionType === SlpTransactionType.GENESIS) {
-            if(chunks.length !== 10)
-                throw Error('GENESIS with incorrect number of parameters');
-            slpMsg.symbol = chunks[3] ? chunks[3]!.toString('utf8') : '';
-            slpMsg.name = chunks[4] ? chunks[4]!.toString('utf8') : '';
-            slpMsg.documentUri = chunks[5] ? chunks[5]!.toString('utf8') : '';
+        if (slpMsg.transactionType === SlpTransactionType.GENESIS) {
+            if (chunks.length !== 10) {
+                throw Error("GENESIS with incorrect number of parameters");
+            }
+            slpMsg.symbol = chunks[3] ? chunks[3]!.toString("utf8") : "";
+            slpMsg.name = chunks[4] ? chunks[4]!.toString("utf8") : "";
+            slpMsg.documentUri = chunks[5] ? chunks[5]!.toString("utf8") : "";
             slpMsg.documentSha256 = chunks[6] ? chunks[6] : null;
-            if(slpMsg.documentSha256) {
-                if(slpMsg.documentSha256.length !== 0 && slpMsg.documentSha256.length !== 32)
-                    throw Error('Token document hash is incorrect length');
+            if (slpMsg.documentSha256) {
+                if (slpMsg.documentSha256.length !== 0 && slpMsg.documentSha256.length !== 32) {
+                    throw Error("Token document hash is incorrect length");
+                }
+            }
+            if (!chunks[7]) {
+                throw Error("Bad decimals buffer");
+            }
+            slpMsg.decimals = (Slp.parseChunkToInt(chunks[7]!, 1, 1, true) as number);
+            if (slpMsg.versionType === 0x41 && slpMsg.decimals !== 0) {
+                throw Error("NFT1 child token must have divisibility set to 0 decimal places.");
+            }
+            if (slpMsg.decimals > 9) {
+                throw Error("Too many decimals");
             }
-            if(!chunks[7])
-                throw Error("Bad decimals buffer")
-            slpMsg.decimals = <number>Slp.parseChunkToInt(chunks[7]!, 1, 1, true);
-            if(slpMsg.versionType === 0x41 && slpMsg.decimals !== 0)
-                throw Error('NFT1 child token must have divisibility set to 0 decimal places.')
-            if(slpMsg.decimals > 9)
-                throw Error('Too many decimals')
             slpMsg.batonVout = chunks[8] ? Slp.parseChunkToInt(chunks[8]!, 1, 1) : null;
-            if(slpMsg.batonVout !== null) {
-                if (slpMsg.batonVout < 2)
-                    throw Error('Mint baton cannot be on vout=0 or 1');
+            if (slpMsg.batonVout !== null) {
+                if (slpMsg.batonVout < 2) {
+                    throw Error("Mint baton cannot be on vout=0 or 1");
+                }
                 slpMsg.containsBaton = true;
             }
-            if(slpMsg.versionType === 0x41 && slpMsg.batonVout !== null)
-                throw Error("NFT1 child token must not have a minting baton!")
-            if(!chunks[9])
-                throw Error("Bad Genesis quantity buffer")
-            if(chunks[9]!.length !== 8)
-                throw Error("Genesis quantity must be provided as an 8-byte buffer")
-            slpMsg.genesisOrMintQuantity = this.buffer2BigNumber(chunks[9]!);                
-            if(slpMsg.versionType === 0x41 && !slpMsg.genesisOrMintQuantity.eq(1))
-                throw Error("NFT1 child token must have GENESIS quantity of 1.")
-        }
-        else if(slpMsg.transactionType === SlpTransactionType.SEND) {
-            if(chunks.length < 4)
-                throw Error('SEND with too few parameters');
-            if(!chunks[3])
-                throw Error("Bad tokenId buffer")
-            if(chunks[3]!.length !== 32)
-                throw Error('token_id is wrong length');
-            slpMsg.tokenIdHex = chunks[3]!.toString('hex');
+            if (slpMsg.versionType === 0x41 && slpMsg.batonVout !== null) {
+                throw Error("NFT1 child token must not have a minting baton!");
+            }
+            if (!chunks[9]) {
+                throw Error("Bad Genesis quantity buffer");
+            }
+            if (chunks[9]!.length !== 8) {
+                throw Error("Genesis quantity must be provided as an 8-byte buffer");
+            }
+            slpMsg.genesisOrMintQuantity = this.buffer2BigNumber(chunks[9]!);
+            if (slpMsg.versionType === 0x41 && !slpMsg.genesisOrMintQuantity.eq(1)) {
+                throw Error("NFT1 child token must have GENESIS quantity of 1.");
+            }
+        } else if (slpMsg.transactionType === SlpTransactionType.SEND) {
+            if (chunks.length < 4) {
+                throw Error("SEND with too few parameters");
+            }
+            if (!chunks[3]) {
+                throw Error("Bad tokenId buffer");
+            }
+            if (chunks[3]!.length !== 32) {
+                throw Error("token_id is wrong length");
+            }
+            slpMsg.tokenIdHex = chunks[3]!.toString("hex");
             // # Note that we put an explicit 0 for  ['token_output'][0] since it
             // # corresponds to vout=0, which is the OP_RETURN tx output.
             // # ['token_output'][1] is the first token output given by the SLP
@@ -175,93 +186,118 @@ export class Slp {
             slpMsg.sendOutputs = [];
             slpMsg.sendOutputs.push(new Big(0));
             chunks.slice(4).forEach(chunk => {
-                if(!chunk)
-                    throw Error("Bad send quantity buffer.")
-                if(chunk.length !== 8)
-                    throw Error('SEND quantities must be 8-bytes each.');
+                if (!chunk) {
+                    throw Error("Bad send quantity buffer.");
+                }
+                if (chunk.length !== 8) {
+                    throw Error("SEND quantities must be 8-bytes each.");
+                }
                 slpMsg.sendOutputs!.push(this.buffer2BigNumber(chunk));
             });
             // # maximum 19 allowed token outputs, plus 1 for the explicit [0] we inserted.
-            if(slpMsg.sendOutputs.length < 2)
-                throw Error('Missing output amounts');
-            if(slpMsg.sendOutputs.length > 20)
-                throw Error('More than 19 output amounts');
-        }
-        else if(slpMsg.transactionType === SlpTransactionType.MINT) {
-            if(slpMsg.versionType === 0x41)
-                throw Error("NFT1 Child cannot have MINT transaction type.")
-            if(chunks.length != 6)
-                throw Error('MINT with incorrect number of parameters');
-            if(!chunks[3])
+            if (slpMsg.sendOutputs.length < 2) {
+                throw Error("Missing output amounts");
+            }
+            if (slpMsg.sendOutputs.length > 20) {
+                throw Error("More than 19 output amounts");
+            }
+        } else if (slpMsg.transactionType === SlpTransactionType.MINT) {
+            if (slpMsg.versionType === 0x41) {
+                throw Error("NFT1 Child cannot have MINT transaction type.");
+            }
+            if (chunks.length !== 6) {
+                throw Error("MINT with incorrect number of parameters");
+            }
+            if (!chunks[3]) {
                 throw Error("Bad token_id buffer");
-            if(chunks[3]!.length != 32)
-                throw Error('token_id is wrong length');
-            slpMsg.tokenIdHex = chunks[3]!.toString('hex');
-            slpMsg.batonVout = chunks[4] ? Slp.parseChunkToInt(chunks[4]!,1,1) : null;
-            if(slpMsg.batonVout !== null && slpMsg.batonVout !== undefined) {
-                if(slpMsg.batonVout < 2)
-                    throw Error('Mint baton cannot be on vout=0 or 1');
+            }
+            if (chunks[3]!.length !== 32) {
+                throw Error("token_id is wrong length");
+            }
+            slpMsg.tokenIdHex = chunks[3]!.toString("hex");
+            slpMsg.batonVout = chunks[4] ? Slp.parseChunkToInt(chunks[4]!, 1, 1) : null;
+            if (slpMsg.batonVout !== null && slpMsg.batonVout !== undefined) {
+                if (slpMsg.batonVout < 2) {
+                    throw Error("Mint baton cannot be on vout=0 or 1");
+                }
                 slpMsg.containsBaton = true;
             }
-            if(!chunks[5])
-                throw Error("Bad Mint quantity buffer")
-            if(chunks[5]!.length !== 8)
-                throw Error("Mint quantity must be provided as an 8-byte buffer")
+            if (!chunks[5]) {
+                throw Error("Bad Mint quantity buffer");
+            }
+            if (chunks[5]!.length !== 8) {
+                throw Error("Mint quantity must be provided as an 8-byte buffer");
+            }
             slpMsg.genesisOrMintQuantity = this.buffer2BigNumber(chunks[5]!);
-        }
-        else
+        } else {
             throw Error("Bad transaction type");
+ }
 
-        if(!slpMsg.genesisOrMintQuantity && (!slpMsg.sendOutputs || slpMsg.sendOutputs.length === 0))
+        if (!slpMsg.genesisOrMintQuantity && (!slpMsg.sendOutputs || slpMsg.sendOutputs.length === 0)) {
             throw Error("SLP message must have either Genesis/Mint outputs or Send outputs, both are missing");
+        }
 
         return slpMsg;
     }
 
-    static buffer2BigNumber(amount: Buffer): Big {
-        if(amount.length < 5 || amount.length > 8)
+    public static parseChunkToInt(intBytes: Buffer, minByteLen: number, maxByteLen: number, raiseOnNull = false) {
+        // # Parse data as unsigned-big-endian encoded integer.
+        // # For empty data different possibilities may occur:
+        // #      minByteLen <= 0 : return 0
+        // #      raise_on_Null == False and minByteLen > 0: return None
+        // #      raise_on_Null == True and minByteLen > 0:  raise SlpInvalidOutputMessage
+        if (intBytes.length >= minByteLen && intBytes.length <= maxByteLen) {
+            return intBytes.readUIntBE(0, intBytes.length);
+        }
+        if (intBytes.length === 0 && !raiseOnNull) {
+            return null;
+        }
+        throw Error("Field has wrong length");
+    }
+
+    public static buffer2BigNumber(amount: Buffer): Big {
+        if (amount.length < 5 || amount.length > 8) {
             throw Error("Buffer must be between 4-8 bytes in length");
-        return (new Big(amount.readUInt32BE(0).toString())).times(2**32).plus(amount.readUInt32BE(4).toString());
+        }
+        return (new Big(amount.readUInt32BE(0).toString())).times(2 ** 32).plus(amount.readUInt32BE(4).toString());
     }
 
     // Get a list of operations with accompanying push data (if a push opcode)
-    static getScriptOperations(script: Buffer) {
-        let ops: PushDataOperation[] = [];
+    public static getScriptOperations(script: Buffer) {
+        const ops: PushDataOperation[] = [];
         try {
             let n = 0;
             let dlen: number;
             while (n < script.length) {
-                let op: PushDataOperation = { opcode: script[n], data: null }
+                const op: PushDataOperation = { opcode: script[n], data: null };
                 n += 1;
-                if(op.opcode <= Script.opcodes.OP_PUSHDATA4) {
-                    if(op.opcode < Script.opcodes.OP_PUSHDATA1)
+                if (op.opcode <= Script.opcodes.OP_PUSHDATA4) {
+                    if (op.opcode < Script.opcodes.OP_PUSHDATA1) {
                         dlen = op.opcode;
-                    else if(op.opcode === Script.opcodes.OP_PUSHDATA1) {
+                    } else if (op.opcode === Script.opcodes.OP_PUSHDATA1) {
                         dlen = script[n];
                         n += 1;
-                    }
-                    else if(op.opcode === Script.opcodes.OP_PUSHDATA2) {
-                        dlen = script.slice(n, n + 2).readUIntLE(0,2);
+                    } else if (op.opcode === Script.opcodes.OP_PUSHDATA2) {
+                        dlen = script.slice(n, n + 2).readUIntLE(0, 2);
                         n += 2;
-                    }
-                    else {
-                        dlen = script.slice(n, n + 4).readUIntLE(0,4);
+                    } else {
+                        dlen = script.slice(n, n + 4).readUIntLE(0, 4);
                         n += 4;
                     }
-                    if((n + dlen) > script.length) {
-                        throw Error('IndexError');
+                    if ((n + dlen) > script.length) {
+                        throw Error("IndexError");
                     }
-                    if(dlen > 0)
+                    if (dlen > 0) {
                         op.data = script.slice(n, n + dlen);
-                    n += dlen
+                    }
+                    n += dlen;
                 }
                 ops.push(op);
             }
-        } catch(e) {
-            //console.log(e);
-            throw Error('truncated script')
+        } catch (e) {
+            // console.log(e);
+            throw Error("truncated script");
         }
         return ops;
     }
- 
 }
diff --git a/package-lock.json b/package-lock.json
index d8480d3..07d0b69 100644
--- a/package-lock.json
+++ b/package-lock.json
@@ -1,6 +1,6 @@
 {
   "name": "slp-validate",
-  "version": "1.0.0",
+  "version": "1.0.1",
   "lockfileVersion": 1,
   "requires": true,
   "dependencies": {
@@ -763,6 +763,12 @@
       "integrity": "sha512-mBBwmeGTrxEMO4pMaaf/uUEFHnYtwr8FTe8Y/mer4rcV/bye0qGm6pw1bGZFGStxC5O76c5ZAVBGnqHmOaJpdQ==",
       "dev": true
     },
+    "get-caller-file": {
+      "version": "1.0.3",
+      "resolved": "https://registry.npmjs.org/get-caller-file/-/get-caller-file-1.0.3.tgz",
+      "integrity": "sha512-3t6rVToeoZfYSGd8YoLFR2DJkiQrIiUrGcjvFX2mDw3bn6k2OtwHN0TNCLbBO+w8qTvimhDkv+LSscbJY1vE6w==",
+      "dev": true
+    },
     "glob": {
       "version": "7.1.2",
       "resolved": "https://registry.npmjs.org/glob/-/glob-7.1.2.tgz",
@@ -2095,6 +2101,16 @@
         "supports-color": "5.4.0"
       }
     },
+    "mock-require": {
+      "version": "3.0.3",
+      "resolved": "https://registry.npmjs.org/mock-require/-/mock-require-3.0.3.tgz",
+      "integrity": "sha512-lLzfLHcyc10MKQnNUCv7dMcoY/2Qxd6wJfbqCcVk3LDb8An4hF6ohk5AztrvgKhJCqj36uyzi/p5se+tvyD+Wg==",
+      "dev": true,
+      "requires": {
+        "get-caller-file": "^1.0.2",
+        "normalize-path": "^2.1.1"
+      }
+    },
     "module-deps": {
       "version": "6.2.1",
       "resolved": "https://registry.npmjs.org/module-deps/-/module-deps-6.2.1.tgz",
@@ -2130,6 +2146,15 @@
       "integrity": "sha512-INOFj37C7k3AfaNTtX8RhsTw7qRy7eLET14cROi9+5HAVbbHuIWUHEauBv5qT4Av2tWasiTY1Jw6puUNqRJXQg==",
       "dev": true
     },
+    "normalize-path": {
+      "version": "2.1.1",
+      "resolved": "https://registry.npmjs.org/normalize-path/-/normalize-path-2.1.1.tgz",
+      "integrity": "sha1-GrKLVW4Zg2Oowab35vogE3/mrtk=",
+      "dev": true,
+      "requires": {
+        "remove-trailing-separator": "^1.0.1"
+      }
+    },
     "number-is-nan": {
       "version": "1.0.1",
       "resolved": "https://registry.npmjs.org/number-is-nan/-/number-is-nan-1.0.1.tgz",
@@ -2377,6 +2402,12 @@
         }
       }
     },
+    "remove-trailing-separator": {
+      "version": "1.1.0",
+      "resolved": "https://registry.npmjs.org/remove-trailing-separator/-/remove-trailing-separator-1.1.0.tgz",
+      "integrity": "sha1-wkvOKig62tW8P1jg1IJJuSN52O8=",
+      "dev": true
+    },
     "resolve": {
       "version": "1.12.0",
       "resolved": "https://registry.npmjs.org/resolve/-/resolve-1.12.0.tgz",
@@ -2601,6 +2632,23 @@
       "integrity": "sha1-hnrHTjhkGHsdPUfZlqeOxciDB3c=",
       "dev": true
     },
+    "typescript": {
+      "version": "3.6.4",
+      "resolved": "https://registry.npmjs.org/typescript/-/typescript-3.6.4.tgz",
+      "integrity": "sha512-unoCll1+l+YK4i4F8f22TaNVPRHcD9PA3yCuZ8g5e0qGqlVlJ/8FSateOLLSagn+Yg5+ZwuPkL8LFUc0Jcvksg==",
+      "dev": true
+    },
+    "typescript-tslint-plugin": {
+      "version": "0.5.4",
+      "resolved": "https://registry.npmjs.org/typescript-tslint-plugin/-/typescript-tslint-plugin-0.5.4.tgz",
+      "integrity": "sha512-CQEfGC+p0SoBARI4N2LrGsWJsp4/OE+uKZ68xsWYKHWqMFq4DFQHqOVlK0deEricSN01NmDTqjap63Pw/DHieg==",
+      "dev": true,
+      "requires": {
+        "minimatch": "^3.0.4",
+        "mock-require": "^3.0.2",
+        "vscode-languageserver": "^5.1.0"
+      }
+    },
     "uglify-es": {
       "version": "3.3.9",
       "resolved": "https://registry.npmjs.org/uglify-es/-/uglify-es-3.3.9.tgz",
@@ -2691,6 +2739,44 @@
       "integrity": "sha512-iq+S7vZJE60yejDYM0ek6zg308+UZsdtPExWP9VZoCFCz1zkJoXFnAX7aZfd/ZwrkidzdUZL0C/ryW+JwAiIGw==",
       "dev": true
     },
+    "vscode-jsonrpc": {
+      "version": "4.0.0",
+      "resolved": "https://registry.npmjs.org/vscode-jsonrpc/-/vscode-jsonrpc-4.0.0.tgz",
+      "integrity": "sha512-perEnXQdQOJMTDFNv+UF3h1Y0z4iSiaN9jIlb0OqIYgosPCZGYh/MCUlkFtV2668PL69lRDO32hmvL2yiidUYg==",
+      "dev": true
+    },
+    "vscode-languageserver": {
+      "version": "5.2.1",
+      "resolved": "https://registry.npmjs.org/vscode-languageserver/-/vscode-languageserver-5.2.1.tgz",
+      "integrity": "sha512-GuayqdKZqAwwaCUjDvMTAVRPJOp/SLON3mJ07eGsx/Iq9HjRymhKWztX41rISqDKhHVVyFM+IywICyZDla6U3A==",
+      "dev": true,
+      "requires": {
+        "vscode-languageserver-protocol": "3.14.1",
+        "vscode-uri": "^1.0.6"
+      }
+    },
+    "vscode-languageserver-protocol": {
+      "version": "3.14.1",
+      "resolved": "https://registry.npmjs.org/vscode-languageserver-protocol/-/vscode-languageserver-protocol-3.14.1.tgz",
+      "integrity": "sha512-IL66BLb2g20uIKog5Y2dQ0IiigW0XKrvmWiOvc0yXw80z3tMEzEnHjaGAb3ENuU7MnQqgnYJ1Cl2l9RvNgDi4g==",
+      "dev": true,
+      "requires": {
+        "vscode-jsonrpc": "^4.0.0",
+        "vscode-languageserver-types": "3.14.0"
+      }
+    },
+    "vscode-languageserver-types": {
+      "version": "3.14.0",
+      "resolved": "https://registry.npmjs.org/vscode-languageserver-types/-/vscode-languageserver-types-3.14.0.tgz",
+      "integrity": "sha512-lTmS6AlAlMHOvPQemVwo3CezxBp0sNB95KNPkqp3Nxd5VFEnuG1ByM0zlRWos0zjO3ZWtkvhal0COgiV1xIA4A==",
+      "dev": true
+    },
+    "vscode-uri": {
+      "version": "1.0.8",
+      "resolved": "https://registry.npmjs.org/vscode-uri/-/vscode-uri-1.0.8.tgz",
+      "integrity": "sha512-obtSWTlbJ+a+TFRYGaUumtVwb+InIUVI0Lu0VBUAPmj2cU5JutEXg3xUE0c2J5Tcy7h2DEKVJBFi+Y9ZSFzzPQ==",
+      "dev": true
+    },
     "window-size": {
       "version": "0.1.4",
       "resolved": "https://registry.npmjs.org/window-size/-/window-size-0.1.4.tgz",
diff --git a/package.json b/package.json
index ae005bf..73b6fe4 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "slp-validate",
-  "version": "1.0.0",
+  "version": "1.0.1",
   "description": "SLP transaction validator",
   "main": "index.js",
   "files": [
@@ -29,6 +29,8 @@
     "grpc-slp-graphsearch-node": "^0.0.1",
     "browserify": "^16.2.2",
     "uglify-es": "^3.3.9",
-    "mkdirp": "^0.5.1"
+    "mkdirp": "^0.5.1",
+    "typescript-tslint-plugin": "^0.5.4",
+    "typescript": "^3.6.4"
   }
 }
diff --git a/tsconfig.json b/tsconfig.json
index 39d0d42..cdf8806 100644
--- a/tsconfig.json
+++ b/tsconfig.json
@@ -7,6 +7,9 @@
     "sourceMap": true,                     /* Generates corresponding '.map' file. */
     "downlevelIteration": true,             /* Provide full support for iterables in 'for-of', spread, and destructuring when targeting 'ES5' or 'ES3'. */
     "strict": true,                         /* Enable all strict type-checking options. */
-    "esModuleInterop": true                 /* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies 'allowSyntheticDefaultImports'. */
+    "esModuleInterop": true,                 /* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies 'allowSyntheticDefaultImports'. */
+    "plugins": [
+      { "name": "typescript-tslint-plugin" }
+    ]
   }
 }
diff --git a/tslint.json b/tslint.json
new file mode 100644
index 0000000..f9c8687
--- /dev/null
+++ b/tslint.json
@@ -0,0 +1,8 @@
+// You can modify the configuration here with your own.
+// Make sure that your json is valid, and if you run into
+// other issues, try checking the console for errors.
+
+{
+    "extends": ["tslint:recommended"],
+    "rules": {} // add additional rules and their configuration
+}
