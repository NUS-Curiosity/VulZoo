{
  "id": "CVE-2022-49290",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2025-02-26T07:01:05.853",
  "lastModified": "2025-02-26T07:01:05.853",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nmac80211: fix potential double free on mesh join\n\nWhile commit 6a01afcf8468 (\"mac80211: mesh: Free ie data when leaving\nmesh\") fixed a memory leak on mesh leave / teardown it introduced a\npotential memory corruption caused by a double free when rejoining the\nmesh:\n\n  ieee80211_leave_mesh()\n  -> kfree(sdata->u.mesh.ie);\n  ...\n  ieee80211_join_mesh()\n  -> copy_mesh_setup()\n     -> old_ie = ifmsh->ie;\n     -> kfree(old_ie);\n\nThis double free / kernel panics can be reproduced by using wpa_supplicant\nwith an encrypted mesh (if set up without encryption via \"iw\" then\nifmsh->ie is always NULL, which avoids this issue). And then calling:\n\n  $ iw dev mesh0 mesh leave\n  $ iw dev mesh0 mesh join my-mesh\n\nNote that typically these commands are not used / working when using\nwpa_supplicant. And it seems that wpa_supplicant or wpa_cli are going\nthrough a NETDEV_DOWN/NETDEV_UP cycle between a mesh leave and mesh join\nwhere the NETDEV_UP resets the mesh.ie to NULL via a memcpy of\ndefault_mesh_setup in cfg80211_netdev_notifier_call, which then avoids\nthe memory corruption, too.\n\nThe issue was first observed in an application which was not using\nwpa_supplicant but \"Senf\" instead, which implements its own calls to\nnl80211.\n\nFixing the issue by removing the kfree()'ing of the mesh IE in the mesh\njoin function and leaving it solely up to the mesh leave to free the\nmesh IE."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: mac80211: arregla una posible doble liberaci\u00f3n al unirse a la malla Si bien el commit 6a01afcf8468 (\"mac80211: mesh: Free ie data when leaving mesh\") corrigi\u00f3 una p\u00e9rdida de memoria al salir/desmontar la malla, introdujo una posible corrupci\u00f3n de memoria causada por una doble liberaci\u00f3n al volver a unirse a la malla: ieee80211_leave_mesh() -&gt; kfree(sdata-&gt;u.mesh.ie); ... ieee80211_join_mesh() -&gt; copy_mesh_setup() -&gt; old_ie = ifmsh-&gt;ie; -&gt; kfree(old_ie); Esta doble liberaci\u00f3n/kernel panics se puede reproducir usando wpa_supplicant con una malla cifrada (si se configura sin cifrado a trav\u00e9s de \"iw\", entonces ifmsh-&gt;ie siempre es NULL, lo que evita este problema). Y luego llamar a: $ iw dev mesh0 mesh leave $ iw dev mesh0 mesh join my-mesh Tenga en cuenta que normalmente estos comandos no se usan/funcionan cuando se usa wpa_supplicant. Y parece que wpa_supplicant o wpa_cli est\u00e1n pasando por un ciclo NETDEV_DOWN/NETDEV_UP entre un mesh leave y un mesh join donde NETDEV_UP restablece mesh.ie a NULL a trav\u00e9s de un memcpy de default_mesh_setup en cfg80211_netdev_notifier_call, que luego tambi\u00e9n evita la corrupci\u00f3n de memoria. El problema se observ\u00f3 por primera vez en una aplicaci\u00f3n que no usaba wpa_supplicant sino \"Senf\", que implementa sus propias llamadas a nl80211. Se solucion\u00f3 el problema eliminando el kfree()'ing del IE de malla en la funci\u00f3n de uni\u00f3n de malla y dejando \u00fanicamente en manos del mesh leave la liberaci\u00f3n del IE de malla."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/12e407a8ef17623823fd0c066fbd7f103953d28d",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/273ebddc5fda2967492cb0b6cdd7d81cfb821b76",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/3bbd0000d012f92aec423b224784fbf0f7bf40f8",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/46bb87d40683337757a2f902fcd4244b32bb4e86",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/4a2d4496e15ea5bb5c8e83b94ca8ca7fb045e7d3",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/582d8c60c0c053684f7138875e8150d5749ffc17",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/5d3ff9542a40ce034416bca03864709540a36016",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/615716af8644813355e014314a0bc1e961250f5a",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/c1d9c3628ef0a0ca197595d0f9e01cd3b5dda186",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}