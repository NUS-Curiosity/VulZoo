{
  "id": "CVE-2024-26846",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-04-17T10:15:10.187",
  "lastModified": "2024-06-25T22:15:23.830",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nnvme-fc: do not wait in vain when unloading module\n\nThe module exit path has race between deleting all controllers and\nfreeing 'left over IDs'. To prevent double free a synchronization\nbetween nvme_delete_ctrl and ida_destroy has been added by the initial\ncommit.\n\nThere is some logic around trying to prevent from hanging forever in\nwait_for_completion, though it does not handling all cases. E.g.\nblktests is able to reproduce the situation where the module unload\nhangs forever.\n\nIf we completely rely on the cleanup code executed from the\nnvme_delete_ctrl path, all IDs will be freed eventually. This makes\ncalling ida_destroy unnecessary. We only have to ensure that all\nnvme_delete_ctrl code has been executed before we leave\nnvme_fc_exit_module. This is done by flushing the nvme_delete_wq\nworkqueue.\n\nWhile at it, remove the unused nvme_fc_wq workqueue too."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: nvme-fc: no espere en vano al descargar el m\u00f3dulo. La ruta de salida del m\u00f3dulo tiene una carrera entre eliminar todos los controladores y liberar los 'ID sobrantes'. Para evitar la doble liberaci\u00f3n, la confirmaci\u00f3n inicial agreg\u00f3 una sincronizaci\u00f3n entre nvme_delete_ctrl e ida_destroy. Existe cierta l\u00f3gica al tratar de evitar que se cuelgue para siempre en wait_for_completion, aunque no maneja todos los casos. Por ejemplo, blktests puede reproducir la situaci\u00f3n en la que la descarga del m\u00f3dulo se bloquea para siempre. Si confiamos completamente en el c\u00f3digo de limpieza ejecutado desde la ruta nvme_delete_ctrl, eventualmente se liberar\u00e1n todas las ID. Esto hace que llamar a ida_destroy sea innecesario. Solo tenemos que asegurarnos de que todo el c\u00f3digo nvme_delete_ctrl se haya ejecutado antes de salir de nvme_fc_exit_module. Esto se hace vaciando la cola de trabajo nvme_delete_wq. Mientras lo hace, elimine tambi\u00e9n la cola de trabajo nvme_fc_wq no utilizada."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/085195aa90a924c79e35569bcdad860d764a8e17",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/0bf567d6d9ffe09e059bbdfb4d07143cef42c75c",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/4f2c95015ec2a1899161be6c0bdaecedd5a7bfb2",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/70fbfc47a392b98e5f8dba70c6efc6839205c982",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/baa6b7eb8c66486bd64608adc63fe03b30d3c0b9",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/c0882c366418bf9c19e1ba7f270fe377a9bf5d67",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}