{
  "id": "CVE-2024-39483",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-07-05T07:15:10.767",
  "lastModified": "2024-07-05T12:55:51.367",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: SVM: WARN on vNMI + NMI window iff NMIs are outright masked\n\nWhen requesting an NMI window, WARN on vNMI support being enabled if and\nonly if NMIs are actually masked, i.e. if the vCPU is already handling an\nNMI.  KVM's ABI for NMIs that arrive simultanesouly (from KVM's point of\nview) is to inject one NMI and pend the other.  When using vNMI, KVM pends\nthe second NMI simply by setting V_NMI_PENDING, and lets the CPU do the\nrest (hardware automatically sets V_NMI_BLOCKING when an NMI is injected).\n\nHowever, if KVM can't immediately inject an NMI, e.g. because the vCPU is\nin an STI shadow or is running with GIF=0, then KVM will request an NMI\nwindow and trigger the WARN (but still function correctly).\n\nWhether or not the GIF=0 case makes sense is debatable, as the intent of\nKVM's behavior is to provide functionality that is as close to real\nhardware as possible.  E.g. if two NMIs are sent in quick succession, the\nprobability of both NMIs arriving in an STI shadow is infinitesimally low\non real hardware, but significantly larger in a virtual environment, e.g.\nif the vCPU is preempted in the STI shadow.  For GIF=0, the argument isn't\nas clear cut, because the window where two NMIs can collide is much larger\nin bare metal (though still small).\n\nThat said, KVM should not have divergent behavior for the GIF=0 case based\non whether or not vNMI support is enabled.  And KVM has allowed\nsimultaneous NMIs with GIF=0 for over a decade, since commit 7460fb4a3400\n(\"KVM: Fix simultaneous NMIs\").  I.e. KVM's GIF=0 handling shouldn't be\nmodified without a *really* good reason to do so, and if KVM's behavior\nwere to be modified, it should be done irrespective of vNMI support."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: KVM: SVM: WARN en la ventana vNMI + NMI si los NMI est\u00e1n completamente enmascarados Al solicitar una ventana NMI, WARN en la ventana de vNMI est\u00e1 habilitado si y solo si los NMI est\u00e1n realmente enmascarados, es decir, si la vCPU ya est\u00e1 manejando una NMI. La ABI de KVM para NMI que llegan simult\u00e1neamente (desde el punto de vista de KVM) es inyectar un NMI y esperar el otro. Cuando se usa vNMI, KVM suspende el segundo NMI simplemente configurando V_NMI_PENDING y deja que la CPU haga el resto (el hardware configura autom\u00e1ticamente V_NMI_BLOCKING cuando se inyecta un NMI). Sin embargo, si KVM no puede inyectar inmediatamente una NMI, por ejemplo, porque la vCPU est\u00e1 en una sombra STI o se est\u00e1 ejecutando con GIF=0, entonces KVM solicitar\u00e1 una ventana NMI y activar\u00e1 el WARN (pero seguir\u00e1 funcionando correctamente). Es discutible si el caso GIF=0 tiene sentido o no, ya que la intenci\u00f3n del comportamiento de KVM es proporcionar una funcionalidad lo m\u00e1s cercana posible al hardware real. Por ejemplo, si se env\u00edan dos NMI en r\u00e1pida sucesi\u00f3n, la probabilidad de que ambos NMI lleguen a una sombra de STI es infinitamente baja en hardware real, pero significativamente mayor en un entorno virtual, por ejemplo, si la vCPU tiene prioridad en la sombra de STI. Para GIF=0, el argumento no es tan claro, porque la ventana donde dos NMI pueden colisionar es mucho mayor en el metal desnudo (aunque a\u00fan es peque\u00f1a). Dicho esto, KVM no deber\u00eda tener un comportamiento divergente para el caso GIF=0 en funci\u00f3n de si la compatibilidad con vNMI est\u00e1 habilitada o no. Y KVM ha permitido NMI simult\u00e1neas con GIF=0 durante m\u00e1s de una d\u00e9cada, desde el commit 7460fb4a3400 (\"KVM: Reparar NMI simult\u00e1neas\"). Es decir, el manejo de GIF=0 de KVM no debe modificarse sin una *realmente* buena raz\u00f3n para hacerlo, y si se modifica el comportamiento de KVM, debe hacerse independientemente del soporte de vNMI."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/1d87cf2eba46deaff6142366127f2323de9f84d1",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/b4bd556467477420ee3a91fbcba73c579669edc6",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/f79edaf7370986d73d204b36c50cc563a4c0f356",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}