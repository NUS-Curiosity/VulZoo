{
  "id": "CVE-2024-36935",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-05-30T16:15:16.640",
  "lastModified": "2024-05-30T18:18:58.870",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nice: ensure the copied buf is NUL terminated\n\nCurrently, we allocate a count-sized kernel buffer and copy count bytes\nfrom userspace to that buffer. Later, we use sscanf on this buffer but we\ndon't ensure that the string is terminated inside the buffer, this can lead\nto OOB read when using sscanf. Fix this issue by using memdup_user_nul\ninstead of memdup_user."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se resolvi\u00f3 la siguiente vulnerabilidad: ice: aseg\u00farese de que el buf copiado tenga terminaci\u00f3n NUL. Actualmente, asignamos un b\u00fafer del kernel del tama\u00f1o de un conteo y copiamos el conteo de bytes del espacio de usuario a ese b\u00fafer. M\u00e1s adelante, usamos sscanf en este b\u00fafer pero no nos aseguramos de que la cadena termine dentro del b\u00fafer, esto puede provocar una lectura OOB cuando usamos sscanf. Solucione este problema utilizando memdup_user_nul en lugar de memdup_user."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/5ff4de981983ed84f29b5d92b6550ec054e12a92",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/666854ea9cad844f75a068f32812a2d78004914a",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}