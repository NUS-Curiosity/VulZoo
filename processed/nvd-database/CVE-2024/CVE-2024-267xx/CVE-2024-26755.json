{
  "id": "CVE-2024-26755",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-04-03T17:15:52.103",
  "lastModified": "2024-04-03T17:24:18.150",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nmd: Don't suspend the array for interrupted reshape\n\nmd_start_sync() will suspend the array if there are spares that can be\nadded or removed from conf, however, if reshape is still in progress,\nthis won't happen at all or data will be corrupted(remove_and_add_spares\nwon't be called from md_choose_sync_action for reshape), hence there is\nno need to suspend the array if reshape is not done yet.\n\nMeanwhile, there is a potential deadlock for raid456:\n\n1) reshape is interrupted;\n\n2) set one of the disk WantReplacement, and add a new disk to the array,\n   however, recovery won't start until the reshape is finished;\n\n3) then issue an IO across reshpae position, this IO will wait for\n   reshape to make progress;\n\n4) continue to reshape, then md_start_sync() found there is a spare disk\n   that can be added to conf, mddev_suspend() is called;\n\nStep 4 and step 3 is waiting for each other, deadlock triggered. Noted\nthis problem is found by code review, and it's not reporduced yet.\n\nFix this porblem by don't suspend the array for interrupted reshape,\nthis is safe because conf won't be changed until reshape is done."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: md: No suspender la matriz por remodelaci\u00f3n interrumpida md_start_sync() suspender\u00e1 la matriz si hay repuestos que se pueden agregar o eliminar de conf, sin embargo, si la remodelaci\u00f3n a\u00fan est\u00e1 en marcha progreso, esto no suceder\u00e1 en absoluto o los datos se da\u00f1ar\u00e1n (no se llamar\u00e1 a remove_and_add_spares desde md_choose_sync_action para remodelar), por lo tanto, no hay necesidad de suspender la matriz si la remodelaci\u00f3n a\u00fan no se ha realizado. Mientras tanto, existe un posible punto muerto para raid456: 1) se interrumpe la remodelaci\u00f3n; 2) configure uno de los discos WantReplacement y agregue un nuevo disco a la matriz; sin embargo, la recuperaci\u00f3n no comenzar\u00e1 hasta que finalice la remodelaci\u00f3n; 3) luego emita una IO a trav\u00e9s de la posici\u00f3n de reshpae, esta IO esperar\u00e1 a que la remodelaci\u00f3n avance; 4) contin\u00fae remodelando, luego md_start_sync() encontr\u00f3 que hay un disco de repuesto que se puede agregar a conf, se llama a mddev_suspend(); Los pasos 4 y 3 se esperan el uno al otro y se activa el punto muerto. Observ\u00e9 que este problema se encuentra mediante la revisi\u00f3n del c\u00f3digo y a\u00fan no se ha informado. Solucione este problema al no suspender la matriz durante una remodelaci\u00f3n interrumpida, esto es seguro porque la configuraci\u00f3n no se cambiar\u00e1 hasta que finalice la remodelaci\u00f3n."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/60d6130d0ac1d883ed93c2a1e10aadb60967fd48",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/9e46c70e829bddc24e04f963471e9983a11598b7",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}