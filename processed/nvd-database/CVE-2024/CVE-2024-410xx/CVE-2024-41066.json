{
  "id": "CVE-2024-41066",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-07-29T15:15:14.480",
  "lastModified": "2024-07-29T16:21:52.517",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nibmvnic: Add tx check to prevent skb leak\n\nBelow is a summary of how the driver stores a reference to an skb during\ntransmit:\n    tx_buff[free_map[consumer_index]]->skb = new_skb;\n    free_map[consumer_index] = IBMVNIC_INVALID_MAP;\n    consumer_index ++;\nWhere variable data looks like this:\n    free_map == [4, IBMVNIC_INVALID_MAP, IBMVNIC_INVALID_MAP, 0, 3]\n                                               \tconsumer_index^\n    tx_buff == [skb=null, skb=<ptr>, skb=<ptr>, skb=null, skb=null]\n\nThe driver has checks to ensure that free_map[consumer_index] pointed to\na valid index but there was no check to ensure that this index pointed\nto an unused/null skb address. So, if, by some chance, our free_map and\ntx_buff lists become out of sync then we were previously risking an\nskb memory leak. This could then cause tcp congestion control to stop\nsending packets, eventually leading to ETIMEDOUT.\n\nTherefore, add a conditional to ensure that the skb address is null. If\nnot then warn the user (because this is still a bug that should be\npatched) and free the old pointer to prevent memleak/tcp problems."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se resolvi\u00f3 la siguiente vulnerabilidad: ibmvnic: agregue verificaci\u00f3n de tx para evitar fugas de skb A continuaci\u00f3n se muestra un resumen de c\u00f3mo el controlador almacena una referencia a un skb durante la transmisi\u00f3n: tx_buff[free_map[consumer_index]]-&gt;skb = new_skb ; free_map[consumer_index] = IBMVNIC_INVALID_MAP; consumer_index++; Donde los datos variables se ven as\u00ed: free_map == [4, IBMVNIC_INVALID_MAP, IBMVNIC_INVALID_MAP, 0, 3] consumer_index^ tx_buff == [skb=null, skb=, skb=, skb=null, skb=null ] El controlador tiene comprobaciones para garantizar que free_map[consumer_index] apunte a un \u00edndice v\u00e1lido, pero no hubo ninguna verificaci\u00f3n para garantizar que este \u00edndice apunte a una direcci\u00f3n skb nula o no utilizada. Entonces, si, por casualidad, nuestras listas free_map y tx_buff no est\u00e1n sincronizadas, entonces est\u00e1bamos arriesg\u00e1ndonos a una p\u00e9rdida de memoria skb. Esto podr\u00eda provocar que el control de congesti\u00f3n de TCP deje de enviar paquetes, lo que eventualmente provocar\u00eda ETIMEDOUT. Por lo tanto, agregue un condicional para garantizar que la direcci\u00f3n skb sea nula. De lo contrario, advierta al usuario (porque todav\u00eda es un error que debe corregirse) y libere el puntero antiguo para evitar problemas de memleak/tcp."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/0983d288caf984de0202c66641577b739caad561",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/16ad1557cae582e79bb82dddd612d9bdfaa11d4c",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/267c61c4afed0ff9a2e83462abad3f41d8ca1f06",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/e7b75def33eae61ddaad6cb616c517dc3882eb2a",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}