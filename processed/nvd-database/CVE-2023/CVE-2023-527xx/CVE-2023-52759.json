{
  "id": "CVE-2023-52759",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-05-21T16:15:15.330",
  "lastModified": "2024-05-21T16:53:56.550",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\ngfs2: ignore negated quota changes\n\nWhen lots of quota changes are made, there may be cases in which an\ninode's quota information is increased and then decreased, such as when\nblocks are added to a file, then deleted from it. If the timing is\nright, function do_qc can add pending quota changes to a transaction,\nthen later, another call to do_qc can negate those changes, resulting\nin a net gain of 0. The quota_change information is recorded in the qc\nbuffer (and qd element of the inode as well). The buffer is added to the\ntransaction by the first call to do_qc, but a subsequent call changes\nthe value from non-zero back to zero. At that point it's too late to\nremove the buffer_head from the transaction. Later, when the quota sync\ncode is called, the zero-change qd element is discovered and flagged as\nan assert warning. If the fs is mounted with errors=panic, the kernel\nwill panic.\n\nThis is usually seen when files are truncated and the quota changes are\nnegated by punch_hole/truncate which uses gfs2_quota_hold and\ngfs2_quota_unhold rather than block allocations that use gfs2_quota_lock\nand gfs2_quota_unlock which automatically do quota sync.\n\nThis patch solves the problem by adding a check to qd_check_sync such\nthat net-zero quota changes already added to the transaction are no\nlonger deemed necessary to be synced, and skipped.\n\nIn this case references are taken for the qd and the slot from do_qc\nso those need to be put. The normal sequence of events for a normal\nnon-zero quota change is as follows:\n\ngfs2_quota_change\n   do_qc\n      qd_hold\n      slot_hold\n\nLater, when the changes are to be synced:\n\ngfs2_quota_sync\n   qd_fish\n      qd_check_sync\n         gets qd ref via lockref_get_not_dead\n   do_sync\n      do_qc(QC_SYNC)\n         qd_put\n\t    lockref_put_or_lock\n   qd_unlock\n      qd_put\n         lockref_put_or_lock\n\nIn the net-zero change case, we add a check to qd_check_sync so it puts\nthe qd and slot references acquired in gfs2_quota_change and skip the\nunneeded sync."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: gfs2: ignora los cambios de cuota negados. Cuando se realizan muchos cambios de cuota, puede haber casos en los que la informaci\u00f3n de cuota de un inodo aumenta y luego disminuye, como cuando se agregan bloques a un archivo, luego eliminado de \u00e9l. Si es el momento adecuado, la funci\u00f3n do_qc puede agregar cambios de cuota pendientes a una transacci\u00f3n, luego, otra llamada a do_qc puede negar esos cambios, lo que resulta en una ganancia neta de 0. La informaci\u00f3n de cuota_cambio se registra en el b\u00fafer qc (y en el elemento qd). del inodo tambi\u00e9n). El b\u00fafer se agrega a la transacci\u00f3n mediante la primera llamada a do_qc, pero una llamada posterior cambia el valor de distinto de cero a cero. En ese momento ya es demasiado tarde para eliminar buffer_head de la transacci\u00f3n. M\u00e1s tarde, cuando se llama al c\u00f3digo de sincronizaci\u00f3n de cuota, el elemento qd de cambio cero se descubre y se marca como una advertencia de afirmaci\u00f3n. Si fs se monta con errores = p\u00e1nico, el kernel entrar\u00e1 en p\u00e1nico. Esto generalmente se ve cuando los archivos se truncan y los cambios de cuota se niegan mediante punch_hole/truncate, que usa gfs2_quota_hold y gfs2_quota_unhold en lugar de bloquear asignaciones que usan gfs2_quota_lock y gfs2_quota_unlock, que sincronizan autom\u00e1ticamente la cuota. Este parche resuelve el problema agregando una verificaci\u00f3n a qd_check_sync de modo que los cambios de cuota neta cero ya agregados a la transacci\u00f3n ya no se consideren necesarios para sincronizarse y omitirse. En este caso, se toman referencias para el qd y el slot de do_qc, por lo que es necesario ponerlas. La secuencia normal de eventos para un cambio de cuota normal distinto de cero es la siguiente: gfs2_quota_change do_qc qd_hold slot_hold M\u00e1s tarde, cuando se van a sincronizar los cambios: gfs2_quota_sync qd_fish qd_check_sync obtiene qd ref mediante lockref_get_not_dead do_sync do_qc(QC_SYNC) qd_put lockref_put_or_lock qd_unlock qd_put lockref_put_or_lock En el caso de cambio neto cero, agregamos una verificaci\u00f3n a qd_check_sync para que coloque las referencias de qd y slot adquiridas en gfs2_quota_change y omita la sincronizaci\u00f3n innecesaria."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/119565e566f91ff3588ffcd5812f0c8061586c6b",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/1c28dace66015b675a343b89b0c87abbfda05ff4",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/212f112fe5e90e98eb8d48585682880dae139f4c",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/2a054b87a1b799b391e578597a42ee6e57a987ae",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/2bb42a27a92ff3984c9fa5fbe128eced3ea693f2",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/4c6a08125f2249531ec01783a5f4317d7342add5",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/53fc16c1ad84f5467ec24341670b63aa759335d3",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/5bfda356e903633d16ae1bac1ee38364e12628a3",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/b4deec69fe32b58dc5fb4ace52456ece85b75561",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}