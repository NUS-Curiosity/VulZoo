{
  "id": "CVE-2021-47227",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-05-21T15:15:11.900",
  "lastModified": "2024-05-21T16:54:26.047",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nx86/fpu: Prevent state corruption in __fpu__restore_sig()\n\nThe non-compacted slowpath uses __copy_from_user() and copies the entire\nuser buffer into the kernel buffer, verbatim.  This means that the kernel\nbuffer may now contain entirely invalid state on which XRSTOR will #GP.\nvalidate_user_xstate_header() can detect some of that corruption, but that\nleaves the onus on callers to clear the buffer.\n\nPrior to XSAVES support, it was possible just to reinitialize the buffer,\ncompletely, but with supervisor states that is not longer possible as the\nbuffer clearing code split got it backwards. Fixing that is possible but\nnot corrupting the state in the first place is more robust.\n\nAvoid corruption of the kernel XSAVE buffer by using copy_user_to_xstate()\nwhich validates the XSAVE header contents before copying the actual states\nto the kernel. copy_user_to_xstate() was previously only called for\ncompacted-format kernel buffers, but it works for both compacted and\nnon-compacted forms.\n\nUsing it for the non-compacted form is slower because of multiple\n__copy_from_user() operations, but that cost is less important than robust\ncode in an already slow path.\n\n[ Changelog polished by Dave Hansen ]"
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se resolvi\u00f3 la siguiente vulnerabilidad: x86/fpu: evita la corrupci\u00f3n del estado en __fpu__restore_sig() La ruta lenta no compactada usa __copy_from_user() y copia todo el b\u00fafer del usuario en el b\u00fafer del kernel, palabra por palabra. Esto significa que el b\u00fafer del kernel ahora puede contener un estado completamente inv\u00e1lido en el que XRSTOR realizar\u00e1 #GP. validar_user_xstate_header() puede detectar parte de esa corrupci\u00f3n, pero eso deja a las personas que llaman la responsabilidad de borrar el b\u00fafer. Antes de la compatibilidad con XSAVES, era posible simplemente reinicializar el b\u00fafer por completo, pero con los estados del supervisor eso ya no es posible porque la divisi\u00f3n del c\u00f3digo de borrado del b\u00fafer lo hac\u00eda al rev\u00e9s. Arreglar eso es posible, pero no corromper al Estado en primer lugar es m\u00e1s s\u00f3lido. Evite la corrupci\u00f3n del b\u00fafer XSAVE del kernel utilizando copy_user_to_xstate() que valida el contenido del encabezado XSAVE antes de copiar los estados reales al kernel. copy_user_to_xstate() anteriormente solo se llamaba para buffers del kernel en formato compacto, pero funciona tanto para formatos compactos como no compactos. Usarlo para el formato no compacto es m\u00e1s lento debido a m\u00faltiples operaciones __copy_from_user(), pero ese costo es menos importante que el c\u00f3digo robusto en una ruta que ya es lenta. [Registro de cambios pulido por Dave Hansen]"
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/076f732b16a5bf842686e1b43ab6021a2d98233e",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/484cea4f362e1eeb5c869abbfb5f90eae6421b38",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/ec25ea1f3f05d6f8ee51d1277efea986eafd4f2a",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}