{
  "id": "CVE-2021-47505",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-05-24T15:15:11.000",
  "lastModified": "2024-05-24T18:09:20.027",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\naio: fix use-after-free due to missing POLLFREE handling\n\nsignalfd_poll() and binder_poll() are special in that they use a\nwaitqueue whose lifetime is the current task, rather than the struct\nfile as is normally the case.  This is okay for blocking polls, since a\nblocking poll occurs within one task; however, non-blocking polls\nrequire another solution.  This solution is for the queue to be cleared\nbefore it is freed, by sending a POLLFREE notification to all waiters.\n\nUnfortunately, only eventpoll handles POLLFREE.  A second type of\nnon-blocking poll, aio poll, was added in kernel v4.18, and it doesn't\nhandle POLLFREE.  This allows a use-after-free to occur if a signalfd or\nbinder fd is polled with aio poll, and the waitqueue gets freed.\n\nFix this by making aio poll handle POLLFREE.\n\nA patch by Ramji Jiyani <ramjiyani@google.com>\n(https://lore.kernel.org/r/20211027011834.2497484-1-ramjiyani@google.com)\ntried to do this by making aio_poll_wake() always complete the request\ninline if POLLFREE is seen.  However, that solution had two bugs.\nFirst, it introduced a deadlock, as it unconditionally locked the aio\ncontext while holding the waitqueue lock, which inverts the normal\nlocking order.  Second, it didn't consider that POLLFREE notifications\nare missed while the request has been temporarily de-queued.\n\nThe second problem was solved by my previous patch.  This patch then\nproperly fixes the use-after-free by handling POLLFREE in a\ndeadlock-free way.  It does this by taking advantage of the fact that\nfreeing of the waitqueue is RCU-delayed, similar to what eventpoll does."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: aio: corrige el use-after-free debido a la falta de manejo de POLLFREE. signalfd_poll() y binder_poll() son especiales porque usan una cola de espera cuya duraci\u00f3n es la tarea actual, en lugar de la struct archivo como es normalmente el caso. Esto est\u00e1 bien para bloquear encuestas, ya que una encuesta de bloqueo ocurre dentro de una tarea; sin embargo, las encuestas sin bloqueo requieren otra soluci\u00f3n. Esta soluci\u00f3n consiste en despejar la cola antes de liberarla, enviando una notificaci\u00f3n POLLFREE a todos los camareros. Desafortunadamente, s\u00f3lo eventpoll maneja POLLFREE. Un segundo tipo de encuesta sin bloqueo, aio poll, se agreg\u00f3 en el kernel v4.18 y no maneja POLLFREE. Esto permite que se produzca un use-after-free si se sondea un signalfd o un binder fd con aio poll y se libera la cola de espera. Solucione este problema haciendo que la encuesta de aio se maneje POLLFREE. Un parche de Ramji Jiyani  (https://lore.kernel.org/r/20211027011834.2497484-1-ramjiyani@google.com) intent\u00f3 hacer esto haciendo que aio_poll_wake() siempre completara la solicitud en l\u00ednea si Se ve POLLFREE. Sin embargo, esa soluci\u00f3n ten\u00eda dos errores. Primero, introdujo un punto muerto, ya que bloque\u00f3 incondicionalmente el contexto aio mientras manten\u00eda el bloqueo de la cola de espera, lo que invierte el orden de bloqueo normal. En segundo lugar, no consider\u00f3 que las notificaciones de POLLFREE se pierdan mientras la solicitud ha sido retirada temporalmente de la cola. El segundo problema lo resolvi\u00f3 mi parche anterior. Luego, este parche corrige adecuadamente el use-after-free al manejar POLLFREE sin interbloqueos. Lo hace aprovechando el hecho de que la liberaci\u00f3n de la cola de espera tiene un retraso de RCU, similar a lo que hace eventpoll."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/321fba81ec034f88aea4898993c1bf15605c023f",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/4105e6a128e8a98455dfc9e6dbb2ab0c33c4497f",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/47ffefd88abfffe8a040bcc1dd0554d4ea6f7689",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/50252e4b5e989ce64555c7aef7516bdefc2fea72",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/60d311f9e6381d779d7d53371f87285698ecee24",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}