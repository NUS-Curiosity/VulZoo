
Date: Wed, 19 Mar 2003 17:22:12 -0500
From: Tom Yu <tlyu@....EDU>
To: kerberos-announce@....edu
Cc: bugtraq@...urityfocus.com
Subject: MITKRB5-SA-2003-003: faulty length checks in xdrmem_getbytes


-----BEGIN PGP SIGNED MESSAGE-----

                 MIT krb5 Security Advisory 2003-003

2003-03-18

Topic: faulty length checks in xdrmem_getbytes

Severity: serious

SUMMARY
=======

The MIT Kerberos 5 implementation includes an RPC library derived from
SUNRPC.  We have been notified that the xdrmem_getbytes() function
contains faulty length checks.  These length checks are vulnerable to
an integer overflow, which may be exploitable to create denials of
service or to gain unauthorized access to sensitive information.

An attacker who has successfully authenticated to the Kerberos
administration daemon (kadmind) may be able to crash kadmind or induce
it to leak sensitive information, such as secret keys.  For the attack
to succeed, it is believed that the configuration of the kadmind
installation must allow it to successfully allocate more than INT_MAX
bytes of memory.

IMPACT
======

* An attacker capable of authenticating to kadmind may be able to crash
  kadmind.

* Under extremely unlikely circumstances, an attacker capable of
  authenticating to kadmind may be able to induce it to return
  sensitive information, such as secret keys.

AFFECTED SOFTWARE
=================

* All releases of MIT Kerberos 5, up to and including krb5-1.2.7.

FIX
===

Apply the following patch to src/lib/rpc/xdr_mem.c and rebuild your
tree.

Index: xdr_mem.c
===================================================================
RCS file: /cvs/krbdev/krb5/src/lib/rpc/xdr_mem.c,v
retrieving revision 1.8
diff -c -r1.8 xdr_mem.c
*** xdr_mem.c	1998/02/14 02:27:24	1.8
- --- xdr_mem.c	2003/02/04 22:57:24
***************
*** 47,52 ****
- --- 47,54 ----
  #include <gssrpc/xdr.h>
  #include <netinet/in.h>
  #include <stdio.h>
+ #include <string.h>
+ #include <limits.h>
  
  static bool_t	xdrmem_getlong();
  static bool_t	xdrmem_putlong();
***************
*** 83,89 ****
  	xdrs->x_op = op;
  	xdrs->x_ops = &xdrmem_ops;
  	xdrs->x_private = xdrs->x_base = addr;
! 	xdrs->x_handy = size;
  }
  
  static void
- --- 85,91 ----
  	xdrs->x_op = op;
  	xdrs->x_ops = &xdrmem_ops;
  	xdrs->x_private = xdrs->x_base = addr;
! 	xdrs->x_handy = (size > INT_MAX) ? INT_MAX : size; /* XXX */
  }
  
  static void
***************
*** 98,105 ****
  	long *lp;
  {
  
! 	if ((xdrs->x_handy -= sizeof(rpc_int32)) < 0)
  		return (FALSE);
  	*lp = (long)ntohl(*((rpc_u_int32 *)(xdrs->x_private)));
  	xdrs->x_private += sizeof(rpc_int32);
  	return (TRUE);
- --- 100,109 ----
  	long *lp;
  {
  
! 	if (xdrs->x_handy < sizeof(rpc_int32))
  		return (FALSE);
+ 	else
+ 		xdrs->x_handy -= sizeof(rpc_int32);
  	*lp = (long)ntohl(*((rpc_u_int32 *)(xdrs->x_private)));
  	xdrs->x_private += sizeof(rpc_int32);
  	return (TRUE);
***************
*** 111,118 ****
  	long *lp;
  {
  
! 	if ((xdrs->x_handy -= sizeof(rpc_int32)) < 0)
  		return (FALSE);
  	*(rpc_int32 *)xdrs->x_private = (rpc_int32)htonl((rpc_u_int32)(*lp));
  	xdrs->x_private += sizeof(rpc_int32);
  	return (TRUE);
- --- 115,124 ----
  	long *lp;
  {
  
! 	if (xdrs->x_handy < sizeof(rpc_int32))
  		return (FALSE);
+ 	else
+ 		xdrs->x_handy -= sizeof(rpc_int32);
  	*(rpc_int32 *)xdrs->x_private = (rpc_int32)htonl((rpc_u_int32)(*lp));
  	xdrs->x_private += sizeof(rpc_int32);
  	return (TRUE);
***************
*** 125,132 ****
  	register unsigned int len;
  {
  
! 	if ((xdrs->x_handy -= len) < 0)
  		return (FALSE);
  	memmove(addr, xdrs->x_private, len);
  	xdrs->x_private += len;
  	return (TRUE);
- --- 131,140 ----
  	register unsigned int len;
  {
  
! 	if (xdrs->x_handy < len)
  		return (FALSE);
+ 	else
+ 		xdrs->x_handy -= len;
  	memmove(addr, xdrs->x_private, len);
  	xdrs->x_private += len;
  	return (TRUE);
***************
*** 139,146 ****
  	register unsigned int len;
  {
  
! 	if ((xdrs->x_handy -= len) < 0)
  		return (FALSE);
  	memmove(xdrs->x_private, addr, len);
  	xdrs->x_private += len;
  	return (TRUE);
- --- 147,156 ----
  	register unsigned int len;
  {
  
! 	if (xdrs->x_handy < len)
  		return (FALSE);
+ 	else
+ 		xdrs->x_handy -= len;
  	memmove(xdrs->x_private, addr, len);
  	xdrs->x_private += len;
  	return (TRUE);
***************
*** 179,185 ****
  {
  	rpc_int32 *buf = 0;
  
! 	if (xdrs->x_handy >= len) {
  		xdrs->x_handy -= len;
  		buf = (rpc_int32 *) xdrs->x_private;
  		xdrs->x_private += len;
- --- 189,195 ----
  {
  	rpc_int32 *buf = 0;
  
! 	if (len >= 0 && xdrs->x_handy >= len) {
  		xdrs->x_handy -= len;
  		buf = (rpc_int32 *) xdrs->x_private;
  		xdrs->x_private += len;

The patch was generated against krb5-1.2.7; patches to other releases
may apply with some offset.

This patch may also be found at:

http://web.mit.edu/kerberos/www/advisories/2003-003-xdr_patch.txt

The associated detached PGP signature is at:

http://web.mit.edu/kerberos/www/advisories/2003-003-xdr_patch.txt.asc

REFERENCES
==========

This announcement and related security advisories may be found on the
MIT Kerberos security advisory page at:

        http://web.mit.edu/kerberos/www/advisories/index.html

The main MIT Kerberos web page is at:

        http://web.mit.edu/kerberos/www/index.html

CERT VU#516825

        http://www.kb.cert.org/vuls/id/516825

CVE CAN-2003-0028

        http://cve.mitre.org/cgi-bin/cvename.cgi?name=CAN-2003-0028

ACKNOWLEDGMENTS
===============

Thanks to CERT for notifying us of this vulnerability.

DETAILS
=======

The xdrmem_getbytes() function decrements the private signed integer
"xdrs->x_handy" by the supplied length "len", which is an unsigned
int.  It then verifies that the resulting value of "xdrs->x_handy" is
non-negative.  Using a carefully chosen value of "len" (so that it is
greater than INT_MAX), it is possible for this check to succeed even
if the value of "len" would cause the buffer to be overrun on read.
This overrun may result in a segmentation fault, or in the
unauthorized copying of sensitive information.

A mitigating factor is that most call chains that end up calling
xdrmem_getbytes() first call malloc() (via the mem_alloc() macro) to
allocate a buffer of the requested length.  This allocation of more
than INT_MAX bytes will fail on most configurations due to internal
limitations of malloc() or due to system resource limits.  On systems
where allocation of more than INT_MAX bytes can succeed (possibly
including 64-bit environments), the probability of successful exploit
is higher.

In MIT krb5, the vulnerable invocations of xdrmem_getbytes() inside
kadmind only occur after the user has successfully authenticated.
Additionally, any unauthorized copies of sensitive data obtained by
exercising this vulnerability are extremely unlikely to be returned to
the remote client.

REVISION HISTORY
================

2003-03-18      original release
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.0.7 (SunOS)

iQCVAwUBPnd5J6bDgE/zdoE9AQEIeAQAxuMhSNtC94YhIqQcuhRsKXFf/T8T8lh6
YUeTNaqA9sQkZBE2sZEyI4uq0iiZjwQyUfhylcPbEaIX3f9dto8YWmRvPztsvIQR
jzAlRU4o7//kw2oWu1JQC0FNpcifr1D1j0E59xqjDaCGDa6LlMFqd/V77pHKIcLU
c0DO4+ORljY=
=54iC
-----END PGP SIGNATURE-----

